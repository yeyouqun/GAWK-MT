<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2016 

Free Software Foundation, Inc.

This is Edition 4.1 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 4.1.4 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".


The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual."

 -->
<!-- Created on December 27, 2018 by texi2html 5.0
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>The GNU Awk User&rsquo;s Guide</title>

<meta name="description" content="The GNU Awk User&rsquo;s Guide">
<meta name="keywords" content="The GNU Awk User&rsquo;s Guide">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 5.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:pre}
span.nolinebreak {white-space:pre}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<h1>GAWK: Effective AWK Programming</h1>
<h3 align="right">A User&rsquo;s Guide for GNU Awk</h3>
<h3 align="right">Edition 4.1</h3>
<h3 align="right">August, 2016</h3>
<strong>Arnold D. Robbins</strong><br>



<p>&ldquo;To boldly go where no man has gone before&rdquo; is a
Registered Trademark of Paramount Pictures Corporation. <br>
</p><br>
<br>
<br>
<p>Published by:
</p><br>

<p>Free Software Foundation <br>
51 Franklin Street, Fifth Floor <br>
Boston, MA  02110-1301 USA <br>
Phone: +1-617-542-5942 <br>
Fax: +1-617-542-2652 <br>
Email: <a href="mailto:gnu@gnu.org">gnu@gnu.org</a> <br>
URL: <a href="http://www.gnu.org/">http://www.gnu.org/</a> <br>
</p>
<p>ISBN 1-882114-28-0 <br>
</p><br>
<br>

<p>Copyright &copy; 1989, 1991, 1992, 1993, 1996&ndash;2005, 2007, 2009&ndash;2016 <br>
Free Software Foundation, Inc.
</p><br>
<br>

<p>This is Edition 4.1 of <cite>GAWK: Effective AWK Programming: A User&rsquo;s Guide for GNU Awk</cite>,
for the 4.1.4 (or later) version of the GNU
implementation of AWK.
</p>
<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being &ldquo;GNU General Public License&rdquo;, with the
Front-Cover Texts being &ldquo;A GNU Manual&rdquo;, and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
&ldquo;GNU Free Documentation License&rdquo;.
</p>
<ol>
<li>
The FSF&rsquo;s Back-Cover Text is: &ldquo;You have the freedom to
copy and modify this GNU manual.&rdquo;
</li></ol>
<hr>
<a name="Top"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[ &lt; ]</td>
<td valign="middle" align="left">[<a href="#Foreword3" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="General-Introduction"></a>
<h1 class="top">General Introduction</h1>

<p>This file documents <code>awk</code>, a program that you can use to select
particular records in a file and perform operations upon them.
</p>

<p>Copyright &copy; 1989, 1991, 1992, 1993, 1996&ndash;2005, 2007, 2009&ndash;2016 <br>
Free Software Foundation, Inc.
</p><br>
<br>

<p>This is Edition 4.1 of <cite>GAWK: Effective AWK Programming: A User&rsquo;s Guide for GNU Awk</cite>,
for the 4.1.4 (or later) version of the GNU
implementation of AWK.
</p>
<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being &ldquo;GNU General Public License&rdquo;, with the
Front-Cover Texts being &ldquo;A GNU Manual&rdquo;, and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
&ldquo;GNU Free Documentation License&rdquo;.
</p>
<ol>
<li>
The FSF&rsquo;s Back-Cover Text is: &ldquo;You have the freedom to
copy and modify this GNU manual.&rdquo;
</li></ol>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Foreword3">第三版前言</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Some nice words about this
                                   website.
</td></tr>
<tr><td align="left" valign="top"><a href="#Foreword4">第四版前言</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      More nice words.
</td></tr>
<tr><td align="left" valign="top"><a href="#Preface">前言</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        What this website is about; brief
                                   history and acknowledgments.
</td></tr>
<tr><td align="left" valign="top"><a href="#Translator-Preface">译序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                A basic introduction to using
                                   <code>awk</code>. How to run an <code>awk</code>
                                   program. Command-line syntax.
</td></tr>
<tr><td align="left" valign="top"><a href="#Invoking-Gawk">2 运行 <code>awk</code> 与 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How to run <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp">3 正则表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         All about matching things using regular
                                   expressions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Reading-Files">4 读取输入文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How to read files and manipulate fields.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printing">5 打印输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       How to print using <code>awk</code>. Describes
                                   the <code>print</code> and <code>printf</code>
                                   statements. Also describes redirection of
                                   output.
</td></tr>
<tr><td align="left" valign="top"><a href="#Expressions">6 表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Expressions are the basic building blocks
                                   of statements.
</td></tr>
<tr><td align="left" valign="top"><a href="#Patterns-and-Actions">7 模式、动作与变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Overviews of patterns and actions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arrays">8 <code>awk</code> 数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         The description and use of arrays. Also
                                   includes array-oriented control statements.
</td></tr>
<tr><td align="left" valign="top"><a href="#Functions">9 函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Built-in and user-defined functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              A Library of <code>awk</code> Functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Sample-Programs">2 实用的 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Many <code>awk</code> programs with complete
                                   explanations.
</td></tr>
<tr><td align="left" valign="top"><a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">1 <code>gawk</code> 的高级特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Stuff for advanced users, specific to
                                   <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Internationalization">2 <code>gawk</code> 的国际化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Getting <code>gawk</code> to speak your
                                   language.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugger">3 调试 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       The <code>gawk</code> debugger.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arbitrary-Precision-Arithmetic">4 算术运算与 <code>gawk</code> 中的任意精度算术运算</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Arbitrary precision arithmetic with
                                   <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Dynamic-Extensions">5 编写 <code>gawk</code> 扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Adding new built-in functions to
                                   <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095">Appendix A <code>awk</code> 语言的演化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               The evolution of the <code>awk</code>
                                   language.
</td></tr>
<tr><td align="left" valign="top"><a href="#Installation">Appendix B 安装 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Installing <code>gawk</code> under various
                                   operating systems.
</td></tr>
<tr><td align="left" valign="top"><a href="#Notes">Appendix C 实现提示</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          Notes about adding things to <code>gawk</code>
                                   and possible future work.
</td></tr>
<tr><td align="left" valign="top"><a href="#Basic-Concepts">Appendix D 基本编程概念</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 A very quick introduction to programming
                                   concepts.
</td></tr>
<tr><td align="left" valign="top"><a href="#Glossary">名词解释</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       An explanation of some unfamiliar terms.
</td></tr>
<tr><td align="left" valign="top"><a href="#Copying">GNU General Public License</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Your right to copy and distribute
                                   <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> The license for this website.
</td></tr>
<tr><td align="left" valign="top"><a href="#Index">Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          Concept and Variable Index.
</td></tr>
<tr><td align="left" valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                             The history of <code>gawk</code> and
                                        <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Names">玫瑰别名</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                               What name to use to find
                                        <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#This-Manual">使用本书</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Using this website. Includes
                                        sample input files that you can use.
</td></tr>
<tr><td align="left" valign="top"><a href="#Conventions">排版约定</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Typographical Conventions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Brief history of the GNU project and
                                        this website.
</td></tr>
<tr><td align="left" valign="top"><a href="#How-To-Contribute">如何贡献</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Helping to save the world.
</td></tr>
<tr><td align="left" valign="top"><a href="#Acknowledgments">致谢</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Acknowledgments.
</td></tr>
<tr><td align="left" valign="top"><a href="#Running-gawk">1.1 如何执行 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        How to run <code>gawk</code> programs;
                                        includes command-line syntax.
</td></tr>
<tr><td align="left" valign="top"><a href="#One_002dshot">1.1.1 一次性 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                            Running a short throwaway
                                        <code>awk</code> program.
</td></tr>
<tr><td align="left" valign="top"><a href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Using no input files (input from the
                                        keyboard instead).
</td></tr>
<tr><td align="left" valign="top"><a href="#Long">1.1.3 运行长程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                                Putting permanent <code>awk</code>
                                        programs in files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Making self-contained <code>awk</code>
                                        programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                            Adding documentation to <code>gawk</code>
                                        programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                             More discussion of shell quoting
                                        issues.
</td></tr>
<tr><td align="left" valign="top"><a href="#DOS-Quoting">1.1.6.1 MS-Windows 批处理文件中的引号问题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Quoting in Windows Batch Files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Sample-Data-Files">1.2 例子中使用的数据文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Sample data files for use in the
                                        <code>awk</code> programs illustrated in
                                        this website.
</td></tr>
<tr><td align="left" valign="top"><a href="#Very-Simple">1.3 一些简单例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         A very simple example.
</td></tr>
<tr><td align="left" valign="top"><a href="#Two-Rules">1.4 两规则的例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           A less simple one-line example using
                                        two rules.
</td></tr>
<tr><td align="left" valign="top"><a href="#More-Complex">1.5 复杂一点的例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        A more complex example.
</td></tr>
<tr><td align="left" valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Subdividing or combining statements
                                        into lines.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Features">1.7 <code>awk</code> 的其他特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Other Features of <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#When">1.8 何时使用 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                                When to use <code>gawk</code> and when to
                                        use other things.
</td></tr>
<tr><td align="left" valign="top"><a href="#Intro-Summary">1.9 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Summary of the introduction.
</td></tr>
<tr><td align="left" valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        How to run <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Options">2.2 命令行参数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                             Command-line options and their
                                        meanings.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Input file names and variable
                                        assignments.
</td></tr>
<tr><td align="left" valign="top"><a href="#Naming-Standard-Input">2.4 命名标准输入</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               How to specify standard input with
                                        other files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Environment-Variables">2.5 <code>gawk</code> 使用的环境变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               The environment variables
                                        <code>gawk</code> uses.
</td></tr>
<tr><td align="left" valign="top"><a href="#AWKPATH-Variable">2.5.1 环境变量 <code>AWKPATH</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Searching directories for
                                        <code>awk</code> programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#AWKLIBPATH-Variable">2.5.2 环境变量 <code>AWKLIBPATH</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Searching directories for
                                        <code>awk</code> shared libraries.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Environment-Variables">2.5.3 其他的环境变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         The environment variables.
</td></tr>
<tr><td align="left" valign="top"><a href="#Exit-Status">2.6 <code>gawk</code> 的退出状态</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         <code>gawk</code>&rsquo;s exit status.
</td></tr>
<tr><td align="left" valign="top"><a href="#Include-Files">2.7 在你的程序中包含其他的文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Including other files into your
                                        program.
</td></tr>
<tr><td align="left" valign="top"><a href="#Loading-Shared-Libraries">2.8 在你的程序装入动态扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Loading shared libraries into your
                                        program.
</td></tr>
<tr><td align="left" valign="top"><a href="#Obsolete">2.9 已经取消的选项以及特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                            Obsolete Options and/or features.
</td></tr>
<tr><td align="left" valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Undocumented Options and Features.
</td></tr>
<tr><td align="left" valign="top"><a href="#Invoking-Summary">2.11 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Invocation summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        How to Use Regular Expressions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    How to write nonprinting characters.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Regular Expression Operators.
</td></tr>
<tr><td align="left" valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 What can go between &lsquo;<samp>[...]</samp>&rsquo;.
</td></tr>
<tr><td align="left" valign="top"><a href="#Leftmost-Longest">3.5 匹配多少？</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    How much text matches.
</td></tr>
<tr><td align="left" valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Using Dynamic Regexps.
</td></tr>
<tr><td align="left" valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Operators specific to GNU software.
</td></tr>
<tr><td align="left" valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    How to do case-insensitive matching.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Summary">3.9 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Regular expressions summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Records">4.1 输入如何拆分为记录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                             Controlling how data is split into
                                        records.
</td></tr>
<tr><td align="left" valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   How standard <code>awk</code> splits
                                        records.
</td></tr>
<tr><td align="left" valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How <code>gawk</code> splits records.
</td></tr>
<tr><td align="left" valign="top"><a href="#Fields">4.2 检查域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                              An introduction to fields.
</td></tr>
<tr><td align="left" valign="top"><a href="#Nonconstant-Fields">4.3 非常数域编号</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Nonconstant Field Numbers.
</td></tr>
<tr><td align="left" valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Changing the Contents of a Field.
</td></tr>
<tr><td align="left" valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    The field separator and how to change
                                        it.
</td></tr>
<tr><td align="left" valign="top"><a href="#Default-Field-Splitting">4.5.1 标准的域分隔符空白符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How fields are normally separated.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Using regexps as the field separator.
</td></tr>
<tr><td align="left" valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Making each character a separate
                                        field.
</td></tr>
<tr><td align="left" valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Setting <code>FS</code> from the command
                                        line.
</td></tr>
<tr><td align="left" valign="top"><a href="#Full-Line-Fields">4.5.5 一行即一域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Making the full line be a single
                                        field.
</td></tr>
<tr><td align="left" valign="top"><a href="#Field-Splitting-Summary">4.5.6 域分割总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Some final points and a summary table.
</td></tr>
<tr><td align="left" valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Reading constant width data.
</td></tr>
<tr><td align="left" valign="top"><a href="#Splitting-By-Content">4.7 以内容定义域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Defining Fields By Content
</td></tr>
<tr><td align="left" valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Reading multiline records.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                             Reading files under explicit program
                                        control using the <code>getline</code>
                                        function.
</td></tr>
<tr><td align="left" valign="top"><a href="#Plain-Getline">4.9.1 不带参数调用 <code>getline</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Using <code>getline</code> with no
                                        arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fVariable">4.9.2 将 <code>getline</code> 赋值给变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Using <code>getline</code> into a variable.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Using <code>getline</code> from a file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fVariable_002fFile">4.9.4 从文件中 <code>getline</code> 到变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Using <code>getline</code> into a variable
                                        from a file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Using <code>getline</code> from a pipe.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fVariable_002fPipe">4.9.6 从管道中 <code>getline</code> 到变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Using <code>getline</code> into a variable
                                        from a pipe.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Using <code>getline</code> from a coprocess.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fVariable_002fCoprocess">4.9.8 使用并程 <code>getline</code> 到变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Using <code>getline</code> into a variable
                                        from a coprocess.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Important things to know about
                                        <code>getline</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline-Summary">4.9.10 <code>getline</code> 变体总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Summary of <code>getline</code> Variants.
</td></tr>
<tr><td align="left" valign="top"><a href="#Read-Timeout">4.10 带超时的输入读取</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Reading input with a timeout.
</td></tr>
<tr><td align="left" valign="top"><a href="#Command_002dline-directories">4.11 命令行中的目录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            What happens if you put a directory on
                                        the command line.
</td></tr>
<tr><td align="left" valign="top"><a href="#Input-Summary">4.12 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Input summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Input-Exercises">4.13 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Exercises.
</td></tr>
<tr><td align="left" valign="top"><a href="#Print">5.1 <code>print</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                               The <code>print</code> statement.
</td></tr>
<tr><td align="left" valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Simple examples of <code>print</code>
                                        statements.
</td></tr>
<tr><td align="left" valign="top"><a href="#Output-Separators">5.3 输出分隔符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   The output separators and how to
                                        change them.
</td></tr>
<tr><td align="left" valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                                Controlling Numeric Output With
                                        <code>print</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printf">5.5 使用 <code>printf</code> 语句美化打印</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                              The <code>printf</code> statement.
</td></tr>
<tr><td align="left" valign="top"><a href="#Basic-Printf">5.5.1 使用 <code>printf</code> 语句美化打印</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Syntax of the <code>printf</code> statement.
</td></tr>
<tr><td align="left" valign="top"><a href="#Control-Letters">5.5.2 格式控制字母</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Format-control letters.
</td></tr>
<tr><td align="left" valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Format-specification modifiers.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printf-Examples">5.5.4 <code>printf</code> 范例</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Several examples.
</td></tr>
<tr><td align="left" valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         How to redirect output to multiple
                                        files and pipes.
</td></tr>
<tr><td align="left" valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          Special files for I/O.
</td></tr>
<tr><td align="left" valign="top"><a href="#Special-Files">5.8 <code>gawk</code> 中的特殊文件名</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       File name interpretation in
                                        <code>gawk</code>. <code>gawk</code> allows
                                        access to inherited file descriptors.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Inherited-Files">5.8.1 在 <code>gawk</code> 访问其他已开文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Accessing other open files with
                                        <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Special-Network">5.8.2 用于网络的特殊文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Special files for network
                                        communications.
</td></tr>
<tr><td align="left" valign="top"><a href="#Special-Caveats">5.8.3 特殊文件名说明</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Things to watch out for.
</td></tr>
<tr><td align="left" valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Closing Input and Output Files and
                                        Pipes.
</td></tr>
<tr><td align="left" valign="top"><a href="#Output-Summary">5.10 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Output summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Output-Exercises">5.11 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Exercises.
</td></tr>
<tr><td align="left" valign="top"><a href="#Values">6.1 常量、变量与转换</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                              Constants, Variables, and Regular
                                        Expressions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Constants">6.1.1 常量表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           String, numeric and regexp constants.
</td></tr>
<tr><td align="left" valign="top"><a href="#Scalar-Constants">6.1.1.1 数值与字串常量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Numeric and string constants.
</td></tr>
<tr><td align="left" valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  What are octal and hex numbers.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Constants">6.1.1.3 正则表达式常量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Regular Expression constants.
</td></tr>
<tr><td align="left" valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              When and how to use a regexp constant.
</td></tr>
<tr><td align="left" valign="top"><a href="#Variables">6.1.3 变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           Variables give names to values for
                                        later use.
</td></tr>
<tr><td align="left" valign="top"><a href="#Using-Variables">6.1.3.1 在程序中使用变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Using variables in your programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Assignment-Options">6.1.3.2 在命令行中进行变量赋值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Setting variables on the command line
                                        and a summary of command-line syntax.
                                        This is an advanced method of input.
</td></tr>
<tr><td align="left" valign="top"><a href="#Conversion">6.1.4 在字串与数值之间进行转换</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          The conversion of strings to numbers
                                        and vice versa.
</td></tr>
<tr><td align="left" valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 How <code>awk</code> Converts Between
                                        Strings And Numbers.
</td></tr>
<tr><td align="left" valign="top"><a href="#Locale-influences-conversions">6.1.4.2 语言设置会影响转换</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       How the locale may affect conversions.
</td></tr>
<tr><td align="left" valign="top"><a href="#All-Operators">6.2 操作符：对值进行处理</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       <code>gawk</code>&rsquo;s operators.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Arithmetic operations (&lsquo;<samp>+</samp>&rsquo;,
                                        &lsquo;<samp>-</samp>&rsquo;, etc.)
</td></tr>
<tr><td align="left" valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Concatenating strings.
</td></tr>
<tr><td align="left" valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Changing the value of a variable or a
                                        field.
</td></tr>
<tr><td align="left" valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Incrementing the numeric value of a
                                        variable.
</td></tr>
<tr><td align="left" valign="top"><a href="#Truth-Values-and-Conditions">6.3 真值与条件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Testing for true and false.
</td></tr>
<tr><td align="left" valign="top"><a href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        What is &ldquo;true&rdquo; and what is
                                        &ldquo;false&rdquo;.
</td></tr>
<tr><td align="left" valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               How variables acquire types and how
                                        this affects comparison of numbers and
                                        strings with &lsquo;<samp>&lt;</samp>&rsquo;, etc.
</td></tr>
<tr><td align="left" valign="top"><a href="#Variable-Typing">6.3.2.1 字串类型与数值类型</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     String type versus numeric type.
</td></tr>
<tr><td align="left" valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                The comparison operators.
</td></tr>
<tr><td align="left" valign="top"><a href="#POSIX-String-Comparison">6.3.2.3 POSIX 中的字串比较规则</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             String comparison with POSIX rules.
</td></tr>
<tr><td align="left" valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Combining comparison expressions using
                                        boolean operators &lsquo;<samp>||</samp>&rsquo; (&ldquo;or&rdquo;),
                                        &lsquo;<samp>&amp;&amp;</samp>&rsquo; (&ldquo;and&rdquo;) and &lsquo;<samp>!</samp>&rsquo;
                                        (&ldquo;not&rdquo;).
</td></tr>
<tr><td align="left" valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Conditional expressions select between
                                        two subexpressions under control of a
                                        third subexpression.
</td></tr>
<tr><td align="left" valign="top"><a href="#Function-Calls">6.4 函数调用</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      A function call is an expression.
</td></tr>
<tr><td align="left" valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          How various operators nest.
</td></tr>
<tr><td align="left" valign="top"><a href="#Locales">6.6 哪里造成差异</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                             How the locale affects things.
</td></tr>
<tr><td align="left" valign="top"><a href="#Expressions-Summary">6.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Expressions summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Pattern-Overview">7.1 模式元素</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    What goes into a pattern.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Patterns">7.1.1 以正则表达式为模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Using regexps as patterns.
</td></tr>
<tr><td align="left" valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Any expression can be used as a
                                        pattern.
</td></tr>
<tr><td align="left" valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                              Pairs of patterns specify record
                                        ranges.
</td></tr>
<tr><td align="left" valign="top"><a href="#BEGIN_002fEND">7.1.4 <code>BEGIN</code> 与 <code>END</code> 特殊模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           Specifying initialization and cleanup
                                        rules.
</td></tr>
<tr><td align="left" valign="top"><a href="#Using-BEGIN_002fEND">7.1.4.1 开始与结束动作</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     How and why to use BEGIN/END rules.
</td></tr>
<tr><td align="left" valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   I/O issues in BEGIN/END rules.
</td></tr>
<tr><td align="left" valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Two special patterns for advanced
                                        control.
</td></tr>
<tr><td align="left" valign="top"><a href="#Empty">7.1.6 空模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                               The empty pattern, which matches every
                                        record.
</td></tr>
<tr><td align="left" valign="top"><a href="#Using-Shell-Variables">7.2 在程序中使用 Shell 变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               How to use shell variables with
                                        <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Action-Overview">7.3 动作</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     What goes into an action.
</td></tr>
<tr><td align="left" valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          Describes the various control
                                        statements in detail.
</td></tr>
<tr><td align="left" valign="top"><a href="#If-Statement">7.4.1 <code>if</code>-<code>else</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Conditionally execute some
                                        <code>awk</code> statements.
</td></tr>
<tr><td align="left" valign="top"><a href="#While-Statement">7.4.2 <code>while</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Loop until some condition is
                                        satisfied.
</td></tr>
<tr><td align="left" valign="top"><a href="#Do-Statement">7.4.3 <code>do</code>-<code>while</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Do specified action while looping
                                        until some condition is satisfied.
</td></tr>
<tr><td align="left" valign="top"><a href="#For-Statement">7.4.4 <code>for</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Another looping statement, that
                                        provides initialization and increment
                                        clauses.
</td></tr>
<tr><td align="left" valign="top"><a href="#Switch-Statement">7.4.5 <code>switch</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Switch/case evaluation for conditional
                                        execution of statements based on a
                                        value.
</td></tr>
<tr><td align="left" valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Immediately exit the innermost
                                        enclosing loop.
</td></tr>
<tr><td align="left" valign="top"><a href="#Continue-Statement">7.4.7 <code>continue</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Skip to the end of the innermost
                                        enclosing loop.
</td></tr>
<tr><td align="left" valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Stop processing the current input
                                        record.
</td></tr>
<tr><td align="left" valign="top"><a href="#Nextfile-Statement">7.4.9 <code>nextfile</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Stop processing the current file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Exit-Statement">7.4.10 <code>exit</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Stop execution of <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Built_002din-Variables">7.5 预定义变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Summarizes the predefined variables.
</td></tr>
<tr><td align="left" valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Built-in variables that you change to
                                        control <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                            Built-in variables where <code>awk</code>
                                        gives you information.
</td></tr>
<tr><td align="left" valign="top"><a href="#ARGC-and-ARGV">7.5.3 使用 <code>ARGC</code> 与 <code>ARGV</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Ways to use <code>ARGC</code> and
                                        <code>ARGV</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Pattern-Action-Summary">7.6 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Patterns and Actions summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Basics">8.1 数组基础</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        The basics of arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Introduction to Arrays
</td></tr>
<tr><td align="left" valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               How to examine one element of an
                                        array.
</td></tr>
<tr><td align="left" valign="top"><a href="#Assigning-Elements">8.1.3 给数组元素赋值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How to change an element of an array.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Example">8.1.4 基本数组实例</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Basic Example of an Array
</td></tr>
<tr><td align="left" valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   A variation of the <code>for</code>
                                        statement. It loops through the
                                        indices of an array&rsquo;s existing
                                        elements.
</td></tr>
<tr><td align="left" valign="top"><a href="#Controlling-Scanning">8.1.6 在 <code>gawk</code> 中使用预定义的数组遍历顺序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Controlling the order in which arrays
                                        are scanned.
</td></tr>
<tr><td align="left" valign="top"><a href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How to use numbers as subscripts in
                                        <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Using Uninitialized variables as
                                        subscripts.
</td></tr>
<tr><td align="left" valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                              The <code>delete</code> statement removes an
                                        element from an array.
</td></tr>
<tr><td align="left" valign="top"><a href="#Multidimensional">8.5 多维数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Emulating multidimensional arrays in
                                        <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Multiscanning">8.5.1 遍历多维数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Scanning multidimensional arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arrays-of-Arrays">8.6 多维数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    True multidimensional arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arrays-Summary">8.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Summary of arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Built_002din">9.1 内置函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                            Summarizes the built-in functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    How to call built-in functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Functions that work with numbers,
                                        including <code>int()</code>, <code>sin()</code>
                                        and <code>rand()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Functions for string manipulation,
                                        such as <code>split()</code>, <code>match()</code>
                                        and <code>sprintf()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        More than you want to know about
                                        &lsquo;<samp>\</samp>&rsquo; and &lsquo;<samp>&amp;</samp>&rsquo; with
                                        <code>sub()</code>, <code>gsub()</code>, and
                                        <code>gensub()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Functions for files and shell
                                        commands.
</td></tr>
<tr><td align="left" valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Functions for dealing with timestamps.
</td></tr>
<tr><td align="left" valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Functions for bitwise operations.
</td></tr>
<tr><td align="left" valign="top"><a href="#Type-Functions">9.1.7 获取类型信息</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Functions for type information.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Functions for string translation.
</td></tr>
<tr><td align="left" valign="top"><a href="#User_002ddefined">9.2 用户自定义函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Describes User-defined functions in
                                        detail.
</td></tr>
<tr><td align="left" valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   How to write definitions and what they
                                        mean.
</td></tr>
<tr><td align="left" valign="top"><a href="#Function-Example">9.2.2 函数定义范例</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    An example function definition and
                                        what it does.
</td></tr>
<tr><td align="left" valign="top"><a href="#Function-Caveats">9.2.3 调用用户自定义函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Things to watch out for.
</td></tr>
<tr><td align="left" valign="top"><a href="#Calling-A-Function">9.2.3.1 如何调用函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Don&rsquo;t use spaces.
</td></tr>
<tr><td align="left" valign="top"><a href="#Variable-Scope">9.2.3.2 控制变量作用域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Controlling variable scope.
</td></tr>
<tr><td align="left" valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Passing parameters.
</td></tr>
<tr><td align="left" valign="top"><a href="#Return-Statement">9.2.4 <code>return</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Specifying the value a function
                                        returns.
</td></tr>
<tr><td align="left" valign="top"><a href="#Dynamic-Typing">9.2.5 函数与其在变量类型上的影响</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      How variable types can change at
                                        runtime.
</td></tr>
<tr><td align="left" valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Choosing the function to call at
                                        runtime.
</td></tr>
<tr><td align="left" valign="top"><a href="#Functions-Summary">9.4 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Summary of functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       How to best name private global
                                        variables in library functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#General-Functions">1.2 通用编程</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Functions that are of general use.
</td></tr>
<tr><td align="left" valign="top"><a href="#Strtonum-Function">1.2.1 将数值转换成字串</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   A replacement for the built-in
                                        <code>strtonum()</code> function.
</td></tr>
<tr><td align="left" valign="top"><a href="#Assert-Function">1.2.2 断言</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     A function for assertions in
                                        <code>awk</code> programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      A function for rounding if
                                        <code>sprintf()</code> does not do it
                                        correctly.
</td></tr>
<tr><td align="left" valign="top"><a href="#Cliff-Random-Function">1.2.4 Cliff 随机数生成器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               The Cliff Random Number Generator.
</td></tr>
<tr><td align="left" valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Functions for using characters as
                                        numbers and vice versa.
</td></tr>
<tr><td align="left" valign="top"><a href="#Join-Function">1.2.6 将数组合并成字串</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       A function to join an array into a
                                        string.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getlocaltime-Function">1.2.7 管理时间</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               A function to get formatted times.
</td></tr>
<tr><td align="left" valign="top"><a href="#Readfile-Function">1.2.8 一次读取整个文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   A function to read an entire file at
                                        once.
</td></tr>
<tr><td align="left" valign="top"><a href="#Shell-Quoting">1.2.9 将字串用引号引起并传递给 Shell</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       A function to quote strings for the
                                        shell.
</td></tr>
<tr><td align="left" valign="top"><a href="#Data-File-Management">1.3 数据文件管理</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Functions for managing command-line
                                        data files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Filetrans-Function">1.3.1 注意数据文件的边界</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  A function for handling data file
                                        transitions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Rewind-Function">1.3.2 重新读取当前文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     A function for rereading the current
                                        file.
</td></tr>
<tr><td align="left" valign="top"><a href="#File-Checking">1.3.3 检查可读的数据文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Checking that data files are readable.
</td></tr>
<tr><td align="left" valign="top"><a href="#Empty-Files">1.3.4 检查长度为零的文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Checking for zero-length files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Ignoring-Assigns">1.3.5 将赋值当成是文件名</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Treating assignments as file names.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     A function for processing command-line
                                        arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Functions for getting user
                                        information.
</td></tr>
<tr><td align="left" valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Functions for getting group
                                        information.
</td></tr>
<tr><td align="left" valign="top"><a href="#Walking-Arrays">1.7 遍历多维数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      A function to walk arrays of arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Library-Functions-Summary">1.8 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Summary of library functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Library-Exercises">1.9 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Exercises.
</td></tr>
<tr><td align="left" valign="top"><a href="#Running-Examples">2.1 运行例子程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    How to run these examples.
</td></tr>
<tr><td align="left" valign="top"><a href="#Clones">2.2 为快乐与评测重新发明轮子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                              Clones of common utilities.
</td></tr>
<tr><td align="left" valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         The <code>cut</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       The <code>egrep</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Id-Program">2.2.3 打印用户信息</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          The <code>id</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Split-Program">2.2.4 将大文件分片</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       The <code>split</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Tee-Program">2.2.5 将输出复制到多个文件中</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         The <code>tee</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Uniq-Program">2.2.6 打印去重文本行</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        The <code>uniq</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Wc-Program">2.2.7 统计</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          The <code>wc</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Miscellaneous-Programs">2.3 <code>awk</code> 程序的大集合</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Some interesting <code>awk</code>
                                        programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Dupword-Program">2.3.1 查找文档中的重复字</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Finding duplicated words in a
                                        document.
</td></tr>
<tr><td align="left" valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       An alarm clock.
</td></tr>
<tr><td align="left" valign="top"><a href="#Translate-Program">2.3.3 转换字符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   A program similar to the <code>tr</code>
                                        utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Labels-Program">2.3.4 打印邮件标题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Printing mailing labels.
</td></tr>
<tr><td align="left" valign="top"><a href="#Word-Sorting">2.3.5 生成字使用统计</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        A program to produce a word usage
                                        count.
</td></tr>
<tr><td align="left" valign="top"><a href="#History-Sorting">2.3.6 从未排序的文本中去重</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Eliminating duplicate entries from a
                                        history file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extract-Program">2.3.7 从 Texinfo 源文件中提取程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Pulling out programs from Texinfo
                                        source files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Simple-Sed">2.3.8 一个简单的流编辑器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          A Simple Stream Editor.
</td></tr>
<tr><td align="left" valign="top"><a href="#Igawk-Program">2.3.9 使用库函数的简单方式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       A wrapper for <code>awk</code> that
                                        includes files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Anagram-Program">2.3.10 从字典中查找单词</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Finding anagrams from a dictionary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Signature-Program">2.3.11 来些新鲜的</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   People do amazing things with too much
                                        time on their hands.
</td></tr>
<tr><td align="left" valign="top"><a href="#Programs-Summary">2.4 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Summary of programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Programs-Exercises">2.5 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Exercises.
</td></tr>
<tr><td align="left" valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Allowing nondecimal input data.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Sorting">1.2 控制数组排序与遍历</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Facilities for controlling array
                                        traversal and sorting arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Controlling-Array-Traversal">1.2.1 控制数据遍历</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         How to use PROCINFO[&quot;sorted_in&quot;].
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How to use <code>asort()</code> and
                                        <code>asorti()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Two-way communications with another
                                        process.
</td></tr>
<tr><td align="left" valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Using <code>gawk</code> for network
                                        programming.
</td></tr>
<tr><td align="left" valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           Profiling your <code>awk</code> programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Advanced-Features-Summary">1.6 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Summary of advanced features.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-and-L10N">2.1 国际化与本地化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Internationalization and Localization.
</td></tr>
<tr><td align="left" valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How GNU <code>gettext</code> works.
</td></tr>
<tr><td align="left" valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Features for the programmer.
</td></tr>
<tr><td align="left" valign="top"><a href="#Translator-i18n">2.4 翻译 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Features for the translator.
</td></tr>
<tr><td align="left" valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Extracting marked strings.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printf-Ordering">2.4.2 重排 <code>printf</code> 参数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Rearranging <code>printf</code> arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    <code>awk</code>-level portability
                                        issues.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        A simple i18n example.
</td></tr>
<tr><td align="left" valign="top"><a href="#Gawk-I18N">2.6 <code>gawk</code> 可以说你的语言</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           <code>gawk</code> is also
                                        internationalized.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-Summary">2.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Summary of I18N stuff.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugging">3.1 <code>gawk</code> 调试器介绍</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           Introduction to <code>gawk</code>
                                        debugger.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugging-Concepts">3.1.1 通用的调试技术</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Debugging in General.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugging-Terms">3.1.2 调试概念</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Additional Debugging Concepts.
</td></tr>
<tr><td align="left" valign="top"><a href="#Awk-Debugging">3.1.3 <code>awk</code> 调试</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Awk Debugging.
</td></tr>
<tr><td align="left" valign="top"><a href="#Sample-Debugging-Session">3.2 <code>gawk</code> 调试例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Sample debugging session.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugger-Invocation">3.2.1 如何开启调试器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 How to Start the Debugger.
</td></tr>
<tr><td align="left" valign="top"><a href="#Finding-The-Bug">3.2.2 查找 Bug</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Finding the Bug.
</td></tr>
<tr><td align="left" valign="top"><a href="#List-of-Debugger-Commands">3.3 主要的调试器命令</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Main debugger commands.
</td></tr>
<tr><td align="left" valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Control of Breakpoints.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Control of Execution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Viewing and Changing Data.
</td></tr>
<tr><td align="left" valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Dealing with the Stack.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Obtaining Information about the
                                        Program and the Debugger State.
</td></tr>
<tr><td align="left" valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Miscellaneous Commands.
</td></tr>
<tr><td align="left" valign="top"><a href="#Readline-Support">3.4 支持</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Readline support.
</td></tr>
<tr><td align="left" valign="top"><a href="#Limitations">3.5 限制</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Limitations and future plans.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugging-Summary">3.6 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Debugging summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Computer-Arithmetic">4.1 计算机算术计算说明</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 A quick intro to computer math.
</td></tr>
<tr><td align="left" valign="top"><a href="#Math-Definitions">4.2 要了解的其他知识</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Defining terms used.
</td></tr>
<tr><td align="left" valign="top"><a href="#MPFR-features">4.3 <code>gawk</code> 的任意精度计算</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       The MPFR features in <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#FP-Math-Caution">4.4 浮点算法：买者自慎！</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Things to know.
</td></tr>
<tr><td align="left" valign="top"><a href="#Inexactness-of-computations">4.4.1 浮点计算是不精确的</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Floating point math is not exact.
</td></tr>
<tr><td align="left" valign="top"><a href="#Inexact-representation">4.4.1.1 很多的数不能完全表示</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Numbers are not exactly represented.
</td></tr>
<tr><td align="left" valign="top"><a href="#Comparing-FP-Values">4.4.1.2 值比较时要小心</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 How to compare floating point values.
</td></tr>
<tr><td align="left" valign="top"><a href="#Errors-accumulate">4.4.1.3 错误累积</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Errors get bigger as they go.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getting-Accuracy">4.4.2 获取你需要的精度</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Getting more accuracy takes some work.
</td></tr>
<tr><td align="left" valign="top"><a href="#Try-To-Round">4.4.3 增加几位精度然后再舍入转出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Add digits and round.
</td></tr>
<tr><td align="left" valign="top"><a href="#Setting-precision">4.4.4 设置精度</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   How to set the precision.
</td></tr>
<tr><td align="left" valign="top"><a href="#Setting-the-rounding-mode">4.4.5 设置舍入转出模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           How to set the rounding mode.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arbitrary-Precision-Integers">4.5 <code>gawk</code> 中的任意精度整数计算</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Arbitrary Precision Integer Arithmetic
                                        with <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#POSIX-Floating-Point-Problems">4.6 标准与既存实践</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Standards Versus Existing Practice.
</td></tr>
<tr><td align="left" valign="top"><a href="#Floating-point-summary">4.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Summary of floating point discussion.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Intro">5.1 介绍</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     What is an extension.
</td></tr>
<tr><td align="left" valign="top"><a href="#Plugin-License">5.2 扩展许可</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      A note about licensing.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Mechanism-Outline">5.3 在高层级中是它是如何工作的</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         An outline of how it works.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Description">5.4 API 描述</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           A full description of the API.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Functions-Introduction">5.4.1 介绍</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Introduction to the API functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#General-Data-Types">5.4.2 通用目的的数据类型</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  The data types.
</td></tr>
<tr><td align="left" valign="top"><a href="#Memory-Allocation-Functions">5.4.3 内存分配函数与相应的简化宏</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Functions for allocating memory.
</td></tr>
<tr><td align="left" valign="top"><a href="#Constructor-Functions">5.4.4 构造函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Functions for creating values.
</td></tr>
<tr><td align="left" valign="top"><a href="#Registration-Functions">5.4.5 注册函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Functions to register things with
                                        <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Functions">5.4.5.1 注册扩展函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Registering extension functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Exit-Callback-Functions">5.4.5.2 注册退出函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Registering an exit callback.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Version-String">5.4.5.3 注册扩展版本字串</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Registering a version string.
</td></tr>
<tr><td align="left" valign="top"><a href="#Input-Parsers">5.4.5.4 定制输入分析器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Registering an input parser.
</td></tr>
<tr><td align="left" valign="top"><a href="#Output-Wrappers">5.4.5.5 定制输出包装器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Registering an output wrapper.
</td></tr>
<tr><td align="left" valign="top"><a href="#Two_002dway-processors">5.4.5.6 定制双路处理器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Registering a two-way processor.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printing-Messages">5.4.6 打印信息</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Functions for printing messages.
</td></tr>
<tr><td align="left" valign="top"><a href="#Updating-ERRNO">5.4.7 更新 <code>ERRNO</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Functions for updating <code>ERRNO</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Requesting-Values">5.4.8 请求值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   How to get a value.
</td></tr>
<tr><td align="left" valign="top"><a href="#Accessing-Parameters">5.4.9 访问与更新参数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Functions for accessing parameters.
</td></tr>
<tr><td align="left" valign="top"><a href="#Symbol-Table-Access">5.4.10 符号表访问</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Functions for accessing global
                                        variables.
</td></tr>
<tr><td align="left" valign="top"><a href="#Symbol-table-by-name">5.4.10.1 通过名字访问与更新变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Accessing variables by name.
</td></tr>
<tr><td align="left" valign="top"><a href="#Symbol-table-by-cookie">5.4.10.2 通过 Cookie 访问与更新变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Accessing variables by &ldquo;cookie&rdquo;.
</td></tr>
<tr><td align="left" valign="top"><a href="#Cached-values">5.4.10.3 创建并使用缓存值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Creating and using cached values.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Manipulation">5.4.11 数组操作</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Functions for working with arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Data-Types">5.4.11.1 数组数据类型</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Data types for working with arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Functions">5.4.11.2 数组函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Functions for working with arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Flattening-Arrays">5.4.11.3 遍历数组的所有元素</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   How to flatten arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Creating-Arrays">5.4.11.4 如何生成与发布数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     How to create and populate arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Variables">5.4.12 API 变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Variables provided by the API.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Versioning">5.4.12.1 API Version Constants and Variables</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                API Version information.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Informational-Variables">5.4.12.2 信息变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Variables providing information about
                                        <code>gawk</code>&rsquo;s invocation.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Boilerplate">5.4.13 样板代码</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Boilerplate code for using the API.
</td></tr>
<tr><td align="left" valign="top"><a href="#Finding-Extensions">5.5 <code>gawk</code> 如何找到扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How <code>gawk</code> finds compiled
                                        extensions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Example">5.6 例子：一些文件函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Example C code for an extension.
</td></tr>
<tr><td align="left" valign="top"><a href="#Internal-File-Description">5.6.1 使用 <code>chdir()</code> 与 <code>stat()</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           What the new functions will do.
</td></tr>
<tr><td align="left" valign="top"><a href="#Internal-File-Ops">5.6.2 <code>chdir()</code> 与 <code>stat()</code> 的C 代码</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   The code for internal file operations.
</td></tr>
<tr><td align="left" valign="top"><a href="#Using-Internal-File-Ops">5.6.3 整合扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How to use an external extension.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Samples">5.7 <code>gawk</code> 发行版本中的例子扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   The sample extensions that ship with
                                        <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-File-Functions">5.7.1 与文件相关的函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     The file functions sample.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Fnmatch">5.7.2 针对 <code>fnmatch()</code>　的接口</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            An interface to <code>fnmatch()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Fork">5.7.3 针对 <code>fork()</code>，<code>wait()</code>，与 <code>waitpid()</code> 的接口</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               An interface to <code>fork()</code> and
                                        other process functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Inplace">5.7.4 启用文件就地编辑</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Enabling in-place file editing.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Ord">5.7.5 字符与数值：<code>ord()</code> 与 <code>chr()</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Character to value to character
                                        conversions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Readdir">5.7.6 读取目录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            An interface to <code>readdir()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Revout">5.7.7 倒转输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Reversing output sample output
                                        wrapper.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Rev2way">5.7.8 双路 I/O 例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Reversing data sample two-way
                                        processor.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Read-write-array">5.7.9 输出与恢复数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Serializing an array to a file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Readfile">5.7.10 读取整个文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Reading an entire file into a string.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Time">5.7.11 扩展的时间函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               An interface to <code>gettimeofday()</code>
                                        and <code>sleep()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-API-Tests">5.7.12 <code>API</code> 测试</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Tests for the API.
</td></tr>
<tr><td align="left" valign="top"><a href="#gawkextlib">5.8 <code>gawkextlib</code> 项目</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          The <code>gawkextlib</code> project.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-summary">5.9 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Extension summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Exercises">5.10 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Exercises.
</td></tr>
<tr><td align="left" valign="top"><a href="#V7_002fSVR3_002e1">A.1 在 V7 与 SVR3.1 之间的变化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           The major changes between V7 and
                                        System V Release 3.1.
</td></tr>
<tr><td align="left" valign="top"><a href="#SVR4">A.2 在 SVR3.1 与 SVR4 之间的变化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                                Minor changes between System V
                                        Releases 3.1 and 4.
</td></tr>
<tr><td align="left" valign="top"><a href="#POSIX">A.3 在 SVR4 与 POSIX 之间的变化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                               New features from the POSIX standard.
</td></tr>
<tr><td align="left" valign="top"><a href="#BTL">A.4 Brian Kernighan 的 <code>awk</code> 的扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                                 New features from Brian Kernighan&rsquo;s
                                        version of <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#POSIX_002fGNU">A.5 不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           The extensions in <code>gawk</code> not
                                        in POSIX <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Feature-History">A.6 <code>gawk</code> 特性历史</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     The history of the features in
                                        <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Common-Extensions">A.7 通用扩展汇总</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Common Extensions Summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Ranges-and-Locales">A.8 正则表达式范围与本地语言设置：又臭又长陈年旧事</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How locales used to affect regexp
                                        ranges.
</td></tr>
<tr><td align="left" valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        The major contributors to
                                        <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#History-summary">A.10 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     History summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Gawk-Distribution">B.1 <code>gawk</code> 发布版</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   What is in the <code>gawk</code>
                                        distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getting">B.1.1 取得 <code>gawk</code> 发布版</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                             How to get the distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extracting">B.1.2 提取发布版</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          How to extract the distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Distribution-contents">B.1.3 <code>gawk</code> 发布版的内容</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               What is in the distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Unix-Installation">B.2 在 Unix-like 的系统上编译与安装 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Installing <code>gawk</code> under
                                        various versions of Unix.
</td></tr>
<tr><td align="left" valign="top"><a href="#Quick-Installation">B.2.1 为 Unix-like 的系统编译 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Compiling <code>gawk</code> under Unix.
</td></tr>
<tr><td align="left" valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Other compile-time options.
</td></tr>
<tr><td align="left" valign="top"><a href="#Configuration-Philosophy">B.2.3 配置过程</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How it&rsquo;s all supposed to work.
</td></tr>
<tr><td align="left" valign="top"><a href="#Non_002dUnix-Installation">B.3 安装到其他操作系统上</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Installation on Other Operating
                                        Systems.
</td></tr>
<tr><td align="left" valign="top"><a href="#PC-Installation">B.3.1 安装到 PC 操作系统</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Installing and Compiling
                                        <code>gawk</code> on MS-DOS and OS/2.
</td></tr>
<tr><td align="left" valign="top"><a href="#PC-Binary-Installation">B.3.1.1 为 PC 系统安装一个编译版</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Installing a prepared distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#PC-Compiling">B.3.1.2 为 PC 操作系统编译 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Compiling <code>gawk</code> for MS-DOS,
                                        Windows32, and OS/2.
</td></tr>
<tr><td align="left" valign="top"><a href="#PC-Testing">B.3.1.3 在 PC 操作系统上测试 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                          Testing <code>gawk</code> on PC systems.
</td></tr>
<tr><td align="left" valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                            Running <code>gawk</code> on MS-DOS,
                                        Windows32 and OS/2.
</td></tr>
<tr><td align="left" valign="top"><a href="#Cygwin">B.3.1.5 在 Cygwin 中使用 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                              Building and running <code>gawk</code>
                                        for Cygwin.
</td></tr>
<tr><td align="left" valign="top"><a href="#MSYS">B.3.1.6 在 MSYS 环境中使用 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                                Using <code>gawk</code> In The MSYS
                                        Environment.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Installation">B.3.2 在 Vax/VMS 以及 OpenVMS 系统上编译安装 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Installing <code>gawk</code> on VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Compilation">B.3.2.1 在 VMS 上编译 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     How to compile <code>gawk</code> under
                                        VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Dynamic-Extensions">B.3.2.2 在 VMS 编译 <code>gawk</code> 动态扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Compiling <code>gawk</code> dynamic
                                        extensions on VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Installation-Details">B.3.2.3 在VMS 上安装<code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How to install <code>gawk</code> under
                                        VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Running">B.3.2.4 在 VMS 上运行 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         How to run <code>gawk</code> under VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-GNV">B.3.2.5 VMS 的 GNV 项目</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                             The VMS GNV Project.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Old-Gawk">B.3.2.6 有一些 VMS 系统有旧版本的 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        An old version comes with some VMS
                                        systems.
</td></tr>
<tr><td align="left" valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                                Reporting Problems and Bugs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Other freely available <code>awk</code>
                                        implementations.
</td></tr>
<tr><td align="left" valign="top"><a href="#Installation-summary">B.6 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Summary of installation.
</td></tr>
<tr><td align="left" valign="top"><a href="#Compatibility-Mode">C.1 后向兼容与调试</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How to disable certain <code>gawk</code>
                                        extensions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Additions">C.2 <code>gawk</code> 添加功能</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           Making Additions To <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Accessing-The-Source">C.2.1 访问 <code>gawk</code> 的 Git 仓库</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Accessing the Git repository.
</td></tr>
<tr><td align="left" valign="top"><a href="#Adding-Code">C.2.2 添加新特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         Adding code to the main body of
                                        <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#New-Ports">C.2.3 将 <code>gawk</code> 移植到新系统中</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                           Porting <code>gawk</code> to a new
                                        operating system.
</td></tr>
<tr><td align="left" valign="top"><a href="#Derived-Files">C.2.4 为什么自动生成的文件要放在 Git 中</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Why derived files are kept in the Git
                                        repository.
</td></tr>
<tr><td align="left" valign="top"><a href="#Future-Extensions">C.3 后续可能的扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   New features that may be implemented
                                        one day.
</td></tr>
<tr><td align="left" valign="top"><a href="#Implementation-Limitations">C.4 实现的一些限制</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Some limitations of the
                                        implementation.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Design">C.5 扩展 API 设计</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Design notes about the extension API.
</td></tr>
<tr><td align="left" valign="top"><a href="#Old-Extension-Problems">C.5.1 旧机制的问题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Problems with the old mechanism.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-New-Mechanism-Goals">C.5.2 新机制的目标</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Goals for the new mechanism.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Other-Design-Decisions">C.5.3 其他的设计决策</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Some other design decisions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Future-Growth">C.5.4 未来的增长空间</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Some room for future growth.
</td></tr>
<tr><td align="left" valign="top"><a href="#Old-Extension-Mechanism">C.6 对旧扩展的兼容性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Some compatibility for old extensions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Notes-summary">C.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       Summary of implementation notes.
</td></tr>
<tr><td align="left" valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    The high level view.
</td></tr>
<tr><td align="left" valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   A very quick intro to data types.
</td></tr>
</table>



<hr size="6">
<a name="Foreword3"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Top" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Foreword4" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Foreword4" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00ac_00aca_00b8_0089c_0089_0088aa_0089_008de_00a8_0080"></a>
<h1 class="unnumbered">第三版前言</h1>


<p>我跟 Arnold Robbins 是好朋友。 在 1990 年，
我们由于 AWK 因缘际会而结识。
当时我正开始一份新工作，并注意到在公司角落里放着一台没用的 Unix 计算机。
没有人知道怎么使用它，我也不会。但是，几天后，它跑起来了，并且我就是 root，也是唯一的用户。
从那天起，我就开始从一个统计分析师向一个 Unix 程序员转变了。
</p>
<p>我经常往返于图书馆与书店，搜索跟 Unix 相关的图书。
有一次找到一本灰色的 AWK 相关的书，即 a.k.a. 
Alfred V. Aho, Brian W. Kernighan, 与 Peter J. Weinberger 写的 <cite>The AWK Programming Language</cite>（Addison-Wesley, 1988）。
<code>awk</code> 简洁的编程规范——就是在输入中查找某种模式的字串并执行相应动作——经常能够将复杂的或者冗长的操作化为几行代码。
我非常兴奋，并着手开始利用 AWK 进行编程。
</p>
<p>可是，我计算机上的 <code>awk</code> 是在灰色书里所描述的一个受限的语言版本。
而我发现我的计算机中的就是“旧 <code>awk</code>”，而书中讲述的是“新 <code>awk</code>”。
我知道这是典型情况；旧版本不肯让位，也不愿意放弃自己的名字。
如果一个系统有一个“新 <code>awk</code>”，就会毫无例外地叫做 <code>nawk</code>，并且有几个系统有这样的软件。
取得 <code>nawk</code> 的方式是通过 <code>prep.ai.mit.edu</code> 的 <code>ftp</code> 下载源代码。
<code>gawk</code> 是一个由 David Trueman and Arnold 所写的新版本的 <code>awk</code>，并可以在 GNU General Public License 的许可下取得。
</p>
<p>（顺便说一句，现在找“新 <code>awk</code>”很容易了，GNU/Linux 就带有，你也可以在大多数系统中下载二进制版本或者源代码；
我老婆就在她的 VMS BOX 中使用 <code>gawk</code>。）
</p>
<p>我的 Unix 系统因闲置而被使用起来，当然也还不会连接到网络中。
因此，很明显由于 <code>gawk</code> 的存在，以及 Unix 社会社区的一般特点，我需要一个“新 <code>awk</code>”。
因此，我就写了一个，我把它叫做 <code>mawk</code>。
在我完成前，我已经知道了 <code>gawk</code>，但是已经太迟了。
因此，我还是把 <code>mawk</code> 发送到了 <code>comp.source</code> 的新闻组里。
</p>
<p>几天后，我收到了来自 Arnold 的邮件，里面他介绍了一下他自己。
他建议我分享 <code>mawk</code> 的设计与算法，并且提交一个 POSIX 标准草案，这样我就能够更新 <code>mawk</code> 来支持 <cite>The AWK Programming Language</cite> 发布后的语言扩展。
</p>
<p>袒白讲，如果我们的角色互换，我可能就不会如此开放，我们也就可能从不会见面。
我很高兴我们见了一面。他是一个 AWK 专家中的专家，也是确实是个好人。
Arnold 为 Free Software Foundation 贡献了很多的才能与时间。
</p>
<p>这本书是 <code>gawk</code> 的参考书，但是核心是一个关于 AWK 编程的书，适用于非常广的读者。
编程规范参考的是 1987 年贝尔实验室的定义，并于 1992 年成为 POSIX 工具标准的语言规范。
</p>
<p>另一方面，对于 AWK 程序新手，能够学到实用的编程方法，而这也正是 AWK 的基本方法：
数据驱动控制流，利用正则表达式进行匹配，以及关联数组。那些正在尝鲜的人可以通过特殊的 &lsquo;<tt>/inet</tt>&rsquo; 文件来使用 <code>gawk</code> 的网络协议接口。
</p>
<p>这本书中的例子会清楚地表明，使用 AWK 编写的程序要比C写成的程序更小更快。
结果，可能利用 AWK 来编写算法并快速运行，以此来及时发现问题。经常的情况下，解释型的性能就足够了，因此 AWK 的原型就直接转换成了产品。
</p>
<p>新的 <code>pgawk</code>（profiling gawk）会产生代码执行的采样数据。
我最近实验了一个算法，即对 
<em>n</em>
行输入，显示出约
~ C n^2
这样的性能，而理论预测下为约 
~ C n log n
。查看了 &lsquo;<tt>awkprof.out</tt>&rsquo; 程序几分钟后，就在程序的一行代码中发现了问题所在。
这样，<code>pgawk</code> 又成为我程序员工具箱中的一个好工具。
</p>
<p>Arnold 淫浸在 AWK 中有十几年，并且开发了 <code>gawk</code>，也即本书的主题。如果你使用 AWK，并且想知道 how，那么就读这本书吧。
</p>
<a name="index-Brennan_002c-Michael"></a>
<div class="display">
<pre class="display">Michael Brennan
Author of <code>mawk</code>
March 2001
</pre></div>

<hr>
<a name="Foreword4"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Foreword3" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Foreword3" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Preface" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Preface" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00ac_00acaa_009b_009bc_0089_0088aa_0089_008de_00a8_0080"></a>
<h1 class="unnumbered">第四版前言</h1>


<p>有些东西一直没有变化。
13 年前，我写下“如果你使用 AWK 或者想学习它如何工作，那么就读这本书。”
这句话当时是真理，而现在依然是真理。
</p>
<p>学习如何使用编程语言并仅仅是掌握语法这么简单。需要在理解的基础上利用语言提供的特性来解决现实中的编程问题。这本书的焦点就是用许多的例子来展示如何使用 AWK。
</p>
<p>而有些东西是有变化的。我们的计算机要比之前快得多，并且有更多的内存。结果是高级的语言导致了速度与存储的低效使用。因为性能而先在 AWK 中写原型然后用 C 重写，这种情况很少发生，因为更多的情况下，原型已经足够快了。
</p>
<p>当然，有些操作更适合于用 C 或者 C++ 来实现，对于 <code>gawk</code> 4.1 以及后面的版本，你不需要选择到底是用 AWK 还是用 C/C++ 来实现。你可以用 AWK 来实现大部分的程序。而用 C/C++ 来写的程序，你完全可以用 C 或者 C++ 来写成动态插件，然后使用 <code>gawk</code> 进行装载合并。
<a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>,
描述了所有的技术细节，其中有许多的例子，希望让你学习到里里外外的一切。
</p>
<p>我很享受用 AWK 来进行编程，并且在用心（重）读这本书。我想你也会这样。
</p>
<a name="index-Brennan_002c-Michael-1"></a>
<div class="display">
<pre class="display">Michael Brennan
Author of <code>mawk</code>
October 2014
</pre></div>

<hr>
<a name="Preface"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Foreword4" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Foreword4" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0089_008de_00a8_0080"></a>
<h1 class="unnumbered">前言</h1>



<p>当工作于文本文件的时候，有几类工作不断重复出现。
你可能想抽取指定的行并丢弃其他部分。或者你想更改特定模式的文本，而其他部分的不变。
这样的工作使用 <code>awk</code> 来完成通常很简单。<code>awk</code> 工具解释特定的编程语言，使得它处理数据重组的工作非常在行。
</p>
<p>GNU 版本的 <code>awk</code> 称为 <code>gawk</code>。在使用恰当的参数或者环境变量的情况下，
它完全与 POSIX 标准<a name="DOCF1" href="#FOOT1">(1)</a> <code>awk</code> 语言兼容，同时与 Brian Kemighan 维护的 Unix 版本的 <code>awk</code> 语言兼容。
这就是说，正确编写的 <code>awk</code> 程序，也可以在 <code>gawk</code> 下运行。因此，在大多情况下，我们不区别两者的实现。
</p>
<a name="index-awk_002c-POSIX-and_002c-See-Also-POSIX-awk"></a>
<a name="index-awk_002c-POSIX-and"></a>
<a name="index-POSIX_002c-awk-and"></a>
<a name="index-gawk_002c-awk-and"></a>
<a name="index-awk_002c-gawk-and"></a>
<a name="index-awk_002c-uses-for"></a>

<p>通过 <code>awk</code> 我们可以达到如下目的：
</p>
<ul>
<li>
管理小的个人数据库

</li><li>
产生报表

</li><li>
完善数据

</li><li>
产生索引并执行其他文件准备工作

</li><li>
实验算法，这样可以回头用其他的语言实现。

</li></ul>

<a name="index-awk_002c-See-Also-gawk"></a>
<a name="index-gawk_002c-See-Also-awk"></a>
<a name="index-gawk_002c-uses-for"></a>

<p>除此之外，<code>gawk</code> 还提供如下设施，使我们能够：
</p>
<ul>
<li>
抽取数据的位或者块用于处理

</li><li>
排序数据

</li><li>
实现简单的网络通讯

</li><li>
测评并调试 <code>awk</code> 程序

</li><li>
用 C/C++ 编写函数以扩展语言功能

</li></ul>

<p>本网页会向你们传授 <code>awk</code> 语言，并告诉你们如何来有效地使用它。
你有可能已经熟悉基本的系统命令，如 <code>cat</code>、<code>ls</code><a name="DOCF2" href="#FOOT2">(2)</a> 等，也熟悉一些基本的 shell 工具，如输入输出重定向以及管道。
</p>
<a name="index-GNU-awk_002c-See-gawk"></a>

<p><code>awk</code> 语言的实现可以在许多不同的计算机环境中获取。
本网页除了描述 <code>awk</code> 语言的总体，也会描述<code>awk</code> 的特殊实现，即 <code>gawk</code>（表示 GNU <code>awk</code>）。
<code>gawk</code> 在很多 Unix 系统下运行，包括从 Intel 架构的 PC 机，到大型机系统。
<code>gawk</code> 也被移植到了 Mac OS 平台，Windows 平台
（所有版本） 以及 OS/2 的 PC 机，
还有 OpenVMS<a name="DOCF3" href="#FOOT3">(3)</a> 系统上。 
</p>
<hr>
<a name="Translator-Preface"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Preface" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#History" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_0091aa_00ba_008f"></a>
<h1 class="unnumbered">译序</h1>

<p>这是我第一次翻译这么长的书。
</p>
<p>当我看到 GAWK 简单的语言与强大的功能时，我于是想到网上查找一些中文的资料，以快速学习一下这个工具，这样可以方便我在处理 Linux 字串时能够使用到它。
</p>
<p>但是我很失望，找了很久，能够找到的资料基本上是支离破碎的，并没有完整全面的中文手册。我于是求其次地找了一个英文文档，其原名为《GAWK: Effective AWK Programming》，由 Arnold D. Robbins，即 <code>gawk</code> 当前的主要维护者之一编写。初看之下，里面的内容浅显易懂，正好符合我自己的需求。因为这个原因，我萌发了将这个手册翻译为中文的想法。但是我拿不准我是否有这样的坚持，能够将这个手册全部翻译出来。
</p>
<p>我长久都没有动手，主要是因为没有这个魄力下定决心来做这件事情，再一个对于自己的语言能力也不太自信。一年后，这个想法一直在大脑里挥之不去。于是心里盘算，英文文档大概有 500 多页，如果我每天翻译两页，则一年后，怎么着也能够把这个文档翻译出来。并且，如果能够翻译到四页，则所需要的时间立即减少一半。翻译一本英文书，除去能力外，还得看自己是不是能够放弃翻译时的功利想法，觉得这么做是否值得。并在这种情况下，是否能够坚持一个较长而无味的过程，最后将文档翻译出来。最后，我还是下定决心，试一试。
</p>
<p>于是我第一步是将 PDF 格式的英文文档转换成 Word 文档（我用其他的工具转换过，但是结果不是很好。因为原来的 PDF 文档中有很多特别的格式，在 Word 中很难控制。所以一不做，二不休，干脆把文字复制出来，再调整其格式与原来的 PDF 相符。我不知道这么做是不是很蠢，并有违程序员懒的美名！）。光这个事情就耗了我近一个星期的时间，2016 年春节前把这个底本做好了，并且开始了翻译。
</p>
<p>实在的，前面的翻译速度是有一点慢，但是总体来说，还是按照原先的设计速度进行的。就算在过年的几天里，几乎每天都有进展。而且，翻译的难度不是很大，最考验人的是每天要拿出一定的时间来做这个事情。因为一旦停下来，就会为停下来找理由。后面就会有越来越多的理由来为延迟开脱。所以，自从翻译开始，我几乎没有中断每天做一点翻译。在翻译最后的几个附录中，我还差点要放弃翻译下去，因为觉得那些东西翻译没有什么用。但是为了保证翻译的完整性，同时也为把这个事情做“圆满”，我还是坚持把这个事情做下来了。最后只剩下 GPL 与 FDL 没有翻译。这两个协议比较其他的部分有难度一些。关键在于要翻译出带点协议性质，语言精准而且严谨，确实对我而言，能力还是不够的。而且这两个协议，我想在互联网上应该已经有了，所以也就不再翻译了。
</p>
<p>翻译到后面的时候，自己确实感觉比原来快了，可能是因为熟练了的原因。剩下的整理也花掉了我的一些时间。通过翻译这个事情，确实使自己有如下收获：
</p>
<ol>
<li>
至少对 Word 文档的操作有一点点提升。

</li><li>
考验并提升了一下自己的能力。

</li><li>
再遇到长的英文文档，可能就没那么怵了。

</li><li>
翻译能力是否有大的提高，这个不好说，但是应该有一点吧。

</li></ol>

<p>这里的文字，几乎都是一个字一个字码起来，而且也是第一次翻译，里面肯定还是有很多错误的地方，也有一些词不达意的地方，对于汉语的掌握有欠火候，也会使得翻译出来的行文没有那么符合中文习惯，或者不够优美。这些真还得要各位海涵，如果大家觉得这个翻译对大家有一点作用，我就觉得这些付出也值得了。如果读者更慷慨一点，能够告诉我哪里有问题，或者有一些改进的建议那就更好了。如果有这方面的改进，请发邮件到 yeyouqun@163.com。
</p>
<p>我希望我的一点小努力，也为中国的软件事业做了一点点贡献。
</p>
<p>在最后，如果要有什么感谢的，首先得要感谢自由软件运动的发起者们。如果没有他们，就不会有自由软件社区，也就不会有 GNU/Linux，也就没有 GAWK 这些优秀的工具。其次还要感谢原文的作者。别人也是自由软件的拥趸，如果没有他们的先期付出，也就没有这个文档的存在。目前还只有我一个人在翻译这个文档，如果可以，我想小激动地感谢一下自己。我希望以后感谢列表能够变得更长。希望更多的人参与到完善它的过程里来。
</p>
<p>对了，我想感谢一下我儿子。好多次我打开电脑开启一天的翻译工作的时候，他经常会在键盘上随意敲击，使得我还得花掉一些时间来撤销他所做的“工作”。而且还要嚷着要听 《ABCD 歌》什么的，还得陪他听他所说的一万分钟那么久。
</p>
<p>不自量力的叶佑群
</p>
<p>2016 年 4 月 
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     The history of <code>gawk</code> and
                                <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Names">玫瑰别名</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       What name to use to find <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#This-Manual">使用本书</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Using this website. Includes sample
                                input files that you can use.
</td></tr>
<tr><td align="left" valign="top"><a href="#Conventions">排版约定</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Typographical Conventions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Brief history of the GNU project and this
                                website.
</td></tr>
<tr><td align="left" valign="top"><a href="#How-To-Contribute">如何贡献</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Helping to save the world.
</td></tr>
<tr><td align="left" valign="top"><a href="#Acknowledgments">致谢</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Acknowledgments.
</td></tr>
</table>


<hr>
<a name="History"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Names" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-a_00b8_008e-gawk-c_009a_0084aa_008e_0086aa_008f_00b2"></a>
<h2 class="unnumberedsec"><code>awk</code> 与 <code>gawk</code> 的历史</h2>
<a name="index-recipe-for-a-programming-language"></a>
<a name="index-programming-language_002c-recipe-for"></a>
<a name="index-sidebar_002c-c_00bc_0096c_00a8_008be_00af_00ade_00a8_0080e_008f_009caa_008d_0095"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>编程语言菜单</b>
</p>


<table>
<tr><td></td><td>1 份 <code>egrep</code></td><td>1 份 <code>snobol</code><a name="DOCF4" href="#FOOT4">(4)</a></td></tr>
<tr><td></td><td>2 份 <code>ed</code></td><td>3 份 C</td></tr>
</table>

<p>将所有部分通过 <code>lex</code> 与 <code>yacc</code> 混合在一起，并且辅以少量文档，并发布。
</p>
<p>8 年后，添加多一份 <code>egrep</code>，以及两份的 C。文档完备然后发布。
</p></td></tr></table>

<a name="index-Aho_002c-Alfred"></a>
<a name="index-Weinberger_002c-Peter"></a>
<a name="index-Kernighan_002c-Brian"></a>
<a name="index-awk_002c-history-of"></a>

<p><code>awk</code> 的名字来源于最初的设计者：Alfred V.
Aho, Peter J. Weinberger 和 Brian W. Kernighan。
它的第一个版本写于 1977 年的 AT&amp;T 贝尔实验室。
1985 年，新版本语言通过引入用户自定义的函数、多输入流、正则表达式，而使得其功能更加强大。
新版本的 <code>gawk</code> 在 Unix System V Release 3.1（1987 年）的时候已经广泛可用。
而在 System V Release 4（1989 年）中的版本添加了一些新的特性，并清理掉了一些语言的“暗角”行为。
在 POSIX 命令语言以及工具标准中，对 <code>awk</code>规范进行进一步的澄清。
<code>gawk</code> 的设计者与最初的 <code>awk</code> 设计者对于 POSIX 规范都有相应的反馈。
</p>
<a name="index-Rubin_002c-Paul"></a>
<a name="index-Fenlason_002c-Jay"></a>
<a name="index-Trueman_002c-David"></a>
<p>Paul Rubin 在 1986 年编写了 <code>gawk</code>，Jay Fenlason 根据 Richard Stallman 的建议完善了它。
John Woods 也贡献了部分代码。在 1988 年和 1989 年，David Trueman 在我的帮助下完全重构了 <code>gawk</code>，以解决与更新的 <code>awk</code> 兼容的问题。
大概是 1994 年，我成为了主要的维护者。现在的版本主要着眼于 Bug 修复、性能提升，标准化，有时也添加一些新的特性。
</p>
<p>1997 年 5 月，J&uuml;rgen Kahrs 觉得有必要用 <code>awk</code> 访问网络，在我的一些帮助下，<code>gawk</code> 添加进了这样的特性。
当时，他也写了 <cite>TCP/IP Internetworking with <code>gawk</code></cite>
（一个单独可获取的文档，是 gawk 发行版本的一部分）的主体内容。
他的代码最终在 <code>gawk</code> 3.1 版本 的时候成为主流 <code>gawk</code> 发布版本的一部分。
</p>
<p>John Haque 重写了 <code>gawk</code> 的内部实现，以提供 <code>awk</code> 级的调试器，这个版本在 2011 年的 <code>gawk</code> 4.0 版本 可用。
</p>
<p>查看 <a href="#Contributors"><code>gawk</code> 的主要贡献者</a>。
</p>
<hr>
<a name="Names"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#History" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#This-Manual" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_008e_00abc_0091_00b0aa_0088_00abaa_0090_008d"></a>
<h2 class="unnumberedsec">玫瑰别名</h2>

<a name="index-awk_002c-new-vs_002e-old"></a>

<p><code>awk</code> 语言已经进化了多年，在 <a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095"><code>awk</code> 语言的演化</a>，有完全的列表。
在本网页中所涉及的我们可以称为“new <code>awk</code>”。
类似的，<code>awk</code> 的原始版本称为“old <code>awk</code>”。
</p>
<p>在现在多数的系统中，你运行 <code>awk</code> 工具你都有一些版本的新 <code>awk</code><a name="DOCF5" href="#FOOT5">(5)</a>。
如果你的系统中的标准 <code>awk</code> 是旧的版本，你用下面的代码测试，就可以得到这样的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 1 /dev/null</kbd>
error--&gt; awk: syntax error near line 1
error--&gt; awk: bailing out near line 1
</pre></div>

<p>在这个例子中，你应该能查找到一新版本的 <code>awk</code>，或者直接安装 <code>gawk</code> 即可。
在本网页中，如果所涉及的所有语言特性，都在一个完整实现了 POSIX 标准的 <code>awk</code> 中找到，我们为了简化，就使用 <code>awk</code> 来指代。当提到的特性特定于 GNU 版本，我们则使用 <code>gawk</code> 指代。
</p>
<hr>
<a name="This-Manual"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Names" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Conventions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8ae_009c_00aca_00b9_00a6"></a>
<h2 class="unnumberedsec">使用本书</h2>
<a name="index-awk_002c-terms-describing"></a>

<p><code>awk</code> 这个词，即指代特定的程序，也表示你要用于告诉这个程序所做事情的语言。
当需要特别小心时，我们称之为“<code>awk</code> 语言”，以及“<code>awk</code> 工具”。
本网页既说明如何用 <code>awk</code> 语言编写程序，也说明如何来运行 <code>awk</code> 工具。
“<code>awk</code> 程序”术语则指用 <code>awk</code> 语言编写的程序。
</p>
<a name="index-gawk_002c-awk-and-1"></a>
<a name="index-awk_002c-gawk-and-1"></a>
<a name="index-POSIX-awk"></a>

<p>本书主要涉及 POSIX 标准所定义的 <code>awk</code> 特性。也包括在 <code>gawk</code> 中实现了的那些特性。这么处理，在于试图描述 <code>gawk</code> 与其他 <code>awk</code> 
实现版本<a name="DOCF6" href="#FOOT6">(6)</a>
之间的差异。
最后，会提及那些在 <code>gawk</code> 中实现了，但不在 <code>awk</code> POSIX 标准中定义的特性。
</p>
<p>本网页既可以作为教程，又可以作为参考。如果你是个新手，你可以跳过那些复杂的部分。你也可以忽略那些交叉参考；他们主要用于专家级用户，同时作为信息参考以及用于本网页的 
<a href="http://www.gnu.org/software/gawk/manual/">HTML</a>
版本。
</p>
<p>在全网页中还分布有一些边侧栏。
它们主要对相关的点进行更完整全面的解释，但是第一次读本网页时可能不太有兴趣涉猎。
所有在边侧栏的内容会在索引中出现。
</p>
<p>在多数据情况下，我们使用的例子都是完整的 <code>awk</code> 程序。
一些进阶部分的小节，仅显示 <code>awk</code> 程序的一部分，以此来说明正在进行描述的概念。
</p>
<p>本网页主要目标人群主要集中在那些还没接触过 <code>awk</code> 的人，书中相当多的信息对于专家也非常有用。
对于 <code>awk</code> POSIX 标准的部分更是如此。
包括在 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a> 和
在
<a href="#Sample-Programs">实用的 <code>awk</code> 程序</a> 的样例程序。这些样例程序应该会相当有趣。
</p>
<p>本网页分为如下这些部分：
</p>

<ul>
<li>
第一部分对 <code>awk</code> 语言以及 <code>gawk</code> 程序进行详细描述。通过从最基础的开始，不断详解 <code>awk</code> 的所有特性。
它们包含如下章节：

<ul class="no-bullet">
<li>-
<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">开始 <code>awk</code></a>,
包括一些使用 <code>awk</code> 的基本内容。

</li><li>-
<a href="#Invoking-Gawk">运行 <code>awk</code> 与 <code>gawk</code></a>,
描述如何运行 <code>gawk</code>、命令行参数的意义，以及它如何来查找 <code>awk</code> 程序源代码。

</li><li>-
<a href="#Regexp">正则表达式</a>,
总体介绍正则表达式，尤其是那些 POSIX <code>awk</code> 以及 <code>gawk</code> 所支持的内容。

</li><li>-
<a href="#Reading-Files">读取输入文件</a>,
描述 <code>awk</code> 如何来读取数据。本章中介绍记录（Records）与域（Fields）的概念，也包括 <code>getline</code> 命令。I/O 重定向是首先要描述的部分，而网络 I/O 则简单涉及。

</li><li>-
<a href="#Printing">打印输出</a>,
介绍在 <code>awk</code> 程序中如何使用 <code>print</code> 与 <code>printf</code> 产生输出。

</li><li>-
<a href="#Expressions">表达式</a>,
介绍表达式，这些表达式是构建程序代码块，并完成目标的基础。

</li><li>-
<a href="#Patterns-and-Actions">模式、动作与变量</a>,
描述如何为匹配记录编写模式，即当某个记录匹配时所执行的动作。同时还包括 <code>awk</code> 与 <code>gawk</code> 所使用的预定义变量。

</li><li>-
<a href="#Arrays"><code>awk</code> 数组</a>,
包括 <code>awk</code> 中的唯一的数组结构，关联数组。删除数组元素以及整个数组，同时也涉及 <code>gawk</code> 中的数组的排序。
在本章还包括 <code>gawk</code> 如何来提供多维数组的实现方式。

</li><li>-
<a href="#Functions">函数</a>,
描述 <code>awk</code> 与 <code>gawk</code> 所提供的内建函数，以及用户自定义函数。讨论 <code>gawk</code> 如何来间接调用函数。

</li></ul>

</li><li>
第二部分展示如何使用 <code>awk</code> 与 <code>gawk</code> 来解决实际问题。
这里有非常多的代码供读者阅读与学习。这个部分包括如下各章：

<ul class="no-bullet">
<li>-
<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a>, 展示大量的可以通过 <code>awk</code> 程序来调用的函数。

</li><li>-
<a href="#Sample-Programs">实用的 <code>awk</code> 程序</a>,
有许多的 <code>awk</code> 程序。

</li></ul>

<p>通过阅读这两章，可以让你看到 <code>awk</code> 程序如何来解决真正的问题。
</p>
</li><li>
第三部分关注特定于 <code>gawk</code> 的特性，它们包括如下各章：

<ul class="no-bullet">
<li>-
<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk"><code>gawk</code> 的高级特性</a>,
描述各种高级特性。其中包括如来控制数组遍历的顺序、与另一个进程之间的双向通信、执行 TCP/IP 通信、测评你的 <code>awk</code> 程序。

</li><li>-
<a href="#Internationalization"><code>gawk</code> 的国际化</a>,
描述如何将程序消息在运行时翻译成不同语言的特性。

</li><li>-
<a href="#Debugger">调试 <code>awk</code> 程序</a>, 
描述 <code>gawk</code> 调试器。

</li><li>-
<a href="#Arbitrary-Precision-Arithmetic">算术运算与 <code>gawk</code> 中的任意精度算术运算</a>,
描述高级的数学计算工具。

</li><li>-
<a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>, 
描述如何通过编写 C 与 C++ 扩展为 <code>gawk</code> 添加新变量与函数。

</li></ul>

</li><li>
第四部分包括一些附录，名词解释，以及本网页代码所使用的两个许可。它们包含如下附录：

<ul class="no-bullet">
<li>-
<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095"><code>awk</code> 语言的演化</a>,
描述 <code>awk</code> 语言从第一个版本到现在的演化过程。同时也描述 <code>gawk</code> 在不同的时间内所引入的特性。

</li><li>-
<a href="#Installation">安装 <code>gawk</code></a>,
描述如何获取 <code>gawk</code>，如何在 POSIX 兼容的系统中编译，以及如何在非 POSIX 系统中编译与使用它。
介绍如何来报告 <code>gawk</code> Bug，
以及介绍可以自由获取 <code>awk</code> 的地方。


</li><li>-
<a href="#Notes">实现提示</a>,
描述如何禁用 <code>gawk</code> 扩展，以及如何向 <code>gawk</code> 贡献新代码，还包括 <code>gawk</code> 未来可能的开发方向。

</li><li>-
<a href="#Basic-Concepts">基本编程概念</a>,
为那些初识计算编程的人提供一些粗略的背景资料。

<p><a href="#Glossary">名词解释</a>, 
定义大多数的本网页中所用到的术语的意义，如果你看到你不熟悉的，可以参考这里。
</p>
</li><li>-
<a href="#Copying">GNU General Public License</a>, and
<a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>,
提供本网页中源代码以及本网页所使用到的两个许可证协议。

</li></ul>
</li></ul>



<hr>
<a name="Conventions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#This-Manual" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#ae_009a_0097e_00a7_0092" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008e_0092c_0089_0088c_00ba_00a6aa_00ae_009a"></a>
<h2 class="unnumberedsec">排版约定</h2>

<a name="index-Texinfo"></a>
<p>本网页是通过 <a href="http://www.gnu.org/software/texinfo/">Texinfo</a><a name="DOCF7" href="#FOOT7">(7)</a> 完成的。
这是一种文档格式化语言。 单一的 TexInfo 源文件，即可用于产生在线版本的文档，也可以产生打印输出的文档。
因为这个原因，其排版约定与你所读其他的书可能有一些差异。
</p>
<p>你在命令行上输入的例子，由通用的 Shell 主次提示符，&lsquo;<samp>$</samp>&rsquo; 与 &lsquo;<samp>&gt;</samp>&rsquo; 引导。
输入命令<kbd>如下</kbd>。
命令行的输出由字符“-|”引导。这代表了命令行的典型输出。
错误信息以及其他的命令行标准错误输出则由“error--&gt;”引导，例如：
</p>
<div class="example">
<pre class="example">$ <kbd>echo hi on stdout</kbd>
-| hi on stdout
$ <kbd>echo hello on stderr 1&gt;&amp;2</kbd>
error--&gt; hello on stderr
</pre></div>

<p>在文本中，所有与程序相关的东西，如命令名、变量和函数名、字串、数据、正则表达式常量都以 <code>this font</code> 这样的字体出现。
代码段也以相同的字体呈现，并用单引号括起来，表现为 &lsquo;<samp>like this</samp>&rsquo;。
由用户或者程序员替换的部分以 <var>this font</var>，这样的字体出现。
选项是如 &lsquo;<samp>-f</samp>&rsquo; 这样的参数。文件名由 &lsquo;<tt>/path/to/ourfile</tt>&rsquo; 这样的串提示。
有些需要强调的东西以 <em>这样</em> 的字体出现。
如果某一点需要特别强调，它以 <strong>这样</strong> 的字体出现。
第一个出现的术语，同一个句子中的先前出现的术语，包括其定义也用相同的字体，表现为 <em>这样</em> 的字体。
</p>
<p>你从键盘上键入的字符也用 <kbd>like this</kbd> 这样的字体呈现。
对于一些特别的“控制字符”，这些字符是需要你同时键入 <kbd>CONTROL</kbd> 键以及另一个键来输入。
比如 <kbd>Ctrl-d</kbd> 需要首先按下并保持 <kbd>CONTROL</kbd> 键，然后敲击 <kbd>d</kbd> 键，然后再释放两个键。
</p>
<p>为了简单处理，在本网页中，我们把 Brian Kernighan 版本的 <code>awk</code> 称为“BWK <code>awk</code>”（<a href="#Other-Versions">其他可自由获取的 <code>awk</code></a>，查看这个版本与其他版本的信息）。
</p>
<hr>
<a name="ae_009a_0097e_00a7_0092"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Conventions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Conventions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Manual-History" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="unnumberedsubsec">暗角</h3>
<a name="index-Kernighan_002c-Brian-1"></a>
<blockquote>
<p><i>暗角总是存在的——无论你多么仔细，总是有一些更小的，黑暗的地方。</i>
</p></blockquote>
<p align="center">&mdash; <em>Brian Kernighan</em>
</p>
<a name="index-d_002ec_002e_002c-See-dark-corner"></a>
<a name="index-dark-corner"></a>
<p>在没有做 POSIX 标准（以及没写 <cite>GAWK: Effective AWK Programming</cite>）之前，<code>awk</code> 特性的文档少得可怜，甚至是没有文档。
对于这样的特性（经常称为“暗角”）在这个网页以
&ldquo;(d.c.).&rdquo;
的形式提示。
它们也出现在索引中的“暗角”区。
</p>
<p>但是，正如开放性引述所提示的，在定义上对暗角的覆盖是不完全的。
</p>
<a name="index-c_002ee_002e_002c-See-common-extensions"></a>

<p>对于 <code>awk</code> 标准语言的扩展，很多 <code>awk</code> 实现都支持，他们用
&ldquo;(c.e.),&rdquo; 进行标示，并在索引中的“通用扩展”以及“扩展，通用”中进行列出。
</p>
<hr>
<a name="Manual-History"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#ae_009a_0097e_00a7_0092" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#How-To-Contribute" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="GNU-e_00a1_00b9c_009b_00aeaa_008f_008aae_009c_00acc_00bd_0091e_00a1_00b5"></a>
<h2 class="unnumberedsec">GNU 项目及本网页</h2>

<a name="index-FSF-_0028Free-Software-Foundation_0029"></a>
<a name="index-Free-Software-Foundation-_0028FSF_0029"></a>
<a name="index-Stallman_002c-Richard"></a>

<p>自由软件基金会（FSF）是一个非营利性组织，其专注于开发与发布可自由分发的软件。
它由 Richard M. Stallman——即最初的 Emacs 编辑器的作者——创建。GNU 的 Emacs 软件也是目前用得最广泛的 Emacs 版本。
</p>
<a name="index-GNU-Project"></a>
<a name="index-GPL-_0028General-Public-License_0029"></a>
<a name="index-General-Public-License_002c-See-GPL"></a>
<a name="index-documentation_002c-online"></a>

<p>GNU<a name="DOCF8" href="#FOOT8">(8)</a> 
项目是自由软件基金会的项目，其目前依然还在持续地为创建一个完全可自由发布，与 POSIX 兼容的计算环境而努力。
自由软件基金会通过“通用公共请可”（GPL）来保证其下的软件的源代码对于终端用户总是可用的。
GPL 的复本已经包含在
本网页中
以供参考
(see section <a href="#Copying">GNU General Public License</a>).
GPL 也应用于用 C 写成的 <code>gawk</code>。要查找更多的关于自由软件基金会以及 GNU 项目的在线信息，你可以查看 <a href="http://www.gnu.org">GNU 项目的主页</a>。
本网页也可以从 <a href="http://www.gnu.org/software/gawk/manual/">GNU 站点</a> 上阅读。
</p>
<p>Shell，编辑器（Emacs），高度可移植的 C、C++ 与 Object-C 编译器，符号调试器以及大量的小工具（如 <code>gawk</code>），都已经完成并可自由获取。
GNU 操作系统内核（HURD）也已经发布，只是还处于开发的早期阶段。
</p>
<a name="index-Linux"></a>
<a name="index-GNU_002fLinux"></a>
<a name="index-operating-systems_002c-BSD_002dbased"></a>
<p>在 GNU 操作系统完全开发好前，你应该考虑使用 GNU/Linux，一个可自由发布的，Unix-like 的操作系统，用于 Intel、Power 这样的构架，Sun Sparc，IBM S/390 等其他系统<a name="DOCF9" href="#FOOT9">(9)</a>。很多的 GNU/Linux 发行版本都可以通过互联网下载。
</p>
<p>你正在阅读的这个网页也是免费的——最起码的。
这里面的信息对任何一个人都是免费的。也包括与 <code>gawk</code> 相关的，对于机器可读的源代码。
（花一点时间阅读一下在<a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>中的自由文档许可证协议。）
</p>
<a name="index-Close_002c-Diane"></a>
<p>此网页已经经过了多个版本。Paul Rubin 写了第一份 <cite>The GAWK Manual</cite>，大概有40页。
Diane Close 与 Richard Stallman 丰富了它，产生了一个大概 90 页的版本，它只针对最初的，“旧”版本的 <code>awk</code>。
</p>
<p>我从 1988 年秋天开始着手制作那个版本。随着工作的推进，自由软件基金会出版了几个初步的版本（版本号 0.<var>x</var>）。
在 1996 年，1.0 版本随着 <code>gawk</code> 3.0.0 发布。
自由软件基金会出版了前两个版本，书名为 <cite>The GNU Awk User&rsquo;s Guide</cite>。
</p>
<p>这一版维持了之前的版本的基本结构。
FSF 4.0 版的内容完全校对和更新了。所有 4.0 版本之前的 <code>gawk</code> 版本的参考都删去了。
那个版本中很重要的一点是增加了 <a href="#Debugger">调试 <code>awk</code> 程序</a>。
</p>
<p>在 FSF 版本中，
4.1 版本
重新组织了文档内容，主要的更新是增加了 <a href="#Arbitrary-Precision-Arithmetic">算术运算与 <code>gawk</code> 中的任意精度算术运算</a> 以及 <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>。
</p>
<p>这个网页未来一定会持续优化。如果你在这个网页发现了错误，请报告它。
<a href="#Bugs">报告问题与 BUG</a> ，你可以找到关于提交电子版问题报告的信息。 
</p>

<hr>
<a name="How-To-Contribute"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Manual-History" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Acknowledgments" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a6_0082a_00bd_0095e_00b4_00a1c_008c_00ae"></a>
<h2 class="unnumberedsec">如何贡献</h2>

<p>作为 GNU <code>awk</code> 的维护者，我曾经想着我应该能够管理这一大堆的公开可得的 <code>awk</code> 程序，我甚至招募过贡献者。
从互联网可以得到我想要的东西，能够帮助 <code>gawk</code> 的发布版保持在一个可管理的大小。
</p>
<p>最原始的材料，如本网页，还可以从 <a href="ftp://ftp.freefriends.org/arnold/Awkstuff">ftp://ftp.freefriends.org/arnold/Awkstuff</a> 获取。
为了把这个事情做得更为开放广泛，我还申请了 <code>awk.info</code> 域名。
</p>
<p>但是，我发现我没有时间完全地来管理这些分布的代码：文档已经不再增长，而域名已经几年前就不能使用了。
</p>
<p>2008 年的晚些时候，有志愿者设立了 <code>awk</code> 相关的网站—— <a href="http://awk.info">http://awk.info</a> ——工作做得相当棒。
</p>
<p>如果你写过一个有味的 <code>awk</code> 程序，或者写了 <code>gawk</code> 扩展并且希望与其他人分享，请看 <a href="http://awk.info/?contribute">http://awk.info/?contribute</a> 来了解如何将它发布到网站上。
</p>


<hr>
<a name="Acknowledgments"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#How-To-Contribute" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-Preface" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0087_00b4e_00b0_00a2"></a>
<h2 class="unnumberedsec">致谢</h2>

<p>最初的 <cite>The GAWK Manual</cite> 的致谢如下：
</p>
<blockquote>
<p>很多的人需要感谢，因为他们帮助产生了这个手册。
Jay Fenlason 提供了许多的想法与例子。
Richard Mlynarik 与 Robert Chassell 给了文档非常有帮助的点评。
John W. 写了 <cite>A Supplemental Document for AWK</cite> 文档。
UC San Diego 化学部的 Pierce 指出几个问题，既与 <code>awk</code> 实现有关，也与手册有关，不然这些问题会逃过我们的眼睛。
</p></blockquote>

<a name="index-Stallman_002c-Richard-1"></a>
<p>我要感谢 Richard M. Stallman，感谢他对美好世界的愿景，并有勇气成立 FSF 并开启 GNU 项目。
</p>
<p>本网页更早版本的致谢如下：
</p>
<blockquote>
<p>下面的人（按字母顺序）为本网页的不同版本提供了很好的点评：
Rick Adams，
Dr. Nelson H.F. Beebe， 
Karl Berry，
Dr. Michael Brennan，
Rich Burridge，
Claire Cloutier，
Diane Close，
Scott Deifik，
Christopher (“Topher”) Eliot，
Jeffrey Friedl，
Dr. Darrel Hankerson，
Michal Jaegermann，
Dr. Richard J. LeBlanc，
Michael Lijewski，
Pat Rankin，
Miriam Robbins，
Mary Sheehan，
和 Chuck Toporek。
</p>
<a name="index-Berry_002c-Karl"></a>
<a name="index-Chassell_002c-Robert-J_002e"></a>
<p>Robert J. Chassell 在使用 Texinfo 上提供了非常有价值的建议。
他也应该得到特别感谢，因为他说服我<em>不要</em>用 <cite>How to Gawk Politely</cite> 这样的标题来命名本网页。
Karl Berry 在 Texinfo 中的 TeX 部分给予了相当大的帮助。
</p>
<a name="index-Hartholz_002c-Marshall"></a>
<a name="index-Hartholz_002c-Elaine"></a>
<a name="index-Schreiber_002c-Bert"></a>
<a name="index-Schreiber_002c-Rita"></a>
<p>我也要感谢 Marshall 与 Seattle 的 Elaine Hartholz ，还有 Detroit 的 Bert and Rita Schreiber 博士，
他们牺牲了大量的假期时间——他们本可以安安静解地在家里度过——使得我在本网页的制作和 <code>gawk</code> 上的工作都能进展神速。
</p>
<a name="index-Hughes_002c-Phil"></a>
<p>SSC 的 Phil Hughes 借给我他的笔记本 GNU/Linux 系统，不是一次，而是两次，他以这样的一种方式使我在离开家的时候做了大量的工作。
</p>
<a name="index-Trueman_002c-David-1"></a>
<p>David Trueman 应该得到特别的致谢。他自告奋勇地承担起了优化 <code>gawk</code> 的工作，因此 <code>gawk</code> 才会执行得如此之好，没有 Bug。
尽管他现在不再介入 <code>gawk</code> 的工作，但是与他在这个项目上一起工作相当愉快。
</p>
<a name="index-Drepper_002c-Ulrich"></a>
<a name="index-GNITS-mailing-list"></a>
<a name="index-mailing-list_002c-GNITS"></a>
<p>GNITS 邮件列表中的那些无畏的成员们，以及最值得尊敬的 Ulrich Drepper 为设计国际化特性提供了无价的帮助与反馈。
</p>
<p>来自 O&rsquo;Reilly &amp; Associates 的 Chuck Toporek，Mary Sheehan，和 Claire Cloutier，对 <code>gawk</code> 3.1 版的本网页提供了编辑上的帮助，作出了重要贡献。
</p></blockquote>

<a name="index-Beebe_002c-Nelson-H_002eF_002e"></a>
<a name="index-Buening_002c-Andreas"></a>
<a name="index-Collado_002c-Manuel"></a>
<a name="index-Colombo_002c-Antonio"></a>
<a name="index-Davies_002c-Stephen"></a>
<a name="index-Deifik_002c-Scott"></a>
<a name="index-Demaille_002c-Akim"></a>
<a name="index-G_002e_002c-Daniel-Richard"></a>
<a name="index-Hankerson_002c-Darrel"></a>
<a name="index-Jaegermann_002c-Michal"></a>
<a name="index-Kahrs_002c-Jurgen"></a>
<a name="index-Kasal_002c-Stepan"></a>
<a name="index-Malmberg_002c-John"></a>
<a name="index-Pitts_002c-Dave"></a>
<a name="index-Ramey_002c-Chet"></a>
<a name="index-Rankin_002c-Pat"></a>
<a name="index-Schorr_002c-Andrew"></a>
<a name="index-Vinschen_002c-Corinna"></a>
<a name="index-Zaretskii_002c-Eli"></a>

<p>Dr. Nelson Beebe，
Andreas Buening，
Dr. Manuel Collado，
Antonio Colombo，
Stephen Davies，
Scott Deifik，
Akim Demaille，
Daniel Richard G.，
Darrel Hankerson，
Michal Jaegermann，
J&uuml;rgen Kahrs，
Stepan Kasal，
John Malmberg，
Dave Pitts，
Chet Ramey，
Pat Rankin，
Andrew Schorr，
Corinna Vinschen，
和 Eli Zaretskii
（按字母顺序）
组成了目前的 <code>gawk</code> “霹雳移植性小组”。如果没有他们的艰苦工作与帮助，<code>gawk</code> 不会今天有如此稳定，可移植的程序。与这样的一群好人小组一起工作曾经是也将一直是件快乐的事情。
</p>
<p>许多人贡献了相当多的代码与文档，<a href="#Contributors"><code>gawk</code> 的主要贡献者</a> ，其中有完整的列表。
</p>

<p>谢谢 Michael Brennan 写的序言。
</p>
<a name="index-Duman_002c-Patrice"></a>
<a name="index-Berry_002c-Karl-1"></a>
<p>谢谢 Patrice Dumas 新写的 <code>makeinfo</code> 程序，也谢谢 Karl Berry 持续工作使用 Texinfo 这样的标志语言如此牛B。
</p>
<a name="index-Kernighan_002c-Brian-2"></a>
<a name="index-Brennan_002c-Michael-2"></a>
<a name="index-Day_002c-Robert-P_002eJ_002e"></a>
<p>Robert P.J. Day，Michael Brennan，还有 Brian Kernighan，非常好心地作为了本网页 2015 版本的审核者。
他们的工作使用让本网页质量更优。
</p>
<p>我还要感谢 Brian Kernighan，因为在测试与调试 <code>gawk</code> 期间提供的无价帮助，也为他在澄清无数的语言疑点上的的持续帮助与建议。
没有他的帮助，<code>gawk</code> 和它的文档不会像现在这么优秀。
</p>
<p>Brian 是一流程序员与技术作者，我要（又一次）感谢他，因为他持续的友谊与为我树立起来的近 30 年的模范作用。
有这样的人作为评论人真是大幸。而他一直以来都如此谦卑<small class="enddots">...</small>
</p>
<a name="index-Robbins_002c-Miriam"></a>
<a name="index-Robbins_002c-Jean"></a>
<a name="index-Robbins_002c-Harry"></a>
<a name="index-G_002dd"></a>
<p>我还得感谢我的内人，Miriam。因为她的耐心，在这个项目的多个版本之间作为第一读者，同时还与我分享电脑。
还要感谢我的老爸老妈，因为他们的爱与生而育我的艰辛。最后，我也要把我的感谢献给 G-d，是他给我了许多机会，礼物，而这些礼物使我能够更好地利用这些机会。
</p><br>
<br>
<p>Arnold Robbins <br>
Nof Ayalon <br>
Israel <br>
February 2015
</p>
<hr>
<a name="c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Translator-Preface" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Acknowledgments" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Running-gawk" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="part">第一部分:<br> <code>awk</code> 语言</h1>
<hr>


<a name="Getting-Started"></a>
<a name="aa_00bc_0080aa_00a7_008b-awk"></a>
<h1 class="chapter">1 开始 <code>awk</code></h1>
<a name="index-awk_002c-function-of"></a>

<p><code>awk</code> 的基本功能就是查找具某种模式的文本行（或者其他单位的文本）。
当匹配某个模式后，<code>awk</code> 会对该行执行指定的动作。
<code>awk</code> 然后继续输入行，直到文件输入处理完毕。
</p>
<a name="index-awk_002c-uses-for-1"></a>
<a name="index-programming-languages_002c-data_002ddriven-vs_002e-procedural"></a>
<a name="index-awk-programs"></a>
<p><code>awk</code> 中的程序与其他语言的程序不同，因为 <code>awk</code> 程序是<em>数据驱动</em>的（即你描述你要处理的数据，然后告诉程序找到相应数据后要执行的工作）。
多数其他语言都是<em>过程式</em>的；你需要在非常细的细节上描述程序每一行要做什么。
当与过程式语言打交道时，一般很难清楚地描述你的程序所要处理的数据。正是由于这个原因，<code>awk</code> 程序非常易读易写。
</p>
<a name="index-program_002c-definition-of"></a>
<a name="index-rule_002c-definition-of"></a>
<p>当执行 <code>awk</code> 程序，你需要指定一个<em>程序</em>告知 <code>awk</code> 接下来要做什么。
这个程序包括一系统的<em>规则</em>（有可能也会包含<em>函数定义</em>，一些你现在可以忽略的高级特性；see section <a href="#User_002ddefined">用户自定义函数</a>)，
每个规则指定了要查找的模式以及一个在查找到模式时要执行的动作。
</p>
<p>在语法上，规则包括一个<em>模式</em>，后面带着<em>动作</em>。动作是包含在花括号中的，与模式分离。每一行一般都是新的不同的规则。
因此，<code>awk</code> 程序看起来像这样：
</p>
<div class="example">
<pre class="example"><var>pattern</var> { <var>action</var> }
<var>pattern</var> { <var>action</var> }
&hellip;
</pre></div>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Running-gawk">1.1 如何执行 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                How to run <code>gawk</code> programs; includes
                                command-line syntax.
</td></tr>
<tr><td align="left" valign="top"><a href="#Sample-Data-Files">1.2 例子中使用的数据文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Sample data files for use in the <code>awk</code>
                                programs illustrated in this website.
</td></tr>
<tr><td align="left" valign="top"><a href="#Very-Simple">1.3 一些简单例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 A very simple example.
</td></tr>
<tr><td align="left" valign="top"><a href="#Two-Rules">1.4 两规则的例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   A less simple one-line example using two
                                rules.
</td></tr>
<tr><td align="left" valign="top"><a href="#More-Complex">1.5 复杂一点的例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                A more complex example.
</td></tr>
<tr><td align="left" valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Subdividing or combining statements into
                                lines.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Features">1.7 <code>awk</code> 的其他特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Other Features of <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#When">1.8 何时使用 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        When to use <code>gawk</code> and when to use
                                other things.
</td></tr>
<tr><td align="left" valign="top"><a href="#Intro-Summary">1.9 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Summary of the introduction.
</td></tr>
</table>

<hr>
<a name="Running-gawk"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#One_002dshot" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a6_0082a_00bd_0095ae_0089_00a7e_00a1_008c-awk-c_00a8_008baa_00ba_008f"></a>
<h2 class="section">1.1 如何执行 <code>awk</code> 程序</h2>

<a name="index-awk-programs_002c-running"></a>
<p>有几种方式执行 <code>awk</code> 程序。如果程序很短，最好的方式直接包含在程序的执行命令行中，如下：
</p>
<div class="example">
<pre class="example">awk '<var>program</var>' <var>input-file1</var> <var>input-file2</var> &hellip;
</pre></div>

<a name="index-command-line_002c-formats"></a>
<p>当程序比较长，更好的方式是将其放在一个文件中，然后通过命令行执行：
</p>
<div class="example">
<pre class="example">awk -f <var>program-file</var> <var>input-file1</var> <var>input-file2</var> &hellip;
</pre></div>

<p>在本小节中，我们使用两种方式，但是每种方式都有一些变化。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#One_002dshot">1.1.1 一次性 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Running a short throwaway <code>awk</code>
                                program.
</td></tr>
<tr><td align="left" valign="top"><a href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Using no input files (input from the keyboard
                                instead).
</td></tr>
<tr><td align="left" valign="top"><a href="#Long">1.1.3 运行长程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Putting permanent <code>awk</code> programs in
                                files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Making self-contained <code>awk</code> programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Adding documentation to <code>gawk</code>
                                programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     More discussion of shell quoting issues.
</td></tr>
</table>

<hr>
<a name="One_002dshot"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Running-gawk" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Running-gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Read-Terminal" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_0080ae_00ac_00a1ae_0080_00a7-awk-c_00a8_008baa_00ba_008f"></a>
<h3 class="subsection">1.1.1 一次性 <code>awk</code> 程序</h3>

<p>一旦你熟悉了 <code>awk</code>，你就可以在使用时立即输入一些简单的程序。
你可以把程序作为 <code>awk</code> 命令行的第一个参数，像这样：
</p>
<div class="example">
<pre class="example">awk '<var>program</var>' <var>input-file1</var> <var>input-file2</var> &hellip;
</pre></div>

<p>这个<var>程序</var>包括一系列的模式与动作，正如早些时候所描述的那样。
</p>
<a name="index-single-quote-_0028_0027_0029"></a>
<a name="index-_0027-_0028single-quote_0029"></a>
<p>这种命令格式告诉 <em>Shell</em>，或者命令行解释器，开启 <code>awk</code>，并用其中的<var>程序</var>来处理输入文件。
<var>程序</var>是由单引号引起来的，因此 Shell 不会将 <code>awk</code> 中的特殊字符解析成 Shell 的字符。
单引号也使用 Shell 将所有的<var>程序</var>都作为单独的 <code>awk</code> 部分，可以让<var>程序</var>多于一行。
</p>
<a name="index-shells_002c-scripts"></a>
<a name="index-awk-programs_002c-running_002c-from-shell-scripts"></a>
<p>这样的方式用来执行短的或者中等大小的 <code>awk</code> 程序是很方便的，因为它避免了要用一个单独的文件来写 <code>awk</code> 程序。
自包含的 Shell 脚本更加可靠，这样就不会跟其他的文件弄混淆。
</p>
<p>在本章的后面部分，即
<a href="#Very-Simple">一些简单例子</a>，我们会学一些那些自包含的程序很短的例子。
</p>
<hr>
<a name="Read-Terminal"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#One_002dshot" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Running-gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Long" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_008daa_00b8_00a6e_00be_0093aa_0085_00a5ae_0096_0087a_00bb_00b6e_00bf_0090e_00a1_008c-awk"></a>
<h3 class="subsection">1.1.2 不带输入文件运行 <code>awk</code></h3>

<a name="index-standard-input"></a>
<a name="index-input_002c-standard"></a>
<a name="index-input-files_002c-running-awk-without"></a>
<p>你也可以运行 <code>awk</code> 程序，不带输入文件，如果你敲入下面的命令行：
</p>
<div class="example">
<pre class="example">awk '<var>program</var>'
</pre></div>

<p><code>awk</code> 会使<var>程序</var>导向到<em>标准输入</em>，也就是说，你在键盘上输入的一切都会接受为输入数据。
这会一直持续，直到你输入 <kbd>Ctrl-d</kbd> 来表示“end-of-file”。
（在非 POSIX 操作系统中，“end-of-file”有可能不同。如在 OS/2 中则是 <kbd>Ctrl-z</kbd>）
</p>
<a name="index-files_002c-input_002c-See-input-files"></a>
<a name="index-input-files_002c-running-awk-without-1"></a>
<a name="index-awk-programs_002c-running_002c-without-input-files"></a>
<p>如下面的例子，程序打印一小段建议（来自由 Douglas Adams 的 <cite>The Hitchhiker&rsquo;s Guide to the Galaxy</cite>），使你消除计算机程序复杂性的忧虑：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print &quot;Don\47t Panic!&quot; }'</kbd>
-| Don't Panic!
</pre></div>

<p><code>awk</code> 在读入任何输入之前，先执行与 <code>BEGIN</code> 相关的语句。
如果程序中没有了其他的代码了，像这个例子中的情况一样，<code>awk</code> 就直接结束，而不是试图读取自己不知道如何处理的输入。
&lsquo;<samp>\47</samp>&rsquo; 是一个小技巧（后面会解释）来将单引号引入程序，这样就不用使用 Shell 丑陋的引文伎俩。
</p>
<blockquote>
<p><b>提示:</b> 如果你使用 Bash，你需要先执行命令 &lsquo;<samp>set +H</samp>&rsquo;，然后再执行这个交互式的命令，以禁用 C shell 式的命令历史，
在这种方式下 &lsquo;<samp>!</samp>&rsquo; 会被当作特殊字符。我们建议你将这个命令放在你用户的启动文件中。<a name="DOCF10" href="#FOOT10">(10)</a> 
</p></blockquote>

<p>下面是一个简单模拟 <code>cat</code> 工具的 <code>awk</code> 程序；它复制你输入的字符，然后输出到标准输出上（为什么这个可以做得到等会解释）：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print }'</kbd>
<kbd>Now is the time for all good men</kbd>
-| Now is the time for all good men
<kbd>to come to the aid of their country.</kbd>
-| to come to the aid of their country.
<kbd>Four score and seven years ago, ...</kbd>
-| Four score and seven years ago, ...
<kbd>What, me worry?</kbd>
-| What, me worry?
<kbd>Ctrl-d</kbd>
</pre></div>

<hr>
<a name="Long"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Read-Terminal" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Running-gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Executable-Scripts" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00bf_0090e_00a1_008ce_0095_00bfc_00a8_008baa_00ba_008f"></a>
<h3 class="subsection">1.1.3 运行长程序</h3>

<a name="index-awk-programs_002c-running-1"></a>
<a name="index-awk-programs_002c-lengthy"></a>
<a name="index-files_002c-awk-programs-in"></a>
<p>有时，<code>awk</code> 程序非常长，在这种情况下，更方便的方法是将程序放在一个独立的文件中。
为了告诉 <code>awk</code> 执行某个文件中的程序，你敲入：
</p>
<div class="example">
<pre class="example">awk -f <var>source-file</var> <var>input-file1</var> <var>input-file2</var> &hellip;
</pre></div>

<a name="index-_002df-option"></a>
<a name="index-command-line_002c-option-_002df"></a>
<p>&lsquo;<samp>-f</samp>&rsquo; 参数指示 <code>awk</code> 工具从 <var>source-file</var> 中读取程序（see section <a href="#Options">命令行参数</a>）。
任何的文件名都可以作为<var>source-file</var>。如你可以输入下面命令行：
</p>
<div class="example">
<pre class="example">BEGIN { print &quot;Don't Panic!&quot; }
</pre></div>

<p>到文件 &lsquo;<tt>advice</tt>&rsquo; 中，然后执行下面的命令行：
</p>
<div class="example">
<pre class="example">awk -f advice
</pre></div>

<p>下面的代码做一样的事情：
</p>
<div class="example">
<pre class="example">awk 'BEGIN { print &quot;Don\47t Panic!&quot; }'
</pre></div>

<a name="index-quoting-in-gawk-command-lines"></a>
<p>这个已经早解释过（see section <a href="#Read-Terminal">不带输入文件运行 <code>awk</code></a>）。
注意，当你用 &lsquo;<samp>-f</samp>&rsquo; 参数指定文件名时，你不需要把文件名引起来，因为大多数文件名都不会含 Shell 特殊字符。
在文件 &lsquo;<tt>advice</tt>&rsquo; 中，<code>awk</code> 程序并没有把文件内容给引起来。引号只在命令行上输入程序才需要。（当然，把程序代码放入文件中，使得我们可以直接使用引号（‘’），而不需要像 &lsquo;<samp>\47</samp>&rsquo; 这样的进行输入。
</p>
<a name="index-single-quote-_0028_0027_0029-in-gawk-command-lines"></a>
<a name="index-_0027-_0028single-quote_0029-in-gawk-command-lines"></a>
<p>如果你想清楚地标识这样的 <code>awk</code> 程序，你可以给文件名加上扩展名 &lsquo;<tt>.awk</tt>&rsquo; 。
这不会影响 <code>awk</code> 程序的执行，但确实使“家务事”容易了许多。
</p>
<hr>
<a name="Executable-Scripts"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Long" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Running-gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Comments" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008f_00afae_0089_00a7e_00a1_008cc_009a_0084-awk-c_00a8_008baa_00ba_008f"></a>
<h3 class="subsection">1.1.4 可执行的 <code>awk</code> 程序</h3>
<a name="index-awk-programs-1"></a>
<a name="index-_0023-_0028number-sign_0029_002c-_0023_0021-_0028executable-scripts_0029"></a>
<a name="index-Unix_002c-awk-scripts-and"></a>
<a name="index-number-sign-_0028_0023_0029_002c-_0023_0021-_0028executable-scripts_0029"></a>

<p>如果你学过 <code>awk</code>，你可能就会想用 &lsquo;<samp>#!</samp>&rsquo; 这样的机制写一个自包含的 <code>awk</code> 脚本。
在很多系统<a name="DOCF11" href="#FOOT11">(11)</a>
上你都可以这么干。例如，你可以把advice文件写成这样：
</p>
<div class="example">
<pre class="example">#! /bin/awk -f

BEGIN { print &quot;Don't Panic!&quot; }
</pre></div>

<p>把这个文件设置成可执行权限（用 <code>chmod</code> 工具），在 Shell 中简单地输入 &lsquo;<samp>advice</samp>&rsquo;，
系统就会将 <code>awk</code> 执行成像你输入了 &lsquo;<samp>awk -f advice</samp>&rsquo; 一样：
</p>
<div class="example">
<pre class="example">$ <kbd>chmod +x advice</kbd>
$ <kbd>advice</kbd>
-| Don't Panic!
</pre></div>

<p>（我们假设你已经将你的当前目录放在了你的 Shell 的搜索路径变量下【一般为 <code>$PATH</code>】。
如果没有这么做，你敲入 &lsquo;<samp>./advice</samp>&rsquo; 就可以了。）
</p>
<p>自包含的 <code>awk</code> 脚本在用户调用脚本但不需要知道程序是用 <code>awk</code> 实现时非常有用。
</p>
<a name="index-sidebar_002c-c_0090_0086e_00a7_00a3-_0023_0021"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>理解 &lsquo;<samp>#!</samp>&rsquo;</b>
</p>

<a name="index-portability_002c-_0023_0021-_0028executable-scripts_0029"></a>

<p><code>awk</code> 是一个<em>解释型</em>语言。这表示，<code>awk</code> 工具把你的程序读入后，会根据你程序中的指令来处理你的数据。
（这不同于 C 这样的<em>编译型</em>语言，首先你需要将它们编译成机器代码，这些代码可以直接被你系统的处理器执行。）
<code>awk</code> 工具因此被称为<em>解释器（interpreter）</em>。多数的现代语言都是解释执行的。
</p>
<p>以 &lsquo;<samp>#!</samp>&rsquo; 开始的行列出了要执行的解释器文件的完整路径，包括一个单一的可选命令行参数要传递给对应的解释器。
操作系统然后用给定的参数执行解释器以及所有的参数列表执行被执行的程序。
第一个参数即是 <code>awk</code> 程序的完整路径。
其他的参数，要么是 <code>awk</code> 的参数，要么是数据文件，或者二者兼有。
（注意，在很多的系统上，<code>awk</code> 会在 &lsquo;<tt>/usr/bin</tt>&rsquo; 目录下找到，而不是在 &lsquo;<tt>/bin</tt>&rsquo; 目录下。）
</p>
<p>有的系统会将解释器的长度限制在 32 个字符。但这种情况用软连接就可以解决。
</p>
<p>在 &lsquo;<samp>#!</samp>&rsquo; 行，你在 <code>awk</code> 的路径后面最好不好放超一个参数。
这不会有作用。操作系统会将那一行剩下的内容当作一个参数，并传递给 <code>awk</code>。
这会导致一些令人疑惑的行为——多数像是 <code>awk</code> 使用方法的一些诊断信息。
</p>
<a name="index-ARGC_002fARGV-variables_002c-portability-and"></a>
<a name="index-portability_002c-ARGV-variable"></a>
<p>最后，<code>ARGV[0]</code> 参数的值（see section <a href="#Built_002din-Variables">预定义变量</a>）会根据系统的同而不同。
有的系统会把 &lsquo;<samp>awk</samp>&rsquo; 作为它的值，而有的会将 <code>awk</code> 的完整路径赋值给它（如 &lsquo;<tt>/bin/awk</tt>&rsquo;）。
有一些会将脚本的文件名（&lsquo;<samp>advice</samp>&rsquo;）赋给它。
所以，不要依赖于 <code>ARGV[0]</code> 的值来提供给你的脚本使用。
</p></td></tr></table>

<hr>
<a name="Comments"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Executable-Scripts" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Running-gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Quoting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-c_00a8_008baa_00ba_008fa_00b8_00adc_009a_0084ae_00b3_00a8e_0087_008a"></a>
<h3 class="subsection">1.1.5 <code>awk</code> 程序中的注释</h3>
<a name="index-_0023-_0028number-sign_0029_002c-commenting"></a>
<a name="index-number-sign-_0028_0023_0029_002c-commenting"></a>
<a name="index-commenting"></a>
<a name="index-awk-programs_002c-documenting"></a>

<p><em>注释</em>，就是程序中给人读的文本；它不是可执行程序的一部份。注释可以解释程序是做什么的，以及如何做的。几乎所有的程序语言都会提供注释，因为程序如果没有它们是非常于难理解的。
</p>
<p>在 <code>awk</code> 语言中，注释以 &lsquo;<samp>#</samp>&rsquo; 开头然后持续到一行的结束。 &lsquo;<samp>#</samp>&rsquo; 不一定要是一行的开始字符。
<code>awk</code> 会忽略数字符号 &lsquo;<samp>#</samp>&rsquo; 后面的内容。如我们已经在 &lsquo;<tt>advice</tt>&rsquo; 中输入了下面的内容：
</p>
<div class="example">
<pre class="example"># This program prints a nice, friendly message.  It helps
# keep novice users from being afraid of the computer.
BEGIN    { print &quot;Don't Panic!&quot; }
</pre></div>

<p>你可以将注释也带进命令行中的“用后即扔”<code>awk</code> 程序中，但是一般来讲，这个用处不大；注释的目的是帮你或者其他人后面阅读时理解程序。
</p>
<a name="index-quoting_002c-for-small-awk-programs"></a>
<a name="index-single-quote-_0028_0027_0029_002c-vs_002e-apostrophe"></a>
<a name="index-_0027-_0028single-quote_0029_002c-vs_002e-apostrophe"></a>
<blockquote>
<p><b>注意:</b> <a href="#One_002dshot">一次性 <code>awk</code> 程序</a>，所提到的，你可以将一个中等大小的程序用单引号引起来。这样就使得你的 Shell 脚本是自包含的了。
你这么做的时候，你<em>不要</em>将撇号（’）放到你的注释中（或者你的程序的任何位置）。Shell 会将闭引号当做整个程序的结束。结果就是，Shell 会打印出引号不匹配的错误，而如果 <code>awk</code> 实际是执行了，也会打印出语法错误等奇怪的信息。如下面的例子中：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print &quot;hello&quot; } # let's be cute'</kbd>
&gt;
</pre></div>

<p>Shell 首先看到前面两个引号匹配，然后在后面的注释又看到了一个开始的引号。
因此就有第二个提示，并等待输入。对于 Unix <code>awk</code>，闭引号串会产生这样的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print &quot;hello&quot; } # let's be cute'</kbd>
&gt; <kbd>'</kbd>
error--&gt; awk: can't open file be
error--&gt;  source line number 1
</pre></div>

<a name="index-_005c-_0028backslash_0029"></a>
<a name="index-backslash-_0028_005c_0029"></a>
<p>在 &lsquo;<samp>let's</samp>&rsquo; 中的撇号前面加一个转义符（\）也没有作用，因为转义符在单引号中也不是一个特殊的字符。
下一个子小节中我们会解释 Shell 的引号规则。
</p></blockquote>

<hr>
<a name="Quoting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Comments" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Running-gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#DOS-Quoting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Shell-aa_00bc_0095aa_008f_00b7e_0097_00aee_00a2_0098"></a>
<h3 class="subsection">1.1.6 Shell 引号问题</h3>
<a name="index-shell-quoting_002c-rules-for"></a>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#DOS-Quoting">1.1.6.1 MS-Windows 批处理文件中的引号问题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Quoting in Windows Batch Files.
</td></tr>
</table>

<p>对于短到中等大小的 <code>awk</code> 程序而言，最方便的方式是将程序在命令行中输入。
这个通过将整个程序包含在一对单引号当中即可。无论在交互式的输入程序，还是在一个大的 Shell 脚本中输入都是可以的：
</p>
<div class="example">
<pre class="example">awk '<var>program text</var>' <var>input-file1</var> <var>input-file2</var> &hellip;
</pre></div>

<a name="index-shells_002c-quoting_002c-rules-for"></a>
<a name="index-Bourne-shell_002c-quoting-rules-for"></a>
<p>一旦你通过 Shell 来运行，对于 Shell 的引号规则有所了解总是好的。
下面的规则只应用于 POSIX 兼容的 Bourne 式的 Shell 中（如 Bash，GNU Bourne-Again Shell）。如果你用的是 C Shell，那就需要你自处了。
</p>
<p>在深入规则之前，我们先介绍本网页中通篇所使用的概念，它们就是 <em>null</em>，或者 empty 串。
</p>
<p>null string 就是在字符数据中没有值。换句话说，就是空的。在 <code>awk</code> 程序中写成这样：<code>&quot;&quot;</code>。
在 Shell 中，它可以写成单或者双引号的形式：<code>&quot;&quot;</code> 或者 <code>''</code>。虽说 null string 中没有字符，但是确实是存在的。
例如下面的指令：
</p>
<div class="example">
<pre class="example">$ <kbd>echo &quot;&quot;</kbd>
</pre></div>

<p>在这里，<code>echo</code> 工具收到单一的参数，就算参数中没有字符在其中。
在本网页的后续部分，我们使用术语 <em>null string</em> 以及 <em>empty string</em> 来表示这样的串。现在在引号规则中：
</p>
<ul>
<li>
被引起来的项可以与没有被引起来项连接，也可以与已经引起来的项进行连接。Shell 会将它们全部转换成命令的参数。

</li><li>
在引起来的串中，在任何单个字符前的反斜杠（&lsquo;<samp>\</samp>&rsquo;）都会被 Shell 移除，而将被引起来的字符传递给命令。

</li><li>
<a name="index-_005c-_0028backslash_0029_002c-in-shell-commands"></a>
<a name="index-backslash-_0028_005c_0029_002c-in-shell-commands"></a>
<a name="index-single-quote-_0028_0027_0029_002c-in-shell-commands"></a>
<a name="index-_0027-_0028single-quote_0029_002c-in-shell-commands"></a>
单引号保护在开与闭引号之间的所有字符。Shell 不会对串中的东西做任何解析，并原样地传递给命令。<em>不可能</em>在一个单引号中嵌入单引号。
参考 <a href="#Comments"><code>awk</code> 程序中的注释</a> 中的例子，看看如果你这么做会有什么结果。

</li><li>
<a name="index-double-quote-_0028_0022_0029_002c-in-shell-commands"></a>
<a name="index-_0022-_0028double-quote_0029_002c-in-shell-commands"></a>
双引号保护开引号与闭引号之间的大多数据字串。Shell 只做最小的变量与命令的替换。不同的 Shell 对于双引号的处理是不一样的。

<p>由于在双引号中，特定的字符是会被 Shell 处理的，因此他们在串中一定要进行<em>转义</em>。
要注意这些符号&lsquo;<samp>$</samp>&rsquo;，&lsquo;<samp>`</samp>&rsquo;，&lsquo;<samp>\</samp>&rsquo; 和 &lsquo;<samp>&quot;</samp>&rsquo;。这些符号如果要原样地传递给程序中，你就需要在串中用反斜杠（&lsquo;<samp>\</samp>&rsquo; ）进行转义。
（前导的反斜杠（&lsquo;<samp>\</samp>&rsquo;）会先被过滤掉。）
你可以参考
之前的
在 <a href="#Read-Terminal">不带输入文件运行 <code>awk</code></a> 中的例子：
</p>
<div class="example">
<pre class="example">awk 'BEGIN { print &quot;Don\47t Panic!&quot; }'
</pre></div>

<p>可以写成这样的形式：
</p>
<div class="example">
<pre class="example">$ <kbd>awk &quot;BEGIN { print \&quot;Don't Panic!\&quot; }&quot;</kbd>
-| Don't Panic!
</pre></div>

<a name="index-single-quote-_0028_0027_0029_002c-with-double-quotes"></a>
<a name="index-_0027-_0028single-quote_0029_002c-with-double-quotes"></a>
<p>注意在双引号中的单引号不是特殊符号。
</p>
</li><li>
空串（Null string）如果出现在非空串中时，会被移除，而显式的空串会被保留。例如：可以将域分隔符 <code>FS</code> 指定为空串（null string），可以这么来：

<div class="example">
<pre class="example">awk -F &quot;&quot; '<var>program</var>' <var>files</var> # correct
</pre></div>

<a name="index-null-strings-in-gawk-arguments_002c-quoting-and"></a>
<p>而不要这么来：
</p>
<div class="example">
<pre class="example">awk -F&quot;&quot; '<var>program</var>' <var>files</var>  # wrong!
</pre></div>

<p>在第二个例子中，<code>awk</code> 会尝试使用程序的文本作为 <code>FS</code> 的值，第一个文件名会做为程序的文本！
这会导致在最好的情况下是语法错误，而最坏的情况下会导致令人费解的行为。
</p></li></ul>

<a name="index-quoting-in-gawk-command-lines_002c-tricks-for"></a>
<p>混用单双引号是比较麻烦的。你需要用一些 Shell 的伎俩，如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print &quot;Here is a single quote &lt;'&quot;'&quot;'&gt;&quot; }'</kbd>
-| Here is a single quote &lt;'&gt;
</pre></div>

<p>这个程序中包括三个连接的引串。第一个与第三个都是单引号串，而第二个是双引号串。
</p>
<p>这个其实可以简化为：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print &quot;Here is a single quote &lt;'\''&gt;&quot; }'</kbd>
-| Here is a single quote &lt;'&gt;
</pre></div>

<p>这个得要你自己看哪个更好读。
</p>
<p>另一个使用双引号的选择，就是转换内嵌的，<code>awk</code> 层的双引号。
</p>
<div class="example">
<pre class="example">$ <kbd>awk &quot;BEGIN { print \&quot;Here is a single quote &lt;'&gt;\&quot; }&quot;</kbd>
-| Here is a single quote &lt;'&gt;
</pre></div>

<p>这种选择会非常痛苦，因为双引号，反斜杠（&lsquo;<samp>\</samp>&rsquo;）以及美元符号（&lsquo;<samp>$</samp>&rsquo;）在高级的 <code>awk</code> 程序中是很普遍的。
</p>
<p>第三个选择是使用转义的单双引号字符的对应码的八进制序列（see section <a href="#Escape-Sequences">转义序列</a>），如下：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print &quot;Here is a single quote &lt;\47&gt;&quot; }'</kbd>
-| Here is a single quote &lt;'&gt;
$ <kbd>awk 'BEGIN { print &quot;Here is a double quote &lt;\42&gt;&quot; }'</kbd>
-| Here is a double quote &lt;&quot;&gt;
</pre></div>

<p>这看起来就漂亮多了，但是你需要注释好所转义的东西是什么。
</p>
<p>第四个选择就是使用命令行式的变量赋值，如下：
</p>
<div class="example">
<pre class="example">$ <kbd>awk -v sq=&quot;'&quot; 'BEGIN { print &quot;Here is a single quote &lt;&quot; sq &quot;&gt;&quot; }'</kbd>
-| Here is a single quote &lt;'&gt;
</pre></div>

<p>（在这里，两个串常量以及 <code>sq</code> 的值会被连接起来成为一个单一的串，然后用 <code>print</code> 打印出来。）
</p>
<p>如果你确实在程序中即需要单引号也需要双引号，你最好是将它们移到一个单独的文件中。在文件里，Shell 不会解析你的程序所要做的事情。
</p>
<hr>
<a name="DOS-Quoting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Quoting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Quoting" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Data-Files" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="MS_002dWindows-ae_0089_00b9aa_00a4_0084c_0090_0086ae_0096_0087a_00bb_00b6a_00b8_00adc_009a_0084aa_00bc_0095aa_008f_00b7e_0097_00aee_00a2_0098"></a>
<h4 class="subsubsection">1.1.6.1 MS-Windows 批处理文件中的引号问题</h4>


<p>尽管本网页中一般只针对 POSIX 系统以及 POSIX Shell，下面的问题也值得为用户提出来。
</p>
<a name="index-Brink_002c-Jeroen"></a>
<p>微软 Windows 系统中的 Shell 用双引号来引字串。因此，比较难或者不可能在命令行脚本中通过转义的方式来包含双引号。
多谢 Jeroen Brink 提供下面的例子，呈现文件中的每一行都并用双引号引起来：
</p>
<div class="example">
<pre class="example">gawk &quot;{ print \&quot;\042\&quot; $0 \&quot;\042\&quot; }&quot; <var>file</var>
</pre></div>


<hr>
<a name="Sample-Data-Files"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#DOS-Quoting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Very-Simple" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00be_008baa_00ad_0090a_00b8_00ada_00bd_00bfc_0094_00a8c_009a_0084ae_0095_00b0ae_008d_00aeae_0096_0087a_00bb_00b6"></a>
<h2 class="section">1.2 例子中使用的数据文件</h2>

<a name="index-input-files_002c-examples"></a>
<a name="index-mail_002dlist-file"></a>
<p>本网页中所使用到的例子，主要从两个样例数据文件中输入数据。
第一个是 &lsquo;<tt>mail-list</tt>&rsquo; 文件，里面展示了一系列的人名，同时还有他们的邮件地址，以及相关的个人信息。
第二个是 &lsquo;<tt>inventory-shipped</tt>&rsquo; 文件，包含了每月的发货情况。两个文件中，每一行都称为一条<em>记录</em>。
</p>
<p>在 &lsquo;<tt>mail-list</tt>&rsquo; 文件中，每个记录包括了人名，他/她的电话号码，他/她的邮件地址，以及他/她与作者本人的关系。
列用行来进行分隔。最后一列中的 &lsquo;<samp>A</samp>&rsquo; 表示相识的人。&lsquo;<samp>F</samp>&rsquo; 表示相应的人是朋友关系，&lsquo;<samp>R</samp>&rsquo; 表示相应的人是亲属关系：
</p>
<div class="example">
<pre class="example">Amelia       555-5553     amelia.zodiacusque@gmail.com    F
Anthony      555-3412     anthony.asserturo@hotmail.com   A
Becky        555-7685     becky.algebrarum@gmail.com      A
Bill         555-1675     bill.drowning@hotmail.com       A
Broderick    555-0542     broderick.aliquotiens@yahoo.com R
Camilla      555-2912     camilla.infusarum@skynet.be     R
Fabius       555-1234     fabius.undevicesimus@ucb.edu    F
Julie        555-6699     julie.perscrutabor@skeeve.com   F
Martin       555-6480     martin.codicibus@hotmail.com    A
Samuel       555-3430     samuel.lanceolis@shu.edu        A
Jean-Paul    555-2127     jeanpaul.campanorum@nyu.edu     R
</pre></div>

<a name="index-inventory_002dshipped-file"></a>
<p>&lsquo;<tt>inventory-shipped</tt>&rsquo; 文件中的数据表示了在一年中的发货信息。
每个记录都包括一个月绿色集装箱的发货数，红箱盒装的发货数统计，橙色的袋装的发货数统计，以及蓝色包装的发货数统计。这里面有 16 条记录，包括了了上一年最后 12 个月的数据，以及本年的前 4 个月的数据。用空行分隔了年份：
</p>
<div class="example">
<pre class="example">Jan  13  25  15 115
Feb  15  32  24 226
Mar  15  24  34 228
Apr  31  52  63 420
May  16  34  29 208
Jun  31  42  75 492
Jul  24  34  67 436
Aug  15  34  47 316
Sep  13  55  37 277
Oct  29  54  68 525
Nov  20  87  82 577
Dec  17  35  61 401

Jan  21  36  64 620
Feb  26  58  80 652
Mar  24  75  70 495
Apr  21  70  74 514
</pre></div>

<p>上面的文件包含在 <code>gawk</code> 发布版本，位于目录 &lsquo;<tt>awklib/eg/data</tt>&rsquo; 中。
</p>
<hr>
<a name="Very-Simple"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Data-Files" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Two-Rules" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_0080a_00ba_009bc_00ae_0080aa_008d_0095a_00be_008baa_00ad_0090"></a>
<h2 class="section">1.3 一些简单例子</h2>

<p>下面的命令行执行了一个很简单的 <code>awk</code> 程序，就是查找 &lsquo;<tt>mail-list</tt>&rsquo; 文件中的字符串 &lsquo;<samp>li</samp>&rsquo;
（一组字符称为一个<em>字符串</em>，这个是基于英语中的术语<em>串</em>的用法，如“一串珍珠”或者“火车中的一串车厢”）：
</p>
<div class="example">
<pre class="example">awk '/li/ { print $0 }' mail-list
</pre></div>

<p>如果行中包括了 &lsquo;<samp>li</samp>&rsquo; ，他们就会被打印出来，因为 &lsquo;<samp>print&nbsp;$0</samp>&rsquo; 的意思就是打印当前行。
（只写 &lsquo;<samp>print</samp>&rsquo; 的意思是一样的，所以我们可以用 &lsquo;<samp>print</samp>&rsquo; 代替 &lsquo;<samp>print&nbsp;$0</samp>&rsquo;。）
</p>
<p>你应该注意到 <code>awk</code> 程序中在串 &lsquo;<samp>li</samp>&rsquo; 两边的斜杠（&lsquo;<samp>/</samp>&rsquo;）。
这个斜杠指示了 &lsquo;<samp>li</samp>&rsquo; 是要搜索的东西。这种模式称为<em>正则表达式</em>，这个知识点会在后面涉及（see section <a href="#Regexp">正则表达式</a>）。
这个模式允许匹配单词的部分。在 <code>awk</code> 程序两边由单引号引起来，因此不会解析其中的任何字符。
</p>
<p>下面是这个程序的输出:
</p>
<div class="example">
<pre class="example">$ <kbd>awk '/li/ { print $0 }' mail-list</kbd>
-| Amelia       555-5553     amelia.zodiacusque@gmail.com    F
-| Broderick    555-0542     broderick.aliquotiens@yahoo.com R
-| Julie        555-6699     julie.perscrutabor@skeeve.com   F
-| Samuel       555-3430     samuel.lanceolis@shu.edu        A
</pre></div>

<a name="index-actions_002c-default"></a>
<a name="index-patterns_002c-default"></a>
<p>在 <code>awk</code> 的规则中，即可以省略模式，也可以省略相关的动作，但不能两者都省略。如果模式省略了，那么动作的执行就会针对<em>所有的</em>输入行。
如果动作被省略了，那么默认的运行就是打印所有的匹配行。
</p>
<a name="index-actions_002c-empty"></a>
<p>因此，我们不管例子中的动作（即 <code>print</code> 语句以及花括号），结果也是一样的：<code>awk</code> 会打印所有匹配了 &lsquo;<samp>li</samp>&rsquo; 字串的行。如果省略了 <code>print</code> 语句，而保留花括号，则动作会什么也不做（即不会有行被输出）。
</p>
<a name="index-awk-programs_002c-one_002dline-examples"></a>
<p>实际的 <code>awk</code> 程序大多只有一两行长。下面收集了一些有用而短小的程序，以便于你开始使用 <code>awk</code>。
其中有些程序包括的特性目前还没有涉及（对于程序的描述可以提示你接下来将做什么，但不需要你先读完本网页后成为专家后再来阅读程序！）
大多数的例子都使用名为 &lsquo;<tt>data</tt>&rsquo; 的数据文件。这仅是个占位符；如果你自己使用这些程序，替换成你自己的文件名的 &lsquo;<tt>data</tt>&rsquo; 文件就好了。
为了后续参考：一般来讲要完成同样一件事，<code>awk</code> 可以有不止一种方法。在某个时候，你可能想回过头来看这些例子，看是否能够想出更多方法来做这里展示的相同的事情。
</p>
<ul>
<li>
打印大于 80 个字符的行：

<div class="example">
<pre class="example">awk 'length($0) &gt; 80' data
</pre></div>

<p>这里唯一的规则就是有一个关系表达式作为模式，但是没有动作。因此它用的是默认动作，就是打印记录（输入行）。
</p>
</li><li>
打印最长的行的长度：

<div class="example">
<pre class="example">awk '{ if (length($0) &gt; max) max = length($0) }
     END { print max }' data
</pre></div>

<p>这里与 <code>END</code> 关联的代码，会在所有的行读入后执行；它与 <code>BEGIN</code> 刚好相反。
</p>
<a name="index-expand-utility"></a>
</li><li>
打印 &lsquo;<tt>data</tt>&rsquo; 文件中最长的行的长度：

<div class="example">
<pre class="example">expand data | awk '{ if (x &lt; length($0)) x = length($0) }
                   END { print &quot;maximum line length is &quot; x }'
</pre></div>

<p>这个例子与前面的有一些不同：输入是通过 <code>expand</code> 工具，将 TABs 转换成空格。因此长度的比较实际上是到最右边的列数，而不是每一行的输入字符数。
</p>
</li><li>
打印至少有一个域的行：

<div class="example">
<pre class="example">awk 'NF &gt; 0' data
</pre></div>

<p>这个是最好的删除空白行的方法（即是，创建一个与旧文件一样的文件，但是移除了其中的空白行）。
</p>
</li><li>
打印从 0 到 100 （包含 0 和 100）的7个随机数：

<div class="example">
<pre class="example">awk 'BEGIN { for (i = 1; i &lt;= 7; i++)
                 print int(101 * rand()) }'
</pre></div>

</li><li>
打印<var>多个文件</var>中总共的字节数：

<div class="example">
<pre class="example">ls -l <var>files</var> | awk '{ x += $5 }
                   END { print &quot;total bytes: &quot; x }'
</pre></div>

</li><li>
打印<var>多个文件</var>所使用的 KB 总数：

<div class="example">
<pre class="example">ls -l <var>files</var> | awk '{ x += $5 }
   END { print &quot;total K-bytes:&quot;, x / 1024 }'
</pre></div>

</li><li>
打印所有用户的登录名的排序列表：

<div class="example">
<pre class="example">awk -F: '{ print $1 }' /etc/passwd | sort
</pre></div>

</li><li>
打印文件的行数：

<div class="example">
<pre class="example">awk 'END { print NR }' data
</pre></div>

</li><li>
打印数据文件中的偶数行：

<div class="example">
<pre class="example">awk 'NR % 2 == 0' data
</pre></div>

<p>如果你使用表达式 &lsquo;<samp>NR % 2 == 1</samp>&rsquo;，则程序将打印出奇数行。
</p></li></ul>

<hr>
<a name="Two-Rules"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Very-Simple" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#More-Complex" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_00a4e_00a7_0084aa_0088_0099c_009a_0084a_00be_008baa_00ad_0090"></a>
<h2 class="section">1.4 两规则的例子</h2>
<a name="index-awk-programs-2"></a>

<p><code>awk</code> 工具从文件中一次读取一行。对于每一行，<code>awk</code> 都是尝试与每个模式进行匹配。如果有几个模式与其匹配，则几个动作都会按照匹配的顺序被执行。如果没有模式匹配上，则不会有动作会执行。
</p>
<p>当处理了匹配行的所有规则后（也许也没有），<code>awk</code> 会读取下一行。（但是，see section <a href="#Next-Statement"><code>next</code> 语句</a>，
与 see section <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>.)
这个过程一直持续到文件读取完毕。例如，下面的 <code>awk</code> 程序包含了两个规则：
</p>
<div class="example">
<pre class="example">/12/  { print $0 }
/21/  { print $0 }
</pre></div>

<p>第一个规则用字符串 &lsquo;<samp>12</samp>&rsquo; 作为模式，以及 &lsquo;<samp>print $0</samp>&rsquo; 作为动作。第二个规则用 &lsquo;<samp>21</samp>&rsquo; 作为模式，也用 &lsquo;<samp>print $0</samp>&rsquo; 作为动作。每个规则的动作都用自己的花括号包含起来。
</p>
<p>这个程序打印每一行包含有 &lsquo;<samp>12</samp>&rsquo; <em>或者</em> &lsquo;<samp>21</samp>&rsquo; 的行。如果有一行包含了两个串，则会打印两次，每个规则一次。
</p>
<p>如果我们同时对我们的两个数据文件，即 &lsquo;<tt>mail-list</tt>&rsquo; 文件与 &lsquo;<tt>inventory-shipped</tt>&rsquo; 文件执行这个程序会有什么结果：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '/12/ { print $0 }</kbd>
&gt;      <kbd>/21/ { print $0 }' mail-list inventory-shipped</kbd>
-| Anthony      555-3412     anthony.asserturo@hotmail.com   A
-| Camilla      555-2912     camilla.infusarum@skynet.be     R
-| Fabius       555-1234     fabius.undevicesimus@ucb.edu    F
-| Jean-Paul    555-2127     jeanpaul.campanorum@nyu.edu     R
-| Jean-Paul    555-2127     jeanpaul.campanorum@nyu.edu     R
-| Jan  21  36  64 620
-| Apr  21  70  74 514
</pre></div>

<p>留意在 &lsquo;<tt>mail-list</tt>&rsquo; 文件中的 &lsquo;<samp>Jean-Paul</samp>&rsquo; 开头的行，它被打印了两次，一个规则一次。
</p>
<hr>
<a name="More-Complex"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Two-Rules" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Statements_002fLines" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a4_008dae_009d_0082a_00b8_0080c_0082_00b9c_009a_0084a_00be_008baa_00ad_0090"></a>
<h2 class="section">1.5 复杂一点的例子</h2>

<p>目前我们已经掌握一些基本的技能，现在我们再看一下 <code>awk</code> 典型地还能做些什么事情。这个例子展示了 <code>awk</code> 如何被用来做汇总，选择以及重新安排另一个工具的输出。所用到的特性还没有涉及，因此你不要担心不理解所有的细节：
</p>
<div class="example">
<pre class="example">ls -l | awk '$6 == &quot;Nov&quot; { sum += $5 }
             END { print sum }'
</pre></div>

<a name="index-ls-utility"></a>
<p>这个命令打印当前目录下，最后的修改时间为十一月份的所有文件的总共的字节数。
&lsquo;<samp>ls&nbsp;–l</samp>&rsquo; 是这整体命令的一部分，用于显示一个目录下的文件，包括文件的大小以及最后修改时间。它的输出类似于这样：
</p>
<div class="example">
<pre class="example">-rw-r--r--  1 arnold   user   1933 Nov  7 13:05 Makefile
-rw-r--r--  1 arnold   user  10809 Nov  7 13:03 awk.h
-rw-r--r--  1 arnold   user    983 Apr 13 12:14 awk.tab.h
-rw-r--r--  1 arnold   user  31869 Jun 15 12:20 awkgram.y
-rw-r--r--  1 arnold   user  22414 Nov  7 13:03 awk1.c
-rw-r--r--  1 arnold   user  37455 Nov  7 13:03 awk2.c
-rw-r--r--  1 arnold   user  27511 Dec  9 13:07 awk3.c
-rw-r--r--  1 arnold   user   7989 Nov  7 13:03 awk4.c
</pre></div>

<a name="index-line-continuations_002c-with-C-shell"></a>
<p>第一个域包含了读写权限，第二个域包含了文件的硬连接<a name="DOCF12" href="#FOOT12">(12)</a>
个数，第三个域显示了文件的属主信息。第四个域显示的文件的用户信息。第五个域显示了文件的字节大小。第六、七、八个域分别包括文件最后修改时间的月，日与时间。最后，第九个域包含了文件名。
</p>
<a name="index-initialization_002c-automatic"></a>
<p>在 <code>awk</code> 程序中 &lsquo;<samp>$6 == “Nov”</samp>&rsquo; 就是用来判断 &lsquo;<samp>ls&nbsp;–l</samp>&rsquo; 输出的第六个域是否为 &lsquo;<samp>Nov</samp>&rsquo; 的表达式。
如果每次的输入行的第六个域匹配字串 &lsquo;<samp>Nov</samp>&rsquo; ，<code>awk</code> 就会执行 &lsquo;<samp>sum += $5</samp>&rsquo;。
这个会加上第五个域（文件大小）到变量 <code>sum</code> 中。结果就是，当 <code>awk</code> 完成了所有行的输入时，<code>sum</code> 就包含了匹配模式的所有文件的大小。（这可以工作是因为 <code>awk</code> 的变量会默认初始化为 0。）
</p>
<p>最后一行处理后，<code>END</code> 规则就会执行，并打印出 <code>sum</code> 的值，在这个例子中为 80600。
</p>
<p>这些个高级的 <code>awk</code> 技术会在后面的小节中涉及（see section <a href="#Action-Overview">动作</a>）。在你学习到这些高级技术前，你只需要知道 <code>awk</code> 如何解析你的输入并显示你的输出。通过操作各个域并使用 <code>print</code> 语句，你就可以产生一些相当有用的，令人印象深刻的报表。
</p>
<hr>
<a name="Statements_002fLines"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#More-Complex" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Features" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-e_00af_00adaa_008f_00a5a_00b8_008ee_00a1_008c"></a>
<h2 class="section">1.6 <code>awk</code> 语句与行</h2>
<a name="index-line-breaks"></a>
<a name="index-newlines"></a>

<p>通常情况下，<code>awk</code> 程序的每一行都是一个独立的语句或者一个独立的规则，类似于：
</p>
<div class="example">
<pre class="example">awk '/12/  { print $0 }
     /21/  { print $0 }' mail-list inventory-shipped
</pre></div>

<a name="index-gawk_002c-newlines-in"></a>
<p>但是 <code>gawk</code> 会忽略下面符号后面的任何新行：
</p>
<div class="example">
<pre class="example">,    {    ?    :    ||    &amp;&amp;    do    else
</pre></div>

<p>任何一个新行都会认为是一个语句<a name="DOCF13" href="#FOOT13">(13)</a>
的结束。
</p>
<a name="index-_005c-_0028backslash_0029_002c-continuing-lines-and"></a>
<a name="index-backslash-_0028_005c_0029_002c-continuing-lines-and"></a>
<p>在新的一行会中止一个命令的情况下，如果你想把一行命令写成两行，你可以在第一行的末尾加上反斜杠（&lsquo;<samp>\</samp>&rsquo;）来<em>续写</em>这个命令。
为了识别一行的后续字符（续行），（ &lsquo;<samp>\</samp>&rsquo; ）反斜杠必须是行的结束字符。
反斜杠可以写在这个命令的任何地方，即使在一个字符串或者正则表达式的中间也可以。如：
</p><div class="example">
<pre class="example">awk '/This regular expression is too long, so continue it\
 on the next line/ { print $1 }'
</pre></div>

<a name="index-portability_002c-backslash-continuation-and"></a>
<p>我们一般不在我们的程序代码中利用反斜杠来续行。<code>gawk</code> 对于一行的长度没有限制，因此反斜杠续行并非是必要的。这仅是使得程序更有可读性。因为这个原因，也为清晰起见，我们尽量保证本网页中代码的语句的短小。如果你的代码是写在单独的文件而不是命令行中，那么反斜杠就最有用了。同时你也需要知道不同的发布版本的 <code>awk</code> 对于反斜杠在何处使用是有特殊地方的。因此，为了能最大化你的代码的可移植性，最好不要把你的代码行在字串或者正则表达式中间断行分开。
</p>
<a name="index-csh-utility"></a>
<a name="index-backslash-_0028_005c_0029_002c-continuing-lines-and_002c-in-csh"></a>
<a name="index-_005c-_0028backslash_0029_002c-continuing-lines-and_002c-in-csh"></a>
<blockquote>
<p><b>注意:</b> <em>反斜杠续行不会在 C Shell 中有效。</em>它只在独立的 <code>awk</code> 程序文件，或者一次性的程序中有用，<em>前提是</em>你使用的是 POSIX 兼容的 Shell，例如 Unix Bourne Shell 或者 Bash。但是 C Shell 的表现不同！你需要在行中使用两个反斜杠，然后再写入新行。在使用 C Shell 时你也需要留意 <code>awk</code> 程序中的<em>每一个</em>新行都需要反斜杠转义。作为说明如下：
</p>
<div class="example">
<pre class="example">% <kbd>awk 'BEGIN { \</kbd>
? <kbd>  print \\</kbd>
? <kbd>      &quot;hello, world&quot; \</kbd>
? <kbd>}'</kbd>
-| hello, world
</pre></div>

<p>这里面，&lsquo;<samp>%</samp>&rsquo; 与 &lsquo;<samp>?</samp>&rsquo; 都是 C Shell 的主、次提示符，与标准的 Shell 的 &lsquo;<samp>$</samp>&rsquo; 与 &lsquo;<samp>&gt;</samp>&rsquo; 类似。
</p>
<p>与前面一个例子相比，看看 POSIX 兼容的 Shell 如何来完成：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN {</kbd>
&gt;   <kbd>print \</kbd>
&gt;       <kbd>&quot;hello, world&quot;</kbd>
&gt; <kbd>}'</kbd>
-| hello, world
</pre></div>
</blockquote>

<p><code>awk</code> 是一个面向行的语言。每一个规则的动作都与模式在同一行。为了将它们分隔在不同的行，你<em>必须</em>使用反斜杠来进行续行；没有他选项。
</p>
<a name="index-backslash-_0028_005c_0029_002c-continuing-lines-and_002c-comments-and"></a>
<a name="index-_005c-_0028backslash_0029_002c-continuing-lines-and_002c-comments-and"></a>
<a name="index-commenting_002c-backslash-continuation-and"></a>
<p>还有一个事情要记住，不要将反斜杠与注释混用。<code>awk</code> 只要看到 &lsquo;<samp>#</samp>&rsquo; 开始一个注释，就会忽略一行中<em>所有的</em>后续部分。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { print &quot;dont panic&quot; # a friendly \</kbd>
&gt; <kbd>                                   BEGIN rule</kbd>
&gt; <kbd>}'</kbd>
error--&gt; gawk: cmd. line:2:                BEGIN rule
error--&gt; gawk: cmd. line:2:                ^ syntax error
</pre></div>

<p>在这个例子中，看起来反斜杠会将注释续到下一行。但是，反斜杠-新行这样的组合从来不会被注意到，因为它在注释中被藏起来了。因此，<code>BEGIN</code> 会被视作一个语法错误。
</p>
<a name="index-statements_002c-multiple"></a>
<a name="index-_003b-_0028semicolon_0029_002c-separating-statements-in-actions"></a>
<a name="index-semicolon-_0028_003b_0029_002c-separating-statements-in-actions"></a>
<p>当 <code>awk</code> 的一个规则中的语句很短，你想把它们放在同一行，这个可通过语句之间用分号（&lsquo;<samp>;</samp>&rsquo;）进行分隔。这也同样适应于规则本身。因此，在本小节中展示的程序也可以写在这样：
</p>
<div class="example">
<pre class="example">/12/ { print $0 } ; /21/ { print $0 }
</pre></div>

<blockquote>
<p><b>提示:</b> 需要声明的一点是，用一个分号分隔同一行中的规则并不是 <code>awk</code> 语言的首创。为了与在一个动作的语句处理保持一致，这才加入到 <code>awk</code> 中的。
</p></blockquote>

<hr>
<a name="Other-Features"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements_002fLines" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#When" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-c_009a_0084aa_0085_00b6a_00bb_0096c_0089_00b9ae_0080_00a7"></a>
<h2 class="section">1.7 <code>awk</code> 的其他特性</h2>

<a name="index-variables"></a>
<p><code>awk</code> 语言提供了非常多的预定义的，或者<em>内建的</em>变量，可让你的程序从 <code>awk</code> 获取信息。也有些变量集是让你的 <code>awk</code> 程序控制 <code>awk</code> 如何处理你的数据。
</p>
<p>另外，<code>awk</code> 也提供了很多的内建函数，来做一些通用性的计算与字串相关的操作。<code>gawk</code> 提供了内建的函数用来处理时间戳，执行位操作，以及运行时的字串翻译（国际化），确定变量的类型以及数据排序。
</p>
<p>当我们开发 <code>awk</code> 语言程序时，我们会介绍多数的变量与函数，他们会在 <a href="#Built_002din-Variables">预定义变量</a>，以及 <a href="#Built_002din">内置函数</a>，有系统的描述。
</p>
<hr>
<a name="When"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Features" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Intro-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_0095ae_0097_00b6a_00bd_00bfc_0094_00a8-awk"></a>
<h2 class="section">1.8 何时使用 <code>awk</code></h2>

<a name="index-awk_002c-uses-for-2"></a>
<p>目前，我们已经了解了一些 <code>awk</code> 可以做的事情，你可能有疑问 <code>awk</code> 对你有什么用处。通过使用其他工具程序，更高级的模式，域分隔符，算术语句以及其他的选择方案，你可以产生更为复杂的输出。
<code>awk</code> 对于从大量的原始数据产生报表的场景中非常用有，如从其他的工具，如 <code>ls</code> 的输出中汇总信息。（<a href="#More-Complex">复杂一点的例子</a>）
</p>
<p>用 <code>awk</code> 语言写的程序一般会比较其他的语言所写的程序要短。这使得 <code>awk</code> 程序非常容易组合与使用。
<code>awk</code> 常常在“用后即丢”的场景中快速实现你的代码。由于 <code>awk</code> 是解释型的，这就避免了在编辑-编译-测试-调试这样的程序开发流程的编译流程，而这个流程通常都比较长。
</p>
<a name="index-Brian-Kernighan_0027s-awk"></a>
<p>也有非常复杂 <code>awk</code> 程序，包括一个完整的可重定位的为
 8 位微处理写的汇编器（see section <a href="#Glossary">名词解释</a>，取得详细信息），
以及为专用的 Prolog 计算机写的微代码的汇编器。起初的 <code>awk</code> 的能力没有办法完成这么复杂的任务，但是现代版本的 <code>awk</code> 则具备了这样的能力。
</p>
<a name="index-awk-programs_002c-complex"></a>
<p>如果你发现你可能需要写好几百行的 <code>awk</code> 程序代码，你或许应该考虑使用其他的编程语言，Shell 就对字串处理与匹配就很在行；
另外，它也可以让你充分使用系统中的强大工具。Python 在高层级上的语言编程方便性与使用系统工具之间提供了很好的平衡。
<a name="DOCF14" href="#FOOT14">(14)</a>
</p>
<hr>
<a name="Intro-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#When" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-12"></a>
<h2 class="section">1.9 总结</h2>

<ul>
<li>
<code>awk</code> 程序由<var>模式</var>-<var>动作</var>对组成。

</li><li>
没有<var>模式</var>的<var>动作</var>也会运行。对于没有<var>模式</var>的默认<var>动作</var>就是 &lsquo;<samp>{ print $0 }</samp>&rsquo; 。

</li><li>
要么使用
 &lsquo;<samp>awk '<var>program</var>' <var>files</var></samp>&rsquo; 
或者
 &lsquo;<samp>awk -f <var>program-file</var> <var>files</var></samp>&rsquo; 
来运行 <code>awk</code> 。

</li><li>
你可以使用特殊的 &lsquo;<samp>#!</samp>&rsquo; 字串放在 <code>awk</code> 程序的第一行来直接执行。

</li><li>
<code>awk</code> 程序的注释以 &lsquo;<samp>#</samp>&rsquo; 开始，并持续到同一行的结束。

</li><li>
当在写大的脚本的一部份时，<code>awk</code> 时候要注意引号问题（或者 MS-Windows 的批处理文件）。

</li><li>
可以使用反斜杠来进行源代码续行。也可以在逗号 &lsquo;<samp>,</samp>&rsquo; ，开大括号 &lsquo;<samp>{</samp>&rsquo; ，问号 &lsquo;<samp>?</samp>&rsquo; ，冒号 &lsquo;<samp>:</samp>&rsquo;，&lsquo;<samp>||</samp>&rsquo;，&lsquo;<samp>&amp;&amp;</samp>&rsquo;，&lsquo;<samp>do</samp>&rsquo;，与 &lsquo;<samp>else</samp>&rsquo; 后面自动续行。
</li></ul>


<hr>
<a name="Invoking-Gawk"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Intro-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Command-Line" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00bf_0090e_00a1_008c-awk-a_00b8_008e-gawk"></a>
<h1 class="chapter">2 运行 <code>awk</code> 与 <code>gawk</code></h1>


<p>本章的内容包括如何来运行 <code>awk</code> ，介绍 POSIX 标准的与 <code>gawk</code> 特定的命令行选项，
以及 <code>awk</code> 与 <code>gawk</code> 不带参数运行时的情形。后面再涉及 <code>gawk</code> 如何来搜索文件，在读取其他文件的同时从标准输入读取数据，<code>gawk</code> 的环境变量，退出状态，使用包含文件，以及那些过时的，未文档化的选项与特性。
</p>
<p>本章中的许多特性与选项在后面的章中会更详细地说明。可以跳过本章中那些你现在不感兴趣的内容。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                How to run <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Options">2.2 命令行参数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Command-line options and their meanings.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Input file names and variable assignments.
</td></tr>
<tr><td align="left" valign="top"><a href="#Naming-Standard-Input">2.4 命名标准输入</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       How to specify standard input with other
                                files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Environment-Variables">2.5 <code>gawk</code> 使用的环境变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       The environment variables <code>gawk</code> uses.
</td></tr>
<tr><td align="left" valign="top"><a href="#Exit-Status">2.6 <code>gawk</code> 的退出状态</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 <code>gawk</code>&rsquo;s exit status.
</td></tr>
<tr><td align="left" valign="top"><a href="#Include-Files">2.7 在你的程序中包含其他的文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Including other files into your program.
</td></tr>
<tr><td align="left" valign="top"><a href="#Loading-Shared-Libraries">2.8 在你的程序装入动态扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Loading shared libraries into your program.
</td></tr>
<tr><td align="left" valign="top"><a href="#Obsolete">2.9 已经取消的选项以及特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Obsolete Options and/or features.
</td></tr>
<tr><td align="left" valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Undocumented Options and Features.
</td></tr>
<tr><td align="left" valign="top"><a href="#Invoking-Summary">2.11 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Invocation summary.
</td></tr>
</table>

<hr>
<a name="Command-Line"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Options" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00b0_0083c_0094_00a8-awk"></a>
<h2 class="section">2.1 调用 <code>awk</code></h2>
<a name="index-command-line_002c-invoking-awk-from"></a>
<a name="index-awk_002c-invoking"></a>
<a name="index-arguments_002c-command_002dline_002c-invoking-awk"></a>
<a name="index-options_002c-command_002dline_002c-invoking-awk"></a>

<p>有两种方式来运行 <code>awk</code>——带显式程序的方式或者是一到多个的程序文件方式。下面是两种运行方式的模式；在 [&hellip;] 中包括内容是可选：
</p>
<div class="display">
<pre class="display"><code>awk</code> [<var>options</var>] &lsquo;<samp>-f</samp>&rsquo; <var>progfile</var> [&lsquo;<samp>--</samp>&rsquo;] <var>file</var> &hellip;
<code>awk</code> [<var>options</var>] [&lsquo;<samp>--</samp>&rsquo;] <code>'<var>program</var>'</code> <var>file</var> &hellip;
</pre></div>

<a name="index-GNU-long-options"></a>
<a name="index-long-options"></a>
<a name="index-options_002c-long"></a>
<p>除支持传统的单字母的 POSIX 选项外， <code>gawk</code> 也支持 GNU 长格式的选项。
</p>
<a name="index-dark-corner_002c-invoking-awk"></a>
<a name="index-lint-checking_002c-empty-programs"></a>
<p>也可以用空程序的方式调用 <code>awk</code>：
</p>
<div class="example">
<pre class="example">awk '' datafile1 datafile2
</pre></div>

<a name="index-_002d_002dlint-option"></a>
<p>但是，这样做基本没什么用。当程序内容为空时，<code>awk</code> 会安静地退出。
(d.c.)
如果在命令行中进行了指定了 &lsquo;<samp>--lint</samp>&rsquo; 参数，<code>gawk</code> 会警告说，程序为空。
</p>
<hr>
<a name="Options"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Command-Line" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Arguments" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0091_00bda_00bb_00a4e_00a1_008caa_008f_0082ae_0095_00b0"></a>
<h2 class="section">2.2 命令行参数</h2>
<a name="index-options_002c-command_002dline"></a>
<a name="index-command-line_002c-options"></a>
<a name="index-GNU-long-options-1"></a>
<a name="index-options_002c-long-1"></a>

<p>选项以横杠开始，后面接一个字符。GNU 风格的长选项，则是两个横杠后面带关键字。关键字可以是缩写的，只要缩写使得选项是可识别的唯一标识即可。如果选项带参数，要么是关键字后面直接跟一个等于号（&lsquo;<samp>=</samp>&rsquo;）加上参数的值，要么是关键字与参数的值通过空格分隔。如果特定的选项有多个值，那么只有最后一个值有效。
</p>
<a name="index-POSIX-awk_002c-GNU-long-options-and"></a>
<p><code>gawk</code> 的每一个长选项都有一个对应的 POSIX 风格的短选项。长短选项在所有的上下文中都可以互相替换的。下面的列表列出了 POSIX 标准中规定的选项：
</p>
<dl compact="compact">
<dt><code>-F <var>fs</var></code></dt>
<dt><code>--field-separator <var>fs</var></code></dt>
<dd><a name="index-_002dF-option"></a>
<a name="index-_002d_002dfield_002dseparator-option"></a>
<a name="index-FS-variable_002c-_002d_002dfield_002dseparator-option-and"></a>
<p>Set the <code>FS</code> variable to <var>fs</var>
设置 <code>FS</code> 变量的值为 <var>fs</var>（see section <a href="#Field-Separators">指定记录如何进行分隔</a>）。
</p>
</dd>
<dt><code>-f <var>source-file</var></code></dt>
<dt><code>--file <var>source-file</var></code></dt>
<dd><a name="index-_002df-option-1"></a>
<a name="index-_002d_002dfile-option"></a>
<a name="index-awk-programs_002c-location-of"></a>
<p>从<var>源程序文件</var>中读取 <code>awk</code> 程序，而不是第一个非选项的参数。这个选项可以指定多次；<code>awk</code> 的程序可以由每一个指定的<var>源程序文件</var>连接而成。
</p>
</dd>
<dt><code>-v <var>var</var>=<var>val</var></code></dt>
<dt><code>--assign <var>var</var>=<var>val</var></code></dt>
<dd><a name="index-_002dv-option"></a>
<a name="index-_002d_002dassign-option"></a>
<a name="index-variables_002c-setting"></a>
<p>在执行程序<em>之前</em>，设置<var>变量</var>值为 <var>val</var>。这个变量在 <code>BEGIN</code> 规则中可用（see section <a href="#Other-Arguments">其他命令行参数</a>）。
</p>
<p>&lsquo;<samp>-v</samp>&rsquo; 选项只可以设置一个变量；但是可以使用多次，如此来设置另一个变量的值：
&lsquo;<samp>awk <span class="nolinebreak">-v</span>&nbsp;foo=1 <span class="nolinebreak">-v</span>&nbsp;bar=2 &hellip;</samp>&rsquo; 。
</p>
<a name="index-predefined-variables_002c-_002dv-option_002c-setting-with"></a>
<a name="index-variables_002c-predefined-_002dv-option_002c-setting-with"></a>
<blockquote>
<p><b>注意:</b> 使用 &lsquo;<samp>-v</samp>&rsquo; 选项设置内置变量的值可能导致令人惊讶的结果。<code>awk</code> 在需要的时候，可以重新设置这些变量的值，而忽略你指定的任何初始值。
</p></blockquote>

</dd>
<dt><code>-W <var>gawk-opt</var></code></dt>
<dd><a name="index-_002dW-option"></a>
<p>选择一个实现有关的选项。这是为特定实现而提供的一种 POSIX 转换。这个选项也有一个 GNU 风格的长选项。注意长选项是可以缩写的，只要保证缩写是唯一的即可。特定于 <code>gawk</code> 的选项的完整列表下面会列出。
</p>
</dd>
<dt><code>--</code></dt>
<dd><a name="index-command-line_002c-options_002c-end-of"></a>
<a name="index-options_002c-command_002dline_002c-end-of"></a>
<p>指示命令行选项的结束。后续的参数不会被识别为选项，即使它们以 &lsquo;<samp>-</samp>&rsquo; 开始。
对于 &lsquo;<samp>--</samp>&rsquo; 的解释是参照 POSIX 的参数分析习惯。
</p>
<a name="index-_002d-_0028hyphen_0029_002c-filenames-beginning-with"></a>
<a name="index-hyphen-_0028_002d_0029_002c-filenames-beginning-with"></a>
<p>如果你有一个文件名以 &lsquo;<samp>-</samp>&rsquo; 开始，这个参数则非常有用，或者在 Shell 脚本里，文件名会由用户来指定。在把参数传递给 <code>awk</code> 程序上，这个参数也非常有用。查看 <a href="#Getopt-Function">处理命令行选项</a>。
</p></dd>
</dl>

<p>下面的选项是特定于 <code>gawk</code> 的选项：
</p>
<dl compact="compact">
<dt>&lsquo;<samp>-b</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--characters-as-bytes</samp>&rsquo;</dt>
<dd><a name="index-_002db-option"></a>
<a name="index-_002d_002dcharacters_002das_002dbytes-option"></a>
<p>指定 <code>gawk</code> 将输入的数据按照单字节的方式对待。另外，所有的由 <code>print</code> 或者 <code>printf</code> 的输出也以单字节的方式对待。
</p>
<p>正常情况下，<code>gawk</code> 会按照 POSIX 的标准，按照当前语言设置来处理输入数据（see section <a href="#Locales">哪里造成差异</a>）。
这常常导致将多字节字符转换为宽字符（内部处理了），当输入的数据不是有效的多字节字符时，这可能导致一些问题或者疑惑。这个选项简单地告诉 <code>gawk</code> ，“别碰我的数据！”
</p>
</dd>
<dt>&lsquo;<samp>-c</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--traditional</samp>&rsquo;</dt>
<dd><a name="index-_002dc-option"></a>
<a name="index-_002d_002dtraditional-option"></a>
<a name="index-compatibility-mode-_0028gawk_0029_002c-specifying"></a>
<p>指定兼容模式，在这种模式下 <code>awk</code> 的 GNU 扩展会被禁用，这样 <code>gawk</code> 的表现就跟 BWK <code>awk</code> 一致。
<a href="#POSIX_002fGNU">不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</a>，其中汇总了所有的扩展。
也可以参考 <a href="#Compatibility-Mode">后向兼容与调试</a>。
</p>
</dd>
<dt>&lsquo;<samp>-C</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--copyright</samp>&rsquo;</dt>
<dd><a name="index-_002dC-option"></a>
<a name="index-_002d_002dcopyright-option"></a>
<a name="index-GPL-_0028General-Public-License_0029_002c-printing"></a>
<p>打印简单版本的通用许可证协议（General Public License，GPL）然后退出。
</p>
</dd>
<dt>&lsquo;<samp>-d</samp>&rsquo;[<var>file</var>]</dt>
<dt>&lsquo;<samp>--dump-variables</samp>&rsquo;[<code>=</code><var>file</var>]</dt>
<dd><a name="index-_002dd-option"></a>
<a name="index-_002d_002ddump_002dvariables-option"></a>
<a name="index-dump-all-variables-of-a-program"></a>
<a name="index-awkvars_002eout-file"></a>
<a name="index-files_002c-awkvars_002eout"></a>
<a name="index-variables_002c-global_002c-printing-list-of"></a>
<p>打印经过排序的全局变量，以及它们的类型，以及最终值到 <var>file</var> 中。如果没有提供 <var>file</var> 参数，就把这个列表打印到一个 &lsquo;<tt>awkvars.out</tt>&rsquo; 的文件中，并输出在当前目录。如果提供了 <var>file</var> 参数，在 &lsquo;<samp>-d</samp>&rsquo; 参数与 <var>file</var> 之间不能有空格。
</p>
<a name="index-troubleshooting_002c-typographical-errors_002c-global-variables"></a>
<p>查看全局变量列表，是一种查找程序中输入错误的一种好方法。如果你的程序很大，而函数很多时，可以使用这个选项，来确定你的函数是否有这种情况，即本来使用本地变量却错误地使用了全局变量。（这个在将变量名命令为 <code>i</code>，<code>j</code> 等等名字的情况下尤其容易出错。）
</p>
</dd>
<dt>&lsquo;<samp>-D</samp>&rsquo;[<var>file</var>]</dt>
<dt>&lsquo;<samp>--debug</samp>&rsquo;[<code>=</code><var>file</var>]</dt>
<dd><a name="index-_002dD-option"></a>
<a name="index-_002d_002ddebug-option"></a>
<a name="index-awk-debugging_002c-enabling"></a>
<p>启用 <code>awk</code> 程序调试（see section <a href="#Debugging"><code>gawk</code> 调试器介绍</a>）。
默认情况下，调试器从键盘中交互式地读入命令。可选参数 <var>file</var> 可以让你指定在文件中的命令行列表，而不是交互地输入。
如果你提供了 <var>file</var> 参数，则在 &lsquo;<samp>-D</samp>&rsquo; 与 <var>file</var> 之间不能有空格。
</p>
</dd>
<dt>&lsquo;<samp>-e</samp>&rsquo; <var>program-text</var></dt>
<dt>&lsquo;<samp>--source</samp>&rsquo; <var>program-text</var></dt>
<dd><a name="index-_002de-option"></a>
<a name="index-_002d_002dsource-option"></a>
<a name="index-source-code_002c-mixing"></a>
<p>在 <var>program-text</var> 中指定源代码。这个选项可以让你混用通过文件与通过命令行来提供源代码的方式。这个选项在你有自己的库函数要使用，但是你又通过命令行来转入程序的情况下非常有用。（see section <a href="#AWKPATH-Variable">环境变量 <code>AWKPATH</code></a>）。
</p>
</dd>
<dt>&lsquo;<samp>-E</samp>&rsquo; <var>file</var></dt>
<dt>&lsquo;<samp>--exec</samp>&rsquo; <var>file</var></dt>
<dd><a name="index-_002dE-option"></a>
<a name="index-_002d_002dexec-option"></a>
<a name="index-awk-programs_002c-location-of-1"></a>
<a name="index-CGI_002c-awk-scripts-for"></a>
<p>与 &lsquo;<samp>-f</samp>&rsquo; 参数类似，<code>awk</code> 从 <var>file</var> 中读取程序。与 &lsquo;<samp>-f</samp>&rsquo; 相比，有两个不同：
</p>
<ul>
<li>
这个选项会结束选项的处理；任何在命令行上后续的其他参数都将直接传递给 <code>awk</code> 程序。

</li><li>
命令变量赋值形式 &lsquo;<samp><var>var</var>=<var>value</var></samp>&rsquo; 也将禁止。
</li></ul>

<p>这个选项在写 WWW CGI 程序时通过 URL 传统参数时非常有用。通过这个选项可以防止一些有害的（或者其他的）用户将选项，赋值以及 <code>awk</code> 源代码（通过 &lsquo;<samp>-e</samp>&rsquo; 选项）传递给 CGI 应用。
<a name="DOCF15" href="#FOOT15">(15)</a>
这个选项需要与 &lsquo;<samp>#!</samp>&rsquo; 脚本一起使用（see section <a href="#Executable-Scripts">可执行的 <code>awk</code> 程序</a>），例如这样：
</p>
<div class="example">
<pre class="example">#! /usr/local/bin/gawk -E

<var>awk program here &hellip;</var>
</pre></div>

</dd>
<dt>&lsquo;<samp>-g</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--gen-pot</samp>&rsquo;</dt>
<dd><a name="index-_002dg-option"></a>
<a name="index-_002d_002dgen_002dpot-option"></a>
<a name="index-portable-object-files_002c-generating"></a>
<a name="index-files_002c-portable-object_002c-generating"></a>
<p>分析源程序中的已经做了翻译标志所有字串常量，并产生一个 GNU <code>gettext</code> 可移植的对象模板文件到标准输出上。
<a href="#Internationalization"><code>gawk</code> 的国际化</a>，来取得这个选项的相关信息。
</p>
</dd>
<dt>&lsquo;<samp>-h</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--help</samp>&rsquo;</dt>
<dd><a name="index-_002dh-option"></a>
<a name="index-_002d_002dhelp-option"></a>
<a name="index-GNU-long-options_002c-printing-list-of"></a>
<a name="index-options_002c-printing-list-of"></a>
<a name="index-printing_002c-list-of-options"></a>
<p>打印“使用方式”信息，汇总 <code>gawk</code> 接收的长、短风格的选项然后退出。
</p>
</dd>
<dt>&lsquo;<samp>-i</samp>&rsquo; <var>source-file</var></dt>
<dt>&lsquo;<samp>--include</samp>&rsquo; <var>source-file</var></dt>
<dd><a name="index-_002di-option"></a>
<a name="index-_002d_002dinclude-option"></a>
<a name="index-awk-programs_002c-location-of-2"></a>
<p>从 <var>source-file</var> 读取 <code>awk</code> 源库。这个选项与在你的程序中的 <code>@include</code> 等同。
也非常类似于 &lsquo;<samp>-f</samp>&rsquo; 选项，但是有两个重要的不同。
首先，当 &lsquo;<samp>-i</samp>&rsquo; 指定时，如果源程序之前已经装载过了，则不会再被装载，而当使用 &lsquo;<samp>-f</samp>&rsquo; 时，<code>gawk</code> 总是会装载源文件。
第二，由于这个选项目的是用于库类型的代码，<code>gawk</code> 不会将这些文件识别成主程序的连续输入。
因此，在处理了 &lsquo;<samp>-i</samp>&rsquo; 参数后，<code>gawk</code> 还是希望通过命令行的 &lsquo;<samp>-f</samp>&rsquo; 参数来取得主程序源代码。
</p>
</dd>
<dt>&lsquo;<samp>-l</samp>&rsquo; <var>ext</var></dt>
<dt>&lsquo;<samp>--load</samp>&rsquo; <var>ext</var></dt>
<dd><a name="index-_002dl-option"></a>
<a name="index-_002d_002dload-option"></a>
<a name="index-loading_002c-extensions"></a>
<p>载入一个名为 <var>ext</var> 的动态扩展。扩展存储为系统的共享动态库。
这个选项使用 <code>AWKLIBPATH</code> 变量来搜索库。正确的库后缀会根据系统默认提供，因此你不需要指定扩展名。
扩展的初始化函数为 <code>dl_load()</code>。
另外一个选项就是通过在程序中通过 <code>@load</code> 关键字来装载共享库。
这个高级特性的详细说明在 <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>。
</p>
</dd>
<dt>&lsquo;<samp>-L</samp>&rsquo;[<var>value</var>]</dt>
<dt>&lsquo;<samp>--lint</samp>&rsquo;[<code>=</code><var>value</var>]</dt>
<dd><a name="index-_002dl-option-1"></a>
<a name="index-_002d_002dlint-option-1"></a>
<a name="index-lint-checking_002c-issuing-warnings"></a>
<a name="index-warnings_002c-issuing"></a>
<p>对于可疑的或者不可移植到其他 <code>awk</code> 实现的结果提出告警。
如果提供了 <var>value</var>，则 &lsquo;<samp>-L</samp>&rsquo; 参数与 <var>value</var> 之间不可以有空格。
一些警告会在第一次读入程序时就会给出。而其他的一些会在运行时给出。当可选参数的值是 &lsquo;<samp>fatal</samp>&rsquo;，lint 警告就成了致命错误。
这可能有点夸张，但是这确实能够刺激开发者开发出更加“干净”的 <code>awk</code> 程序。
如果可选参数的值为 &lsquo;<samp>invalid</samp>&rsquo;，则只有在确实是无效的情况下才会发出告警。（这个还没有完全实现）
</p>
<p>有些告警只打印一次，就算这样的可疑结果在你的 <code>awk</code> 程序中出现多次。
因此，当去除了由 &lsquo;<samp>--lint</samp>&rsquo; 所报告的问题时，你应该要仔细检查你的程序中所有不恰当的结构。如果你的程序不长，做这个工作也不会成为什么负担。
</p>
</dd>
<dt>&lsquo;<samp>-M</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--bignum</samp>&rsquo;</dt>
<dd><a name="index-_002dM-option"></a>
<a name="index-_002d_002dbignum-option"></a>
<p>强制对于数据计算使用任意精度。这个选项如果在 <code>gawk</code> 编译时没有使用 GNU MPFR 以及 MP 库时，不会起作用。（查看 <a href="#Arbitrary-Precision-Arithmetic">算术运算与 <code>gawk</code> 中的任意精度算术运算</a>）
</p></dd>
<dt>&lsquo;<samp>-n</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--non-decimal-data</samp>&rsquo;</dt>
<dd><a name="index-_002dn-option"></a>
<a name="index-_002d_002dnon_002ddecimal_002ddata-option"></a>
<a name="index-hexadecimal-values_002c-enabling-interpretation-of"></a>
<a name="index-octal-values_002c-enabling-interpretation-of"></a>
<a name="index-troubleshooting_002c-_002d_002dnon_002ddecimal_002ddata-option"></a>
<p>启用自动的对输入数据的八进制与十六进制值的自动解释（查看 <a href="#Nondecimal-Data">允许非十进制数数据输入</a>）。
</p>
<blockquote>
<p><b>注意:</b> 这个选项有可能严重破坏旧的程序，因此要小心使用。同时也提示，这个参数可能在 <code>gawk</code> 的后面的版本会被取消。
</p></blockquote>

</dd>
<dt>&lsquo;<samp>-N</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--use-lc-numeric</samp>&rsquo;</dt>
<dd><a name="index-_002dN-option"></a>
<a name="index-_002d_002duse_002dlc_002dnumeric-option"></a>
<p>当分析数值输入数据时，强制使用当前的语言设置（current locale）的十进制小数点字符。（查看 <a href="#Locales">哪里造成差异</a>）
</p>
</dd>
<dt>&lsquo;<samp>-o</samp>&rsquo;[<var>file</var>]</dt>
<dt>&lsquo;<samp>--pretty-print</samp>&rsquo;[<code>=</code><var>file</var>]</dt>
<dd><a name="index-_002do-option"></a>
<a name="index-_002d_002dpretty_002dprint-option"></a>
<p>启用 <code>awk</code> 程序的简单打印。默认情况下，输出程序被创建在一个文件名为 &lsquo;<tt>awkprof.out</tt>&rsquo; 文件中（查看 <a href="#Profiling">测评你的 <code>awk</code> 程序</a>）。
可选参数 <var>file</var> 可以让你可以指定一个不同的文件名用于输出。如果你提供了 <var>file</var> 参数，则 &lsquo;<samp>-o</samp>&rsquo; 选项与 <var>file</var> 之间不能有空格。
</p>
<blockquote>
<p><b>提示:</b> 由于 <code>gawk</code> 演化的方式，有这个参数时，你的程序依然会执行。这个会在下一个主要版本发生变化，因此 <code>gawk</code> 仅简化打印程序，而不是执行它。
</p></blockquote>

</dd>
<dt>&lsquo;<samp>-O</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--optimize</samp>&rsquo;</dt>
<dd><a name="index-_002d_002doptimize-option"></a>
<a name="index-_002dO-option"></a>
<p>启用某些程序内部表达式的优化。在此时，这个仅仅包括一些简单的常量折叠。 
</p>
</dd>
<dt>&lsquo;<samp>-p</samp>&rsquo;[<var>file</var>]</dt>
<dt>&lsquo;<samp>--profile</samp>&rsquo;[<code>=</code><var>file</var>]</dt>
<dd><a name="index-_002dp-option"></a>
<a name="index-_002d_002dprofile-option"></a>
<a name="index-awk-profiling_002c-enabling"></a>
<p>启用 <code>awk</code> 程序采样分析（查看 <a href="#Profiling">测评你的 <code>awk</code> 程序</a>）。
默认情况下，采样分析会生成文件名为 &lsquo;<tt>awkprof.out</tt>&rsquo;。
可选参数 <var>file</var> 可以让你指定一个不同的文件名。如果你指定了 <var>file</var> 参数，则在 &lsquo;<samp>-p</samp>&rsquo; 选项与 <var>file</var> 参数之间不能有空格。
采样分析结果中在左边包括程序中的每条语句的执行次数，以及每个函数的函数调用次数。
</p>
</dd>
<dt>&lsquo;<samp>-P</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--posix</samp>&rsquo;</dt>
<dd><a name="index-_002dP-option"></a>
<a name="index-_002d_002dposix-option"></a>
<a name="index-POSIX-mode"></a>
<a name="index-gawk_002c-extensions_002c-disabling"></a>
<p>严格按 POSIX 模式来。这个禁用所有的 <code>gawk</code> 扩展（就像 &lsquo;<samp>--traditional</samp>&rsquo; 一样），并禁用所有不属于 POSIX 的扩展，
</p>
<ul>
<li>
<a name="index-newlines-1"></a>
<a name="index-whitespace_002c-newlines-as"></a>
</li><li>
当 <code>FS</code> 等于单个空格时，新行不会像空格一样用来进行域分隔（查看 <a href="#Fields">检查域</a>）。

</li><li>
在 &lsquo;<samp>?</samp>&rsquo; 或者 &lsquo;<samp>:</samp>&rsquo; 后不能断行（查看 <a href="#Conditional-Exp">条件表达式</a>）。


<a name="index-FS-variable_002c-as-TAB-character"></a>
</li><li>
指定 &lsquo;<samp>-Ft</samp>&rsquo; 时，不能将 <code>FS</code> 的值设置为单一的 TAB 字符（查看 <a href="#Field-Separators">指定记录如何进行分隔</a>）。

<a name="index-locale-decimal-point-character"></a>
<a name="index-decimal-point-character_002c-locale-specific"></a>
</li><li>
语言设置中的十进制小数点字符用来分析输入数据（查看 <a href="#Locales">哪里造成差异</a>）。
</li></ul>

<a name="index-_002d_002dtraditional-option_002c-_002d_002dposix-option-and"></a>
<a name="index-_002d_002dposix-option_002c-_002d_002dtraditional-option-and"></a>
<p>如果你即提供了 &lsquo;<samp>--traditional</samp>&rsquo; 与 &lsquo;<samp>--posix</samp>&rsquo; 参数在命令行中，&lsquo;<samp>--posix</samp>&rsquo; 会优先执行。<code>gawk</code> 则会输出一个警告。
</p>
</dd>
<dt>&lsquo;<samp>-r</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--re-interval</samp>&rsquo;</dt>
<dd><a name="index-_002dr-option"></a>
<a name="index-_002d_002dre_002dinterval-option"></a>
<a name="index-regular-expressions_002c-interval-expressions-and"></a>
<p>在 regexps 中允许区间表达式（查看 <a href="#Regexp-Operators">正则表达式操作符</a>）。现在这个是 <code>gawk</code> 的默认行为。这个参数保留下来，即为了身后的兼容性，也为了与 &lsquo;<samp>--traditional</samp>&rsquo; 组合使用。
</p>
</dd>
<dt>&lsquo;<samp>-S</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--sandbox</samp>&rsquo;</dt>
<dd><a name="index-_002dS-option"></a>
<a name="index-_002d_002dsandbox-option"></a>
<a name="index-sandbox-mode"></a>
<p>禁用 <code>system()</code> 函数，用 <code>getline</code> 进行输入重定向，用 <code>print</code>，<code>printf</code> 以及动态扩展来进行输出重定向。
当你要执行来源有有疑问的 <code>awk</code> 源代码时，为了确保脚本不会访问你的系统（而不是通过指定输入数据文件），这个参数尤其有用。
</p>
</dd>
<dt>&lsquo;<samp>-t</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--lint-old</samp>&rsquo;</dt>
<dd><a name="index-_002dL-option"></a>
<a name="index-_002d_002dlint_002dold-option"></a>
<p>当相应的结构在 Version 7 Unix 起初始的 <code>awk</code> 版本中不可用时，发出告警（查看 <a href="#V7_002fSVR3_002e1">在 V7 与 SVR3.1 之间的变化</a>）。
</p>
</dd>
<dt>&lsquo;<samp>-V</samp>&rsquo;</dt>
<dt>&lsquo;<samp>--version</samp>&rsquo;</dt>
<dd><a name="index-_002dV-option"></a>
<a name="index-_002d_002dversion-option"></a>
<a name="index-gawk_002c-versions-of_002c-information-about_002c-printing"></a>
<p>打印这个 <code>gawk</code> 的版本信息。这个可以让你确定你的 <code>gawk</code> 版本是不是与 Free Software Foundation 发布的最新版本匹配。
在 Bug 报告中也非常有用（查看 <a href="#Bugs">报告问题与 BUG</a>）。
</p></dd>
</dl>

<p>只要提供了程序文本，如果有选项由于警告而被标志为无效，忽略它就可以了。
</p>
<a name="index-_002dF-option_002c-_002dFt-sets-FS-to-TAB"></a>
<p>在兼容模式里，有个特殊的地方，如果果 <var>fs</var> 的值通过 &lsquo;<samp>-F</samp>&rsquo; 参数设置为 &lsquo;<samp>t</samp>&rsquo; ，那么 <code>FS</code> 就会被设置成 TAB 字符（<code>&quot;\t&quot;</code>）。
这种情况只有在使用 &lsquo;<samp>--traditional</samp>&rsquo; 时才会为真，而不是 &lsquo;<samp>--posix</samp>&rsquo;（查看 <a href="#Field-Separators">指定记录如何进行分隔</a>）。
</p>
<a name="index-_002df-option_002c-multiple-uses"></a>
<p>&lsquo;<samp>-f</samp>&rsquo; 参数可以在命令行中使用多次。
<code>awk</code> 将从多个文件中读取程序，就好像这些文件已经合并成了一个大的文件。这种方式在创建 <code>awk</code> 函数库时非常有用。这些函数只需要写一次，然后从某个标准的位置取用，而不是在每个单独的文件中包含。&lsquo;<samp>-i</samp>&rsquo; 参数在这个方面的考虑也类似。（正如 <a href="#Definition-Syntax">函数定义语法</a>，中所提到的，这些函数名必须是唯一的。）
</p>
<p>标准的 <code>awk</code> 中，就算程序是通过键盘输入的，通过 &lsquo;<samp>-f /dev/tty</samp>&rsquo; 完成，库函数也还是可以使用的。
输入程序后，键入 <kbd>Ctrl-d</kbd>（文件结束符）来结束。（你也可以使用 &lsquo;<samp>-f -</samp>&rsquo; 来从标准输入中读取程序源代码，只是这个时候，你就不能同时使用标准输入作为数据的输入源。）
</p>
<p>由于标准 <code>awk</code> 中混用源文件与命令行 <code>awk</code> 程序，显得有一些笨拙，所以 <code>gawk</code> 提供了一个 &lsquo;<samp>-e</samp>&rsquo; 选项。
这并不需要你抢占标准输入来输入源代码，而是让你很容易地混合使用命令行与库源代码（查看 <a href="#AWKPATH-Variable">环境变量 <code>AWKPATH</code></a>）。
与 &lsquo;<samp>-f</samp>&rsquo; 一样，&lsquo;<samp>-e</samp>&rsquo; 与 &lsquo;<samp>-i</samp>&rsquo; 选项也可以在命令中多次使用。
</p>
<a name="index-_002de-option-1"></a>
<p>如果没有 &lsquo;<samp>-f</samp>&rsquo; 或者 &lsquo;<samp>-e</samp>&rsquo; 选项指定，<code>gawk</code> 会使用命令行中的第一个非选项参数作为程序的源代码。
</p>
<a name="index-POSIXLY_005fCORRECT-environment-variable"></a>
<a name="index-lint-checking_002c-POSIXLY_005fCORRECT-environment-variable"></a>
<a name="index-POSIX-mode-1"></a>
<p>如果环境变量 <code>POSIXLY_CORRECT</code> 存在，<code>gawk</code> 就会严格地按照 POSIX 模式执行，就如你提供了 &lsquo;<samp>--posix</samp>&rsquo; 参数一样。
许多的 GNU 程序都查找这个环境变量来禁用与 POSIX 标准有冲突的扩展，但是 <code>gawk</code> 的行为有一些不同：
就算某个特性与 POSIX 没有冲突，它也禁用所有的扩展，然后按照严格的 POSIX 标准模式执行。
如果指定了 &lsquo;<samp>--lint</samp>&rsquo; 选项，<code>gawk</code> 会因为 <code>POSIXLY_CORRECT</code> 而开启 POSIX 模式，然后会输出警告信息，说 POSIX 模式已经启用。
一般来说，你可能会在你的 Shell 的启动脚本中设置这个变量。
对于与 Bourne Shell 兼容的 Shell 来说（如 Bash），你可以将下面的行加入到用户主目录的 &lsquo;<tt>.profile</tt>&rsquo; 文件中：
</p>
<div class="example">
<pre class="example">POSIXLY_CORRECT=true
export POSIXLY_CORRECT
</pre></div>

<a name="index-csh-utility_002c-POSIXLY_005fCORRECT-environment-variable"></a>
<p>对于与 C shell 兼容的 shell，<a name="DOCF16" href="#FOOT16">(16)</a>你可以将下面的行加入到用户主目录的 &lsquo;<tt>.login</tt>&rsquo; 文件中：
</p>
<div class="example">
<pre class="example">setenv POSIXLY_CORRECT true
</pre></div>

<a name="index-portability_002c-POSIXLY_005fCORRECT-environment-variable"></a>
<p>对于每日的工作环境，设置 <code>POSIXLY_CORRECT</code> 变量并不值得建议，但是对于测试你的程序在其他环境中的可移植性则有相当作用。
</p>
<hr>
<a name="Other-Arguments"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Options" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Naming-Standard-Input" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_00b6a_00bb_0096aa_0091_00bda_00bb_00a4e_00a1_008caa_008f_0082ae_0095_00b0"></a>
<h2 class="section">2.3 其他命令行参数</h2>
<a name="index-command-line_002c-arguments"></a>
<a name="index-arguments_002c-command_002dline"></a>

<p>对于命令行中的额外参数，一般都会被当作输入文件来对待，并依次处理。
但是具有 <code><var>var</var>=<var>value</var></code>（将 <var>value</var> 赋值给变量 <var>var</var>）形式的参数，却并不作为一个输入文件指定。
（查看 <a href="#Assignment-Options">在命令行中进行变量赋值</a>。）
在下面的例子中，<var>count=1</var> 是一个变量赋值，而不是文件名：
</p>
<div class="example">
<pre class="example">awk -f program.awk file1 count=1 file2
</pre></div>

<a name="index-gawk_002c-ARGIND-variable-in"></a>
<a name="index-ARGIND-variable_002c-command_002dline-arguments"></a>
<a name="index-ARGV-array_002c-indexing-into"></a>
<a name="index-ARGC_002fARGV-variables_002c-command_002dline-arguments"></a>
<p>所有命令行参数都可以通过 <code>ARGV</code> 数组被 <code>awk</code> 程序得到（查看 <a href="#Built_002din-Variables">预定义变量</a>）。
命令行参数与程序文本（如果有）都在 <code>ARGV</code> 中忽略掉了。其他的参数，包括变量赋值，都包含在了这个数组中。随着对 <code>ARGV</code> 参数的处理，
<code>gawk</code> 会设置 <code>ARGIND</code> 的值为 <code>ARGV</code> 数组的索引，以记录当前的元素位置。
</p>
<p>通过更改 <code>ARGC</code> 与 <code>ARGV</code> 的值，你可以控制 <code>awk</code> 处理输入文件的方式；这个内容在 <a href="#ARGC-and-ARGV">使用 <code>ARGC</code> 与 <code>ARGV</code></a>，会有更详细的描述。
</p>
<a name="index-input-files_002c-variable-assignments-and"></a>
<a name="index-variable-assignments-and-input-files"></a>
<p>对文件名参数与赋值变量参数的区分是在 <code>awk</code> 在准备打开下一个输入文件时处理的。
在那个执行点，<code>awk</code> 会检查文件名，看它是一个文件还是一个变量赋值；如果是，<code>awk</code> 会设置那个变量而不是打开文件进行读操作。
</p>
<p>因此，在处理完所有之前的文件后，变量就会被设置成相应的值。
特别的，以这种方式对变量进行的赋值，在 <code>BEGIN</code> 规则（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）中是<em>不可</em>访问到的，
因为这个规则在 <code>awk</code> 开始扫描参数列表之前就已经执行了。
</p>
<a name="index-dark-corner_002c-escape-sequences"></a>
<p>在命令行上所给的赋值变量会按照转义的方式进行处理（查看 <a href="#Escape-Sequences">转义序列</a>）。
(d.c.)
</p>
<p>在一些非常早期的 <code>awk</code> 实现中，当变量赋值参数出现在任何文件名之前，
则赋值操作会发生在 <code>BEGIN</code> 规则执行<em>之前</em>。
<code>awk</code> 的行为因此就不一致了；一些命令行赋值会在 <code>BEGIN</code> 规则中就可以使用，而其他的则不可以。
非常不幸的是，一些应用程序却依赖于这样的“特性”。当 <code>awk</code> 变得更一致的时候，&lsquo;<samp>-v</samp>&rsquo; 选项就用来协调应用依赖于这种旧行为的代码。
</p>
<p>变量赋值特性会在设置 <code>RS</code>，<code>OFS</code> 和 <code>ORS</code> 变量的值时非常有作用，这个变量用来在扫描数据文件时控制输入输出格式。同时，如果 <code>awk</code> 要多次扫描数据文件时，用来控制状态也非常有用。例如：
</p>
<a name="index-files_002c-multiple-passes-over"></a>
<div class="example">
<pre class="example">awk 'pass == 1  { <var>pass 1 stuff</var> }
     pass == 2  { <var>pass 2 stuff</var> }' pass=1 mydata pass=2 mydata
</pre></div>

<p>有了变量赋值特性后，用 &lsquo;<samp>-F</samp>&rsquo; 参数来设置 <code>FS</code> 的值，严格来说就不那么必要了。这里保留下来只是为了兼容历史版本。
</p>
<hr>
<a name="Naming-Standard-Input"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Arguments" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Environment-Variables" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0091_00bdaa_0090_008dae_00a0_0087aa_0087_0086e_00be_0093aa_0085_00a5"></a>
<h2 class="section">2.4 命名标准输入</h2>

<p>很多情况下，你希望同时从标准输入与文件中输入数据，你希望读一个文件，再从标准输入的管道中读入数据，然后再读另一个文件。
</p>
<p>将标准输入命名的方式，对所有版本的 <code>awk</code>，都是使用一个单独的减号，或者说是横杠 &lsquo;<samp>-</samp>&rsquo; ，例如：
</p>
<div class="example">
<pre class="example"><var>some_command</var> | awk -f myprog.awk file1 - file2
</pre></div>

<p>这个例子中，<code>awk</code> 首先读取文件 &lsquo;<tt>file1</tt>&rsquo;，然后从 <var>some_command</var> 的输出中读入数据，最后从 &lsquo;<tt>file2</tt>&rsquo; 中读取数据。
</p>
<p>当你使用 <code>getline</code> 来读取文件时，你也可以用 <code>&quot;-&quot;</code> 来命名标准输入（查看 <a href="#Getline_002fFile">使用 <code>getline</code> 读取文件</a>）。
</p>
<p>另外，<code>gawk</code> 也可以让你在命令行或者程序文件中指定特殊的文件名 &lsquo;<tt>/dev/stdin</tt>&rsquo;。
一些版本的 <code>awk</code> 也支持这种方式，但这并不是标准。（有些操作系统在文件系统中提供文件 &lsquo;<tt>/dev/stdin</tt>&rsquo;；而 <code>gawk</code> 总是自己来处理这个文件。）
</p>
<hr>
<a name="Environment-Variables"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Naming-Standard-Input" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#AWKPATH-Variable" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-a_00bd_00bfc_0094_00a8c_009a_0084c_008e_00afaa_00a2_0083aa_008f_0098e_0087_008f"></a>
<h2 class="section">2.5 <code>gawk</code> 使用的环境变量</h2>
<a name="index-environment-variables-used-by-gawk"></a>

<p>有很多的环境变量会影响到 <code>gawk</code> 的行为。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#AWKPATH-Variable">2.5.1 环境变量 <code>AWKPATH</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Searching directories for <code>awk</code>
                                programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#AWKLIBPATH-Variable">2.5.2 环境变量 <code>AWKLIBPATH</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Searching directories for <code>awk</code> shared
                                libraries.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Environment-Variables">2.5.3 其他的环境变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> The environment variables.
</td></tr>
</table>

<hr>
<a name="AWKPATH-Variable"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Environment-Variables" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Environment-Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#AWKLIBPATH-Variable" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_008e_00afaa_00a2_0083aa_008f_0098e_0087_008f-AWKPATH"></a>
<h3 class="subsection">2.5.1 环境变量 <code>AWKPATH</code></h3>
<a name="index-AWKPATH-environment-variable"></a>
<a name="index-directories_002c-searching-for-source-files"></a>
<a name="index-search-paths_002c-for-source-files"></a>
<a name="index-differences-in-awk-and-gawk_002c-AWKPATH-environment-variable"></a>
<p>在大多的 <code>awk</code> 实现中，你可以指定为每个程序文件指定确定的路径名，除非文件就在当前目录。
但是，如果通过 &lsquo;<samp>-f</samp>&rsquo; 或者 &lsquo;<samp>-i</samp>&rsquo; 选项所提供的文件名中没有包括目录分隔符 &lsquo;<samp>/</samp>&rsquo;，<code>gawk</code> 则会在一系列的目录中进行搜索
（称为<em>搜索路径</em>），一个接一个地查找是否有指定的文件名。
</p>
<p>这些搜索路径包括一系列的由冒号分隔的路径名。<a name="DOCF17" href="#FOOT17">(17)</a> 
<code>gawk</code> 从 <code>AWKPATH</code> 环境变量中取得它的搜索路径。如果不存在这个变量，或者这个变量为空，<code>gawk</code> 会使用默认的路径（后面说明）。
</p>
<p>搜索路径特性用来创建通用的 <code>awk</code> 函数库非常有用。
库文件可以放在一个标准的默认目录中，然后在命令行中指定一个短的文件名。不然的话，你需要输入每个文件的完整路径。
</p>
<p>通过使用 &lsquo;<samp>-i</samp>&rsquo; 或者 &lsquo;<samp>-f</samp>&rsquo; 选项，你的命令行 <code>awk</code> 程序可以利用 <code>awk</code> 的库文件
（查看 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a>）。
如果是在兼容模式中，路径搜索并没有实现，因此，而对于 &lsquo;<samp>--traditional</samp>&rsquo; 与 &lsquo;<samp>--posix</samp>&rsquo; 模式，搜索路径不可用。
查看 <a href="#Options">命令行参数</a>。
</p>
<p>如果源代码文件没有在初始的路径中找到，则路径搜索会在文件名后面加一个 &lsquo;<samp>.awk</samp>&rsquo; 后缀名后再执行搜索。
</p>
<p><code>gawk</code> 的路径搜索机制与 Shell 的机制有点类似。
（可以查看 <a href="http://www.gnu.org/software/bash/manual/"><cite>Bourne-Again Shell 手册</cite></a>。）
它将空的路径项视为当前路径。（一个空项由一个冒号开始，或者以冒号结束的路径，或者两个紧接着的冒号表示 [&lsquo;<samp>::</samp>&rsquo;]。）
</p>
<blockquote>
<p><b>提示:</b> 要将当前路径包括在路径中，要么在项目中放一个点号 &lsquo;<tt>.</tt>&rsquo; 或者写一个空的路径项。
</p>
<p><code>gawk</code> 之前的几个不同版本会显示地在当前目录进行搜索，不管是在搜索路径前还是后。
在版本 4.1.2 这个版本中，则不再这么处理；如果你希望搜索当前目录，你必须包括一个点 &lsquo;<tt>.</tt>&rsquo; 作为一个独立的项，要么在搜索路径中加入一个空项。
</p></blockquote>

<p><code>AWKPATH</code> 的默认路么是：
&lsquo;<samp>.:/usr/local/share/awk</samp>&rsquo;。
<a name="DOCF18" href="#FOOT18">(18)</a>
由于 &lsquo;<tt>.</tt>&rsquo; 包括在了开始处，<code>gawk</code> 会首先搜索当前目录，然后再搜索 &lsquo;<tt>/usr/local/share/awk</tt>&rsquo;。
在实践中，这意味着你很少需要更改 <code>AWKPATH</code> 的值。
</p>
<p><code>gawk</code> 将其使用的搜索路径的值放在 <code>ENVIRON[&quot;AWKPATH&quot;]</code> 元素中。
这提供了可以让你在 <code>awk</code> 程序中访问搜索路径的机制。
</p>
<p>尽管你可以在程序中更改 <code>ENVIRON[&quot;AWKPATH&quot;]</code> 的值，但这不会影响正在执行的程序的行为。
原因如下：<code>AWKPATH</code> 是用来作为搜索程序文件的环境变量。
一旦你的程序运行起来，所有的文件都已经搜索到了，<code>gawk</code> 就不再需要 <code>AWKPATH</code> 变量了。
</p>
<hr>
<a name="AWKLIBPATH-Variable"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#AWKPATH-Variable" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Environment-Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Environment-Variables" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_008e_00afaa_00a2_0083aa_008f_0098e_0087_008f-AWKLIBPATH"></a>
<h3 class="subsection">2.5.2 环境变量 <code>AWKLIBPATH</code></h3>
<a name="index-AWKLIBPATH-environment-variable"></a>
<a name="index-directories_002c-searching-for-loadable-extensions"></a>
<a name="index-search-paths_002c-for-loadable-extensions"></a>
<a name="index-differences-in-awk-and-gawk_002c-AWKLIBPATH-environment-variable"></a>

<p><code>AWKLIBPATH</code> 环境变量与 <code>AWKPATH</code> 变量类似，但是是由来搜索可装载的扩展（存储为系统的共享库），而不是用来搜索源代码文件，
这些扩展由 &lsquo;<samp>-l</samp>&rsquo; 选项进行指定。如果扩展没有找到，会在搜索完成后加上恰当的共享库后缀后再次搜索。
例如，在 GNU/Linux 系统中，后缀是 &lsquo;<samp>.so</samp>&rsquo;。
搜索路径也可以用于用 <code>@load</code> 关键词进行的扩展装载（查看 <a href="#Loading-Shared-Libraries">在你的程序装入动态扩展</a>）。
</p>
<p>如果 <code>AWKLIBPATH</code> 在环境变量中不存在，或者为空，<code>gawk</code> 会使用默认的路径，
一般是 &lsquo;<samp>/usr/local/lib/gawk</samp>&rsquo;，但这也会由于 <code>gawk</code> 构建的方式而有不同。
</p>
<p><code>gawk</code> 会将搜索路径的值存放于 <code>ENVIRON[&quot;AWKLIBPATH&quot;]</code> 中。这样，在你的程序中可以得到实际的搜索路径。
</p>
<hr>
<a name="Other-Environment-Variables"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#AWKLIBPATH-Variable" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Environment-Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Exit-Status" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_00b6a_00bb_0096c_009a_0084c_008e_00afaa_00a2_0083aa_008f_0098e_0087_008f"></a>
<h3 class="subsection">2.5.3 其他的环境变量</h3>
<p>还有很多的环境变量会影响 <code>gawk</code> 的行为，但是它们都比较特殊。下面的变量都是一般的用户使用：
</p>
<dl compact="compact">
<dt><code>GAWK_MSEC_SLEEP</code></dt>
<dd><p>指定连接重试的间隔，以毫秒为单位。在不支持 <code>usleep()</code> 调用的系统上，这个值为向上舍入为整数秒。
</p>
</dd>
<dt><code>GAWK_READ_TIMEOUT</code></dt>
<dd><p>指定 <code>gawk</code> 在返回出错前，等待输入的毫秒数。查看 <a href="#Read-Timeout">带超时的输入读取</a>。
</p>
</dd>
<dt><code>GAWK_SOCK_RETRIES</code></dt>
<dd><p>控制 <code>gawk</code> 重试双向 TCP/IP （Socket）连接的次数。查看 <a href="#TCP_002fIP-Networking">利用 <code>gawk</code> 进行网络通信</a>。
</p>
</dd>
<dt><code>POSIXLY_CORRECT</code></dt>
<dd><p>导致 <code>gawk</code> 切换到 POSIX 兼容模式，并禁用所有的传统的与 GNU 扩展。查看 <a href="#Options">命令行参数</a>。
</p></dd>
</dl>

<p>下面的环境变量由 <code>gawk</code> 的开发者用于测试与调测目的。它们会改变。这些变量是：
</p>
<dl compact="compact">
<dt><code>AWKBUFSIZE</code></dt>
<dd><p>这个变量只影响在 POSIX 兼容系统上的 <code>gawk</code>。
如果值是 &lsquo;<samp>exact</samp>&rsquo;，<code>gawk</code> 会使用输入文件的大小作为内存缓存的大小，来用进行 I/O 的分配。其他情况下的值则是一个整数值，
<code>gawk</code> 使用这个值进行缓存的分配。（当这个变量没有设置，<code>gawk</code> 使用文件大小与默认块大小两者中的小的数值，
这一般来说者是文件系统的 I/O 块大小。）
</p>
</dd>
<dt><code>AWK_HASH</code></dt>
<dd><p>如果这个变量存在，值为 &lsquo;<samp>gst</samp>&rsquo; ，<code>gawk</code> 会切换使用来自于 GNU Smalltalk 的哈希函数来管理数组。这个函数比标准的函数要稍快。
</p>
</dd>
<dt><code>AWKREADFUNC</code></dt>
<dd><p>如果这个变量存在，<code>gawk</code> 会切换成一次一行地读取文件，而不是整块地读。这个变量的存在是为了调试在 non-POSIX 操作系统上文件系统的问题，在这个系统上的 I/O 是以记录来进行读取而不是以块的方式。
</p>
</dd>
<dt><code>GAWK_MSG_SRC</code></dt>
<dd><p>如果这个变量存在，<code>gawk</code> 会在产生的警告信息与致命信息中加入文件名与行号。它的目的是帮助分离消息源，因为有可能有多个地方会产生相同的警告或者错误信息。
</p>
</dd>
<dt><code>GAWK_LOCALE_DIR</code></dt>
<dd><p>指明编译好的信息对象文件的位置。在 <code>gawk</code> 开始运行的时候，这个变量被传递给 <code>bindtextdomain()</code> 函数。
</p>
</dd>
<dt><code>GAWK_NO_DFA</code></dt>
<dd><p>如果这个变量存在，<code>gawk</code> 不会使用 DFA regexp 匹配器
<a name="DOCF19" href="#FOOT19">(19)</a>
来进行“它匹配么？”类型的匹配测试。这会导致 <code>gawk</code> 更慢。它的目的是帮助分隔两个 <code>gawk</code> 内部使用的 regexp 匹配器。（本来应该是没有什么差异的，但是偶尔有时理论与实际相互不太合拍。）
</p>
</dd>
<dt><code>GAWK_NO_PP_RUN</code></dt>
<dd><p>当 <code>gawk</code> 指定 &lsquo;<samp>--pretty-print</samp>&rsquo; 选项时，如果存在这个变量，它将不会执行程序。
</p>
<blockquote>
<p><b>注意:</b> 这个变量在下个版本发布时不会继续存在。
</p></blockquote>

</dd>
<dt><code>GAWK_STACKSIZE</code></dt>
<dd><p>指定 <code>gawk</code> 内部求值栈的增长的大小，如果需要增长的话。
</p>
</dd>
<dt><code>INT_CHAIN_MAX</code></dt>
<dd><p>指定 <code>gawk</code> 管理的由整数进行索引的数组中的哈希链的元素的最大数值。
</p>
</dd>
<dt><code>STR_CHAIN_MAX</code></dt>
<dd><p>指定 <code>gawk</code> 管理的由字串进行索引的数组中的哈希链的元素的最大数值。
</p>
</dd>
<dt><code>TIDYMEM</code></dt>
<dd><p>如果这个变量存在，<code>gawk</code> 则使用 GNU C 库中的 <code>mtrace()</code> 库调用来跟踪可能的内存泄露。
</p></dd>
</dl>

<hr>
<a name="Exit-Status"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Environment-Variables" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Include-Files" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-c_009a_0084e_0080_0080aa_0087_00bac_008a_00b6ae_0080_0081"></a>
<h2 class="section">2.6 <code>gawk</code> 的退出状态</h2>

<a name="index-exit-status_002c-of-gawk"></a>
<p>如果使用一个数值来与 <code>exit</code> 语句一起使用（查看 <a href="#Exit-Statement"><code>exit</code> 语句</a>），<code>gawk</code> 则用这个数值做为它的退出状态数值。
</p>
<p>否则，如果在执行中没有发生错误，<code>gawk</code> 则用 C 的常量 <code>EXIT_SUCCESS</code> 退出，这一般为 0。
</p>
<p>如果出现了错误，<code>gawk</code> 则使用 C 常量 <code>EXIT_FAILURE</code> 退出，这一般是 1。
</p>
<p>如果 <code>gawk</code> 由于致命错误而退出，则退出状态为 2。在 non-POSIX 系统上，这个值可能会被影射为 <code>EXIT_FAILURE</code>。
</p>
<hr>
<a name="Include-Files"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Exit-Status" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Loading-Shared-Libraries" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8a_00bd_00a0c_009a_0084c_00a8_008baa_00ba_008fa_00b8_00adaa_008c_0085aa_0090_00abaa_0085_00b6a_00bb_0096c_009a_0084ae_0096_0087a_00bb_00b6"></a>
<h2 class="section">2.7 在你的程序中包含其他的文件</h2>


<p>本小节中所描述的特性都是 <code>gawk</code> 所独有的。
</p>
<a name="index-_0040include-directive"></a>
<a name="index-file-inclusion_002c-_0040include-directive"></a>
<a name="index-including-files_002c-_0040include-directive"></a>
<p><code>@include</code> 关键字可以用来读取 <code>awk</code> 外部的源文件。这赋予了你将大的 <code>awk</code> 源程序拆分为更小的，可管理的代码块的能力，也可以让你复用通用的 <code>awk</code> 源代码。这就是说，你可以将实现特定任务的 <code>awk</code> 函数组织成外部文件。
通过 <code>@include</code> 关键字与 <code>AWKPATH</code> 环境变量搭配使用，这些文件可以像函数库一样被使用。注意，源文件也可以通过 &lsquo;<samp>-i</samp>&rsquo; 选项包含进来。
</p>
<p>让我们看个例子。我们启动两个小的（没啥用的）<code>awk</code> 脚本，名字为 &lsquo;<tt>test1</tt>&rsquo; 与 &lsquo;<tt>test2</tt>&rsquo;。这里是 &lsquo;<tt>test1</tt>&rsquo; 的脚本：
</p>
<div class="example">
<pre class="example">BEGIN {
    print &quot;This is script test1.&quot;
}
</pre></div>

<p>这里是 &lsquo;<tt>test2</tt>&rsquo; 的：
</p>
<div class="example">
<pre class="example">@include &quot;test1&quot;
BEGIN {
    print &quot;This is script test2.&quot;
}
</pre></div>

<p>用 <code>gawk</code> 执行 &lsquo;<tt>test2</tt>&rsquo; 产生了下面的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f test2</kbd>
-| This is script test1.
-| This is script test2.
</pre></div>

<p><code>gawk</code> 执行 &lsquo;<tt>test2</tt>&rsquo; 脚本，而这脚本通过 <code>@include</code> 关键字包含了 &lsquo;<tt>test1</tt>&rsquo;。
因此，包含外部的 <code>awk</code> 源代码，你可以只使用 <code>@include</code>，后面加上要包含的文件名，并用双引号引起来。
</p>
<blockquote>
<p><b>提示:</b> 要记住，这是个语言结构，并且文件名不能是个串变量，而只能是一个在双引号中的代表其自身的字串常量。
</p></blockquote>

<p>文件包含有可能是内嵌的；例如，如果有第三个脚本，名字为 &lsquo;<tt>test3</tt>&rsquo;：
</p>
<div class="example">
<pre class="example">@include &quot;test2&quot;
BEGIN {
    print &quot;This is script test3.&quot;
}
</pre></div>

<p>用 <code>gawk</code> 执行脚本 &lsquo;<tt>test3</tt>&rsquo; 则会产生下面的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f test3</kbd>
-| This is script test1.
-| This is script test2.
-| This is script test3.
</pre></div>

<p>文件名也可以是一个目录名。如：
</p>
<div class="example">
<pre class="example">@include &quot;../io_funcs&quot;
</pre></div>

<p>或者：
</p>
<div class="example">
<pre class="example">@include &quot;/usr/awklib/network&quot;
</pre></div>

<p>上面两个格式都是正确的。<code>AWKPATH</code> 环境变量在使用 <code>@include</code> 时会产生巨大好处。在 <code>@include</code> 使用 <code>AWKPATH</code> 环境变量的规则，在命令行搜索中也是一样适应的（查看 <a href="#AWKPATH-Variable">环境变量 <code>AWKPATH</code></a>）。
</p>
<p>用这来构建 <code>gawk</code> 的函数库非常有用。如果你有一个大的，非常有用的通用 <code>awk</code> 函数脚本，你就可以将他们拆分为一个个库文件，然后将这些文件放在一个特定目录。然后你可以将这些“库”包含进来。你可以使用文件的全路径，也可以通过设置 <code>AWKPATH</code> 环境变量，然后使用 <code>@include</code>，并仅使用全路径名的文件名部分即可。
当然，你也可以将库文件放在不止一个目录下；更复杂的工作环境是这样的，你用多个目录来组织需要包含的文件。
</p>
<p>由于可以通过多个 &lsquo;<samp>-f</samp>&rsquo; 选项来指定个文件，<code>@include</code> 这样的机制并不严格需要。
但是，<code>@include</code> 关键字可以帮你构建自包含的 <code>gawk</code> 程序，这样可以避免写复杂，多余的命令行。特别是，<code>@include</code> 在写 CGI 脚本来运行网络页面时非常有用。
</p>
<p>如在 <a href="#AWKPATH-Variable">环境变量 <code>AWKPATH</code></a>，所提到的，当前的目录总是包含在文件 <code>AWKPATH</code> 搜索路径的第一个位置，这也同样应用于 <code>@include</code> 机制。
</p>
<hr>
<a name="Loading-Shared-Libraries"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Include-Files" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Obsolete" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8a_00bd_00a0c_009a_0084c_00a8_008baa_00ba_008fe_00a3_0085aa_0085_00a5aa_008a_00a8ae_0080_0081ae_0089_00a9aa_00b1_0095"></a>
<h2 class="section">2.8 在你的程序装入动态扩展</h2>

<p>本小节描述的也是 <code>gawk</code> 的特性。
</p>
<a name="index-_0040load-directive"></a>
<a name="index-loading-extensions_002c-_0040load-directive"></a>
<a name="index-extensions_002c-loading_002c-_0040load-directive"></a>
<p><code>@load</code> 关键字，可以用来读取外部的 <code>awk</code> 扩展（存储为系统共享库）。
这个机制可以让你使用编译过的代码来实现非常高的执行性能，并且/或者使用使用一些 <code>awk</code> 语言所不支持的能力。
<code>AWKLIBPATH</code> 变量来用进行扩展的搜索。使用 <code>@load</code> 机制完全与使用命令行选项 &lsquo;<samp>-l</samp>&rsquo; 等同。
</p>
<p>如果扩展一开始没有在 <code>AWKLIBPATH</code> 中找到，会通过给文件名附加上默认动态库扩展名再搜索一次。例如，在 GNU/Linux 系统中，这个后缀名是 &lsquo;<samp>.so</samp>&rsquo; ：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk '@load &quot;ordchr&quot;; BEGIN {print chr(65)}'</kbd>
-| A
</pre></div>

<p>上面的代码与下面的例子等同：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -lordchr 'BEGIN {print chr(65)}'</kbd>
-| A
</pre></div>

<p>对于命令行的使用，&lsquo;<samp>-l</samp>&rsquo; 选项更加方便，但是 <code>@load</code> 用来在你的 <code>awk</code> 源代码中嵌入必须的扩展也非常有用。
</p>
<p><a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>，详细解释了如何（用 C 或者 C++）来写扩展，这些扩展可以用 <code>@load</code> 来装载，也可以用 &lsquo;<samp>-l</samp>&rsquo; 选项来装载。
在这章里也述及了 <code>ordchr</code> 扩展。
</p>
<hr>
<a name="Obsolete"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Loading-Shared-Libraries" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Undocumented" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b7_00b2c_00bb_008faa_008f_0096ae_00b6_0088c_009a_0084e_0080_0089e_00a1_00b9a_00bb_00a5aa_008f_008ac_0089_00b9ae_0080_00a7"></a>
<h2 class="section">2.9 已经取消的选项以及特性</h2>


<a name="index-options_002c-deprecated"></a>
<a name="index-features_002c-deprecated"></a>
<a name="index-obsolete-features"></a>
<p>本小节所涉及的特性以及/或者命令行选项，来自之前的 <code>gawk</code> 发布版本。
这些特性，命令行选项要么已经不再可用，要么是虽然是还支持，但是已经标志为放弃状态(意味着它们在下个版本中将<em>不再</em>可用)。
</p>
<p>进程相关的特殊文件 &lsquo;<tt>/dev/pid</tt>&rsquo;，&lsquo;<tt>/dev/ppid</tt>&rsquo;，&lsquo;<tt>/dev/pgrpid</tt>&rsquo;，与 &lsquo;<tt>/dev/user</tt>&rsquo; 已经在 <code>gawk</code> 3.1 版本取消了，但是还可以使用。
到 4.0 版本的时候，它们将不再被 <code>gawk</code> 识别。（而是使用 <code>PROCINFO</code>，查看 <a href="#Auto_002dset">传递信息的内置变量</a>。）
</p>

<hr>
<a name="Undocumented"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Obsolete" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009c_00aae_00ae_00b0e_00bd_00bdc_009a_0084e_0080_0089e_00a1_00b9a_00b8_008ec_0089_00b9ae_0080_00a7"></a>
<h2 class="section">2.10 未记载的选项与特性</h2>
<a name="index-undocumented-features"></a>
<a name="index-features_002c-undocumented"></a>
<a name="index-Skywalker_002c-Luke"></a>
<a name="index-Kenobi_002c-Obi_002dWan"></a>
<a name="index-Jedi-knights"></a>
<a name="index-Knights_002c-jedi"></a>
<blockquote>
<p><i>使用源代码，祝好运！</i>
</p></blockquote>
<p align="center">&mdash; <em>Obi-Wan</em>
</p>
<a name="index-shells_002c-sea"></a>
<p>本小节特意留空。
</p>

<hr>
<a name="Invoking-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Undocumented" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-7"></a>
<h2 class="section">2.11 总结</h2>

<ul>
<li>
使用 &lsquo;<samp>awk '<var>program</var>' <var>files</var></samp>&rsquo; 或者 &lsquo;<samp>awk -f <var>program-file</var> <var>files</var></samp>&rsquo; 来运行 <code>awk</code>。

</li><li>
对所有版本的 <code>awk</code>，有三个标准的选项，即 &lsquo;<samp>-f</samp>&rsquo;，&lsquo;<samp>-F</samp>&rsquo; 与 &lsquo;<samp>-v</samp>&rsquo;。
<code>gawk</code> 支持这几个选项，也支持其他许多的选项，以及 GNU 风格的长选项。

</li><li>
非选项的命令行参数通常会被当做文件名对待，除非它他有 &lsquo;<samp><var>var</var>=<var>value</var></samp>&rsquo; 这样的形式，这种形式下，会在 <code>awk</code> 处理输入文件时执行变量赋值语句。

</li><li>
所有的非选项命令行参数，不包括程序文本，都会存放于 <code>ARGV</code> 数组中，调整 <code>ARGC</code> 与 <code>ARGV</code> 会影响 <code>awk</code> 处理输入的方式。

</li><li>
在命令行中，你可以使用一个单一的减号（&lsquo;<samp>-</samp>&rsquo;）来指定标准输入。
<code>gawk</code> 也可以让你使用特殊文件名 &lsquo;<tt>/dev/stdin</tt>&rsquo;。

</li><li>
<code>gawk</code> 会关注一系列的环境变量，<code>AWKPATH</code>，<code>AWKLIBPATH</code> 与 <code>POSIXLY_CORRECT</code> 是最重要的几个。

</li><li>
<code>gawk</code> 的退出状态向调用它的程序传递了相应的信息。在程序代码中使用 <code>exit</code> 语句来设置 <code>awk</code> 程序的退出状态。

</li><li>
<code>gawk</code> 可以将其他的 <code>awk</code> 源代码包含在到你的程序中，
这是通过 <code>@include</code> 语句以及/或者 &lsquo;<samp>-i</samp>&rsquo; 与 &lsquo;<samp>-f</samp>&rsquo; 命令行参数来实现的。

</li><li>
通过 <code>@load</code> 语句与/或者 &lsquo;<samp>-l</samp>&rsquo; 选项，你可以将使用 C 或者 C++ 编译的其他附加功能模块（扩展）引入你的程序。
（这个高级特性会在 <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>，中进行详细说明。）
</li></ul>

<hr>
<a name="Regexp"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Invoking-Gawk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Invoking-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Usage" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h1 class="chapter">3 正则表达式</h1>

<a name="index-regexp"></a>
<a name="index-regular-expressions"></a>

<p><em>正则表达式</em>，也称为 <em>regexp</em>，是描述字串集的方法。由于正则表达式是 <code>awk</code> 程序最基础的部分，
它们的格式与使用有必要用单独的章来进行解析。
</p>
<a name="index-forward-slash-_0028_002f_0029-to-enclose-regular-expressions"></a>
<a name="index-_002f-_0028forward-slash_0029-to-enclose-regular-expressions"></a>
<p>在斜杠对（&lsquo;<samp>/</samp>&rsquo;）中包括的正则表达式，在 <code>awk</code> 中称为模式，用以匹配那些属于这个字串集的输入记录。
最简单的正则表达式就是一串字符序列，数字或者二者兼而有之。这样的正则表达式匹配任意具有这个字符序列的字串。
所以正则表达式 &lsquo;<samp>foo</samp>&rsquo; 匹配任意包含 &lsquo;<samp>foo</samp>&rsquo; 的字串。这样，模式 <code>/foo/</code> 匹配任意的输入记录，
只要这个记录在<em>任意位置</em>包含这三个连续的字符序列 &lsquo;<samp>foo</samp>&rsquo; 好可。其他类型的正则表达式可以让你指定更复杂的字串类。
</p>
<p>在本章的开始的例子，都是比较简单的。当我们更深入地解释正则表达式如何工作时，就会写一些更复杂的例子。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                How to Use Regular Expressions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How to write nonprinting characters.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Regular Expression Operators.
</td></tr>
<tr><td align="left" valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         What can go between &lsquo;<samp>[...]</samp>&rsquo;.
</td></tr>
<tr><td align="left" valign="top"><a href="#Leftmost-Longest">3.5 匹配多少？</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How much text matches.
</td></tr>
<tr><td align="left" valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Using Dynamic Regexps.
</td></tr>
<tr><td align="left" valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Operators specific to GNU software.
</td></tr>
<tr><td align="left" valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How to do case-insensitive matching.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Summary">3.9 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Regular expressions summary.
</td></tr>
</table>

<hr>
<a name="Regexp-Usage"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Escape-Sequences" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a6_0082a_00bd_0095a_00bd_00bfc_0094_00a8ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h2 class="section">3.1 如何使用正则表达式</h2>

<a name="index-regular-expressions_002c-as-patterns"></a>
<p>正则表达式通过两个斜杠包含起来进行使用。然后正则表达式就会对记录的整个文本进行测试。（正常情况下，只需要按顺序匹配文本的一部份就能够成功测试匹配与否。）例如，下面只需要记录的任意位置出现 &lsquo;<samp>li</samp>&rsquo; 串，就打印它的第二个域：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '/li/ { print $2 }' mail-list</kbd>
-| 555-5553
-| 555-0542
-| 555-6699
-| 555-3430
</pre></div>

<a name="index-regular-expressions_002c-operators"></a>
<a name="index-operators_002c-string_002dmatching"></a>
<a name="index-string_002dmatching-operators"></a>
<a name="index-_007e-_0028tilde_0029_002c-_007e-operator"></a>
<a name="index-tilde-_0028_007e_0029_002c-_007e-operator"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator"></a>
<a name="index-if-statement_002c-use-of-regexps-in"></a>
<a name="index-while-statement_002c-use-of-regexps-in"></a>
<a name="index-do_002dwhile-statement_002c-use-of-regexps-in"></a>
<p>正则表达式也可以用于匹配表达式。这些表达式中你可以指定一个要匹配的串；而不需要整个的输入记录。
有两个操作符来执行匹配，一个是 &lsquo;<samp>~</samp>&rsquo;，一个是 &lsquo;<samp>!~</samp>&rsquo;。
这些表达式可以用作模式部分，也可以用在 <code>if</code> 语句，<code>while</code> 语句，<code>for</code> 语句，以及 <code>do</code> 语句。
（查看 <a href="#Statements">动作中的控制语句</a>。）例如，下面的例子中，如果 <var>exp</var>（存有字串）匹配 <var>regexp</var> 则会为真：
</p>
<div class="example">
<pre class="example"><var>exp</var> ~ /<var>regexp</var>/
</pre></div>

<p>下面这个例子中，匹配，或者选择所有的输入记录中的第一个域中某个地方存在大字的字母 &lsquo;<samp>J</samp>&rsquo; ：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '$1 ~ /J/' inventory-shipped</kbd>
-| Jan  13  25  15 115
-| Jun  31  42  75 492
-| Jul  24  34  67 436
-| Jan  21  36  64 620
</pre></div>

<p>下面执行一样的功能：
</p>
<div class="example">
<pre class="example">awk '{ if ($1 ~ /J/) print }' inventory-shipped
</pre></div>

<p>下个例子中，如果表达式 <var>exp</var>（存有字串）<em>不</em>匹配 regexp 则为真：
</p>
<div class="example">
<pre class="example"><var>exp</var> !~ /<var>regexp</var>/
</pre></div>

<p>下面的例子中匹配或者选择所有的，第一个域不包含大写字母 &lsquo;<samp>J</samp>&rsquo; 的记录：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '$1 !~ /J/' inventory-shipped</kbd>
-| Feb  15  32  24 226
-| Mar  15  24  34 228
-| Apr  31  52  63 420
-| May  16  34  29 208
&hellip;
</pre></div>

<a name="index-regexp-constants"></a>
<a name="index-constant-regexps"></a>
<a name="index-regular-expressions_002c-constants_002c-See-regexp-constants"></a>
<p>当 regexp 被斜杠包含时，如 <code>/foo/</code> 我们称之为<em>正则表达式常量</em>，就类似于 <code>5.27</code> 是一个数值常量以及 <code>&quot;foo&quot;</code> 是一个字串常量一样。
</p>
<hr>
<a name="Escape-Sequences"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Usage" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Operators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00bd_00aca_00b9_0089aa_00ba_008faa_0088_0097"></a>
<h2 class="section">3.2 转义序列</h2>

<a name="index-escape-sequences_002c-in-strings"></a>
<a name="index-backslash-_0028_005c_0029_002c-in-escape-sequences"></a>
<a name="index-_005c-_0028backslash_0029_002c-in-escape-sequences"></a>
<p>有些字符不能够原样地在字串常量（<code>&quot;foo&quot;</code>）或者正则表达式常量（<code>/foo/</code>）中。
相反，它们需要放在<em>转义序列</em>中，在这个序列中，字符会用一个反斜杠（&lsquo;<samp>\</samp>&rsquo;）开始。
其中的一个用法就是在一个双引号字串常量中包含进一个双引号。由于光双引号会结束一个串，在字串中，你必须使用 &lsquo;<samp>\&quot;</samp>&rsquo; 来表示一个实际的双引号。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print &quot;He said \&quot;hi!\&quot; to her.&quot; }'</kbd>
-| He said &quot;hi!&quot; to her.
</pre></div>

<p>反斜杠字符自己本身也是一个不能以通常方式包含的字符；你必须输入 &lsquo;<samp>\\</samp>&rsquo; 来将反斜杠包含进字串或者正则表达式中。因此，如果字串的内容为 &lsquo;<samp>&quot;</samp>&rsquo; 与 &lsquo;<samp>\</samp>&rsquo;，则必须写成 <code>&quot;\&quot;\\&quot;</code>。
</p>
<p>其他的转义字符是一些如 TAB 或者换行符这样的不可打印字符。没什么东西可以阻止你输入大多数的不可打印字符到字串常量或者正则表达式常量中，但那看起来奇丑无比。
</p>
<p>下面的列表列出了所有的在 <code>awk</code> 中使用的转义的字符以及其对应的字符。除非另外提示，所有这些转义字符即可用于字串常量也用于正则表达式：
</p>
<dl compact="compact">
<dt><code>\\</code></dt>
<dd><p> 字符反斜杠 &lsquo;<samp>\</samp>&rsquo;。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005ca-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005ca-escape-sequence"></a>
</dd>
<dt><code>\a</code></dt>
<dd><p> “alert”字符，<kbd>Ctrl-g</kbd>，ASCII 代码 7（BEL，响铃）。（这通常是制造一些可以听得到的噪声。）
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005cb-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005cb-escape-sequence"></a>
</dd>
<dt><code>\b</code></dt>
<dd><p> 退格，<kbd>Ctrl-h</kbd>，ASCII 代码8（BS）。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005cf-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005cf-escape-sequence"></a>
</dd>
<dt><code>\f</code></dt>
<dd><p> 换页，<kbd>Ctrl-l</kbd>，ASCII 代码 12（FF）。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005cn-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005cn-escape-sequence"></a>
</dd>
<dt><code>\n</code></dt>
<dd><p> 换行，<kbd>Ctrl-j</kbd>，ASCII 代码 10（LF）。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005cr-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005cr-escape-sequence"></a>
</dd>
<dt><code>\r</code></dt>
<dd><p> 回车，<kbd>Ctrl-m</kbd>，ASCII 代码13（CR）。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005ct-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005ct-escape-sequence"></a>
</dd>
<dt><code>\t</code></dt>
<dd><p> 水平跳格，<kbd>Ctrl-i</kbd>，ASCII 代码9（HT）。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005cv-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005cv-escape-sequence"></a>
</dd>
<dt><code>\v</code></dt>
<dd><p> 垂直跳格，<kbd>Ctrl-k</kbd>，ASCII 代码11（VT）。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005cnnn-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005cnnn-escape-sequence"></a>
</dd>
<dt><code>\<var>nnn</var></code></dt>
<dd><p> 八进制值 <var>nnn</var>，<var>nnn</var> 表示 1 到 3 位的 &lsquo;<samp>0</samp>&rsquo; 到 &lsquo;<samp>7</samp>&rsquo; 之间的数字。如，ASCII ESC 字符的代码是 &lsquo;<samp>\033</samp>&rsquo;。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005cx-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005cx-escape-sequence"></a>
<a name="index-common-extensions_002c-_005cx-escape-sequence"></a>
<a name="index-extensions_002c-common_002c-_005cx-escape-sequence"></a>
</dd>
<dt><code>\x<var>hh</var>&hellip;</code></dt>
<dd><p> 十六进制值 <var>hh</var>，<var>hh</var> 表示十六进制数字（&lsquo;<samp>0</samp>&rsquo; 到 &lsquo;<samp>9</samp>&rsquo;，以及 &lsquo;<samp>A</samp>&rsquo; 到 &lsquo;<samp>F</samp>&rsquo; 或者 &lsquo;<samp>a</samp>&rsquo; 到 &lsquo;<samp>f</samp>&rsquo;）序列。
类似于 ISO C 中的结构，转换序列一直延续到第一个非十六进制的数字为止。
(c.e.)但是，使用两个以上的十六进制的数字会产生未定义的结果。（&lsquo;<samp>\x</samp>&rsquo; 转义序列在 POSIX <code>awk</code> 中不被支持。）
</p>
<blockquote>
<p><b>注意:</b> 下一个 <code>gawk</code> 的主要版本会有改变，会使用到 &lsquo;<samp>\x</samp>&rsquo; 后面跟两个最大的十六进制数字的情况。
</p></blockquote>

<a name="index-_005c-_0028backslash_0029_002c-_005c_002f-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005c_002f-escape-sequence"></a>
</dd>
<dt><code>\/</code></dt>
<dd><p>A literal slash (necessary for regexp constants only).
 字面斜杠字符（在正则表达式的常量中使用）。当你要在一个正则表达式中加入有反斜杠的表达式常量时使用
（如 <code>/.*:\/home\/[[:alnum:]]+:.*/</code> 符号会在 <a href="#Bracket-Expressions">使用方括号表达式</a> 讨论。）
由于正则表达式通过斜杠来分隔，所以如果斜杠是其中的一部分，你就需要进行转义，以通知 <code>awk</code> 继续处理正则表达式后面的部分。
</p>
<a name="index-_005c-_0028backslash_0029_002c-_005c_0022-escape-sequence"></a>
<a name="index-backslash-_0028_005c_0029_002c-_005c_0022-escape-sequence"></a>
</dd>
<dt><code>\&quot;</code></dt>
<dd><p> 字面双引号（仅在字串常量中使用）。这个序列当你要在一个字串常量中包含双引号时使用
 （例如 <code>&quot;He said \&quot;hi!\&quot; to her.&quot;</code>）。
 由于双引号用来分隔字串，所以当在字串中有双引号时，你需要进行转义，以通知 <code>awk</code> 继续处理字串后面的部分。
</p></dd>
</dl>

<p>在 <code>gawk</code> 的正则表达式中，有许多的以反斜杠开始两字符序列有关特殊的意义。查看 <a href="#GNU-Regexp-Operators">特定于 <code>gawk</code> 的正则表达式操作符</a>。
</p>
<p>在正则表达式中，在任意字符前的反斜杠，不在前面的列表中，也没有在 <a href="#GNU-Regexp-Operators">特定于 <code>gawk</code> 的正则表达式操作符</a> 中，其下一个字符则会按字面的处理。
就算它正常情况下是正则表达式的操作符。例如 <code>/a\+b/</code> 匹配3个字符的串 &lsquo;<samp>a+b</samp>&rsquo; 。
</p>
<a name="index-backslash-_0028_005c_0029_002c-in-escape-sequences-1"></a>
<a name="index-_005c-_0028backslash_0029_002c-in-escape-sequences-1"></a>
<a name="index-portability"></a>
<p>为了完全可移植，不要使用任何没有在前面列表列出的字符或者在不是正则表达式操作符字符前使用反斜杠。
</p>
<a name="index-sidebar_002c-aa_00b8_00b8e_00a7_0084aa_00ad_0097c_00ac_00a6aa_0089_008dc_009a_0084aa_008f_008dae_0096_009cae_009d_00a0"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>常规字符前的反斜杠</b>
</p>

<a name="index-portability_002c-backslash-in-escape-sequences"></a>
<a name="index-POSIX-awk_002c-backslashes-in-string-constants"></a>
<a name="index-backslash-_0028_005c_0029_002c-in-escape-sequences_002c-POSIX-and"></a>
<a name="index-_005c-_0028backslash_0029_002c-in-escape-sequences_002c-POSIX-and"></a>

<a name="index-troubleshooting_002c-backslash-before-nonspecial-character"></a>
<p>如果你在字串常量中的某个未在前面的列表中列出的字符前使用反斜杠，POSIX <code>awk</code> 有意地使这种情况为未定义。有两个选择：
</p>
<a name="index-Brian-Kernighan_0027s-awk-1"></a>
<dl compact="compact">
<dt>把反斜杠去掉</dt>
<dd><p>这正是 BWK <code>awk</code> 与 <code>gawk</code> 两者所做的。
例如 <code>&quot;a\qc&quot;</code> 与 <code>&quot;aqc&quot;</code> 一样。
（因为这是很容易引入，又容易错过的 Bug，<code>gawk</code> 会给予警告。）
考虑 &lsquo;<samp>FS = &quot;[&nbsp;\t]+\|[&nbsp;\t]+&quot;</samp>&rsquo; 使用竖线 &lsquo;<samp>|</samp>&rsquo; 以及周边的空白作为域分隔符，
这时，需要在字串中使用两个反斜杠：&lsquo;<samp>FS = &quot;[&nbsp;\t]+\\|[&nbsp;\t]+&quot;</samp>&rsquo;。）
</p>
<a name="index-gawk_002c-escape-sequences"></a>
<a name="index-Unix-awk_002c-backslashes-in-escape-sequences"></a>
<a name="index-mawk-utility"></a>
</dd>
<dt>保留反斜杠</dt>
<dd><p>有一些 <code>awk</code> 实现会这么做。在这种实现中，输入 <code>&quot;a\qc&quot;</code> 将与输入 <code>&quot;a\\qc&quot;</code> 相同。
</p></dd>
</dl>
</td></tr></table>

<p>总结一下：
</p>
<ul>
<li>
对于字串常量与正则表达式常量，前面列表中的转义序列都是会首先处理。处理的时间非常靠前，<code>awk</code> 一读完你的程序，就处理了。

</li><li>
常量正则表达式或者动态正则表达式（查看 <a href="#Computed-Regexps">使用动态正则表达式</a>），<code>gawk</code> 都会处理列在 <a href="#GNU-Regexp-Operators">特定于 <code>gawk</code> 的正则表达式操作符</a> 中的操作符。

</li><li>
在其他的符号前使用反斜杠，都表示把这个符号按字面处理。
</li></ul>

<a name="index-sidebar_002c-e_00bd_00aca_00b9_0089aa_0085_0083aa_00ad_0097c_00ac_00a6"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>转义元字符</b>
</p>

<a name="index-metacharacters_002c-escape-sequences-for"></a>

<p>假设你使用八进制或者十六进制转义来提交正则表达式的元字符（查看 <a href="#Regexp-Operators">正则表达式操作符</a>），<code>awk</code> 是否将这些字符做为字面字符还是一个正则表达式操作符？
</p>
<a name="index-dark-corner_002c-escape-sequences_002c-for-metacharacters"></a>
<p>由于历史原因，这样的字符是按照字面字符来处理的。
(d.c.)
然而，POSIX 标准却表示它们应该被当成真正的元字符，<code>gawk</code> 则是这么处理的。
在兼容模式下（查看 <a href="#Options">命令行参数</a>），<code>gawk</code> 在正则表达式常中会将这些转义的八进制或者十六进制的字符按字面处理。因此 <code>/a\52b/</code> 与 <code>/a\*b/</code> 等同。
</p></td></tr></table>

<hr>
<a name="Regexp-Operators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Escape-Sequences" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Bracket-Expressions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fae_0093_008da_00bd_009cc_00ac_00a6"></a>
<h2 class="section">3.3 正则表达式操作符</h2>
<a name="index-regular-expressions_002c-operators-1"></a>
<a name="index-metacharacters-in-regular-expressions"></a>

<p>你可以在正则表达式中与特定字符进行组合，称为<em>正则表达式操作符</em>或者<em>元字符</em>，来给正常表达式加入更加强大的能力与多样性。
</p>
<p>在前节 <a href="#Escape-Sequences">转义序列</a> 中所描述的转义字符，在正则表达式中也是有效的。
它们通过反斜杠 &lsquo;<samp>\</samp>&rsquo; 引入，然后在处理正则表达式第一步，被识别成或者转换成相应的真实字符。
</p>
<p>下面是元字符列表。所有的那些未列在此的，非转义序列，就是代表他们自己：
</p>
<dl compact="compact">
<dd><a name="index-backslash-_0028_005c_0029_002c-regexp-operator"></a>
<a name="index-_005c-_0028backslash_0029_002c-regexp-operator"></a>
</dd>
<dt><code>\</code></dt>
<dd><p>这个取消了某个字符的在匹配时的特殊含义，如 &lsquo;<samp>\$</samp>&rsquo; 就是匹配字符 &lsquo;<samp>$</samp>&rsquo; 。
</p>
<a name="index-regular-expressions_002c-anchors-in"></a>
<a name="index-Texinfo_002c-chapter-beginnings-in-files"></a>
<a name="index-_005e-_0028caret_0029_002c-regexp-operator"></a>
<a name="index-caret-_0028_005e_0029_002c-regexp-operator"></a>
</dd>
<dt><code>^</code></dt>
<dd><p>这里匹配字串的开头。&lsquo;<samp>^@chapter</samp>&rsquo; 匹配字串开头的 &lsquo;<samp>@chapter</samp>&rsquo;，如可以用来识别 Texinfo 中章的开头。
&lsquo;<samp>^</samp>&rsquo; 也被称为<em>锚定符</em>，因为它就是将模式设定成匹配字串的开头。
</p>
<p>要了解 &lsquo;<samp>^</samp>&rsquo; 并不是匹配内嵌在字串中行头（即 &lsquo;<samp>\n</samp>&rsquo; 字符正右边的点）。下面的例子中条件表达式不为真：
</p>
<div class="example">
<pre class="example">if (&quot;line1\nLINE 2&quot; ~ /^L/) &hellip;
</pre></div>

<a name="index-_0024-_0028dollar-sign_0029_002c-regexp-operator"></a>
<a name="index-dollar-sign-_0028_0024_0029_002c-regexp-operator"></a>
</dd>
<dt><code>$</code></dt>
<dd><p>这个与 &lsquo;<samp>^</samp>&rsquo; 类似，但是匹配的是串尾。如 &lsquo;<samp>p$</samp>&rsquo; 匹配以 &lsquo;<samp>p</samp>&rsquo; 结尾的串。
&lsquo;<samp>$</samp>&rsquo; 是个锚定符，但是不匹配内嵌在字串中行尾（在 &lsquo;<samp>\n</samp>&rsquo; 按行符正前的位置）。下面的例子的条件返回非真。
</p>
<div class="example">
<pre class="example">if (&quot;line1\nLINE 2&quot; ~ /1$/) &hellip;
</pre></div>

<a name="index-_002e-_0028period_0029_002c-regexp-operator"></a>
<a name="index-period-_0028_002e_0029_002c-regexp-operator"></a>
</dd>
<dt><code>.</code> (period)</dt>
<dd><p>匹配单个字符，<em>包括</em>换行符。
如 &lsquo;<samp>.P</samp>&rsquo; 匹配任意字符后面跟 &lsquo;<samp>P</samp>&rsquo; 的任意字串。通过使用连接符，我们可以构造这样的正则表达式，如 &lsquo;<samp>U.A</samp>&rsquo;， 来匹配任意的三字符序列，其以 &lsquo;<samp>U</samp>&rsquo; 开头，以 &lsquo;<samp>A</samp>&rsquo; 结尾。
</p>
<a name="index-POSIX-awk_002c-period-_0028_002e_0029_002c-using"></a>
<p>在严格的 POSIX 模式（查看 <a href="#Options">命令行参数</a>）下，&lsquo;<samp>.</samp>&rsquo; 不匹配 <small>NUL</small>（空）字符，该字符所有的位都被置成了 0。
否则，<small>NUL</small> 就只是另一个字符。其他版本的 <code>awk</code> 可能不能匹配 <small>NUL</small> 字符。
</p>
<a name="index-_005b_005d-_0028square-brackets_0029_002c-regexp-operator"></a>
<a name="index-square-brackets-_0028_005b_005d_0029_002c-regexp-operator"></a>
<a name="index-bracket-expressions"></a>
<a name="index-character-sets_002c-See-Also-bracket-expressions"></a>
<a name="index-character-lists_002c-See-bracket-expressions"></a>
<a name="index-character-classes_002c-See-bracket-expressions"></a>
</dd>
<dt><code>[</code>&hellip;<code>]</code></dt>
<dd><p>这东西叫<em>方括号表达式</em>。<a name="DOCF20" href="#FOOT20">(20)</a>
它要匹配的是包含在方括号中的任意<em>一个</em>字符。
例如，&lsquo;<samp>[MVX]</samp>&rsquo; 匹配字符 &lsquo;<samp>M</samp>&rsquo;，&lsquo;<samp>V</samp>&rsquo; 或者 &lsquo;<samp>X</samp>&rsquo; 中的一个。可以在方括号中放入什么字符的完整讨论在 <a href="#Bracket-Expressions">使用方括号表达式</a>。
</p>
<a name="index-bracket-expressions_002c-complemented"></a>
</dd>
<dt><code>[^</code>&hellip;<code>]</code></dt>
<dd><p>这个是<em>方括号相反表达式</em>。在字符 &lsquo;<samp>[</samp>&rsquo; 后面的第一个字符<em>必须</em>是 &lsquo;<samp>^</samp>&rsquo;。
这里匹配<em>除了</em>方括号中列出的那些字符。例如，&lsquo;<samp>[^awk]</samp>&rsquo;，匹配不是 &lsquo;<samp>a</samp>&rsquo;，&lsquo;<samp>w</samp>&rsquo;，&lsquo;<samp>k</samp>&rsquo; 的字符。
</p>
<a name="index-_007c-_0028vertical-bar_0029"></a>
<a name="index-vertical-bar-_0028_007c_0029"></a>
</dd>
<dt><code>|</code></dt>
<dd><p>这个是<em>选择操作符</em>，用来指定其他选择。
&lsquo;<samp>|</samp>&rsquo; 在所有的正则表达式操作符中具有最低的优先级。
例如，&lsquo;<samp>^P|[aeiiouy]</samp>&rsquo; 要么匹配 &lsquo;<samp>^P</samp>&rsquo;，要么匹配 &lsquo;<samp>[aeiouy]</samp>&rsquo;。
就是说，匹配任意以 &lsquo;<samp>P</samp>&rsquo; 开头的字串，或者包含（在字串中的任一位置）英语元音字母的字串。
</p>
<p>选择操作会在正则表达式的两边取中最大可能性的一边。
</p>
<a name="index-_0028_0029-_0028parentheses_0029_002c-regexp-operator"></a>
<a name="index-parentheses-_0028_0029_002c-regexp-operator"></a>
</dd>
<dt><code>(</code>&hellip;<code>)</code></dt>
<dd><p>圆括号用来对正则表达式进行组合，如算法中的类似。他们可以将具有选择操作符 &lsquo;<samp>|</samp>&rsquo; 的正则表达式组合起来。
例如 &lsquo;<samp>@(samp|code)\{[^}]+\}]+\}</samp>&rsquo; 
能够匹配 &lsquo;<samp>@code{foo}</samp>&rsquo; 与 &lsquo;<samp>@samp{bar}</samp>&rsquo;。
（这里 Texinfo 的格式控制序列。 &lsquo;<samp>+</samp>&rsquo; 在本列表中后面解释。）
</p>
<a name="index-_002a-_0028asterisk_0029_002c-_002a-operator_002c-as-regexp-operator"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a-operator_002c-as-regexp-operator"></a>
</dd>
<dt><code>*</code></dt>
<dd><p>这个符号表达前面的正则表达式可以重复多次来找匹配。
例如 &lsquo;<samp>ph*</samp>&rsquo; 中将 &lsquo;<samp>*</samp>&rsquo; 符号放在前面的 &lsquo;<samp>h</samp>&rsquo; 后面，来查找一个 &lsquo;<samp>p</samp>&rsquo; 后面跟跟随任意多个 &lsquo;<samp>h</samp>&rsquo; 的匹配串。这也会匹配仅有 &lsquo;<samp>p</samp>&rsquo;，而后面没有 &lsquo;<samp>h</samp>&rsquo; 的情况。
</p>
<p>在理解 &lsquo;<samp>*</samp>&rsquo; 如何工作上面，有两个微妙的地方要注意。第一，&lsquo;<samp>*</samp>&rsquo; 只应用在其前面的单独正则表达式组件（例如，在 &lsquo;<samp>ph*</samp>&rsquo; 中，只作用于 &lsquo;<samp>h</samp>&rsquo;）。
要使 &lsquo;<samp>*</samp>&rsquo; 应用在一个更大的子表达式中，则使用括号：&lsquo;<samp>(ph)*</samp>&rsquo; 匹配 &lsquo;<samp>ph</samp>&rsquo;，&lsquo;<samp>phph</samp>&rsquo;，&lsquo;<samp>phphph</samp>&rsquo; 等等。
</p>
<p>第二，&lsquo;<samp>*</samp>&rsquo; 会查找尽可能多的重复。如果要匹配的文本为 &lsquo;<samp>phhhhhhhhhhhhhhooey</samp>&rsquo;，则 &lsquo;<samp>ph*</samp>&rsquo; 会匹配所有的 &lsquo;<samp>h</samp>&rsquo; 。
</p>
<a name="index-_002b-_0028plus-sign_0029_002c-regexp-operator"></a>
<a name="index-plus-sign-_0028_002b_0029_002c-regexp-operator"></a>
</dd>
<dt><code>+</code></dt>
<dd><p>本符号类似于 &lsquo;<samp>*</samp>&rsquo;，只是其前面的表达式至少要匹配一次。这就是说，&lsquo;<samp>wh+y</samp>&rsquo; 会匹配 &lsquo;<samp>why</samp>&rsquo;，以及 &lsquo;<samp>whhy</samp>&rsquo;，但是不会匹配 &lsquo;<samp>wy</samp>&rsquo;，而 &lsquo;<samp>wh*y</samp>&rsquo; 则会匹配所有的三个。
</p>
<a name="index-_003f-_0028question-mark_0029_002c-regexp-operator"></a>
<a name="index-question-mark-_0028_003f_0029_002c-regexp-operator"></a>
</dd>
<dt><code>?</code></dt>
<dd><p>这个符号类似于 &lsquo;<samp>*</samp>&rsquo;，只是其前面的表达式只能匹配要么一次，要么不匹配。例如，&lsquo;<samp>fe?d</samp>&rsquo; 匹配 &lsquo;<samp>fed</samp>&rsquo; 与 &lsquo;<samp>fd</samp>&rsquo;，而不是其他的什么。
</p>
<a name="index-interval-expressions_002c-regexp-operator"></a>
</dd>
<dt><code>{</code><var>n</var><code>}</code></dt>
<dt><code>{</code><var>n</var><code>,}</code></dt>
<dt><code>{</code><var>n</var><code>,</code><var>m</var><code>}</code></dt>
<dd><p>在花括号中与其中的一个或者两个数值表示一种<em>区间表达式</em>。
如果只有一个数值在花括号中，则前面的表达式重复 <var>n</var> 次。
如果有两个数值，并以逗号分隔，则前面的表达式重复 <var>n</var> 到 <var>m</var> 次。
如果只有一个数值，后面跟一个逗号，则前面的表达式至少要重复 <var>n</var> 次。
</p>
<dl compact="compact">
<dt><code>wh{3}y</code></dt>
<dd><p>匹配 &lsquo;<samp>whhhy</samp>&rsquo;， 但不匹配 &lsquo;<samp>why</samp>&rsquo; or &lsquo;<samp>whhhhy</samp>&rsquo; 。
</p>
</dd>
<dt><code>wh{3,5}y</code></dt>
<dd><p>只匹配 &lsquo;<samp>whhhy</samp>&rsquo;，&lsquo;<samp>whhhhy</samp>&rsquo;，或者 &lsquo;<samp>whhhhhy</samp>&rsquo; 。
</p>
</dd>
<dt><code>wh{2,}y</code></dt>
<dd><p>匹配 &lsquo;<samp>whhy</samp>&rsquo;，&lsquo;<samp>whhhy</samp>&rsquo;，等等。
</p></dd>
</dl>

<a name="index-POSIX-awk_002c-interval-expressions-in"></a>
<p>区间表达式在 <code>awk</code> 上历来不受支持。后面成为 POSIX 标准的一部分，使得 <code>awk</code> 与 <code>egrep</code> 之间相互保持一致。
</p>
<a name="index-gawk_002c-interval-expressions-and"></a>
<p>最开始时，由于旧的程序可能在正则表达式常量中使用 &lsquo;<samp>{</samp>&rsquo; 与 &lsquo;<samp>}</samp>&rsquo;，<code>gawk</code> 因此在正则表达式中<em>不</em>匹配区间表达式。
</p>
<p>但是从 4.0 开始，<code>gawk</code> 开始默认匹配区间表达式。这是因为与 POSIX 标准兼容，相比于与旧的程序兼容，前者更为重要。
</p>
<p>对于在正则表达式中使用 &lsquo;<samp>{</samp>&rsquo; 与 &lsquo;<samp>}</samp>&rsquo; 的程序，好的实践是将他们用反斜杠进行转义。
这样的话，你的正则表达式就是有效的，并在任何其他的版本中可用。<a name="DOCF21" href="#FOOT21">(21)</a>
</p>
<p>最后，当 &lsquo;<samp>{</samp>&rsquo; 与 &lsquo;<samp>}</samp>&rsquo; 出现在正则表达式常量中，但不是以一种可以被解释为区间表达式的方式（如 <code>/q{a}/</code>），那么他们就只表示自己。
</p></dd>
</dl>

<a name="index-precedence_002c-regexp-operators"></a>
<a name="index-regular-expressions_002c-operators_002c-precedence-of"></a>
<p>在正则表达式中，&lsquo;<samp>*</samp>&rsquo;，&lsquo;<samp>+</samp>&rsquo; 以及 &lsquo;<samp>?</samp>&rsquo; 操作符，包括花括号 &lsquo;<samp>{</samp>&rsquo; 与 &lsquo;<samp>}</samp>&rsquo;，具有最高的优先级，
然后是连接操作符，最后才是 &lsquo;<samp>|</samp>&rsquo;，在数学上，括号可以改变操作符的组合方式。
</p>
<a name="index-POSIX-awk_002c-regular-expressions-and"></a>
<a name="index-gawk_002c-regular-expressions_002c-precedence"></a>
<p>在 POSIX <code>awk</code> 中与 <code>gawk</code> 中，&lsquo;<samp>*</samp>&rsquo;，&lsquo;<samp>+</samp>&rsquo; 以及 &lsquo;<samp>?</samp>&rsquo; 操作符，如果在正则表达式中，它们前面没有任何字符了，那么它就代表它们自己。
如 <code>/+/</code> 匹配一个字面加号。但是，很多其他的 <code>awk</code> 版本会把这样的用法视为语法错误。
</p>
<p>如果 <code>gawk</code> 在兼容模式下（查看 <a href="#Options">命令行参数</a>），区间表达式在正则表达式中是不可用的。
</p>
<hr>
<a name="Bracket-Expressions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Operators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Leftmost-Longest" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8ae_0096_00b9ae_008b_00acaa_008f_00b7e_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h2 class="section">3.4 使用方括号表达式</h2>
<a name="index-bracket-expressions-1"></a>
<a name="index-bracket-expressions_002c-range-expressions"></a>
<a name="index-range-expressions-_0028regexps_0029"></a>
<a name="index-character-lists-in-regular-expression"></a>

<p>如前面所提到的，方括号表达式匹配在括号中列出的任意字符。
</p>
<p>在方括号表达式内，一个<em>范围表达式</em>由两个用连字符分隔的字符组成。它匹配以系统的本地字符集排序，并处于这两个字符间的符号。如 &lsquo;<samp>[0-9]</samp>&rsquo; 与 &lsquo;<samp>[0123456789]</samp>&rsquo; 等同。
（查看 <a href="#Ranges-and-Locales">正则表达式范围与本地语言设置：又臭又长陈年旧事</a>，对 POSIX 标准与 <code>gawk</code> 变化过程的解释，这主要是有一些历史兴趣所在。）
</p>
<p><a href="http://www.unicode.org">Unicode 字符编码标准</a> 的流行，带来了一个新的小问题。方括号表达式内使用的八进制和十六进制的转移序列，只能表示单字节的字符（编码范围在 0-256 之间的字符）。为了匹配编码范围大于 256 的字符，请直接输入多字节字符的编码。
</p>
<a name="index-_005c-_0028backslash_0029_002c-in-bracket-expressions"></a>
<a name="index-backslash-_0028_005c_0029_002c-in-bracket-expressions"></a>
<a name="index-_005e-_0028caret_0029_002c-in-bracket-expressions"></a>
<a name="index-caret-_0028_005e_0029_002c-in-bracket-expressions"></a>
<a name="index-_002d-_0028hyphen_0029_002c-in-bracket-expressions"></a>
<a name="index-hyphen-_0028_002d_0029_002c-in-bracket-expressions"></a>
<p>为了包括这些字符 &lsquo;<samp>\</samp>&rsquo;，&lsquo;<samp>]</samp>&rsquo;，&lsquo;<samp>-</samp>&rsquo;，或者 &lsquo;<samp>^</samp>&rsquo; 在方括号表达式中，将在它们之前使用 &lsquo;<samp>\</samp>&rsquo;，如：
</p>
<div class="example">
<pre class="example">[d\]]
</pre></div>

<p>会匹配 &lsquo;<samp>d</samp>&rsquo; 或者 &lsquo;<samp>]</samp>&rsquo;，另外，如果你将 &lsquo;<samp>]</samp>&rsquo; 就放在开方括号 &lsquo;<samp>[</samp>&rsquo; 的后面，则闭方括号会以其字面字符对待并进行匹配。
</p>
<a name="index-POSIX-awk_002c-bracket-expressions-and"></a>
<a name="index-Extended-Regular-Expressions-_0028EREs_0029"></a>
<a name="index-EREs-_0028Extended-Regular-Expressions_0029"></a>
<a name="index-egrep-utility"></a>
<p>对于在方括号中的 &lsquo;<samp>\</samp>&rsquo; 表达式对待上，与其他的 <code>awk</code> 实现是兼容的，也是 POSIX 标准所要求的。
在 <code>awk</code> 中的正则表达式，是 POSIX EREs（扩展正则表达式，Extended Regular Expressions）规范的一个超集。
POSIX 的扩展正则表达式基于传统的 <code>egrep</code> 工具所接受的正则表达式。
</p>
<a name="index-bracket-expressions_002c-character-classes"></a>
<a name="index-POSIX-awk_002c-bracket-expressions-and_002c-character-classes"></a>
<p><em>字符类</em>是在 POSIX 标准中引入的一个特性。字符类是一种特殊的符号，用其来表述具有特定属性的一类字符的列表，但是实际的字符由于国家的不同，以及/或者字符集的不同而不同。如，对于字母类的符号，在美国与法国之间就不一样。
</p>
<p>正则表达式的字符类，只有在一个方括号表达式中的方括号<em>内部</em>才会有效。
字符类由 &lsquo;<samp>[:</samp>&rsquo;，一个代表类的关键字，以及 &lsquo;<samp>:]</samp>&rsquo; 组成，<a href="#table_002dchar_002dclasses">Table 3.1</a> 列出了由 POSIX 标准定义的字符类。
</p>
<div class="float"><a name="table_002dchar_002dclasses"></a>

<table>
<thead><tr><th width="15%">类</th><th width="85%">含义</th></tr></thead>
<tr><td width="15%"><code>[:alnum:]</code></td><td width="85%">字母数字字符</td></tr>
<tr><td width="15%"><code>[:alpha:]</code></td><td width="85%">字母字符</td></tr>
<tr><td width="15%"><code>[:blank:]</code></td><td width="85%">空格与 TAB 字符</td></tr>
<tr><td width="15%"><code>[:cntrl:]</code></td><td width="85%">控制字符</td></tr>
<tr><td width="15%"><code>[:digit:]</code></td><td width="85%">数字字符</td></tr>
<tr><td width="15%"><code>[:graph:]</code></td><td width="85%">可见可打印的字符（空格是可打印的，但是是不可见的，而 &lsquo;<samp>a</samp>&rsquo; 则兼而有之）</td></tr>
<tr><td width="15%"><code>[:lower:]</code></td><td width="85%">小写字母字符</td></tr>
<tr><td width="15%"><code>[:print:]</code></td><td width="85%">可打印字符（那些不是控制字符的字符）</td></tr>
<tr><td width="15%"><code>[:punct:]</code></td><td width="85%">标点字符（那些不是字母，数字，控制以及空格字符的字符）</td></tr>
<tr><td width="15%"><code>[:space:]</code></td><td width="85%">空格字符（如空格，TAB，以及回档，等）</td></tr>
<tr><td width="15%"><code>[:upper:]</code></td><td width="85%">字母的大写字符</td></tr>
<tr><td width="15%"><code>[:xdigit:]</code></td><td width="85%">十六进制的数字的字符</td></tr>
</table>
</div><p><strong>Table 3.1: POSIX 字符类
</strong>
</p>
<p>例如，在 POSIX 标准前，你必须用这样的表达式 <code>/[A-Za-z0-9]/</code> 来匹配字母数字字符。
如果你的字符集有另一套字母字符，这个就不会匹配它们。
通过 POSIX 的字符类，你可写成这样 <code>/[[:alnum:]]/</code> 来匹配你的字符集中的字母与数字。
有一些工具的正则表达式提供了一种非标准的 &lsquo;<samp>[:ascii:]</samp>&rsquo; 字符类，<code>awk</code> 则没有提供。但是，你可以这样 &lsquo;<samp>[\x00-\x7F]</samp>&rsquo; 来模拟这种结构。
这会匹配数值上为 0 到 127 之间的，定义在 ASCII 字符集中的字符。利用其反的字符列表（&lsquo;<samp>[^\x00-\x7F]</samp>&rsquo;）可以匹配任何个不在 ASCII 中的单字节字符。
</p>
<a name="index-bracket-expressions_002c-collating-elements"></a>
<a name="index-bracket-expressions_002c-non_002dASCII"></a>
<a name="index-collating-elements"></a>
<p>有两个额外的序列可以出现在方括号表达式中，这些用来应用到非 ASCII 字符集中，这些字符集有的单符号（称为<em>集合元素</em>）可以由多个字符来表示。
它们也可以有几个字符是等同的，以进行<em>校对</em>，排序等目的。（如在法语中，普通字母 &ldquo;e&rdquo; 有一个重音字母 &ldquo;&egrave;&rdquo; 是等同的。）这些序列是：
</p>
<dl compact="compact">
<dd><a name="index-bracket-expressions_002c-collating-symbols"></a>
<a name="index-collating-symbols"></a>
</dd>
<dt>集合符号</dt>
<dd><p>在 &lsquo;<samp>[.</samp>&rsquo; 与 &lsquo;<samp>.]</samp>&rsquo; 之间的，多字符集合元素。例如，如果 &lsquo;<samp>ch</samp>&rsquo; 是一个集合元素，这样 &lsquo;<samp>[[.ch.]]</samp>&rsquo; 就是可以匹配这样的集合元素的正则表达式。而 &lsquo;<samp>[ch]</samp>&rsquo; 则是匹配 &lsquo;<samp>c</samp>&rsquo; 或者 &lsquo;<samp>h</samp>&rsquo; 的正则表达式。
</p>
<a name="index-bracket-expressions_002c-equivalence-classes"></a>
</dd>
<dt>等同类</dt>
<dd><p>特定于字符集的用于命名等同字符列表。其名字由 &lsquo;<samp>[=</samp>&rsquo; 与 &lsquo;<samp>=]</samp>&rsquo; 包含。
如名字 &lsquo;<samp>e</samp>&rsquo; 可以用来表示所有的 &ldquo;e,&rdquo; &ldquo;&ecirc;,&rdquo; &ldquo;&egrave;,&rdquo; 与 &ldquo;&eacute;.&rdquo;。
在这种情况下，&lsquo;<samp>[[=e=]]</samp>&rsquo; 就是用来匹配 &lsquo;<samp>e</samp>&rsquo;，&lsquo;<samp>&ecirc;</samp>&rsquo;，&lsquo;<samp>&eacute;</samp>&rsquo;，或者 &lsquo;<samp>&egrave;</samp>&rsquo; 的正则表达式。
</p></dd>
</dl>

<p>这个特性在那些非英语的字符集中非常有用。
</p>
<a name="index-internationalization_002c-localization_002c-character-classes"></a>
<a name="index-gawk_002c-character-classes-and"></a>
<a name="index-POSIX-awk_002c-bracket-expressions-and_002c-character-classes-1"></a>
<blockquote>
<p><b>注意:</b> <code>gawk</code> 当前所使用的一些正则表达式匹配库，只能识别 POSIX 字符类；它们无法识别集合符号或者等同类。
</p></blockquote>

<p>在一个方括号表达式内，一个开方括号（&lsquo;<samp>[</samp>&rsquo;）作为它本身来使用，而不表示一个字符类，集合元素或者等同类。
&lsquo;<samp>.</samp>&rsquo; 和 &lsquo;<samp>*</samp>&rsquo; 同理。
</p>
<hr>
<a name="Leftmost-Longest"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Bracket-Expressions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Computed-Regexps" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008c_00b9e_0085_008daa_00a4_009aaa_00b0_0091i_00bc_009f"></a>
<h2 class="section">3.5 匹配多少？</h2>

<a name="index-regular-expressions_002c-leftmost-longest-match"></a>
<p>考虑下面的例子：
</p>
<div class="example">
<pre class="example">echo aaaabcd | awk '{ sub(/a+/, &quot;&lt;A&gt;&quot;); print }'
</pre></div>

<p>在这个例子中，我们使用 <code>sub()</code> 函数来改变输入记录。
（<code>sub()</code> 用第二个参数替换，任意匹配第一个参数的文本内容，查看 <a href="#String-Functions">字串操作函数</a>。）
这里，正则表达式 <code>/a+/</code> 表示“一个或者多个 &lsquo;<samp>a</samp>&rsquo; 字符”，并将其替换为文件 &lsquo;<samp>&lt;A&gt;</samp>&rsquo; 。
</p>
<p>输入中包括 4 个 &lsquo;<samp>a</samp>&rsquo; 字符。<code>awk</code>（以及 POSIX）正则表达式总是匹配最左边<em>最长</em>的输入字符序列。
因此，所有的 4 个 &lsquo;<samp>a</samp>&rsquo; 字符都将被 &lsquo;<samp>&lt;A&gt;</samp>&rsquo; 替换。
</p>
<div class="example">
<pre class="example">$ <kbd>echo aaaabcd | awk '{ sub(/a+/, &quot;&lt;A&gt;&quot;); print }'</kbd>
-| &lt;A&gt;bcd
</pre></div>

<p>对于简单的匹配/不匹配的测试，这就并不太重要，但是当执行文本匹配与替换时，
如 <code>match()</code>，<code>sub()</code>，<code>gsub()</code> 与 <code>gensub()</code> 等函数所执行的，这个特点就非常重要了。
理解这个原则对于基本正则表达式分隔的记录也非常重要（查看 <a href="#Records">输入如何拆分为记录</a>，也可查看 <a href="#Field-Separators">指定记录如何进行分隔</a>）。
</p>
<hr>
<a name="Computed-Regexps"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Leftmost-Longest" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#GNU-Regexp-Operators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8aa_008a_00a8ae_0080_0081ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h2 class="section">3.6 使用动态正则表达式</h2>

<a name="index-regular-expressions_002c-computed"></a>
<a name="index-regular-expressions_002c-dynamic"></a>
<a name="index-_007e-_0028tilde_0029_002c-_007e-operator-1"></a>
<a name="index-tilde-_0028_007e_0029_002c-_007e-operator-1"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-1"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-1"></a>
<p>在 &lsquo;<samp>~</samp>&rsquo; 或者 &lsquo;<samp>!~</samp>&rsquo; 操作符的右手边，不一定需要一个正则表达式常量（例如用斜杠分隔这些的字串），也可以是任意的表达式。
在必要的情况下，表达式会被求值，或者转换为字串；这个字串即被用于当做正则表达式。
以这种方式计算的表达式称为<em>动态正则表达式</em>或者<em>计算型正则表达式</em>：
</p>
<div class="example">
<pre class="example">BEGIN { digits_regexp = &quot;[[:digit:]]+&quot; }
$0 ~ digits_regexp    { print }
</pre></div>

<p>上面的例子中，将 <code>digits_regexp</code> 设置成描述一个或者多个数字的正则表达式，并测试输入记录是否匹配这个表达式。
</p>
<blockquote>
<p><b>提示:</b> 当使用 &lsquo;<samp>~</samp>&rsquo; 与 &lsquo;<samp>!~</samp>&rsquo; 操作符时，要了解使用这样的用斜杠表式的正则表达式字串常量与用双引号括起来的正则表达式之间的不同。
如果你准备使用字串常量，你就必须得理解字串实际上会被扫描两遍；第一次是 <code>awk</code> 读取你的程序的时候，第二次是当要执行与操作符左边的字串与右边的模式符进行匹配的时候。
这对于所有求值为字串的表达式都是如此（如前例中的 <code>digits_regexp</code>），而并不止是字串常量才如此。
</p></blockquote>

<a name="index-regexp-constants_002c-slashes-vs_002e-quotes"></a>
<a name="index-_005c-_0028backslash_0029_002c-in-regexp-constants"></a>
<a name="index-backslash-_0028_005c_0029_002c-in-regexp-constants"></a>
<a name="index-_0022-_0028double-quote_0029_002c-in-regexp-constants"></a>
<a name="index-double-quote-_0028_0022_0029_002c-in-regexp-constants"></a>
<p>字串会被扫描两次会有什么不同呢？答案是与转义序列有关，尤其是反斜杠。为了将反斜杠加入到正则表达式中的字串，你需要输入两个反斜杠。
</p>
<p>例如，<code>/\*/</code> 是字符 &lsquo;<samp>*</samp>&rsquo; 的正则表达式。只需要一个反斜杠。如果你要在字串在实现相同的事情，你就得输入 <code>&quot;\\*&quot;</code>。
第一个反斜杠转义第二个反斜杠，因此实际的字串才包含两个字符，即 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>*</samp>&rsquo; 。
</p>
<a name="index-troubleshooting_002c-regexp-constants-vs_002e-string-constants"></a>
<a name="index-regexp-constants_002c-vs_002e-string-constants"></a>
<a name="index-string-constants_002c-vs_002e-regexp-constants"></a>
<p>假设你既使用正则表达式常量与字串常量来描述正则表达式，你该如何来选择使用？答案是正则表达式常量，有几个原因：
</p>
<ul>
<li>
字串常量写起来更复杂，读起来也更难。使用正则表达式常量使你的程序少出错。不理解两种常量之间的差异常常是错误之源。

</li><li>
用正则表大式常量更加高效。<code>awk</code> 会注意到你提供正则表达式，会将它存成能够更加高效地进行模式匹配的形式。当使用字串常量，<code>awk</code> 则首先需要将其转换成内部形式然后才执行模式匹配。

</li><li>
使用正则表达式常量是一种更好的形式，能够更容易看清你要进行的正则表达式匹配。
</li></ul>

<a name="index-sidebar_002c-aa_009c_00a8aa_008a_00a8ae_0080_0081ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fa_00b8_00adc_009a_0084ae_0096_00b9ae_008b_00acaa_008f_00b7e_00a1_00a8e_00be_00beaa_00bc_008fa_00b8_00ada_00bd_00bfc_0094_00a8-_005cn"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>在动态正则表达式中的方括号表达式中使用 <code>\n</code> </b>
</p>

<a name="index-regular-expressions_002c-dynamic_002c-with-embedded-newlines"></a>
<a name="index-newlines_002c-in-dynamic-regexps"></a>

<p>一些旧版本的 <code>awk</code> 不能够在动态正则表达式中的方括号表达式里使用换行符 &lsquo;<samp>\n</samp>&rsquo;：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '$0 ~ &quot;[ \t\n]&quot;'</kbd>
error--&gt; awk: newline in character class [
error--&gt; ]...
error--&gt;  source line number 1
error--&gt;  context is
error--&gt;        $0 ~ &quot;[ &gt;&gt;&gt;  \t\n]&quot; &lt;&lt;&lt;
</pre></div>

<a name="index-newlines_002c-in-regexp-constants"></a>
<p>但是在正则表达式常量中却没有问题：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '$0 ~ /[ \t\n]/'</kbd>
<kbd>here is a sample line</kbd>
-| here is a sample line
<kbd>Ctrl-d</kbd>
</pre></div>

<p><code>gawk</code> 没有这个问题，并且在实践中也很少出现，但是在后面的使用中，则值得注意一下。
</p></td></tr></table>

<hr>
<a name="GNU-Regexp-Operators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Computed-Regexps" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Case_002dsensitivity" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0089_00b9aa_00ae_009aa_00ba_008e-gawk-c_009a_0084ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fae_0093_008da_00bd_009cc_00ac_00a6"></a>
<h2 class="section">3.7 特定于 <code>gawk</code> 的正则表达式操作符</h2>


<a name="index-regular-expressions_002c-operators_002c-gawk"></a>
<a name="index-gawk_002c-regular-expressions_002c-operators"></a>
<a name="index-operators_002c-GNU_002dspecific"></a>
<a name="index-regular-expressions_002c-operators_002c-for-words"></a>
<a name="index-word_002c-regexp-definition-of"></a>
<p>GNU 软件在处理正则表达式时提供了许多额外的正则操作符。
在本小节中列出的操作符是 <code>gawk</code> 特有的，他们在其他的 <code>awk</code> 中是没有的。这些操作符多数是用来处理字（单词）匹配。
对于我们的目的而言，一个<em>单词</em>就是一个或者多个字母、数字或者下划线（&lsquo;<samp>_</samp>&rsquo;）的连续序列：
</p>
<dl compact="compact">
<dd><a name="index-backslash-_0028_005c_0029_002c-_005cs-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005cs-operator-_0028gawk_0029"></a>
</dd>
<dt><code>\s</code></dt>
<dd><p>匹配任意的空白字符，你可看成是 &lsquo;<samp>[[:space:]]</samp>&rsquo; 缩写。
</p>
<a name="index-backslash-_0028_005c_0029_002c-_005cS-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005cS-operator-_0028gawk_0029"></a>
</dd>
<dt><code>\S</code></dt>
<dd><p>匹配任意非空白字符，可以看成是 &lsquo;<samp>[^[:space:]]</samp>&rsquo; 的缩写。
</p>
<a name="index-backslash-_0028_005c_0029_002c-_005cw-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005cw-operator-_0028gawk_0029"></a>
</dd>
<dt><code>\w</code></dt>
<dd><p>匹配任意组成单词的字符，也就是匹配任意的字母，数字或者下划线。可以看成为 &lsquo;<samp><span class="nolinebreak">[[:alnum:]_]</span></samp>&rsquo; 的缩写。
</p>
<a name="index-backslash-_0028_005c_0029_002c-_005cW-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005cW-operator-_0028gawk_0029"></a>
</dd>
<dt><code>\W</code></dt>
<dd><p>匹配任意的非组成单词的字符，可以看成是 &lsquo;<samp><span class="nolinebreak">[^[:alnum:]_]</span></samp>&rsquo; 的缩写。
</p>
<a name="index-backslash-_0028_005c_0029_002c-_005c_003c-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005c_003c-operator-_0028gawk_0029"></a>
</dd>
<dt><code>\&lt;</code></dt>
<dd><p>匹配单词开始的空串，如 <code>/\&lt;away/</code> 匹配 &lsquo;<samp>away</samp>&rsquo;，但是不匹配 &lsquo;<samp>stowaway</samp>&rsquo; 。
</p>
<a name="index-backslash-_0028_005c_0029_002c-_005c_003e-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005c_003e-operator-_0028gawk_0029"></a>
</dd>
<dt><code>\&gt;</code></dt>
<dd><p>匹配单词后的空串，如 <code>/stow\&gt;/</code> 匹配 &lsquo;<samp>stow</samp>&rsquo;，但是不匹配 &lsquo;<samp>stowaway</samp>&rsquo; 。
</p>
<a name="index-backslash-_0028_005c_0029_002c-_005cy-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005cy-operator-_0028gawk_0029"></a>
<a name="index-word-boundaries_002c-matching"></a>
</dd>
<dt><code>\y</code></dt>
<dd><p>匹配单词两边的空串（如单词的边界）。如 &lsquo;<samp>\yballs?\y</samp>&rsquo; 匹配 &lsquo;<samp>ball</samp>&rsquo; 或者 &lsquo;<samp>balls</samp>&rsquo;，作为单独的单词。
</p>
<a name="index-backslash-_0028_005c_0029_002c-_005cB-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005cB-operator-_0028gawk_0029"></a>
</dd>
<dt><code>\B</code></dt>
<dd><p>匹配单词中任意两个组成单词字符间的空串，例如 <code>/\Brat\B/</code> 匹配 &lsquo;<samp>crate</samp>&rsquo;，但是不匹配 &lsquo;<samp>dirty rat</samp>&rsquo; 。&lsquo;<samp>\B</samp>&rsquo; 的反面实际就是 &lsquo;<samp>\y</samp>&rsquo; 。
</p></dd>
</dl>

<a name="index-buffers_002c-operators-for"></a>
<a name="index-regular-expressions_002c-operators_002c-for-buffers"></a>
<a name="index-operators_002c-string_002dmatching_002c-for-buffers"></a>
<p>还有还两个操作符用在缓存中，在 Emacs 里，<em>缓存</em>很自然的就是一个 Emacs 缓存。在其他的 GNU 程序中，包括 <code>gawk</code>，可以认为整个要匹配的字串就是一个缓存。这两个操作符是：
</p>
<dl compact="compact">
<dt><code>\`</code></dt>
<dd><a name="index-backslash-_0028_005c_0029_002c-_005c_0060-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005c_0060-operator-_0028gawk_0029"></a>
<p>匹配缓存（字串）的开始处的空串。
</p>
<a name="index-backslash-_0028_005c_0029_002c-_005c_0027-operator-_0028gawk_0029"></a>
<a name="index-_005c-_0028backslash_0029_002c-_005c_0027-operator-_0028gawk_0029"></a>
</dd>
<dt><code>\'</code></dt>
<dd><p>匹配缓存（字串）的结束处的窗口。
</p></dd>
</dl>

<a name="index-_005e-_0028caret_0029_002c-regexp-operator-1"></a>
<a name="index-caret-_0028_005e_0029_002c-regexp-operator-1"></a>
<a name="index-_003f-_0028question-mark_0029_002c-regexp-operator-1"></a>
<a name="index-question-mark-_0028_003f_0029_002c-regexp-operator-1"></a>
<p>由于 &lsquo;<samp>^</samp>&rsquo; 与 &lsquo;<samp>$</samp>&rsquo; 总是会匹配字串的开头与结尾，这个操作符没有给 <code>awk</code> 带来什么新的功能。提供这些操作符只是为了与其他的 GNU 软件保持兼容性。
</p>
<a name="index-gawk_002c-word_002dboundary-operator"></a>
<a name="index-word_002dboundary-operator-_0028gawk_0029"></a>
<a name="index-operators_002c-word_002dboundary-_0028gawk_0029"></a>
<p>在其他的 GNU 软件中，单词边界操作符是 &lsquo;<samp>\b</samp>&rsquo; 。但是这个与 <code>awk</code> 语言定义 &lsquo;<samp>\b</samp>&rsquo; 是一个退格有冲突，因此 <code>gawk</code> 使用了一个不同的字母。一个可选择的方法就是在 GNU 操作符中必须输入双反斜杠，但是这个用来起令人疑惑。当前的方法就是在使用 &lsquo;<samp>\y</samp>&rsquo;，这样 GNU 中的 &lsquo;<samp>\b</samp>&rsquo; 在两个恶棍中就出现得少一些。
</p>
<a name="index-regular-expressions_002c-gawk_002c-command_002dline-options"></a>
<a name="index-gawk_002c-command_002dline-options_002c-and-regular-expressions"></a>
<p>有几个命令行参数（查看 <a href="#Options">命令行参数</a>）可以控制 <code>gawk</code> 如何来解释正则表达式中的字符：
</p>
<dl compact="compact">
<dt>No options</dt>
<dd><p>在默认情况下，<code>gawk</code> 会提供所有的 POSIX 正则表达式的设施，
以及
前面所描述的那些 GNU 正则表达式操作符。
那些在 <a href="#Regexp-Operators">正则表达式操作符</a> 描述的 GNU 正则表达式操作符。
</p>
</dd>
<dt><code>--posix</code></dt>
<dd><p>只匹配 POSIX 正则表达式，GNU 操作符没有特殊含义（如 &lsquo;<samp>\w</samp>&rsquo; 就是匹配字面的 &lsquo;<samp>w</samp>&rsquo;）。区间表达式也可用。
</p>
<a name="index-Brian-Kernighan_0027s-awk-2"></a>
</dd>
<dt><code>--traditional</code></dt>
<dd><p>匹配传统的 <code>awk</code> 正则表达式。
GNU 操作符没有特殊含义，并且区间表达式也不可用。因为 BWK <code>awk</code> 支持它们，
POSIX 的字符类（&lsquo;<samp>[[:alnum:]]</samp>&rsquo; 等）可用。由八进制与十六进制描述的转义字符序列会按字面处理，就算它们以正则表达式的元字符出现。
</p>
</dd>
<dt><code>--re-interval</code></dt>
<dd><p>如果指定了 &lsquo;<samp>--traditional</samp>&rsquo;，则可以在正则表达式中使用区间表达式。否则区间表达式是默认可用的。
</p></dd>
</dl>

<hr>
<a name="Case_002dsensitivity"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#GNU-Regexp-Operators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008c_00b9e_0085_008dae_0097_00b6c_009a_0084aa_00a4_00a7aa_00b0_008faa_0086_0099"></a>
<h2 class="section">3.8 匹配时的大小写</h2>

<a name="index-regular-expressions_002c-case-sensitivity"></a>
<a name="index-case-sensitivity_002c-regexps-and"></a>
<p>大小写在正则表达式中非常重要，无论是匹配正常字符（如非元字符）还是在方括号表达式中。因此 &lsquo;<samp>w</samp>&rsquo; 只匹配小写的 &lsquo;<samp>w</samp>&rsquo;，而不是大写的 &lsquo;<samp>W</samp>&rsquo; 。
</p>
<p>不区分大小写的最简单的方法就是使用方括号表达式——如 &lsquo;<samp>[Ww]</samp>&rsquo;。
但是要经常使用的时候就有点烦了，也使得正则表达式更难读。有可以有两个其他方法可以选择。
</p>
<p>第一种方法，就是在要进行不区分大小写匹配的地方，用内建的函数 tolower() 或者 toupper() （当然还没讨论过；可以查看 <a href="#String-Functions">字串操作函数</a>）
将其转换成同一种大小写。例如：
</p>
<div class="example">
<pre class="example">tolower($1) ~ /foo/  { &hellip; }
</pre></div>

<p>将第一个域转换成小写，然后对其进行匹配。这个在 POSIX 兼容的 <code>awk</code> 中是可以使用的。
</p>
<a name="index-gawk_002c-regular-expressions_002c-case-sensitivity"></a>
<a name="index-case-sensitivity_002c-gawk"></a>
<a name="index-differences-in-awk-and-gawk_002c-regular-expressions"></a>
<a name="index-_007e-_0028tilde_0029_002c-_007e-operator-2"></a>
<a name="index-tilde-_0028_007e_0029_002c-_007e-operator-2"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-2"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-2"></a>
<a name="index-IGNORECASE-variable_002c-with-_007e-and-_0021_007e-operators"></a>
<a name="index-gawk_002c-IGNORECASE-variable-in"></a>
<p>另外一个方法，只在 <code>gawk</code> 中使用，就是设置变量 <code>IGNORECASE</code> 为非零值
（查看 <a href="#Built_002din-Variables">预定义变量</a>）。
当 <code>IGNORECASE</code> 为非零时，<em>所有</em>的正则表达式以字串操作都不区分大小写。
</p>
<p>动态地改变 <code>IGNORECASE</code> 的值，就可以控制程序运行时的大小写处理方式。大小写默认情况下是区分的，
因为 <code>IGNORECASE</code> （像其他大多数变量一样）被初始化为0：
</p>
<div class="example">
<pre class="example">x = &quot;aB&quot;
if (x ~ /ab/) &hellip;   # this test will fail

IGNORECASE = 1
if (x ~ /ab/) &hellip;   # now it will succeed
</pre></div>

<p>一般情况下，你不能通过 <code>IGNORECASE</code> 来使特定的规则是大小写不区分的，而其他的规则则是区分的。
因为没有直接的方法来设置 <code>IGNORECASE</code> 以针对特定的规则。
<a name="DOCF22" href="#FOOT22">(22)</a>
如果要这么做，要么使用方括号表达式或者使用 tolower() 方法，但是你可以对 <code>IGNORECASE</code> 所做的事情，就是动态地为所有规则开关大小写区分功能。
</p>
<p><code>IGNORECASE</code> 也可以在命令行上设置，或者在 <code>BEGIN</code> 规则中设置
（查看 <a href="#Other-Arguments">其他命令行参数</a>，也可以参考 <a href="#Using-BEGIN_002fEND">开始与结束动作</a>）。
在命令行上设置 <code>IGNORECASE</code> 使得程序不用更改就可以进行不区分大小写的匹配。
</p>
<p>在多字节字符的区域中，大小写字符是等同的，则是根据它们在字符集中的宽字符值来进行测试的。
否则字符就是按照 ISO-8859-1（ISO Latin-1）字符集进行测试的。
这个字符集是传统 128 ASCII 字符的超集，它也提供了许多的字符可用于欧洲语言。 
<a name="DOCF23" href="#FOOT23">(23)</a>
</p>
<p>如果 <code>gawk</code> 是在兼容模式中，则 <code>IGNORECASE</code> 的值不会有影响（查看 <a href="#Options">命令行参数</a>）。大小写在兼容模式下都是区分的。
</p>
<hr>
<a name="Regexp-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Case_002dsensitivity" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-10"></a>
<h2 class="section">3.9 总结</h2>

<ul>
<li>
正则表达式描述了要被匹配的字串集。在 <code>awk</code> 中，正则表达式常量写成这样：<code>/</code>&hellip;<code>/</code>。

</li><li>
正则表达式常量可以在模式与条件表达式中单独使用，或者利用 &lsquo;<samp>~</samp>&rsquo; 与 &lsquo;<samp>!~</samp>&rsquo; 操作符使其成为匹配表达式的一部分。

</li><li>
转义序列可以让你输入不可打印字符，也可以让你将正则表达式的元字符作为字面字符在表达式中进行匹配。

</li><li>
正则表达式操作符可以提供组合，选择以及重复功能。

</li><li>
方括号表达式使你方便地指定一个字符集合，在正则表达式中的某个点进行匹配。在方括号表达式中。POSIX 字符类可以指定一组区域字符无关的字符。

</li><li>
正则表达式会匹配最左最长的字串。这对于你需要了解匹配的区域范围时是有意义的，像文件替换，以及记录分隔符是正则表达式这种情况。

</li><li>
匹配表达式可以使用动态的正则表达式（如字串值按照正则表达式对待）。

</li><li>
<code>gawk</code> 的 <code>IGNORECASE</code> 变量可以让你控制正则表达式匹配时的大小区分情况。在其他版本的 <code>awk</code> 中，使用 tolower() 或者 toupper ()。

</li></ul>


<hr>
<a name="Reading-Files"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Regexp" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Records" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_00bbaa_008f_0096e_00be_0093aa_0085_00a5ae_0096_0087a_00bb_00b6"></a>
<h1 class="chapter">4 读取输入文件</h1>

<a name="index-reading-input-files"></a>
<a name="index-input-files_002c-reading"></a>
<a name="index-input-files"></a>
<a name="index-FILENAME-variable"></a>
<p>在典型的 <code>awk</code> 程序中，<code>awk</code> 要么从标准输入（默认情况下，就是键盘，但是常常是其他程序命令的管道输入），
要么从你在 <code>awk</code> 命令行上指定的文件中读取数据。如果你指定了输入文件，<code>awk</code> 会按顺序从中读取，并在下一个文件之前处理其中的数据。
当前正在处理的文件可以从参定义的变量 <code>FILENAME</code> 中取得（查看 <a href="#Built_002din-Variables">预定义变量</a>）。
</p>
<a name="index-records"></a>
<a name="index-fields"></a>
<p>输入单位称为<em>记录</em>，并利用你提供的规则一次处理一个记录，每个记录一行。每个记录会被自动力地拆分成几个块，称为<em>域</em>。
这样程序就能够更好地处理记录的不同部分。
</p>
<a name="index-getline-command"></a>
<p>在极少情况下，你可能需要使用 <code>getline</code> 命令来读取数据。<code>getline</code> 非常有用，一是其可以从大量的文件中显示地输入，二是在读取文件时，这些文件不需要在命令地中指定
（查看 <a href="#Getline">用 <code>getline</code> 输入数据</a>）。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Records">4.1 输入如何拆分为记录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Controlling how data is split into records.
</td></tr>
<tr><td align="left" valign="top"><a href="#Fields">4.2 检查域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      An introduction to fields.
</td></tr>
<tr><td align="left" valign="top"><a href="#Nonconstant-Fields">4.3 非常数域编号</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Nonconstant Field Numbers.
</td></tr>
<tr><td align="left" valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Changing the Contents of a Field.
</td></tr>
<tr><td align="left" valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            The field separator and how to change it.
</td></tr>
<tr><td align="left" valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Reading constant width data.
</td></tr>
<tr><td align="left" valign="top"><a href="#Splitting-By-Content">4.7 以内容定义域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Defining Fields By Content
</td></tr>
<tr><td align="left" valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Reading multiline records.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     Reading files under explicit program control
                                using the <code>getline</code> function.
</td></tr>
<tr><td align="left" valign="top"><a href="#Read-Timeout">4.10 带超时的输入读取</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Reading input with a timeout.
</td></tr>
<tr><td align="left" valign="top"><a href="#Command_002dline-directories">4.11 命令行中的目录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    What happens if you put a directory on the
                                command line.
</td></tr>
<tr><td align="left" valign="top"><a href="#Input-Summary">4.12 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Input summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Input-Exercises">4.13 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Exercises.
</td></tr>
</table>

<hr>
<a name="Records"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#awk-split-records" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00be_0093aa_0085_00a5aa_00a6_0082a_00bd_0095ae_008b_0086aa_0088_0086a_00b8_00bae_00ae_00b0aa_00bd_0095"></a>
<h2 class="section">4.1 输入如何拆分为记录</h2>

<a name="index-input_002c-splitting-into-records"></a>
<a name="index-records_002c-splitting-input-into"></a>
<a name="index-NR-variable"></a>
<a name="index-FNR-variable"></a>
<p><code>awk</code> 将输入拆分为记录与域，然后输入到你的程序中。同时，<code>awk</code> 记录从当前输入文件中已经读取的记录数。
这个值存储在预定义的变量 <code>FNR</code> 中，在处理下一个文件时，它会被重置为 0。
另一个预定义的变量称为 <code>NR</code>，来用记录从所有数据文件中已经读取输入记录的总数。它从 0 开始，但是不会自动重设为 0。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           How standard <code>awk</code> splits records.
</td></tr>
<tr><td align="left" valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          How <code>gawk</code> splits records.
</td></tr>
</table>

<hr>
<a name="awk-split-records"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Records" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Records" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#gawk-split-records" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a0_0087aa_0087_0086-awk-c_009a_0084e_00ae_00b0aa_00bd_0095ae_008b_0086aa_0088_0086"></a>
<h3 class="subsection">4.1.1 标准 <code>awk</code> 的记录拆分</h3>

<a name="index-separators_002c-for-records"></a>
<a name="index-record-separators"></a>
<p>记录通过被称为<em>记录分隔符</em>的字符分隔。默认的分隔符是换行符（&lsquo;<samp>\n</samp>&rsquo;）。
这就是为什么记录默认都是一行一行的。
要使用不同的字符来进行记录分隔，简单地给预定义的变量 <code>RS</code> 赋值即可。
</p>
<a name="index-newlines_002c-as-record-separators"></a>
<a name="index-RS-variable"></a>
<p>与其他的变量类似，<code>RS</code> 的值可以在 <code>awk</code> 程序中通过操作符 &lsquo;<samp>=</samp>&rsquo; 来改变（查看 <a href="#Assignment-Ops">赋值表达式</a>）。
新的记录分隔符可以用引号引起来，即指示为一个字串常量。一般地，这么做的正确时间是在程序执行的开始，并在记录未输入之前，因此就可以从第一条记录开始进行处理。
要这么做，可以使用特殊的 <code>BEGIN</code> 模式（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）。例如：
</p>
<div class="example">
<pre class="example">awk 'BEGIN { RS = &quot;u&quot; }
     { print $0 }' mail-list
</pre></div>

<p>在读取任何输入之前，将 <code>RS</code> 的值改成 &lsquo;<samp>u</samp>&rsquo; 。
新的值是一个字串，它的第一个字符是字母 &lsquo;<samp>u</samp>&rsquo;；其结果就是，记录都被字母 &lsquo;<samp>u</samp>&rsquo; 进行分隔。
然后输入文件被读取，<code>awk</code> 程序的第二个规则（没有模式的动作）打印每一个记录。
因为每个 <code>print</code> 语句都会在输出的末尾添加一个换行符，
所以，下面这个 <code>awk</code> 程序就是将每个字母 &lsquo;<samp>u</samp>&rsquo; 换成了换行符。
下面是执行程序在使用 &lsquo;<tt>mail-list</tt>&rsquo; 作为输入文件时的输出：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { RS = &quot;u&quot; }</kbd>
&gt;      <kbd>{ print $0 }' mail-list</kbd>
-| Amelia       555-5553     amelia.zodiac
-| sq
-| e@gmail.com    F
-| Anthony      555-3412     anthony.assert
-| ro@hotmail.com   A
-| Becky        555-7685     becky.algebrar
-| m@gmail.com      A
-| Bill         555-1675     bill.drowning@hotmail.com       A
-| Broderick    555-0542     broderick.aliq
-| otiens@yahoo.com R
-| Camilla      555-2912     camilla.inf
-| sar
-| m@skynet.be     R
-| Fabi
-| s       555-1234     fabi
-| s.
-| ndevicesim
-| s@
-| cb.ed
-|     F
-| J
-| lie        555-6699     j
-| lie.perscr
-| tabor@skeeve.com   F
-| Martin       555-6480     martin.codicib
-| s@hotmail.com    A
-| Sam
-| el       555-3430     sam
-| el.lanceolis@sh
-| .ed
-|         A
-| Jean-Pa
-| l    555-2127     jeanpa
-| l.campanor
-| m@ny
-| .ed
-|      R
-|
</pre></div>

<p>注意名字为 &lsquo;<samp>Bill</samp>&rsquo; 的那一项没有被拆分。在初始的数据文件中（查看 <a href="#Sample-Data-Files">例子中使用的数据文件</a>），那一行是这样的：
</p>
<div class="example">
<pre class="example">Bill         555-1675     bill.drowning@hotmail.com       A
</pre></div>

<p>里面不包含 &lsquo;<samp>u</samp>&rsquo;，因此没有理由要分隔记录，不像其他的部分，它们每个都有一个或者多个 &lsquo;<samp>u</samp>&rsquo; 出现。实际上，这个记录会被当前一个记录的一部分；输出时分隔他们的换行符是原来数据文件中的换行符，而不是 <code>awk</code> 后来打印记录时加上的。
</p>
<a name="index-record-separators_002c-changing"></a>
<a name="index-separators_002c-for-records-1"></a>
<p>另一个方法就是利用变量赋值特性，在命令行上改变记录分隔符（查看 <a href="#Other-Arguments">其他命令行参数</a>）：
</p>
<div class="example">
<pre class="example">awk '{ print $0 }' RS=&quot;u&quot; mail-list
</pre></div>

<p>这里将在处理 &lsquo;<tt>mail-list</tt>&rsquo; 之前将 <code>RS</code> 设置成 &lsquo;<samp>u</samp>&rsquo; 。
</p>
<p>利用类似于 &lsquo;<samp>u</samp>&rsquo; 这样的字母字符作为记录的分隔符有可能产生奇怪的结果。
使用特别一点的字符，如 &lsquo;<samp>/</samp>&rsquo; 更可能在大多数例子中产生正确的结果，但是这也不是打包票的事情。终极方法就是：要了解你的数据。
</p>
<p>使用正则表达式作为记录的分隔符，当 <code>gawk</code> 完全与 POSIX 兼容时，有一个特殊的情况会出现
（查看 <a href="#Options">命令行参数</a>）。下面（极端情况）的管程会打印令人惊讶的 &lsquo;<samp>1</samp>&rsquo; ：
</p>
<div class="example">
<pre class="example">$ <kbd>echo | gawk --posix 'BEGIN { RS = &quot;a&quot; } ; { print NF }'</kbd>
-| 1
</pre></div>

<p>这里有一个域，只包含一个换行符。内建变量 <code>NF</code> 的值就是当前记录的域的数量。
（在正常情况下，<code>gawk</code> 会将换行符当做空格处理，会打印 &lsquo;<samp>0</samp>&rsquo; 作为结果。<code>awk</code> 大多数其他版本都是这么表现的。）
</p>
<a name="index-dark-corner_002c-input-files"></a>
<p>当输入文件结束后，就会结束当前的输入记录，就算文件的最后一个字符不在 <code>RS</code> 里。
(d.c.)
</p>
<a name="index-empty-strings"></a>
<a name="index-null-strings"></a>
<a name="index-strings_002c-empty_002c-See-null-strings"></a>
<p>空串 <code>&quot;&quot;</code>（即没有任何字符的串）对于 <code>RS</code> 的值来说，有着特殊的含义。
即表示记录之间是通过一个或者多个空行来分隔的，而不是其他的什么字符。查看 <a href="#Multiple-Line">多行记录</a>，来获取更多的细节。
</p>
<p>如果你在 <code>awk</code> 程序中中途改变 <code>RS</code> 的值，新的值将用来做后续记录的分隔符，但是当前的记录会继续按原来的方式处理。
</p>
<a name="index-gawk_002c-RT-variable-in"></a>
<a name="index-RT-variable"></a>
<a name="index-records_002c-terminating"></a>
<a name="index-terminating-records"></a>
<a name="index-differences-in-awk-and-gawk_002c-record-separators"></a>
<a name="index-regular-expressions_002c-as-record-separators"></a>
<a name="index-record-separators_002c-regular-expressions-as"></a>
<a name="index-separators_002c-for-records_002c-regular-expressions-as"></a>
<p>当记录尾已经确定好了，<code>gawk</code> 设置变量 <code>RT</code> 的值为输入文件中匹配 <code>RS</code> 的文本。
</p>
<hr>
<a name="gawk-split-records"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#awk-split-records" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Records" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Fields" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8-gawk-aa_0088_0086aa_0089_00b2e_00ae_00b0aa_00bd_0095"></a>
<h3 class="subsection">4.1.2 使用 <code>gawk</code> 分割记录</h3>

<a name="index-common-extensions_002c-RS-as-a-regexp"></a>
<a name="index-extensions_002c-common_002c-RS-as-a-regexp"></a>
<p>当使用 <code>gawk</code> 时，<code>RS</code> 的值并不局限于单个字符的字串，
它也可以是任何的正则表达式（查看 <a href="#Regexp">正则表达式</a>）。(c.e.)
一般来说，每个记录都在下个匹配正则表达式的文件串地方结束；而下一个记录则开始于该匹配文本的地方。
这个一般的原则在通常的情况下是么工作的，此时 <code>RS</code> 只包括一个换行符：
记录结束于下一个匹配串的开始处（输入中的下一个换行符），然后下一个记录就开始于刚才匹配串的后面（即下一行的第一个字符处）。由于换行符匹配 <code>RS</code>，所以其并不是任何记录的一部分。
</p>
<p>当 <code>RS</code> 只是单一的一个字符时，<code>RT</code> 包含相同的单一字符。
但是，当<code>RS</code> 是一个正则表达式时，<code>RT</code> 包含匹配正则表达式的实际的输入文本。
</p>
<p>如果输入文件结束时也没有文本匹配 <code>RS</code>，<code>gawk</code> 将 <code>RT</code> 设置成空串。
</p>
<p>下面的例子解释了这两个特性。例子中将 <code>RS</code> 设置成一个正则表达式，表达式要么匹配换行符，要么是一个或者多个大写字母的序列，其前导并且/或者其末尾带有可选的空白符。
</p>
<div class="example">
<pre class="example">$ <kbd>echo record 1 AAAA record 2 BBBB record 3 |</kbd>
&gt; <kbd>gawk 'BEGIN { RS = &quot;\n|( *[[:upper:]]+ *)&quot; }</kbd>
&gt;             <kbd>{ print &quot;Record =&quot;, $0,&quot;and RT = [&quot; RT &quot;]&quot; }'</kbd>
-| Record = record 1 and RT = [ AAAA ]
-| Record = record 2 and RT = [ BBBB ]
-| Record = record 3 and RT = [
-| ]
</pre></div>

<p>方括号勾勒出 <code>RT</code> 的内容，让你可看到了前面与后面的空白。<code>RT</code> 的终值是一个换行符。
可以查看 <a href="#Simple-Sed">一个简单的流编辑器</a>，来看看更有用的以正则表达式作为 <code>RS</code> 与 <code>RT</code> 的例子。
</p>
<p>如果你将 <code>RS</code> 设置在可以有可选结束文本的正则表达式，如 &lsquo;<samp>RS = &quot;abc(XYZ)?&quot;</samp>&rsquo;，
由于实现上的限制，<code>gawk</code> 有可能匹配正则表达式的前部分，而不会匹配后面的可选部分，尤其是可选的结尾匹配很长的情况。
<code>gawk</code> 会试图避免这个问题，但是目前，并不保证绝不会发生这个情况（即不匹配结尾可选部分———译者）。
</p>
<blockquote>
<p><b>提示:</b> 要记住，在 <code>awk</code> 中，&lsquo;<samp>^</samp>&rsquo; 与 &lsquo;<samp>$</samp>&rsquo; 锚定元字符匹配字串的开始与结束，而不是行的开始与结束。
这样的结果就是，如果有这样的表达式 &lsquo;<samp>RS = &quot;^[[:upper:]]&quot;</samp>&rsquo; 可以只匹配文件的开头。
这是因为 <code>gawk</code> 将输入文件看作是一个包含换行符的长串。因此最好避免在 <code>RS</code> 的值中含有锚定符。
</p></blockquote>

<a name="index-differences-in-awk-and-gawk_002c-RS_002fRT-variables"></a>
<p>将 <code>RS</code> 设置成一个正则表达式，以及 <code>RT</code> 变量是 <code>gawk</code> 的扩展；它们在兼容模式下是不可用的（查看 <a href="#Options">命令行参数</a>）。
在兼容模式下，只有 <code>RS</code> 值的第一个字符会用来确定记录的结束。
</p>
<a name="index-sidebar_002c-RS-_003d-_0022_005c0_0022-ae_0098_00afa_00b8_008daa_008f_00afc_00a7_00bbae_00a4_008dc_009a_0084"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b><code>RS = &quot;\0&quot;</code> 是不可移植的</b>
</p>

<a name="index-portability_002c-data-files-as-single-record"></a>
<p>有那么几次，你可能想将整个数据文件作为一个单独的记录。
唯一能够实现这个功能的就是将 <code>RS</code> 的值设置成不会在输入文件中出现的字符。一般来说，程序比较难做到在任意的输入文件中都是正确的。
</p>
<p>你可能认为，在这种情况下，对于文本文件来说，所有位都由 0 组成的 <small>NUL</small> 字符，适合作为 <code>RS</code> 的值：
</p>
<div class="example">
<pre class="example">BEGIN { RS = &quot;\0&quot; }  # whole file becomes one record?
</pre></div>

<a name="index-differences-in-awk-and-gawk_002c-strings_002c-storing"></a>
<p><code>gawk</code> 实际上接受这样的输入，并且使用 <small>NUL</small> 字符作为记录的分隔符。
这对于特定的特殊文件是可以的，例如在 GNU/Linux 系统上的文件 &lsquo;<tt>/proc/environ</tt>&rsquo;，实际上 <small>NUL</small> 字符实际上是记录分隔符。
可是，对于大多数的 <code>awk</code> 实现来说，这是不可移植的。
</p>
<a name="index-dark-corner_002c-strings_002c-storing"></a>
<p>大多数的其他 <code>awk</code> 实现<a name="DOCF24" href="#FOOT24">(24)</a>内部将字串存成 C 风格的字串。
而 C 风格的字串使用 <small>NUL</small> 做为字串的结束符，效果就是 &lsquo;<samp>RS = &quot;\0&quot;</samp>&rsquo; 与 &lsquo;<samp>RS = &quot;&quot;</samp>&rsquo; 是一样的。
(d.c.)
</p>
<p>新近的 <code>mawk</code> 的版本也可以使用 <small>NUL</small> 字符作为记录的分隔符。
但是，这是个特殊情况：<code>mawk</code> 不允许在字串中嵌入 <small>NUL</small> 字符。（这可能在 <code>mawk</code> 的后续版本中会改变。）
</p>
<a name="index-records_002c-treating-files-as"></a>
<a name="index-treating-files_002c-as-single-records"></a>
<p>通过 <a href="#Readfile-Function">一次读取整个文件</a>，来查看一些有趣的方法来读取整个文件。
如果你使用 <code>gawk</code>，查看 <a href="#Extension-Sample-Readfile">读取整个文件</a>，来选择其他的选项。
</p></td></tr></table>

<hr>
<a name="Fields"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#gawk-split-records" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Nonconstant-Fields" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a3_0080ae_009f_00a5aa_009f_009f"></a>
<h2 class="section">4.2 检查域</h2>

<a name="index-examining-fields"></a>
<a name="index-fields-1"></a>
<a name="index-accessing-fields"></a>
<a name="index-fields_002c-examining"></a>
<a name="index-POSIX-awk_002c-field-separators-and"></a>
<a name="index-field-separators_002c-POSIX-and"></a>
<a name="index-separators_002c-field_002c-POSIX-and"></a>
<p>当 <code>awk</code> 读取输入记录时，记录是自动地被 <code>awk</code> 工具分析或者分隔成称为<em>域</em>的块。
默认情况下，域是通过<em>空白</em>进行分隔的，像一行中的单词一样。
<code>awk</code> 中的空白符表示一个或者多个空格、TABs，或者换行符所组成的串；
<a name="DOCF25" href="#FOOT25">(25)</a>
（其他的字符如回档符，垂直跳格等）被其他语言认为是空白符的这些符号都<em>不</em>被 <code>awk</code> 识别为空白符。
</p>
<p>域的用处是为了让你可以很方便地指定这些记录的块。你不必一定要使用他们，你可以操作整个记录，
但是域可以使得 <code>awk</code> 程序变得非常强大。
</p>
<a name="index-field-operator-_0024"></a>
<a name="index-_0024-_0028dollar-sign_0029_002c-_0024-field-operator"></a>
<a name="index-dollar-sign-_0028_0024_0029_002c-_0024-field-operator"></a>
<a name="index-field-operators_002c-dollar-sign-as"></a>
<p>你使用美元符号（&lsquo;<samp>$</samp>&rsquo;）来指定 <code>awk</code> 程序中的域，符号后面跟的是域的编号。
因此，<code>$1</code> 表示是第一个域，<code>$2</code> 是第二个等等。
（不像 Unix Shell 中，域的编号只被限制用单个数字，例如，<code>$127</code> 是记录中的第 127 个域。）假设下面的行是输入行：
</p>
<div class="example">
<pre class="example">This seems like a pretty nice example.
</pre></div>

<p>这里第一个域，或者 <code>$1</code> 是 &lsquo;<samp>This</samp>&rsquo;，第二个域，或者说 <code>$2</code> 是 &lsquo;<samp>seems</samp>&rsquo; 等等。
注意最后一个域，即 <code>$7</code> 是 &lsquo;<samp>example.</samp>&rsquo; 。
因为在 &lsquo;<samp>e</samp>&rsquo; 与 &lsquo;<samp>.</samp>&rsquo; 之间没有空格，因此点号被认为是第七个域的一部分。
</p>
<a name="index-NF-variable"></a>
<a name="index-fields_002c-number-of"></a>
<p><code>NF</code> 是预定义变量，用来记录当前记录的域数量。<code>awk</code> 在每次读取记录的时候，会自动更新 <code>NF</code> 的值。
无论记录中有多少个域，其最后一个域都可以用 <code>$NF</code> 来表示。因此在上面的例子中，<code>$NF</code> 与 <code>$7</code> 相同，即 &lsquo;<samp>example.</samp>&rsquo; 。
如果你指定域超过了最后一个域（如上面的只有 7 个域的例子中指定 <code>$8</code>），
你会得到一个空串（如果用作数值操作中，则你会得到 0。）
</p>
<p><code>$0</code> 看起来像用来表示第 0 个域，但这是个特别情况，它代表的是整个输入记录。
当你不使用单个的域的时候，你可以使用这个变量。这里有更多的例子：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '$1 ~ /li/ { print $0 }' mail-list</kbd>
-| Amelia       555-5553     amelia.zodiacusque@gmail.com    F
-| Julie        555-6699     julie.perscrutabor@skeeve.com   F
</pre></div>

<p>在这个例子中，会打印文件 &lsquo;<tt>mail-list</tt>&rsquo; 中的每一条记录，其第 1 个域中包含 &lsquo;<samp>li</samp>&rsquo; 字串。
</p>
<p>作为比较，下面的例子中，会在<em>整个记录</em>中查找 &lsquo;<samp>li</samp>&rsquo; 字串，然后打印匹配的记录中的第一个与最后一个域：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '/li/ { print $1, $NF }' mail-list</kbd>
-| Amelia F
-| Broderick R
-| Julie F
-| Samuel A
</pre></div>

<hr>
<a name="Nonconstant-Fields"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Fields" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Changing-Fields" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_009d_009eaa_00b8_00b8ae_0095_00b0aa_009f_009fc_00bc_0096aa_008f_00b7"></a>
<h2 class="section">4.3 非常数域编号</h2>
<a name="index-fields_002c-numbers"></a>
<a name="index-field-numbers"></a>

<p>域编号不一定要是一个常数。<code>awk</code> 程序中的任意表达式都可以用在 &lsquo;<samp>$</samp>&rsquo; 的后面来指定一个域。表达式的值指定了一个域编号。如果果是一个字串，而不是一个数值，则将会被转换成一个数值。看下面例子：
</p>
<div class="example">
<pre class="example">awk '{ print $NR }'
</pre></div>

<p>回忆一下，<code>NR</code> 是到目前为止所读取的记录数：
当读取第一个记录时 <code>NR</code> 为 1，当读取第二个记录时 <code>NR</code> 为 2，等等。
在这个例子中，会打印第一个记录的第一个域，第二个记录的第二个域等等。对于 20 个记录，第 20 个域的值会被打印；
最可能的情况是，记录少于 20 个域，因此这会打印一个空行。这里有另外一个例子，来用另一个表达式来计算域域编号：
</p>
<div class="example">
<pre class="example">awk '{ print $(2*2) }' mail-list
</pre></div>

<p><code>awk</code> 会对 &lsquo;<samp>(2*2)</samp>&rsquo; 表达式进行求值，并用其值作为域的编号，并打印该域。
&lsquo;<samp>*</samp>&rsquo; 代表乘法操作，会在 &lsquo;<samp>$</samp>&rsquo; 之前完成；当在域编号表达式中有二元操作符
<a name="DOCF26" href="#FOOT26">(26)</a>
存在时，这都是必要的。这个例子中，打印 &lsquo;<tt>mail-list</tt>&rsquo; 文件中每一行中关系的类型（第 4 个域）。
（所有的 <code>awk</code> 操作符都按照优先级降序列出在 <a href="#Precedence">操作符优先级（操作符的嵌套）</a>。）
</p>
<p>如果域编号最终计算为 0，你就会得到整个记录。因此，&lsquo;<samp>$(2-2)</samp>&rsquo; 与 <code>$0</code> 的值是一样的。
负的域编号是无效的；这么做一般会导致程序的结束。（POSIX 标准没有定义在使用负的域编号是会产生什么情况。
<code>gawk</code> 会注意到这样的使用方式，并结束整个程序。其他的 <code>awk</code> 实现处理方式可能不同。）
</p>
<p>如在 <a href="#Fields">检查域</a> 中所提到的，<code>awk</code> 将当前记录的域数目存储在内建的变量 <code>NF</code> 中（查看 <a href="#Built_002din-Variables">预定义变量</a>）。
因此，<code>$NF</code> 表达式具有一个特别的特性——就是会直接对 <code>NF</code> 求值，并将这个值作为域编号。
</p>
<hr>
<a name="Changing-Fields"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Nonconstant-Fields" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Separators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009b_00b4ae_0094_00b9aa_009f_009faa_0086_0085aa_00ae_00b9"></a>
<h2 class="section">4.4 更改域内容</h2>

<a name="index-fields_002c-changing-contents-of"></a>
<p><code>awk</code> 所看到的域内容，是可以在 <code>awk</code> 程序中更改的，这会更改 <code>awk</code> 能看到当前输入记录的结果。（这个输入实际上还没有被处理；<code>awk</code> 不会修改输入文件。）考虑下面的例子以及它的输出：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ nboxes = $3 ; $3 = $3 - 10</kbd>
&gt;        <kbd>print nboxes, $3 }' inventory-shipped</kbd>
-| 25 15
-| 32 22
-| 24 14
&hellip;
</pre></div>

<p>上面的程序，首先保存第三个域的原始的值到变量 <code>nboxes</code> 中。
&lsquo;<samp>-</samp>&rsquo; 号表示相减，因此程序重新对第三个域，即 <code>$3</code> 进行赋值为第三个域的原始值减 10：
&lsquo;<samp>$3 - 10</samp>&rsquo; 。（查看 <a href="#Arithmetic-Ops">算术操作符</a>.）
然后打印第三个域的旧值与新值（库房中有人出错了，导致在盘点红盒子时导致了不一致。）
</p>
<p>要使这个能够工作，则 <code>$3</code> 的文件必须是一个数值；而字符串也必须转换成数值以进行算法计算。而减法所得的结果也会转化成字串，并成为第三个域的值。
查看 <a href="#Conversion">在字串与数值之间进行转换</a>。
</p>
<p>当某个域的值被更改了后（如 <code>awk</code> 所见的），输入记录的文本就会被重新计算，以将新的域包含在旧的域所在的位置。
换句话说，<code>$0</code> 会变更以反映变化的域。因此，这个程序会打印输入文件的复本，同时，每行中的第二个域会减去 10：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ $2 = $2 - 10; print $0 }' inventory-shipped</kbd>
-| Jan 3 25 15 115
-| Feb 5 32 24 226
-| Mar 5 24 34 228
&hellip;
</pre></div>

<p>给域范围之外的域赋值也是可以的，如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ $6 = ($5 + $4 + $3 + $2)</kbd>
&gt; <kbd>       print $6 }' inventory-shipped</kbd>
-| 168
-| 297
-| 301
&hellip;
</pre></div>

<a name="index-adding_002c-fields"></a>
<a name="index-fields_002c-adding"></a>
<p>我们在上面创建了 <code>$6</code>，它的值反映了域 <code>$2</code>，<code>$3</code>，<code>$4</code> 与 <code>$5</code> 的和。
&lsquo;<samp>+</samp>&rsquo; 代表加操作。对于文件 &lsquo;<tt>inventory-shipped</tt>&rsquo; 来说，<code>$6</code> 表示了特定月份中，已经发送的包裹的总数。
</p>
<p>创建一个新的域，会改变 <code>awk</code> 的针对当前的输入记录内部复本，也就是 <code>$0</code> 的值。
因此，如果你在添加了一个域后执行 &lsquo;<samp>print $0</samp>&rsquo;，导致输出结果也会包括新的域，同时相应数量的域分隔符会插入到其本身与前一个已经存在的域之间。
</p>
<a name="index-OFS-variable"></a>
<a name="index-output-field-separator_002c-See-OFS-variable"></a>
<a name="index-field-separators_002c-See-Also-OFS"></a>
<p>这样的重新计算既受 <code>NF</code> 的影响，也会影响 <code>NF</code>（域数量；查看 <a href="#Fields">检查域</a>）。
如果，<code>NF</code> 的值被设置成你创建的域的最大值。
<code>$0</code> 的确切格式也同样受一个未讨论的特性的影响：
<em>输出域分隔符</em>，<code>OFS</code>，该分隔符用来分隔域（查看 <a href="#Output-Separators">输出分隔符</a>）。
</p>
<p>但是，仅仅<em>参考</em>一个域范围外的域，并<em>不会</em>改变 <code>$0</code> 的值，也<em>不会</em>改变 <code>NF</code> 的值。参考范围之外的域仅会产生个空串，如：
</p>
<div class="example">
<pre class="example">if ($(NF+1) != &quot;&quot;)
    print &quot;can't happen&quot;
else
    print &quot;everything is normal&quot;
</pre></div>

<p>上面的例子应当打印 &lsquo;<samp>everything is normal</samp>&rsquo;，因为 <code>NF+1</code> 一定会超过域范围。
（查看 <a href="#If-Statement"><code>if</code>-<code>else</code> 语句</a>，来获取关于 <code>awk</code> 的 <code>if-else</code> 语句的更多信息。
查看 <a href="#Typing-and-Comparison">变量类型与比较表达式</a>，来获取 &lsquo;<samp>!=</samp>&rsquo; 操作符的更多信息。）
</p>
<p>知道这样的事实也非常重要：对一个已经存在的域赋值会改变 <code>$0</code> 的值，但是不会改变 <code>NF</code> 的值，就算你给这个域赋给一个空串。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>echo a b c d | awk '{ OFS = &quot;:&quot;; $2 = &quot;&quot;</kbd>
&gt;                       <kbd>print $0; print NF }'</kbd>
-| a::c:d
-| 4
</pre></div>

<p>相应的域还是存在的，只是具有一个空值，在 &lsquo;<samp>a</samp>&rsquo; 与 &lsquo;<samp>c</samp>&rsquo; 之间用冒号进行了分隔。下面的例子显示，如果你创建一个新的域，会发生什么样的情况：
</p>
<div class="example">
<pre class="example">$ <kbd>echo a b c d | awk '{ OFS = &quot;:&quot;; $2 = &quot;&quot;; $6 = &quot;new&quot;</kbd>
&gt;                       <kbd>print $0; print NF }'</kbd>
-| a::c:d::new
-| 6
</pre></div>

<p>中间的域，<code>$5</code> 会以空值创建（由第二对紧邻的冒号指示），<code>NF</code> 的值则更新为 6。
</p>
<a name="index-dark-corner_002c-NF-variable_002c-decrementing"></a>
<a name="index-NF-variable_002c-decrementing"></a>
<p>减少 <code>NF</code> 的值，将会将新值后面的域全部丢弃，并重新计算 <code>$0</code> 的值。
(d.c.)
下面是这样的例子：
</p>
<div class="example">
<pre class="example">$ <kbd>echo a b c d e f | awk '{ print &quot;NF =&quot;, NF;</kbd>
&gt; <kbd>                          NF = 3; print $0 }'</kbd>
-| NF = 6
-| a b c
</pre></div>

<a name="index-portability_002c-NF-variable_002c-decrementing"></a>
<blockquote>
<p><b>注意:</b> 一些版本的 <code>awk</code> 当 <code>NF</code> 递减时不会重建 <code>$0</code>。
</p></blockquote>

<p>最终，有机会在合适的时机强制 <code>awk</code> 利用当前的域与 <code>OFS</code> 值重新整个记录。为了实现这个目的，使用下面看起来没用的赋值语句：
</p>
<div class="example">
<pre class="example">$1 = $1   # force record to be reconstituted
print $0  # or whatever else with $0
</pre></div>

<p>这强制 <code>awk</code> 重建记录。如这里所示，添加相应的注释是有帮助的。
</p>
<p>这是 <code>$0</code> 与记录之间关系的生动体现。
任何对 <code>$0</code> 的赋值都会导致 <code>awk</code> 利用<em>当前</em>的 <code>FS</code> 值对记录进行重新分析。
这也同样使用于内建的函数对于 <code>$0</code> 的更改，例如 <code>sub()</code> 以及 <code>gsub()</code>（查看 <a href="#String-Functions">字串操作函数</a>）。
</p>
<a name="index-sidebar_002c-c_0090_0086e_00a7_00a3-_00240"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>理解 <code>$0</code></b>
</p>


<p>记住 <code>$0</code> 是<em>整个</em>记录这一点非常重要，知道他是通过输入获取的，这一点也同样重要。
它包含任何的前导与后缀的空白符，也就是分隔域的空白符（或者其他的分隔字符）。
</p>
<p>通过简单地设置 <code>FS</code> 或者 <code>OFS</code> 的值来改变域分隔符，并期望简单的 &lsquo;<samp>print</samp>&rsquo; 或者 &lsquo;<samp>print $0</samp>&rsquo; 打印的时新记录的值，
是个常见的错误。
</p>
<p>但是这不会有作用，因为对于更改记录本身什么也没有做。相反的，你必须强制记录要进行重建，典型的情况就是利用如 &lsquo;<samp>$1 = $1</samp>&rsquo; 这样的语句来触发。
</p></td></tr></table>


<hr>
<a name="Field-Separators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Changing-Fields" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Default-Field-Splitting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008c_0087aa_00ae_009ae_00ae_00b0aa_00bd_0095aa_00a6_0082a_00bd_0095e_00bf_009be_00a1_008caa_0088_0086e_009a_0094"></a>
<h2 class="section">4.5 指定记录如何进行分隔</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Default-Field-Splitting">4.5.1 标准的域分隔符空白符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      How fields are normally separated.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Using regexps as the field separator.
</td></tr>
<tr><td align="left" valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Making each character a separate field.
</td></tr>
<tr><td align="left" valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Setting <code>FS</code> from the command line.
</td></tr>
<tr><td align="left" valign="top"><a href="#Full-Line-Fields">4.5.5 一行即一域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Making the full line be a single field.
</td></tr>
<tr><td align="left" valign="top"><a href="#Field-Splitting-Summary">4.5.6 域分割总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Some final points and a summary table.
</td></tr>
</table>

<a name="index-FS-variable"></a>
<a name="index-fields_002c-separating"></a>
<a name="index-field-separators"></a>
<a name="index-fields_002c-separating-1"></a>
<p><em>域分隔符</em>要么是一个单个字符，或者是一个正则表达式，
以控制 <code>awk</code> 将输入记录分隔成域。<code>awk</code> 扫描输入记录的字符序列以匹配分隔符；域则是匹配之间的文本。
</p>
<p>在下面的例子中，我们使用子弹符（&bull;）个表示输出之间的空间。如果域分隔符是 &lsquo;<samp>oo</samp>&rsquo; 然后下面的行：
</p>
<div class="example">
<pre class="example">moo goo gai pan
</pre></div>

<p>将被分成三个域：&lsquo;<samp>m</samp>&rsquo;，&lsquo;<samp>&bull;g</samp>&rsquo;， and &lsquo;<samp>&bull;gai&bull;pan</samp>&rsquo; 。
注意第二个与第三个域中的前导空间。
</p>
<a name="index-troubleshooting_002c-awk-uses-FS-not-IFS"></a>
<p>域分隔符由预定义的变量 <code>FS</code> 表示。
Shell 程序员要注意：<code>awk</code> <em>不</em>使用由 POSIX 兼容 Shell
（例如 Unix Bourne shell，<code>sh</code>，或者 Bash）使用的名字 <code>IFS</code>。
</p>
<a name="index-FS-variable_002c-changing-value-of"></a>
<p><code>FS</code> 的值可以在 <code>awk</code> 的程序当中使用赋值操作符来进行改变，&lsquo;<samp>=</samp>&rsquo; （查看 <a href="#Assignment-Ops">赋值表达式</a>）。
一般来说，进行赋值的正确时机一般是在执行的开始，并在任何记录还没有被处理之前，因此第一条记录会通过正确的分隔符进行处理。
为了实现这样的赋值，你可以使用 <code>BEGIN</code> 模式（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）。
例如，下面的例子将 <code>FS</code> 的值设置成字串 <code>&quot;,&quot;</code>：
</p>
<div class="example">
<pre class="example">awk 'BEGIN { FS = &quot;,&quot; } ; { print $2 }'
</pre></div>

<a name="index-BEGIN-pattern"></a>
<p>如果输入的行为：
</p>
<div class="example">
<pre class="example">John Q. Smith, 29 Oak St., Walamazoo, MI 42139
</pre></div>

<p>这个 <code>awk</code> 程序会提取并打印字串 &lsquo;<samp>&bull;29&bull;Oak&bull;St.</samp>&rsquo; 。
</p>
<a name="index-field-separators_002c-choice-of"></a>
<a name="index-regular-expressions-as-field-separators"></a>
<a name="index-field-separators_002c-regular-expressions-as"></a>
<p>有时，输入数据中包含有分隔符，因此没有按你所预期的方式对或者分隔。如，在我们刚才使用的例子中，人名中有可能有称谓或者后缀，如：
</p>
<div class="example">
<pre class="example">John Q. Smith, LXIX, 29 Oak St., Walamazoo, MI 42139
</pre></div>

<p>同样的程序，会提取 &lsquo;<samp>&bull;LXIX</samp>&rsquo; 而不是 &lsquo;<samp>&bull;29&bull;Oak&bull;St.</samp>&rsquo; 。
如果你预期其打印的是地址，你就会感觉到很奇怪。
终极方法是要仔细选择你的数据结构和分隔符以避免这样的问题。
（如果果数据的格式并不好处理，也可以先将它用另一个程序先输出来进行查看。）
</p>

<hr>
<a name="Default-Field-Splitting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Separators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Separators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Field-Splitting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a0_0087aa_0087_0086c_009a_0084aa_009f_009faa_0088_0086e_009a_0094c_00ac_00a6c_00a9_00bac_0099_00bdc_00ac_00a6"></a>
<h3 class="subsection">4.5.1 标准的域分隔符空白符</h3>

<a name="index-newlines_002c-as-field-separators"></a>
<a name="index-whitespace_002c-as-field-separators"></a>
<p>通常的情况下，域是通过空白符序列进行分隔的（空格，TABs，或者换行符），而不是通过单个空格。
一行中的两个连续空格不会分隔出一个空域。域分隔符 <code>FS</code> 的默认值是包含一个空格的字串，即 <code>&quot;&nbsp;&quot;</code>。
如果 <code>awk</code> 将这个值按照通常的方法解释，每个空格都会分隔出一个域出来，从而导致一行中的连续两个空格会在他们之间产生一个空域。
没有产生这种情况，是因为 <code>FS</code> 值中的单个空格是一种特殊情况——其用来指定域分隔的默认方式。
</p>
<p>如果 <code>FS</code> 是其他的任意单个字符，如 <code>&quot;,&quot;</code>，则每一个这样的字符出现，都会分隔出两个域出来。
两个连续出现，就会分隔出一个空域。如果这个字符出现在开头或者结尾，也会产生一个空域。
空格是唯一一个不按这种规则处理的字符。
</p>
<hr>
<a name="Regexp-Field-Splitting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Default-Field-Splitting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Separators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Single-Character-Fields" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008faa_0088_0086e_009a_0094aa_009f_009f"></a>
<h3 class="subsection">4.5.2 使用正则表达式分隔域</h3>
<a name="index-regular-expressions_002c-as-field-separators"></a>
<a name="index-field-separators_002c-regular-expressions-as-1"></a>
<p>前面的子小节讨论了使用单个字符或者简单串作为 <code>FS</code> 值的情况。更通常的情况，<code>FS</code> 的值可以包含任意的正则表达式。在这种情况下，每一次匹配正则表达式就会分隔域。如下面的赋值：
</p>
<div class="example">
<pre class="example">FS = &quot;, \t&quot;
</pre></div>

<p>每一个输入行中，匹配逗号后面跟着一个空格与一个 TAB 字符的文本区，都将成为一个分隔符。
</p>
<p>在一个不是太普通的正则表达式例子中，会尝试用单个空格来分隔域，与单个的逗号一样的方式。
<code>FS</code> 可以被设置成 <code>&quot;[&nbsp;]&quot;</code>（左方括号，空格，右方括号）。
这个正则表达式只匹配单个空格而不是其它的（查看 <a href="#Regexp">正则表达式</a>）。
</p>
<p>&lsquo;<samp>FS = &quot;&nbsp;&quot;</samp>&rsquo;（单空格）与 &lsquo;<samp>FS = &quot;[&nbsp;\t\n]+&quot;</samp>&rsquo;（匹配一个或者多个空格，TABs 与换行符）之间存在一个重大的差异。
对于 FS 的两个值，域都会被连续的（出现多个相邻的）空格、TABs、与换行符分隔。
但是，当 <code>FS</code> 的值是 <code>&quot;&nbsp;&quot;</code> 时，<code>awk</code> 首先将记录的前后空白符都去掉，然后才去决定域所在的区域。例如下面的管程会打印 &lsquo;<samp>b</samp>&rsquo; ：
</p>
<div class="example">
<pre class="example">$ <kbd>echo ' a b c d ' | awk '{ print $2 }'</kbd>
-| b
</pre></div>

<p>但是这个管程会打印 &lsquo;<samp>a</samp>&rsquo;（注意一下在每个字母前后两额外空格）：
</p>
<div class="example">
<pre class="example">$ <kbd>echo ' a  b  c  d ' | awk 'BEGIN { FS = &quot;[ \t\n]+&quot; }</kbd>
&gt;                                  <kbd>{ print $2 }'</kbd>
-| a
</pre></div>

<a name="index-null-strings-1"></a>
<a name="index-strings_002c-null"></a>
<a name="index-empty-strings_002c-See-null-strings"></a>
<p>在这个例子中，第一个域是 null，或者称为空。
</p>
<p>略去记录的前后空白符在 <code>$0</code> 是如果何来重新计算也会有作用。如，考察下面的管程：
</p>
<div class="example">
<pre class="example">$ <kbd>echo '   a b c d' | awk '{ print; $2 = $2; print }'</kbd>
-|    a b c d
-| a b c d
</pre></div>

<p>第一个 print 语句打印出被读时的内容，并且前头的空白是保留了的。
对于 <code>$2</code> 域的赋值会导致 <code>$0</code> 的重建，并且将 <code>$1</code> 到 <code>$NF</code> 的记录合并在一起，
相互之间用 <code>OFS</code> 的值进行分隔（默认情况下也是空格）。
因为前导的空白在查找 <code>$1</code> 时已经被忽略了，所以它不再是新的 <code>$0</code> 的一部份。
最终，最后的一个 <code>print</code> 语句打印的是新的 <code>$0</code>。
</p>
<a name="index-FS_002c-containing-_005e"></a>
<a name="index-_005e-_0028caret_0029_002c-in-FS"></a>
<a name="index-dark-corner_002c-_005e_002c-in-FS"></a>
<p>使用正则表达式来分隔记录时，有一个额外的细节之处要了解。
这在 POSIX 标准在没有确定，也在没其他地方说明，到底 &lsquo;<samp>^</samp>&rsquo; 在域分隔时表示什么。是只匹配整个记录的开始？还是域分隔出的新串？因此不同的版本的 <code>awk</code> 对于这个问题的回答也是不一样的。你不要依赖于你的程序中的特定行为表现。
(d.c.)
</p>
<a name="index-Brian-Kernighan_0027s-awk-3"></a>
<p>作为提示信息，BWK <code>awk</code> 允许 &lsquo;<samp>^</samp>&rsquo; 只匹配记录的开头。
<code>gawk</code> 也这么处理。如：
</p>
<div class="example">
<pre class="example">$ <kbd>echo 'xxAA  xxBxx  C' |</kbd>
&gt; <kbd>gawk -F '(^x+)|( +)' '{ for (i = 1; i &lt;= NF; i++)</kbd>
&gt; <kbd>                            printf &quot;--&gt;%s&lt;--\n&quot;, $i }'</kbd>
-| --&gt;&lt;--
-| --&gt;AA&lt;--
-| --&gt;xxBxx&lt;--
-| --&gt;C&lt;--
</pre></div>

<hr>
<a name="Single-Character-Fields"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Field-Splitting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Separators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Command-Line-Field-Separator" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0090_0084aa_00ad_0097c_00ac_00a6c_009a_0086a_00b8_00baaa_0088_0086e_009a_0094c_00ac_00a6"></a>
<h3 class="subsection">4.5.3 各字符皆为分隔符</h3>

<a name="index-common-extensions_002c-single-character-fields"></a>
<a name="index-extensions_002c-common_002c-single-character-fields"></a>
<a name="index-differences-in-awk-and-gawk_002c-single_002dcharacter-fields"></a>
<a name="index-single_002dcharacter-fields"></a>
<a name="index-fields_002c-single_002dcharacter"></a>
<p>有那么几次，你可能想测试一下单独地每个字符作为分隔符的情况。这种情况下，
在 <code>gawk</code> 中你只需要简单地将空串（<code>&quot;&quot;</code>）赋值给 <code>FS</code> 即可。(c.e.)
在这个例子中，记录中的每一个单独的字符都将成为一个分隔符。如：
</p>
<div class="example">
<pre class="example">$ <kbd>echo a b | gawk 'BEGIN { FS = &quot;&quot; }</kbd>
&gt;                  <kbd>{</kbd>
&gt;                      <kbd>for (i = 1; i &lt;= NF; i = i + 1)</kbd>
&gt;                          <kbd>print &quot;Field&quot;, i, &quot;is&quot;, $i</kbd>
&gt;                  <kbd>}'</kbd>
-| Field 1 is a
-| Field 2 is
-| Field 3 is b
</pre></div>

<a name="index-dark-corner_002c-FS-as-null-string"></a>
<a name="index-FS-variable_002c-as-null-string"></a>
<p>传统上，<code>FS</code> 等于 <code>&quot;&quot;</code> 的行为并不是确定的。
在这个例子中，Unix <code>awk</code> 的大多数版本只是简单地将整个记录当做一个域。
(d.c.)
在兼容模式下（查看 <a href="#Options">命令行参数</a>），如果 <code>FS</code> 是一个空串，那么 <code>gawk</code> 也会按照上面的方式进行处理。
</p>
<hr>
<a name="Command-Line-Field-Separator"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Single-Character-Fields" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Separators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Full-Line-Fields" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008eaa_0091_00bda_00bb_00a4e_00a1_008ca_00b8_00ade_00ae_00bec_00bd_00ae-FS"></a>
<h3 class="subsection">4.5.4 从命令行中设置 <code>FS</code></h3>
<a name="index-_002dF-option_002c-command_002dline"></a>
<a name="index-field-separator_002c-on-command-line"></a>
<a name="index-command-line_002c-FS-on_002c-setting"></a>
<a name="index-FS-variable_002c-setting-from-command-line"></a>

<p><code>FS</code> 可以在命令行中通过 &lsquo;<samp>-F</samp>&rsquo; 选项进行设置，如：
</p>
<div class="example">
<pre class="example">awk -F, '<var>program</var>' <var>input-files</var>
</pre></div>

<p>设置 <code>FS</code> 的值为 &lsquo;<samp>,</samp>&rsquo;，注意选项使用的是一个大写的 &lsquo;<samp>F</samp>&rsquo;，而不是小写的 &lsquo;<samp>f</samp>&rsquo;。
后者 &lsquo;<samp>-f</samp>&rsquo; 选项指定了包含 <code>awk</code> 程序的文件。
</p>
<p>参数 &lsquo;<samp>-F</samp>&rsquo; 的赋值方式和预定义参数 <code>FS</code> 的赋值方式完全一样。
任何在域分隔字符中的特殊字符都必须进行适当地转义。
如使用一个 &lsquo;<samp>\</samp>&rsquo; 用作一个域分隔符，你需要这样来输入：
</p>
<div class="example">
<pre class="example"># same as FS = &quot;\\&quot;
awk -F\\\\ '&hellip;' files &hellip;
</pre></div>

<a name="index-_005c-_0028backslash_0029_002c-as-field-separator"></a>
<a name="index-backslash-_0028_005c_0029_002c-as-field-separator"></a>
<p>由于 &lsquo;<samp>\</samp>&rsquo; 要在 shell 中用引号引起来，<code>awk</code> 会看到 &lsquo;<samp>-F\\</samp>&rsquo;。
之后 <code>awk</code> 会处理 &lsquo;<samp>\\</samp>&rsquo; 转义字符，
（查看 <a href="#Escape-Sequences">转义序列</a>），最后，产生一个单独的 &lsquo;<samp>\</samp>&rsquo; 用作域分隔符。
</p>
<p>有一个特殊的例子，在兼容模式下（查看 <a href="#Options">命令行参数</a>），
如果 &lsquo;<samp>-F</samp>&rsquo; 的参数是 &lsquo;<samp>t</samp>&rsquo;，则 <code>FS</code> 会被设置成 TAB 符号。
如果你在 Shell 中输入 &lsquo;<samp>-F\t</samp>&rsquo;，没有进行任何转义，则 &lsquo;<samp>\</samp>&rsquo; 会被删除掉。
所以，<code>awk</code> 会了解到你是真的想用 TABs 来分隔记录，而不是 &lsquo;<samp>t</samp>&rsquo; 。
如果你确实是要用 &lsquo;<samp>t</samp>&rsquo; 来分隔记录，则在命令行中使用 &lsquo;<samp>-v FS=&quot;t&quot;</samp>&rsquo; 或者 &lsquo;<samp>-F&quot;[t]&quot;</samp>&rsquo; 。
如果不是在兼容模式下，使用 &lsquo;<samp>-F '\t'</samp>&rsquo; 来指定 TABs 来做域分隔符。
</p>
<p>下面的例子中，我们利用一个名为 &lsquo;<tt>edu.awk</tt>&rsquo; 的程序文件，其中包括了 <code>/edu/</code> 模式，
以及动作 &lsquo;<samp>print $1</samp>&rsquo;：
</p>
<div class="example">
<pre class="example">/edu/   { print $1 }
</pre></div>

<p>我们将 <code>FS</code> 的值设置成 &lsquo;<samp>-</samp>&rsquo; 字符，并把程序运行在文件 &lsquo;<tt>mail-list</tt>&rsquo; 上。
下面的命令打印出那些工作在大学或者在上大学的人的名字列表，以及他们电话号码的前三个数字：
</p>
<div class="example">
<pre class="example">$ <kbd>awk -F- -f edu.awk mail-list</kbd>
-| Fabius       555
-| Samuel       555
-| Jean
</pre></div>

<p>注意第三行输出，第三行内容在原文件是这样的：
</p>
<div class="example">
<pre class="example">Jean-Paul    555-2127     jeanpaul.campanorum@nyu.edu     R
</pre></div>

<p>&lsquo;<samp>-</samp>&rsquo; 是人名的一部分，但是却被用来作了域分隔符，而不是按照预想的那样用电话号码中的 &lsquo;<samp>-</samp>&rsquo; 来做分隔符。这说明了，你需要仔细地选择你的域分隔符。
</p>
<a name="index-Unix-awk_002c-password-files_002c-field-separators-and"></a>
<p>也许，大多数使用单字符作为域分隔的情况下出现在处理 Unix 系统的密码文件。在许多的 Unix 系统中，每个用户在系统的密码文件中都有一个项，一行一用户。这些行中的信息是用冒号分隔的。第一个域是用户的登录名，第二项是用户已经加密过的密码，或者是影子密码（影子密码就是在第二个域中用 &lsquo;<samp>x</samp>&rsquo; 代替的密码。）密码文件的项看起来可能如下：
</p>
<a name="index-Robbins_002c-Arnold"></a>
<div class="example">
<pre class="example">arnold:x:2076:10:Arnold Robbins:/home/arnold:/bin/bash
</pre></div>

<p>下面的程序搜索系统的密码文件并搜打印那些用户的全名没有存在的项：
</p>
<div class="example">
<pre class="example">awk -F: '$5 == &quot;&quot;' /etc/passwd
</pre></div>

<hr>
<a name="Full-Line-Fields"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Command-Line-Field-Separator" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Separators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Splitting-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_0080e_00a1_008caa_008d_00b3a_00b8_0080aa_009f_009f"></a>
<h3 class="subsection">4.5.5 一行即一域</h3>

<p>有时候，将整行当成一个域非常有用，这只要简单地将 <code>FS</code> 设置成 &lsquo;<samp>\n</samp>&rsquo;（换行符）即可，这也是可移植的：
<a name="DOCF27" href="#FOOT27">(27)</a>
</p>
<div class="example">
<pre class="example">awk -F'\n' '<var>program</var>' <var>files &hellip;</var>
</pre></div>

<p>当你这么做时，<code>$1</code> 与 <code>$0</code> 一样。
</p>
<a name="index-sidebar_002c-ae_0094_00b9aa_008f_0098-FS-a_00b8_008da_00bc_009aaa_00bd_00b1aa_0093_008daa_009f_009f"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>改变 <code>FS</code> 不会影响域</b>
</p>


<a name="index-POSIX-awk_002c-field-separators-and-1"></a>
<a name="index-field-separator_002c-POSIX-and"></a>
<p>根据 POSIX 标准，<code>awk</code> 的行为起来就就像记录在被读取的时候就已经分隔了。
这意思就是说，如果你在记录读取后再更改 <code>FS</code> 的值，域的值（如他们如何被分割）应该反映的是旧的 <code>FS</code> 的情况，
而不是新的。
</p>
<a name="index-dark-corner_002c-field-separators"></a>
<a name="index-sed-utility"></a>
<a name="index-stream-editors"></a>
<p>但是，许多的旧的 <code>awk</code> 实现不是这么处理的。
相反，这些实现是当要使用域时，才开始进行分割。域使用<em>当前</em>的 <code>FS</code> 值来进行分割。
(d.c.)
这个行为很难进行识别。
下面的例子解释了两种方法的差异：
</p>
<div class="example">
<pre class="example">sed 1q /etc/passwd | awk '{ FS = &quot;:&quot; ; print $1 }'
</pre></div>

<p>一般都打印：
</p>
<div class="example">
<pre class="example">root
</pre></div>

<p>这是在一个不正确的 <code>awk</code> 实现中的行为，而 <code>gawk</code> 则会打印文件的第一行的整行，如：
</p>
<div class="example">
<pre class="example">root:x:0:0:Root:/:
</pre></div>

<p>（sed 命令
<a name="DOCF28" href="#FOOT28">(28)</a>
打印文件 &lsquo;<tt>/etc/passwd</tt>&rsquo; 的第一行。）
</p></td></tr></table>

<hr>
<a name="Field-Splitting-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Full-Line-Fields" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Separators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Constant-Size" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009f_009faa_0088_0086aa_0089_00b2ae_0080_00bbc_00bb_0093"></a>
<h3 class="subsection">4.5.6 域分割总结</h3>

<p>当你给 <code>FS</code> 赋值为一个字串常量的时候，要记住这个非常重要，其与 <code>awk</code> 正常的字符处理是不一样的。
例如：Unix <code>awk</code> 与 <code>gawk</code>，这样的赋值 &lsquo;<samp>FS = &quot;\..&quot;</samp>&rsquo; 会将 <code>&quot;..&quot;</code> 赋值给 <code>FS</code>
（反斜杠会被去掉）。
这个赋值创建了一个正则表达式表示“域由两个字符进行分割。”
如果你确实想用一个点号（&lsquo;<samp>.</samp>&rsquo;）后面跟一个字符来分割域，使用 &lsquo;<samp>FS = &quot;\\..&quot;</samp>&rsquo;。
</p>
<p>下面是基于 <code>FS</code> 的值的域分割的总结（&lsquo;<samp>==</samp>&rsquo; 表示等于）：
</p>
<dl compact="compact">
<dt><code>FS == &quot; &quot;</code></dt>
<dd><p>域由连续的空格进行分割。记录的前后的空白会被忽略。这是默认分割方式。
</p>
</dd>
<dt><code>FS == <var>任意单个字符</var></code></dt>
<dd><p>域由单个字符进行分割。
多个连续的字符会分割出空域，头、尾的出现也一样。字符甚至可以是正则表达式的元字符，并且也不需要进行转义。
</p>
</dd>
<dt><code>FS == <var>regexp</var></code></dt>
<dd><p>域由匹配 <var>regexp</var> 的正则表达式字符串进行分割。前后匹配会分割出空字符。
</p>
</dd>
<dt><code>FS == &quot;&quot;</code></dt>
<dd><p>记录中的每个字符都是分隔符。（这是一个通用扩展；但是没有由 POSIX 标准定义。）
</p></dd>
</dl>

<a name="index-sidebar_002c-FS-a_00b8_008e-IGNORECASE"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b><code>FS</code> 与 <code>IGNORECASE</code></b>
</p>


<p><em>仅仅</em>当域分割符 <code>FS</code> 的值是正则表达式时，<code>IGNORECASE</code> 变量（查看 <a href="#User_002dmodified">控制 <code>awk</code> 的内置变量</a>）
会影响到分割。
当 <code>FS</code> 是一个单独的字符时，则没有影响，即使字符是一个字母。因此下面的代码：
</p>
<div class="example">
<pre class="example">FS = &quot;c&quot;
IGNORECASE = 1
$0 = &quot;aCa&quot;
print $1
</pre></div>

<p>输出为 &lsquo;<samp>cCa</samp>&rsquo;。
如果你确实想用字母字符来分割域而忽略大小写，就使用正则表达式，并由它来为你处理这样的问题
（如，&lsquo;<samp>FS = &quot;[c]&quot;</samp>&rsquo;）。
在这个例子，<code>IGNORECASE</code> 会产生效果。
</p></td></tr></table>


<hr>
<a name="Constant-Size"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Field-Splitting-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Splitting-By-Content" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_00bbaa_008f_0096aa_009b_00baaa_00ae_009aaa_00ae_00bdaa_00ba_00a6ae_0095_00b0ae_008d_00ae"></a>
<h2 class="section">4.6 读取固定宽度数据</h2>

<a name="index-data_002c-fixed_002dwidth"></a>
<a name="index-fixed_002dwidth-data"></a>
<a name="index-advanced-features_002c-fixed_002dwidth-data"></a>

<p>本小节讨论 <code>gawk</code> 一个高级特性。如果你是 <code>awk</code> 新手，你可以第一次阅读时跳过。
</p>
<p><code>gawk</code> 提供了处理固定宽度域的功能，而不需要特别的域分割符。
例如，这种特性可能出现在旧的 Fortran 程序的输入数据中，其中数字都是连续出现的；
或者是出现在一些程序的输出结果中，这些程序的设计不考虑将它的输出结果作为其他程序的输入数据。
</p>
<p>作为后者的一个例子就是表，它的每一列通过利用可变的数字或者空格来对齐，<em>空的域则全是空格</em>。
很明显的，<code>awk</code> 的一般域分割是基于 <code>FS</code> 的值，不会在这样的例子中工作得好。
尽管一个可移植的 <code>awk</code> 程序可以使用一系列的 <code>substr()</code> 调用来处理 <code>$0</code>（查看 <a href="#String-Functions">字串操作函数</a>），在处理有很多域，并且数据量巨大时，这是一很蹩脚也低效的方法。
</p>
<a name="index-troubleshooting_002c-fatal-errors_002c-field-widths_002c-specifying"></a>
<a name="index-w-utility"></a>
<a name="index-FIELDWIDTHS-variable"></a>
<a name="index-gawk_002c-FIELDWIDTHS-variable-in"></a>
<p>将输入记录分割成固定宽度的域，通过指定一个包含空格分割的数字到内建变量 <code>FIELDWIDTHS</code> 来实现。
每一个数字表示了域的宽度，<em>包含</em>了域之间的列。
如果你想忽略域之间的列，则可以指定分离的域宽度，则后面的处理会忽略掉它。指定一个负的域宽是一个致命错误。
下面的数据是 Unix 工具 <code>w</code> 的输出。这个用来演示 <code>FIELDWIDTHS</code> 的使用非常有用：
</p>
<div class="example">
<pre class="example"> 10:06pm  up 21 days, 14:04,  23 users
User     tty       login&nbsp; idle   JCPU   PCPU  what
hzuo     ttyV0     8:58pm            9      5  vi p24.tex
hzang    ttyV3     6:37pm    50                -csh
eklye    ttyV5     9:53pm            7      1  em thes.tex
dportein ttyV6     8:17pm  1:47                -csh
gierd    ttyD3    10:00pm     1                elm
dave     ttyD4     9:47pm            4      4  w
brent    ttyp0    26Jun91  4:46  26:46   4:41  bash
dave     ttyq4    26Jun9115days     46     46  wnewmail
</pre></div>

<p>下面的程序使用上面的输入，将空闲时间转换为秒数，并打印输出头两个域并计算空闲时间：
</p>
<div class="example">
<pre class="example">BEGIN  { FIELDWIDTHS = &quot;9 6 10 6 7 7 35&quot; }
NR &gt; 2 {
    idle = $4
    sub(/^ +/, &quot;&quot;, idle)   # strip leading spaces
    if (idle == &quot;&quot;)
        idle = 0
    if (idle ~ /:/) {
        split(idle, t, &quot;:&quot;)
        idle = t[1] * 60 + t[2]
    }
    if (idle ~ /days/)
        idle *= 24 * 60 * 60

    print $1, $2, idle
}
</pre></div>

<blockquote>
<p><b>提示:</b> 上面的程序使用了一些 <code>awk</code> 我们目前还没有讨论的特性。
</p></blockquote>

<p>执行上面的程序，产生了如下输出：
</p>
<div class="example">
<pre class="example">hzuo      ttyV0  0
hzang     ttyV3  50
eklye     ttyV5  0
dportein  ttyV6  107
gierd     ttyD3  1
dave      ttyD4  0
brent     ttyp0  286
dave      ttyq4  1296000
</pre></div>

<p>另一个固定宽度输入数据例子（可能更复杂）是来自于投票站。
在美国的一些地区，投票者会将他们的选择在计算机卡上打上孔。
然后处理这些卡，从而统计特定的候选者或者特定的问题。
由于投票者可以不选择某些问题，因此卡上的某些列可能是空的。
处理这类数据的 <code>awk</code> 程序可以使用 <code>FIELDWIDTHS</code> 特性来简化数据的读取。
（当然，让 <code>gawk</code> 选择在选举卡阅读器上的系统是另一个问题！）
</p>
<a name="index-gawk_002c-splitting-fields-and"></a>
<p>向 <code>FS</code> 赋值会让 <code>gawk</code> 使用 <code>FS</code> 来进行域分割。
使用 &lsquo;<samp>FS = FS</samp>&rsquo; 来完成这样的功能，而不需要知道当前的 <code>FS</code> 值。
为了了解当前正在使用的域分割策略，可以使用 <code>PROCINFO[&quot;FS&quot;]</code>
（查看 <a href="#Auto_002dset">传递信息的内置变量</a>）。
如果是常规的分割策略，则返回的值是 <code>&quot;FS&quot;</code>，
如果是固定宽度的分割策略则返回的是 <code>&quot;FIELDWIDTHS&quot;</code>：
</p>
<div class="example">
<pre class="example">if (PROCINFO[&quot;FS&quot;] == &quot;FS&quot;)
    <var>regular field splitting</var> &hellip;
else if  (PROCINFO[&quot;FS&quot;] == &quot;FIELDWIDTHS&quot;)
    <var>fixed-width field splitting</var> &hellip;
else
    <var>content-based field splitting</var> &hellip; <i>(see next 小节)</i>
</pre></div>

<p>当要写一个需要临时改变 <code>FS</code> 或者 <code>FIELDWIDTHS</code> 策略的函数时，
这个功能则非常有用。这个函数读一些记录后，然后恢复初始配置
（查看 <a href="#Passwd-Functions">读取用户数据库</a>，有这种函数的例子）。
</p>
<hr>
<a name="Splitting-By-Content"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Constant-Size" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Multiple-Line" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_00a5aa_0086_0085aa_00ae_00b9aa_00ae_009aa_00b9_0089aa_009f_009f"></a>
<h2 class="section">4.7 以内容定义域</h2>

<p>本小节中，讨论一个 <code>gawk</code> 的高级特性。如果你是一 <code>awk</code> 新手，第一次阅读时，你可以路过这一节。
</p>
<a name="index-advanced-features_002c-specifying-field-content"></a>
<p>通常情况下，当使用 <code>FS</code> 策略时，<code>gawk</code> 将域定义为记录的一部份，它们出现在每个域分割符之间。
换言之，<code>FS</code> 定义了域<em>不是什么</em>，而不是域<em>是什么</em>。
但是，有那么一些时候，你确实需要按照域是什么来定义它们，而不是它们不是什么来定义。
</p>
<p>最臭的例子就是所谓的<em>逗号分隔</em>数据（CSV）。
许多的表单程序，都可以将他们的数据输出为文本文件，
这些记录都以换行符结束，同时通过逗号分隔。
如果只有逗号来分割数据，这个就不是问题。
问题是，当其中的某个域中<em>有</em>逗号时。
在这样的状况下，大多数据的程序都将域用双引号引起来。
<a name="DOCF29" href="#FOOT29">(29)</a>
所以，我们可能有如下这样的数据：
</p>
<div class="example">
<pre class="example">Robbins,Arnold,&quot;1234 A Pretty Street, NE&quot;,MyTown,MyState,12345-6789,USA
</pre></div>

<a name="index-gawk_002c-FPAT-variable-in"></a>
<a name="index-FPAT-variable"></a>
<p><code>FPAT</code> 变量为这样的问题提供了解决方案。<code>FPAT</code> 的值应该是一个正则表达式字串。这个表达式描述了每个域的内容。
</p>
<p>在上面所列的 CSV 数据中，
每个域要么是“一切都不是逗号，”或者“一个双引号，一切不是双引号，一个闭双引号。”
如果写这样的一个正则表达式常量（查看 <a href="#Regexp">正则表达式</a>），
我们有这样的正则表达式 <code>/([^,]+)|(&quot;[^&quot;]+&quot;)/</code>。
把这个正则表达式作为字符串，需要我们转义其中的双引号，于是它就变成了这样：
</p>
<div class="example">
<pre class="example">FPAT = &quot;([^,]+)|(\&quot;[^\&quot;]+\&quot;)&quot;
</pre></div>

<p>是骡子是马，拉出来溜溜，这是来分析上面数据的简单程序：
</p>
<div class="example">
<pre class="example">BEGIN {
    FPAT = &quot;([^,]+)|(\&quot;[^\&quot;]+\&quot;)&quot;
}

{
    print &quot;NF = &quot;, NF
    for (i = 1; i &lt;= NF; i++) {
        printf(&quot;$%d = &lt;%s&gt;\n&quot;, i, $i)
    }
}
</pre></div>

<p>当运行时，我们可以得到下面的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f simple-csv.awk addresses.csv</kbd>
NF =  7
$1 = &lt;Robbins&gt;
$2 = &lt;Arnold&gt;
$3 = &lt;&quot;1234 A Pretty Street, NE&quot;&gt;
$4 = &lt;MyTown&gt;
$5 = &lt;MyState&gt;
$6 = &lt;12345-6789&gt;
$7 = &lt;USA&gt;
</pre></div>

<p>注意含在 <code>$3</code> 里的逗号。
</p>
<p>这种处理 CSV 数据类型的直接提升是在双引号出现时，会自动移除它们，如像这样的：
</p>
<div class="example">
<pre class="example">if (substr($i, 1, 1) == &quot;\&quot;&quot;) {
    len = length($i)
    $i = substr($i, 2, len - 2)    # Get text within the two quotes
}
</pre></div>

<p>与 <code>FS</code> 一起，<code>IGNORECASE</code> 变量会影响 <code>FPAT</code> 类型的域分割策略
（查看 <a href="#User_002dmodified">控制 <code>awk</code> 的内置变量</a>）。
</p>
<p>给 <code>FPAT</code> 赋值，会覆盖 <code>FS</code> 与 <code>FIELDWIDTHS</code> 策略。
与 <code>FIELDWIDTHS</code>, 中的 <code>PROCINFO[&quot;FS&quot;]</code> 的值类似，
如果采用的是基于内容的域分割策略，其值将是 <code>&quot;FPAT&quot;</code>。
</p>
<blockquote>
<p><b>提示:</b> 有一些程序输出的 CSV 数据会包含换行符在双引号之间。
<code>gawk</code> 没办法处理这个问题。就算是符号正规的 CSV 规范的数据，也无能为力。
<code>FPAT</code> 机制为大多数情形提供了一种优雅的解决方法，<code>gawk</code> 的开发者对此也非常满意。
</p></blockquote>

<p>正如所写的，<code>FPAT</code> 所使用的正则表达式，要示每个域包含至少一个字符。直接更改（更改第一个 &lsquo;<samp>+</samp>&rsquo; 为 &lsquo;<samp>*</samp>&rsquo;）允许域可为空：
</p>
<div class="example">
<pre class="example">FPAT = &quot;([^,]*)|(\&quot;[^\&quot;]+\&quot;)&quot;
</pre></div>


<p>最后，<code>patsplit()</code> 函数也实现相同的功能，
用来对常规的字符进行分割（查看 <a href="#String-Functions">字串操作函数</a>）。
</p>
<p>总结一下，<code>gawk</code> 提供三种独立的方法来将输入记录分割成记录。
这些机制通过三个变量来实现，即 <code>FS</code>，<code>FIELDWIDTHS</code>，或者 <code>FPAT</code>，
谁最后被赋值，则采用相应的对应的机制。
</p>
<hr>
<a name="Multiple-Line"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Splitting-By-Content" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a4_009ae_00a1_008ce_00ae_00b0aa_00bd_0095"></a>
<h2 class="section">4.8 多行记录</h2>

<a name="index-multiple_002dline-records"></a>
<a name="index-records_002c-multiline"></a>
<a name="index-input_002c-multiline-records"></a>
<a name="index-files_002c-reading_002c-multiline-records"></a>
<a name="index-input_002c-files_002c-See-input-files"></a>
<p>在一些数据中，单行无法方便地包含所有的信息在一个项中。在这样的情况下，你可以使用多行记录。实现这个方式的第一步是选择你的数据格式。
</p>
<a name="index-record-separators_002c-with-multiline-records"></a>
<p>其中一个技巧是使用一个不常用的字符或者字串来分割数据。
例如，你可以使用换页符（在 <code>awk</code> 中写成 &lsquo;<samp>\f</samp>&rsquo;，同 C 语言）来分割他们，
使得每个记录是文件中的一个页。
接着，将变量 <code>RS</code> 的值设置成 &lsquo;<samp>\f</samp>&rsquo;（只包含一个换页符的字串）。
任意其他的字符也是可以用的，只要它们不是记录数据的一部分。
</p>
<a name="index-RS-variable_002c-multiline-records-and"></a>
<p>另一个技巧是用一个空行来分隔记录，然后通过一个特殊的值，即一个空串赋值给 <code>RS</code>，
以提示记录是通过一个或者多个空行来进行分隔的。
当 <code>RS</code> 被设置成空串，每条记录就是结束于第一个空行。下一个记录直到后续遇到的第一个非空行开始。不管在行中出现多少空行，它们都实际分隔一个记录。（空行必须是完全空的，包含空格的也不算。）
</p>
<a name="index-leftmost-longest-match"></a>
<a name="index-matching_002c-leftmost-longest"></a>
<p>你可以通过将串 <code>&quot;\n\n+&quot;</code> 赋值给 <code>RS</code>，取得与 &lsquo;<samp>RS = &quot;&quot;</samp>&rsquo; 一样的效果。
这个正则表达式匹配记录结尾一个到多个换行符。
另外，正则表达式总是匹配最长的可能序列（查看 <a href="#Leftmost-Longest">匹配多少？</a>）。
因此，下一个记录开始于后续的第一个非空行，不管一行中出现多少的空行，他们都会认为是一个记录分隔符。
</p>
<a name="index-dark-corner_002c-multiline-records"></a>
<p>但是，&lsquo;<samp>RS = &quot;&quot;</samp>&rsquo; 与 &lsquo;<samp>RS = &quot;\n\n+&quot;</samp>&rsquo; 两者之间有一个重要的差别。
第一个情形下，输入的数据文件的前导空行会被忽略，并且如果文件的最后一条记录后面没有额外的一个空行，最后的换行符会被从记录中删除。但是在第二种情况下，这个特殊处理过程不会执行。
(d.c.)
</p>
<a name="index-field-separator_002c-in-multiline-records"></a>
<a name="index-FS_002c-in-multiline-records"></a>
<p>现在，输入已经被分割成记录，第二步是将记录分割成域。
一种方法是用通常的方式是将记录分割成域。
在下面这种特殊情况下，这是一种默认处理方式。
当 <code>RS</code> 被设置成了空串，<em>并且</em> <code>FS</code> 被设置成单个字符的时候，换行符总是被作为域分隔符。
无论由 <code>FS</code> 分割的结果是什么，这都会被加入最终的域分割结果里面。
<a name="DOCF30" href="#FOOT30">(30)</a>
</p>
<p>这个特殊的例外的原始动机可能是为了提供在默认场景下有用的行为（例如 <code>FS</code> 等于 <code>&quot;&nbsp;&quot;</code> 时）。当
你确实不想用换行符来分隔域时，这个特性可能就会有问题，因为没有方法可以避免它。
但是，你可以通过 <code>split()</code> 函数来手工分解记录来修复这个问题
（查看 <a href="#String-Functions">字串操作函数</a>）。
如果你有一个单字符的域分隔符，你可以用另外一种方式来解决这个特性带来的问题，只需要将 <code>FS</code> 设置成这个单字符的正则表达式。
例如，如果域分隔符是一个百号，要使用 &lsquo;<samp>FS = &quot;%&quot;</samp>&rsquo;，而不要使用 &lsquo;<samp>FS = &quot;[%]&quot;</samp>&rsquo;。
</p>
<p>对域进行分割的另外一个方法是将每个域放在一个行中：为了实现这个功能，只需要将变量 <code>FS</code> 设置成字串 <code>&quot;\n&quot;</code>。
（这个单字符分隔符匹配一个换行符。）一个实际的以这种方式进行组织的数据文件可能就是邮件列表，
在这个列表中，空行用来分隔项目。考虑一个名字为 &lsquo;<tt>addresses</tt>&rsquo; 的邮件列表，看起来像下面这样：
</p>
<div class="example">
<pre class="example">Jane Doe
123 Main Street
Anywhere, SE 12345-6789

John Smith
456 Tree-lined Avenue
Smallville, MW 98765-4321
&hellip;
</pre></div>

<p>下面则是一个处理该文件的简单的程序：
</p>
<div class="example">
<pre class="example"># addrs.awk --- simple mailing list program

# Records are separated by blank lines.
# Each line is one field.
BEGIN { RS = &quot;&quot; ; FS = &quot;\n&quot; }

{
      print &quot;Name is:&quot;, $1
      print &quot;Address is:&quot;, $2
      print &quot;City and State are:&quot;, $3
      print &quot;&quot;
}
</pre></div>

<p>执行后，产生如下的输出：
</p>
<div class="example">
<pre class="example">$ <kbd>awk -f addrs.awk addresses</kbd>
-| Name is: Jane Doe
-| Address is: 123 Main Street
-| City and State are: Anywhere, SE 12345-6789
-|
-| Name is: John Smith
-| Address is: 456 Tree-lined Avenue
-| City and State are: Smallville, MW 98765-4321
-|
&hellip;
</pre></div>

<p>在 <a href="#Labels-Program">打印邮件标题</a>，查看一个更实际的程序来处理邮件列表。
下面的列表总结了记录基于 
<code>RS</code>
 的值的记录分割方式：
</p>
<dl compact="compact">
<dt><code>RS == &quot;\n&quot;</code></dt>
<dd><p>记录通过换来符来进行分割（&lsquo;<samp>\n</samp>&rsquo;）。
在效果上，数据文件中的每一行都是一个记录，包括空行。这是默认行为。
</p>
</dd>
<dt><code>RS == <var>任意单独字符</var></code></dt>
<dd><p>记录通过字符来进行分割。多个连续的字符会分割出空记录。
</p>
</dd>
<dt><code>RS == &quot;&quot;</code></dt>
<dd><p>记录通过一连串的空行进行分割。当 <code>FS</code> 是一个单独的字符时，则换行符总会表现为域分隔符，
不管 <code>FS</code> 有什么样的值。文件的头尾的换行符会被忽略掉。
</p>
</dd>
<dt><code>RS == <var>regexp</var></code></dt>
<dd><p>记录通过匹配 <var>regexp</var> 正则表达式的字符串来进行分割。
文件头尾的空行会分割出空的记录。（这是 <code>gawk</code> 的扩展；在 POSIX 中没有对这种情形进行定义。）
</p></dd>
</dl>

<a name="index-gawk_002c-RT-variable-in-1"></a>
<a name="index-RT-variable-1"></a>
<p>如果不是在兼容模式下（查看 <a href="#Options">命令行参数</a>），
<code>gawk</code> 设置 <code>RT</code> 的值为输入数据中匹配由 <code>RS</code> 指定的值的文本。
但是，如果输入文件结束输入而没有匹配 <code>RS</code>，则 <code>gawk</code> 会将 <code>RT</code> 的值设置成空串。
</p>
<hr>
<a name="Getline"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Multiple-Line" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Plain-Getline" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_00a8-getline-e_00be_0093aa_0085_00a5ae_0095_00b0ae_008d_00ae"></a>
<h2 class="section">4.9 用 <code>getline</code> 输入数据</h2>

<a name="index-getline-command_002c-explicit-input-with"></a>
<a name="index-input_002c-explicit"></a>
<p>到目前为止，我们都是从 <code>awk</code> 的主要输入流中获取数据，
要么是标准输入（通常是你的键盘，有时是其他程序的输出）或者通过命令行指定的文件。
<code>awk</code> 语言有一个特殊的内建命令 <code>getline</code> 可以用来显式地在你的控制下读取输入。
</p>
<p><code>getline</code> 命令有几种不同的使用方式，并且初学者最好<em>不要</em>使用。
下面的 <code>getline</code> 使用例子以及相应的解释包括了一些目前还没有涉及的知识。
因此，当你阅读了
本网页
的剩下的部分<em>之后</em>，再回过头来学习 <code>getline</code> ，
则你会更了解 <code>awk</code> 是如何进行工作的。
</p>
<a name="index-gawk_002c-ERRNO-variable-in"></a>
<a name="index-ERRNO-variable_002c-with-getline-command"></a>
<a name="index-differences-in-awk-and-gawk_002c-getline-command"></a>
<a name="index-getline-command_002c-return-values"></a>
<a name="index-_002d_002dsandbox-option_002c-input-redirection-with-getline"></a>

<p><code>getline</code> 命令查看到一个记录时则返回 1， 如果遇到文件结束时则返回 0。
如果在读取数据时发生了错误，如文件不能被打开，则 <code>getline</code> 返回 -1。
在这个情况下，<code>gawk</code> 将变量 <code>ERRNO</code> 的值设置成所遇到的错误的描述字串。
</p>
<p>在下面的例子中，<var>command</var> 代表 shell 命令的字串值。
</p>
<blockquote>
<p><b>提示:</b> 当 &lsquo;<samp>--sandbox</samp>&rsquo; 指定时（查看 <a href="#Options">命令行参数</a>），从文件，管道或者并程 中读取行数据是被禁止的。
</p></blockquote>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Plain-Getline">4.9.1 不带参数调用 <code>getline</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Using <code>getline</code> with no arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fVariable">4.9.2 将 <code>getline</code> 赋值给变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Using <code>getline</code> into a variable.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Using <code>getline</code> from a file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fVariable_002fFile">4.9.4 从文件中 <code>getline</code> 到变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Using <code>getline</code> into a variable from a
                                file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Using <code>getline</code> from a pipe.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fVariable_002fPipe">4.9.6 从管道中 <code>getline</code> 到变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Using <code>getline</code> into a variable from a
                                pipe.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Using <code>getline</code> from a coprocess.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline_002fVariable_002fCoprocess">4.9.8 使用并程 <code>getline</code> 到变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Using <code>getline</code> into a variable from a
                                coprocess.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Important things to know about <code>getline</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getline-Summary">4.9.10 <code>getline</code> 变体总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Summary of <code>getline</code> Variants.
</td></tr>
</table>

<hr>
<a name="Plain-Getline"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fVariable" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_008daa_00b8_00a6aa_008f_0082ae_0095_00b0e_00b0_0083c_0094_00a8-getline"></a>
<h3 class="subsection">4.9.1 不带参数调用 <code>getline</code></h3>

<p><code>getline</code> 命令可以不带参数来从当前文件中读取输入。
在这种情形下，就是读取下一个输入记录并将其分割为域。当你已经完成当前记录的处理，
但是对于下一个记录想<em>马上</em>做一些处理的情况下非常有用。例如：
</p>
<div class="example">
<pre class="example"># Remove text between /* and */, inclusive
{
    if ((i = index($0, &quot;/*&quot;)) != 0) {
        out = substr($0, 1, i - 1)  # leading part of the string
        rest = substr($0, i + 2)    # ... */ ...
        j = index(rest, &quot;*/&quot;)       # is */ in trailing part?
        if (j &gt; 0) {
            rest = substr(rest, j + 2)  # remove comment
        } else {
            while (j == 0) {
                # get more text
                if (getline &lt;= 0) {
                    print(&quot;unexpected EOF or error:&quot;, ERRNO) &gt; &quot;/dev/stderr&quot;
                    exit
                }
                # build up the line using string concatenation
                rest = rest $0
                j = index(rest, &quot;*/&quot;)   # is */ in trailing part?
                if (j != 0) {
                    rest = substr(rest, j + 2)
                    break
                }
            }
        }
        # build up the output line using string concatenation
        $0 = out rest
    }
    print $0
}
</pre></div>


<p>这个 <code>awk</code> 程序从输入中删除 C 风格的注释（&lsquo;<samp>/* &hellip; */</samp>&rsquo;）。
其中用到的一些特性我们还没有讲到，包括字串合并
（查看 <a href="#Concatenation">字串连接</a>），
以及 <code>index()</code>，<code>substr()</code> 内建函数等
（查看 <a href="#String-Functions">字串操作函数</a>）。
通过替换 &lsquo;<samp>print $0</samp>&rsquo; 为其他的语句，你可以执行更为复杂的从输入中删除注释的处理，例如搜索正则表达式等。
（这个程序有一个很微小的细节——就是如果一个注释在本行结束，同时在同一行又开启另一个注释，这个程序不会生效。）
</p>
<p>这种使用 <code>getline</code> 的方式，会设置 <code>$0</code> 的 <code>NF</code>，<code>NR</code>，<code>FNR</code>，<code>RT</code> 变量。
</p>
<blockquote>
<p><b>提示:</b> <code>$0</code> 的新值用于测试接所有接下来的模式。
<code>$0</code> 在触发执行 <code>getline</code> 调用的规则的最初始就会丢失。
另一方面，<code>next</code> 语句读取一个新的记录，并且立即从程序中的第一个规则开始处理它。
查看 <a href="#Next-Statement"><code>next</code> 语句</a>。
</p></blockquote>
<hr>
<a name="Getline_002fVariable"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Plain-Getline" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fFile" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b0_0086-getline-e_00b5_008baa_0080_00bcc_00bb_0099aa_008f_0098e_0087_008f"></a>
<h3 class="subsection">4.9.2 将 <code>getline</code> 赋值给变量</h3>
<a name="index-getline-into-a-variable"></a>
<a name="index-variables_002c-getline-command-into_002c-using"></a>

<p>你也可以使用 &lsquo;<samp>getline <var>var</var></samp>&rsquo; 将从 <code>awk</code> 的输入的下一个记录赋值给一个变量。
这没有做任何针对数据的处理。例如，假设下一行是一个注释或者一个特殊字串，你想读取它的同时，不触发任何规则。
这种形式的 <code>getline</code> 调用可以让你读取行并且将其存在一个变量中，
因此，主循环中 read-a-line-and-check-each-rule（读取一行并检查每个规则）的 <code>awk</code> 循环就看不到这个记录了。
下面的例子交换输入中的两行：
</p>
<div class="example">
<pre class="example">{
     if ((getline tmp) &gt; 0) {
          print tmp
          print $0
     } else
          print $0
}
</pre></div>

<p>例子中使用下面的输入：
</p>
<div class="example">
<pre class="example">wan
tew
free
phore
</pre></div>

<p>并产生如下的结果：
</p>
<div class="example">
<pre class="example">tew
wan
phore
free
</pre></div>

<p>这么使用 <code>getline</code> 命令仅设置变量 <code>NR</code>，<code>FNR</code> 以及 <code>RT</code>（当然还有变量 <var>var</var>）。
记录不会被分割成域，因此域的值（包括 <code>$0</code>）以及 <code>NF</code> 的值都不会改变。
</p>
<hr>
<a name="Getline_002fFile"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fVariable" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fVariable_002fFile" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8-getline-e_00af_00bbaa_008f_0096ae_0096_0087a_00bb_00b6"></a>
<h3 class="subsection">4.9.3 使用 <code>getline</code> 读取文件</h3>

<a name="index-getline-from-a-file"></a>
<a name="index-input-redirection"></a>
<a name="index-redirection-of-input"></a>
<a name="index-_003c-_0028left-angle-bracket_0029_002c-_003c-operator-_0028I_002fO_0029"></a>
<a name="index-left-angle-bracket-_0028_003c_0029_002c-_003c-operator-_0028I_002fO_0029"></a>
<a name="index-operators_002c-input_002foutput"></a>
<p>使用 &lsquo;<samp>getline &lt; <var>file</var></samp>&rsquo; 来从 <var>file</var> 中读取记录。
在这里，<var>file</var> 是一个求值为字串的表达式，并用其指定文件名。
&lsquo;<samp>&lt; <var>file</var></samp>&rsquo; 称为重定向，因为它将输入定向为另一个不同的位置。
例如，下面的程序当它遇到从当前输入文件输入的记录中的第一个域的值为 10 时，
则从文件 &lsquo;<tt>secondary.input</tt>&rsquo; 中读取输入记录：
Here, <var>file</var> is a string-valued expression that
</p>
<div class="example">
<pre class="example">{
    if ($1 == 10) {
         getline &lt; &quot;secondary.input&quot;
         print
    } else
         print
}
</pre></div>

<p>由于主输入流没有被使用，变量 <code>NR</code> 以及 <code>FNR</code> 的值是不会改变的。但是，它所读取的记录会被正常地分割成域，
因此 <code>$0</code> 以及其他域的值是会改变的，因此导致 <code>NF</code> 与 <code>RT</code> 的值是会改变的。
</p>
<a name="index-POSIX-awk_002c-_003c-operator-and"></a>
<p>根据 POSIX 标准，&lsquo;<samp>getline &lt; <var>expression</var></samp>&rsquo; 如果 &lsquo;<samp>$</samp>&rsquo; 中包含未括起来的除 &lsquo;<samp>$</samp>&rsquo; 的操作符时，
则会产生歧义。例如 &lsquo;<samp>getline &lt; dir &quot;/&quot; file</samp>&rsquo; 就是有歧义的，因为连接操作符
（还未讨论到，查看 <a href="#Concatenation">字串连接</a>）是没有被括起来的。
如果你的程序要能够移植到所有的 <code>awk</code> 实现中，你应该这么写 &lsquo;<samp>getline &lt; (dir &quot;/&quot; file)</samp>&rsquo;。
</p>
<hr>
<a name="Getline_002fVariable_002fFile"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fFile" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fPipe" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008eae_0096_0087a_00bb_00b6a_00b8_00ad-getline-aa_0088_00b0aa_008f_0098e_0087_008f"></a>
<h3 class="subsection">4.9.4 从文件中 <code>getline</code> 到变量</h3>
<a name="index-variables_002c-getline-command-into_002c-using-1"></a>

<p>使用 &lsquo;<samp>getline <var>var</var> &lt; <var>file</var></samp>&rsquo; 来从文件 <var>file</var> 中读取输入，
并且将其存放在变量 <var>var</var> 中。如前所示，文件 <var>file</var> 是一个求值为字串的变量，结果中包括要被读取的文件。
</p>
<p>在这个版本的 <code>getline</code> 中，没有一个预定义的变量会改变，记录也不会被分割成域。
唯一改变的就是 <var>var</var> 变量。
<a name="DOCF31" href="#FOOT31">(31)</a>
例如，下面的程序复制所有的输入文件到输出，除了如果记录内容为 &lsquo;<samp>@include&nbsp;<var>filename</var></samp>&rsquo;。
这样的记录会被文件 <var>filename</var> 替换：
</p>
<div class="example">
<pre class="example">{
     if (NF == 2 &amp;&amp; $1 == &quot;@include&quot;) {
          while ((getline line &lt; $2) &gt; 0)
               print line
          close($2)
     } else
          print
}
</pre></div>

<p>注意这里的另外的输入文件的名字是如何构建到程序中的；
它是直接从数据中来的，通过 <code>@include</code> 行的第 2 个域来指定的。
</p>
<p><code>close()</code> 函数的调用是为了保证如果 <code>@include</code> 在输入文件中出现两次，文件的内容也会被指定两次。
查看 <a href="#Close-Files-And-Pipes">关闭输入输出重定向</a>。
</p>
<p>这个程序的不足就是不能处理内嵌 <code>@include</code> 的情况
（例如，<code>@include</code> 语句包含在被包含的文件中），
如一个真正的宏处理器所执行的功能。在 <a href="#Igawk-Program">使用库函数的简单方式</a>，查看处理内嵌 <code>@include</code> 语句的程序。
</p>
<hr>
<a name="Getline_002fPipe"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fVariable_002fFile" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fVariable_002fPipe" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008ec_00ae_00a1e_0081_0093a_00b8_00ada_00bd_00bfc_0094_00a8-getline"></a>
<h3 class="subsection">4.9.5 从管道中使用 <code>getline</code></h3>

<a name="index-Kernighan_002c-Brian-3"></a>
<blockquote>
<p><i>
全知全能太遥远，还是关注细节更有用。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Brian Kernighan</em>
</p>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c-operator-_0028I_002fO_0029"></a>
<a name="index-vertical-bar-_0028_007c_0029_002c-_007c-operator-_0028I_002fO_0029"></a>
<a name="index-input-pipeline"></a>
<a name="index-pipe_002c-input"></a>
<a name="index-operators_002c-input_002foutput-1"></a>
<p>命令的输入也可以被通过使用 &lsquo;<samp><var>command</var> | getline</samp>&rsquo; 来以管道输出给 <code>getline</code>。
在这种情形中，<var>command</var> 是一个 Shell 命令，
同时，它的输出会被以管道形式输出给 <code>awk</code> 来作为输入。这种形式的 <code>getline</code> 从管道中一次读取一个记录。
如，下面的程序复制它的输入到输出中，排除那些以 &lsquo;<samp>@execute</samp>&rsquo; 开头的行，这些行会被替换为将行的剩下的内容当做 Shell 命令执行时产生的输出：
</p>
<div class="example">
<pre class="example">{
     if ($1 == &quot;@execute&quot;) {
          tmp = substr($0, 10)        # Remove &quot;@execute&quot;
          while ((tmp | getline) &gt; 0)
               print
          close(tmp)
     } else
          print
}
</pre></div>

<p><code>close()</code> 函数保证两个相同的 &lsquo;<samp>@execute</samp>&rsquo; 行，命令会执行相应次数。
查看 <a href="#Close-Files-And-Pipes">关闭输入输出重定向</a>。
假设有下面的输入：
</p>
<div class="example">
<pre class="example">foo
bar
baz
@execute who
bletch
</pre></div>

<p>程序可能产生如下的输出：
</p>
<a name="index-Robbins_002c-Bill"></a>
<a name="index-Robbins_002c-Miriam-1"></a>
<a name="index-Robbins_002c-Arnold-1"></a>
<div class="example">
<pre class="example">foo
bar
baz
arnold     ttyv0   Jul 13 14:22
miriam     ttyp0   Jul 13 14:23     (murphy:0)
bill       ttyp1   Jul 13 14:23     (murphy:0)
bletch
</pre></div>

<p>注意这个程序会执行命令 <code>who</code> 然后打印出结果。
（如果你测试这个程序，你可能会得到不同的结果，这依赖于你所登入的系统。）
</p>
<p>这样的 <code>getline</code> 形式会将记录分割成域，并设置 <code>NF</code> 的值，并重新计算 <code>$0</code> 的值。<code>NR</code> 与 <code>FNR</code> 的值不会改变，<code>RT</code> 的值则会被设置。
</p>
<a name="index-POSIX-awk_002c-_007c-I_002fO-operator-and"></a>
<p>根据 POSIX 标准，&lsquo;<samp><var>expression</var> | getline</samp>&rsquo; 表达式中，
如果 <var>expression</var> 包含了未被括起来的除 &lsquo;<samp>$</samp>&rsquo; 之外的操作符时，则会是有歧义的。
例如，&lsquo;<samp>&quot;echo&nbsp;&quot; &quot;date&quot; | getline</samp>&rsquo; 由于连接操作符没有被括起来， 因此这个语句是有歧义的。
如果你想你的程序可以有移植到所有的 <code>awk</code> 实现里，你应该这么写： &lsquo;<samp>(&quot;echo&nbsp;&quot; &quot;date&quot;) | getline</samp>&rsquo;。
</p>
<a name="index-Brian-Kernighan_0027s-awk-4"></a>
<a name="index-mawk-utility-1"></a>
<blockquote>
<p><b>提示:</b> 不幸的是，<code>gawk</code> 在对待像这样的结构 &lsquo;<samp>&quot;echo&nbsp;&quot; &quot;date&quot; | getline</samp>&rsquo; 时是不一致的。
大多数的版本，包括目前的版本，都将其看成 &lsquo;<samp>(&quot;echo&nbsp;&quot; &quot;date&quot;) | getline</samp>&rsquo;。
（这也是 BWK <code>awk</code> 的行为）
有一些版本则会将其看成 &lsquo;<samp>&quot;echo&nbsp;&quot; (&quot;date&quot; | getline)</samp>&rsquo;。（这是 <code>mawk</code> 的行为）
简单地说。显式地使用括号，就不用担心这些问题。
</p></blockquote>

<hr>
<a name="Getline_002fVariable_002fPipe"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fPipe" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fCoprocess" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008ec_00ae_00a1e_0081_0093a_00b8_00ad-getline-aa_0088_00b0aa_008f_0098e_0087_008f"></a>
<h3 class="subsection">4.9.6 从管道中 <code>getline</code> 到变量</h3>
<a name="index-variables_002c-getline-command-into_002c-using-2"></a>

<p>当使用 &lsquo;<samp><var>command</var> | getline <var>var</var></samp>&rsquo; 这种形式，即 <var>command</var> 命令的输出通过管道发送给 <code>getline</code>，
并将其存储在变量 <var>var</var> 中。例如，下面的程序利用 <code>date</code> 工具，
读取当前的日期与时间到变量 <code>current_time</code> 中，然后打印它：
</p>
<div class="example">
<pre class="example">BEGIN {
     &quot;date&quot; | getline current_time
     close(&quot;date&quot;)
     print &quot;Report printed on &quot; current_time
}
</pre></div>

<p>在这个版本的 <code>getline</code> 中，没有任何预定义的变量会改变，记录也不会分割成域，但是 <code>RT</code> 会被设定。
</p>

<hr>
<a name="Getline_002fCoprocess"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fVariable_002fPipe" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fVariable_002fCoprocess" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008eaa_00b9_00b6c_00a8_008ba_00b8_00ada_00bd_00bfc_0094_00a8-getline"></a>
<h3 class="subsection">4.9.7 从并程中使用 <code>getline</code></h3>
<a name="index-coprocesses_002c-getline-from"></a>
<a name="index-getline-command_002c-coprocesses_002c-using-from"></a>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029"></a>
<a name="index-vertical-bar-_0028_007c_0029_002c-_007c_0026-operator-_0028I_002fO_0029"></a>
<a name="index-operators_002c-input_002foutput-2"></a>
<a name="index-differences-in-awk-and-gawk_002c-input_002foutput-operators"></a>

<p>从管道中 <code>getline</code> 读取输入是单向操作。
通过 &lsquo;<samp><var>command</var> | getline</samp>&rsquo; 启动的命令 command 只会将数据发送<em>到</em>你的 <code>awk</code> 程序。
</p>
<p>有时候，你可能会想发送数据到另一个程序用于处理，并将结果返回来。
<code>gawk</code> 可以启动一个<em>并程</em>，同时允许双向通信。
这是通过 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符来实现的。典型的情况中，你首先将数据写到并程中，然后将结果读取回来，如下面所示：
</p>
<div class="example">
<pre class="example">print &quot;<var>some query</var>&quot; |&amp; &quot;db_server&quot;
&quot;db_server&quot; |&amp; getline
</pre></div>

<p>上面的例子中将请求发送到 <code>db_server</code> 中然后读取结果。
</p>
<p><code>NR</code> 与 <code>FNR</code> 的值不会变更，因为主输入流没有被使用。但是，记录会按正常方式分割成域，因此会改变 <code>$0</code> 的值，其他域的值，以及 <code>NF</code> 跟 <code>RT</code> 的值。
</p>
<p>并程是一个高级特性。在这里讨论是因为这小节跟 <code>getline</code> 有关。
查看 <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>，这里并程会更讨论得更深入一些。
</p>
<hr>
<a name="Getline_002fVariable_002fCoprocess"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fCoprocess" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline-Notes" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8aa_00b9_00b6c_00a8_008b-getline-aa_0088_00b0aa_008f_0098e_0087_008f"></a>
<h3 class="subsection">4.9.8 使用并程 <code>getline</code> 到变量</h3>
<a name="index-variables_002c-getline-command-into_002c-using-3"></a>

<p>当你使用 &lsquo;<samp><var>command</var> |&amp; getline <var>var</var></samp>&rsquo;，
并程 <var>command</var> 的输出会通过一个双向管斗管道发送到 <code>getline</code> 中，并保存在变量 <var>var</var> 中。
</p>
<p>在这个版本的 <code>getline</code> 中，没有任何预定义的变量会改变，记录也不会分割成域。
唯一变化的是变量 <var>var</var>，但是 <code>RT</code> 的值会被设定。
</p>

<hr>
<a name="Getline-Notes"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline_002fVariable_002fCoprocess" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getline-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009b_009ee_00a1_00be-getline"></a>
<h3 class="subsection">4.9.9 回顾 <code>getline</code></h3>
<p>这下面有几点关于 <code>getline</code> 的内容需要留意：
</p>
<ul>
<li>
当 <code>getline</code> 改变了 <code>$0</code> 与 <code>NF</code> 的值时，<code>awk</code> 不会自动跳到程序的开始并测试新的记录与模式。但是新的记录会匹配任意后后续规则。

<a name="index-differences-in-awk-and-gawk_002c-implementation-limitations"></a>
<a name="index-implementation-issues_002c-gawk_002c-limits"></a>
<a name="index-awk_002c-implementations_002c-limits"></a>
<a name="index-gawk_002c-implementation-issues_002c-limits"></a>
</li><li>
一些非常老的 <code>awk</code> 实现限制了 <code>awk</code> 程序可以打开的管线的数量就是 1 个。
在 <code>gawk</code> 中，没有这样的限制。你可以打开你想要的在操作系统限制下的管线（以及并程）数量。

<a name="index-side-effects_002c-FILENAME-variable"></a>
<a name="index-FILENAME-variable_002c-getline_002c-setting-with"></a>
<a name="index-dark-corner_002c-FILENAME-variable"></a>
<a name="index-getline-command_002c-FILENAME-variable-and"></a>
<a name="index-BEGIN-pattern_002c-getline-and"></a>
</li><li>
如果你在 <code>BEGIN</code> 规则中使用 <code>getline</code> 而没有重定向符，则会出现一个有趣的副作用。
由于一个未重定向的 <code>getline</code> 会从命令行中的数据文件中读取数据，
第一个 <code>getline</code> 命令会导致 <code>awk</code> 设置 <code>FILENAME</code> 的值。
正常情况下。<code>FILENAME</code> 不会在 <code>BEGIN</code> 规则内有值，由于你还没有开始处理命令行数据文件。
(d.c.)
（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a> 与 <a href="#Auto_002dset">传递信息的内置变量</a>。）

</li><li>
在 <code>getline</code> 中使用 <code>FILENAME</code>（&lsquo;<samp>getline &lt; FILENAME</samp>&rsquo;）有可能导致困惑。
<code>awk</code> 利用当前文件打开一个独立的输入流。
但是不通过使用变量，<code>$0</code> 与 <code>NF</code> 的值也还会改变。
如果你这么做，有可能是偶然，你应该重新考虑你到底想要什么结果。

</li><li>
<a href="#Getline-Summary"><code>getline</code> 变体总结</a>，
提供了 <code>getline</code> 不同变体及在相应情况下受影响的变量的总结表。
也值得注意，那些变体不使用重定向，如果导致了 <code>awk</code> 重新读取一个新的输入文件，也可以导致 <code>FILENAME</code> 的更新。

</li><li>
<a name="index-Moore_002c-Duncan"></a>
如果正在被赋值的变量是一个带副效应的表达式，则不同的 <code>awk</code> 版本会有不同的表现。
这依赖于怎样碰到“end-of-file”。
一些版本中不这些表达式不生效；许多版本（包括 <code>gawk</code>）会生效。
这是一个例子，感谢Duncan Moore：


<div class="example">
<pre class="example">BEGIN {
    system(&quot;echo 1 &gt; f&quot;)
    while ((getline a[++c] &lt; &quot;f&quot;) &gt; 0) { }
    print c
}
</pre></div>

<p>这里，副效应是 &lsquo;<samp>++c</samp>&rsquo; 。如果文件结束时，<code>c</code> 是否是在 <code>a</code> 的元素被赋值之前进行递增么？
</p>
<p><code>gawk</code> 将 <code>getline</code> 按照函数调用来对待，并在尝试读取 &lsquo;<tt>f</tt>&rsquo; 之前对表达式 &lsquo;<samp>a[++c]</samp>&rsquo; 进行求值。
但是，在 <code>awk</code> 的某些版本中，当它知道有字串值要进行赋值时，才会对表达式求值。
</p></li></ul>

<hr>
<a name="Getline-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline-Notes" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Read-Timeout" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="getline-aa_008f_0098a_00bd_0093ae_0080_00bbc_00bb_0093"></a>
<h3 class="subsection">4.9.10 <code>getline</code> 变体总结</h3>
<a name="index-getline-command_002c-variants"></a>

<p><a href="#table_002dgetline_002dvariants">Table 4.1</a> 总结了 <code>getline</code> 的8个变体，并列举了在每种变体下会被设置的预定义变量，以及变体是否是 <code>gawk</code> 的标准扩展。
提示：对每个变体，<code>gawk</code> 都会设置预定义变量 <code>RT</code>。
</p>
<div class="float"><a name="table_002dgetline_002dvariants"></a>

<table>
<thead><tr><th width="33%">Variant</th><th width="38%">Effect</th><th width="27%"><code>awk</code> / <code>gawk</code></th></tr></thead>
<tr><td width="33%"><code>getline</code></td><td width="38%">Sets <code>$0</code>, <code>NF</code>, <code>FNR</code>, <code>NR</code>, and <code>RT</code></td><td width="27%"><code>awk</code></td></tr>
<tr><td width="33%"><code>getline</code> <var>var</var></td><td width="38%">Sets <var>var</var>, <code>FNR</code>, <code>NR</code>, and <code>RT</code></td><td width="27%"><code>awk</code></td></tr>
<tr><td width="33%"><code>getline &lt;</code> <var>file</var></td><td width="38%">Sets <code>$0</code>, <code>NF</code>, and <code>RT</code></td><td width="27%"><code>awk</code></td></tr>
<tr><td width="33%"><code>getline <var>var</var> &lt; <var>file</var></code></td><td width="38%">Sets <var>var</var> and <code>RT</code></td><td width="27%"><code>awk</code></td></tr>
<tr><td width="33%"><var>command</var> <code>| getline</code></td><td width="38%">Sets <code>$0</code>, <code>NF</code>, and <code>RT</code></td><td width="27%"><code>awk</code></td></tr>
<tr><td width="33%"><var>command</var> <code>| getline</code> <var>var</var></td><td width="38%">Sets <var>var</var> and <code>RT</code></td><td width="27%"><code>awk</code></td></tr>
<tr><td width="33%"><var>command</var> <code>|&amp; getline</code></td><td width="38%">Sets <code>$0</code>, <code>NF</code>, and <code>RT</code></td><td width="27%"><code>gawk</code></td></tr>
<tr><td width="33%"><var>command</var> <code>|&amp; getline</code> <var>var</var></td><td width="38%">Sets <var>var</var> and <code>RT</code></td><td width="27%"><code>gawk</code></td></tr>
</table>
</div><p><strong>Table 4.1: <code>getline</code> 变体及其设置的变量
</strong>
</p>
<hr>
<a name="Read-Timeout"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getline-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Command_002dline-directories" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b8_00a6e_00b6_0085ae_0097_00b6c_009a_0084e_00be_0093aa_0085_00a5e_00af_00bbaa_008f_0096"></a>
<h2 class="section">4.10 带超时的输入读取</h2>
<a name="index-timeout_002c-reading-input"></a>

<a name="index-differences-in-awk-and-gawk_002c-read-timeouts"></a>
<p>本小节讨论的特性是 <code>gawk</code> 所独有的。
</p>
<p>在读取键盘上、管道、双向通信，包括 TCP/IP 套接字中读取输入的时候，你可以指定一个为毫秒单位超时时间。
这可以在每个输入，每个命令或者每个连接的基础上来指定。所有这些都可以指定 <code>PROCINFO</code> 数组中的某个元素的值来实现
（查看 <a href="#Auto_002dset">传递信息的内置变量</a>）：
</p>
<div class="example">
<pre class="example">PROCINFO[&quot;input_name&quot;, &quot;READ_TIMEOUT&quot;] = <var>timeout in milliseconds</var>
</pre></div>

<p>如果设置了这样的时间，<code>gawk</code> 超时后，如果没有在指定的超时时间内读取到数据，则会返回一个失败状态。
例如，TCP 客户端可以在指定时间后，决定是放弃接收从服务器返回的响应。
</p>
<div class="example">
<pre class="example">Service = &quot;/inet/tcp/0/localhost/daytime&quot;
PROCINFO[Service, &quot;READ_TIMEOUT&quot;] = 100
if ((Service |&amp; getline) &gt; 0)
    print $0
else if (ERRNO != &quot;&quot;)
    print ERRNO
</pre></div>

<p>下面则是从 user 那里
<a name="DOCF32" href="#FOOT32">(32)</a>
进行交互式读写，并且不等待超过 5 秒：
</p>
<div class="example">
<pre class="example">PROCINFO[&quot;/dev/stdin&quot;, &quot;READ_TIMEOUT&quot;] = 5000
while ((getline &lt; &quot;/dev/stdin&quot;) &gt; 0)
    print $0
</pre></div>

<p>如果没有数据输入，<code>gawk</code> 会在等待指定的超时时期后，结束读操作，并返回失败，
同时设置 <code>ERRNO</code> 的值为恰当的值。负值或者 0 的超时时间，与不指定超时时间一样。
</p>
<p>超时时间也可以设置在在显式的循环中来读取键盘输入，通过读取这些输入来对模式进行匹配，如：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { PROCINFO[&quot;-&quot;, &quot;READ_TIMEOUT&quot;] = 5000 }</kbd>
&gt; <kbd>{ print &quot;You entered: &quot; $0 }'</kbd>
<kbd>gawk</kbd>
-| You entered: gawk
</pre></div>

<p>在这个情形下，如果在5秒之内反应失败，会导致如下错误信息：
</p>
<div class="example">
<pre class="example">error--&gt; gawk: cmd. line:2: (FILENAME=- FNR=1) fatal: error reading input file `-': Connection timed out
</pre></div>

<p>超时或者变更超时可以在任意时间，并在下次从输入设备中读取时产生效果。
在下面的例子中，我们从 1 秒开始，并不断按 1/10 秒的时间递减，直到有输入到达：
</p>
<div class="example">
<pre class="example">PROCINFO[Service, &quot;READ_TIMEOUT&quot;] = 1000
while ((Service |&amp; getline) &gt; 0) {
    print $0
    PROCINFO[Service, &quot;READ_TIMEOUT&quot;] -= 100
}
</pre></div>

<blockquote>
<p><b>提示:</b> 你不可以假设读操作在读取了第 10 个记录后会阻塞。
有可能 <code>gawk</code> 第一次读取时就读取了多于一个的记录并缓存起来。
因为这个原因，在上面的例子中，改变超时值不是特别有用。
</p></blockquote>

<p>如果 <code>PROCINFO</code> 元素没有设置，并且 <code>GAWK_READ_TIMEOUT</code> 环境变量存在，
<code>gawk</code> 会使用这个变量的值来初始化超时值。唯一地使用环境变量来指定超时值有这样的一个缺陷，就是不能够按照每命令或者每个连接地进行控制。
</p>
<p><code>gawk</code> 会认为超时事件是一个错误。
就算后续对于输入设备的读取是成功的。这是一个限制，这也表示你不可以用这个来复用两个或者更多的输入源。
</p>
<p>赋值一个超时值，可以避免读操作一直被阻塞。但是要记住，还有其他的方法来等待输入设置准备就绪。一个网络客户端在可以读取数据之前可能需要等待很长的时间来建立连接，或者要很长的时间来打开 FIFO 特殊文件以进行读取，这时会一直阻塞，直到其他的进程打开这个特殊文件并进行写。
</p>
<hr>
<a name="Command_002dline-directories"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Read-Timeout" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Input-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0091_00bda_00bb_00a4e_00a1_008ca_00b8_00adc_009a_0084c_009b_00aeaa_00bd_0095"></a>
<h2 class="section">4.11 命令行中的目录</h2>
<a name="index-differences-in-awk-and-gawk_002c-command_002dline-directories"></a>
<a name="index-directories_002c-command_002dline"></a>
<a name="index-command-line_002c-directories-on"></a>

<p>根据 POSIX 标准，在 <code>awk</code> 命令行中指定的文件名必须是文本文件；如果不是则会是一个致命错误。
大多数 <code>awk</code> 版本将命令行上指定目录看成是一个致命错误。
</p>
<p>在默认情况下，<code>gawk</code> 在命令行上指定目录会产生一个告警，但是会忽略它。
这让你在 awk 程序中使用 shell 通配符变得更容易：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f whizprog.awk *</kbd>        <i>Directories could kill this program</i>
</pre></div>

<p>如果指定了 &lsquo;<samp>--posix</samp>&rsquo; 或者 &lsquo;<samp>--traditional</samp>&rsquo; 选项，
<code>gawk</code> 则会将在命令行上指定目录视为致命错误。
</p>
<p>查看 <a href="#Extension-Sample-Readdir">读取目录</a>，有一个方式来在 <code>awk</code> 程序将目录视为有用的数据。
</p>
<hr>
<a name="Input-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Command_002dline-directories" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Input-Exercises" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-4"></a>
<h2 class="section">4.12 总结</h2>

<ul>
<li>
根据 <code>RS</code> 的值，输入会被分割成记录，可能如下：

<table>
<thead><tr><th width="25%">Value of <code>RS</code></th><th width="35%">Records are split on &hellip;</th><th width="40%"><code>awk</code> / <code>gawk</code></th></tr></thead>
<tr><td width="25%">Any single character</td><td width="35%">That character</td><td width="40%"><code>awk</code></td></tr>
<tr><td width="25%">The empty string (<code>&quot;&quot;</code>)</td><td width="35%">Runs of two or more newlines</td><td width="40%"><code>awk</code></td></tr>
<tr><td width="25%">A regexp</td><td width="35%">Text that matches the regexp</td><td width="40%"><code>gawk</code></td></tr>
</table>

</li><li>
<code>FNR</code> 表示已经从当前输入文件中读取了多少记录，<code>NR</code> 则表则从所有的文件总读取了多少记录。

</li><li>
<code>gawk</code> 设置 <code>RT</code> 的值为通过 <code>RS</code> 匹配的文本。

</li><li>
将输入分割成记录后，<code>awk</code> 会进一步将记录分割成不同的域，称为 <code>$1</code>，<code>$2</code> 等等。
<code>$0</code> 是整个记录，<code>NF</code> 表示有多少个域。默认的分割域的方式是在空白符之间的字符。

</li><li>
域可以通过变量来进行参考，如 <code>$NF</code>。域也可以被赋值，这会导致 <code>$0</code> 再次被使用时，会被重新计算。
对大于 <code>NF</code> 的值的域进行赋值可以创建新的域，并重建记录，通过 <code>OFS</code> 来分割域。
增大 <code>NF</code> 的值也产生相同的结果。减少 <code>NF</code> 的值，会丢弃超过 <code>NF</code> 之外的域，并重建记录。

</li><li>
域分割比记录分割要复杂一些：

<table>
<thead><tr><th width="40%">Field separator value</th><th width="40%">Fields are split &hellip;</th><th width="20%"><code>awk</code> / <code>gawk</code></th></tr></thead>
<tr><td width="40%"><code>FS == &quot; &quot;</code></td><td width="40%">On runs of whitespace</td><td width="20%"><code>awk</code></td></tr>
<tr><td width="40%"><code>FS == <var>any single character</var></code></td><td width="40%">On that character</td><td width="20%"><code>awk</code></td></tr>
<tr><td width="40%"><code>FS == <var>regexp</var></code></td><td width="40%">On text matching the regexp</td><td width="20%"><code>awk</code></td></tr>
<tr><td width="40%"><code>FS == &quot;&quot;</code></td><td width="40%">Such that each individual character is a separate field</td><td width="20%"><code>gawk</code></td></tr>
<tr><td width="40%"><code>FIELDWIDTHS == <var>list of columns</var></code></td><td width="40%">Based on character position</td><td width="20%"><code>gawk</code></td></tr>
<tr><td width="40%"><code>FPAT == <var>regexp</var></code></td><td width="40%">On the text surrounding text matching the regexp</td><td width="20%"><code>gawk</code></td></tr>
</table>

</li><li>
使用 &lsquo;<samp>FS = &quot;\n&quot;</samp>&rsquo; 会使整个记录成为一个域（假设用换行符来分隔记录）。

</li><li>
<code>FS</code> 可以通过命令行选项 &lsquo;<samp>-F</samp>&rsquo; 进行设置，也可以通过命令行中的变量赋值方式进行设置。

</li><li>
通过 <code>PROCINFO[&quot;FS&quot;]</code> 来查看正在被用于进行域分割的方式。

</li><li>
使用 <code>getline</code> 及其不同的格式来从默认的输入流之外的文件，管道或者并程等地方读取记录。

</li><li>
使用 <code>PROCINFO[<var>file</var>, &quot;READ_TIMEOUT&quot;]</code> 来对从 <var>file</var> 文件读进行超时设置。

</li><li>
标准的 <code>awk</code> 中，在命令行中指定目录是一个致命错误；
<code>gawk</code> 在非 POSIX 模式中会忽略它们。

</li></ul>

<hr>
<a name="Input-Exercises"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Input-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bb_0083a_00b9_00a0-2"></a>
<h2 class="section">4.13 练习</h2>

<ol>
<li>
使用 <code>FIELDWIDTHS</code> 变量（查看 <a href="#Constant-Size">读取固定宽度数据</a>），写一个程序来读取选举数据，
这些数据中每个记录代表一个投票者的选票。构造一个方式来定义列如何来与每个投票项进行关联，并打印总的票数，
包括每个项的弃权票数。

</li><li>
在 <a href="#Plain-Getline">不带参数调用 <code>getline</code></a> 中，有一个程序来从输入中移除 C 风格的注释（&lsquo;<samp>/* &hellip; */</samp>&rsquo;)。
那个程序在一个行中结束一个注释，同时开启另一个注释时工作不正确。可以做一些很小的变更就可以来修复它，如何来做？

</li></ol>

<hr>
<a name="Printing"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-Files" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Input-Exercises" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Print" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0089_0093aa_008d_00b0e_00be_0093aa_0087_00ba"></a>
<h1 class="chapter">5 打印输出</h1>

<a name="index-printing"></a>
<a name="index-output_002c-printing_002c-See-printing"></a>
<p>大多数编程行为就是<em>打印</em>或者说是输出一些或者全部的输入。
使用 <code>print</code> 语句进行简单的输出，利用 <code>printf</code> 语句进行格式化输出。
在决定打印<em>哪个</em>值的场景下，<code>print</code> 语句没什么限制。
但是有两个例外，你无法指定它们<em>如何</em>来打印它们——多少列，是否使用幂方式等等。
（对于这些例外，查看 <a href="#Output-Separators">输出分隔符</a> 和 <a href="#OFMT">控制 <code>print</code> 的数字输出</a>）
对于规范的打印，你需要 <code>printf</code> 语句（查看 <a href="#Printf">使用 <code>printf</code> 语句美化打印</a>）。
</p>
<a name="index-print-statement"></a>
<a name="index-printf-statement"></a>
<p>除了基本的与格式化的打印，本章还会讨论 I/O 重定向到文件与管道的相关问题，
介绍一些 <code>gawk</code> 内部使用的特殊的文件名，还讨论 <code>close()</code> 这个内建函数。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Print">5.1 <code>print</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       The <code>print</code> statement.
</td></tr>
<tr><td align="left" valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Simple examples of <code>print</code> statements.
</td></tr>
<tr><td align="left" valign="top"><a href="#Output-Separators">5.3 输出分隔符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           The output separators and how to change them.
</td></tr>
<tr><td align="left" valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Controlling Numeric Output With <code>print</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printf">5.5 使用 <code>printf</code> 语句美化打印</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      The <code>printf</code> statement.
</td></tr>
<tr><td align="left" valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 How to redirect output to multiple files and
                                pipes.
</td></tr>
<tr><td align="left" valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Special files for I/O.
</td></tr>
<tr><td align="left" valign="top"><a href="#Special-Files">5.8 <code>gawk</code> 中的特殊文件名</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               File name interpretation in <code>gawk</code>.
                                <code>gawk</code> allows access to inherited file
                                descriptors.
</td></tr>
<tr><td align="left" valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Closing Input and Output Files and Pipes.
</td></tr>
<tr><td align="left" valign="top"><a href="#Output-Summary">5.10 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Output summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Output-Exercises">5.11 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Exercises.
</td></tr>
</table>

<hr>
<a name="Print"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Print-Examples" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="print-e_00af_00adaa_008f_00a5"></a>
<h2 class="section">5.1 <code>print</code> 语句</h2>

<p>利用 <code>print</code> 进行简单的，标准化的输出。只需要指定要打印的字串以及数字，并用逗号分隔它们。它们输出时用简单的空格进行分隔，并在最后附加上换行符。语句看起来如下：
</p>
<div class="example">
<pre class="example">print <var>item1</var>, <var>item2</var>, &hellip;
</pre></div>

<p>整个的项目列表可以用括号括起来，但是可选的。
如果项目表达式使用了 &lsquo;<samp>&gt;</samp>&rsquo; 这样的关系操作符，则括号是必须的；否则会产生令人困惑的输出重定向
（查看 <a href="#Redirection">重定向 <code>print</code> 与 <code>printf</code> 的输出</a>）。
</p>
<p>要打印的项，可以是常量字串，数值，当前记录的域（如 <code>$1</code>），变量，以及任意的 <code>awk</code> 表达式。数值会被转换成字串，然后再打印。
</p>
<a name="index-records_002c-printing"></a>
<a name="index-lines_002c-blank_002c-printing"></a>
<a name="index-text_002c-printing"></a>
<p>简单的 &lsquo;<samp>print</samp>&rsquo; 语句，同时没有带任何打印项，等同于 &lsquo;<samp>print $0</samp>&rsquo;：即打印整个的当前记录。
要打印一个空行，则使用 &lsquo;<samp>print &quot;&quot;</samp>&rsquo;。
要打字固定的文本片，使用字串常量，如 <code>&quot;Don't&nbsp;Panic&quot;</code> 这样的项。
如果你忘记使用双引号字符，则文件会被当成 <code>awk</code> 表达式，这样有可能会产生一个错误。要记住，在任意两个要打印的项目之间空格是要打印的。
</p>
<p>注意 <code>print</code> 语句是一个语句，而不是一个表达式——你不能使用在模式-动作语句中的模式部分。
</p>
<hr>
<a name="Print-Examples"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Print" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Output-Separators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="print-e_00af_00adaa_008f_00a5a_00be_008baa_00ad_0090"></a>
<h2 class="section">5.2 <code>print</code> 语句例子</h2>

<p>每一个 <code>print</code> 语句至少会产生一行输出。但是不限于只输出一行。如是项目中的值是一个字串，并包含一个换行符，则换行符会与剩下的串一起输出。一个单一的 <code>print</code> 语句可以按这种方式首先任意行数。
</p>
<a name="index-newlines_002c-printing"></a>
<p>下面是一个打印内嵌了
换行符
（&lsquo;<samp>\n</samp>&rsquo; 是一个转义序列，用来表示换行符；参考 <a href="#Escape-Sequences">转义序列</a> ）
的字符串的例子：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print &quot;line one\nline two\nline three&quot; }'</kbd>
-| line one
-| line two
-| line three
</pre></div>

<a name="index-fields_002c-printing"></a>
<p>下一个例子，会运行在文件 &lsquo;<tt>inventory-shipped</tt>&rsquo; 上，并打印每个输入记录的前两个域，它们之间有空格：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print $1, $2 }' inventory-shipped</kbd>
-| Jan 13
-| Feb 15
-| Mar 15
&hellip;
</pre></div>

<a name="index-print-statement_002c-commas_002c-omitting"></a>
<a name="index-troubleshooting_002c-print-statement_002c-omitting-commas"></a>
<p>常见的使用 <code>print</code> 语句的错误是省略了项目之间的逗号。这常会导致在输出中所有的项目挤在了一些，相互之间没有空格。原因在于在 <code>awk</code> 中，并列两个字串表示的是合并它们。这是相同的程序，但是没有逗号的情况：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print $1 $2 }' inventory-shipped</kbd>
-| Jan13
-| Feb15
-| Mar15
&hellip;
</pre></div>

<a name="index-BEGIN-pattern_002c-headings_002c-adding"></a>
<p>对于不熟悉 &lsquo;<tt>inventory-shipped</tt>&rsquo; 文件的读者，
上面的两个例子的输出没什么意义。开头的行可能更清楚。
让我们在我们的月份（<code>$1</code>）表以及已经发送的蓝包（<code>$2</code>）中添加一些头部信息：
我们使用 <code>BEGIN</code> （参考 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）来实现，这样头部只会打印一次：
</p>
<div class="example">
<pre class="example">awk 'BEGIN {  print &quot;Month Crates&quot;
              print &quot;----- ------&quot; }
           {  print $1, $2 }' inventory-shipped
</pre></div>

<p>当执行时，程序打印如下：
</p>
<div class="example">
<pre class="example">Month Crates
----- ------
Jan 13
Feb 15
Mar 15
&hellip;
</pre></div>

<p>然而，唯一的问题是头部信息与表数据并没有对齐。我们可以在其中打印一些空格来修复这个问题：
</p>
<div class="example">
<pre class="example">awk 'BEGIN { print &quot;Month Crates&quot;
             print &quot;----- ------&quot; }
           { print $1, &quot;     &quot;, $2 }' inventory-shipped
</pre></div>

<a name="index-printf-statement_002c-columns_002c-aligning"></a>
<a name="index-columns_002c-aligning"></a>
<p>如果要修复的列有很多，这样的修复方式会非常繁琐。计算两三个列是很简单的，
但是超过这个数的时候，所耗的时间就很多了。
这就是为什么要使用 <code>printf</code> 语句原因（查看 <a href="#Printf">使用 <code>printf</code> 语句美化打印</a>）；它的其中一个特别功能就是对齐数据列。
</p>
<a name="index-line-continuations_002c-in-print-statement"></a>
<a name="index-print-statement_002c-line-continuations-and"></a>
<blockquote>
<p><b>提示:</b> 你可以对 <code>print</code> 或者 <code>printf</code> 进行续行，只需要简单地在任意的逗号后面放置一个换行符即可。
（查看 <a href="#Statements_002fLines"><code>awk</code> 语句与行</a>）。
</p></blockquote>

<hr>
<a name="Output-Separators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Print-Examples" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#OFMT" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00be_0093aa_0087_00baaa_0088_0086e_009a_0094c_00ac_00a6"></a>
<h2 class="section">5.3 输出分隔符</h2>

<a name="index-OFS-variable-1"></a>
<p>如前所述，<code>print</code> 语句包含了由逗号分隔的项目列表。
在输出中，项目一般是用空格进行分隔。但是也不一定非要这样，空格只是默认情况。
任意的字串都可以用来当成是输出分隔会，只需要设定预定义的变量 <code>OFS</code>。
这个变量初始值就是串 <code>&quot;&nbsp;&quot;</code>（一个空格）。
</p>
<p>整个的 <code>print</code> 语句输出称为一个<em>输出记录（output record）</em>。
每一个 <code>print</code> 语句输出一个输出记录，然后输出一个<em>输出记录分隔符</em>（或者 <code>ORS</code>）。
<code>ORS</code> 的初始值为串 <code>&quot;\n&quot;</code>（一个换行符）。因此，每一个 <code>print</code> 语句产生一个单独的行。
</p>
<a name="index-output_002c-records"></a>
<a name="index-output-record-separator_002c-See-ORS-variable"></a>
<a name="index-ORS-variable"></a>
<a name="index-BEGIN-pattern_002c-OFS_002fORS-variables_002c-assigning-values-to"></a>
<p>为了改变输出域以及记录的分隔方式，给变量 <code>OFS</code> 以及 <code>ORS</code> 赋值即可。
通常做这件事的地方就是 <code>BEGIN</code> 规则里（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>），
因此，在任意的输入被处理之前就可以就绪。也可以在命令行中的对其进行赋值，需要放在输入文件之前，
或者使用 &lsquo;<samp>-v</samp>&rsquo; 命令行选项（查看 <a href="#Options">命令行参数</a>）。
下面的例子打印记录的第一与第二个域，并用分号分隔，并在每个换行符的后面增加一个空行：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { OFS = &quot;;&quot;; ORS = &quot;\n\n&quot; }</kbd>
&gt;            <kbd>{ print $1, $2 }' mail-list</kbd>
-| Amelia;555-5553
-|
-| Anthony;555-3412
-|
-| Becky;555-7685
-|
-| Bill;555-1675
-|
-| Broderick;555-0542
-|
-| Camilla;555-2912
-|
-| Fabius;555-1234
-|
-| Julie;555-6699
-|
-| Martin;555-6480
-|
-| Samuel;555-3430
-|
-| Jean-Paul;555-2127
-|
</pre></div>

<p>如果 <code>ORS</code> 的值中不包含换行符，程序的输出就会挤在一行中。
</p>
<hr>
<a name="OFMT"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Output-Separators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Printf" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008e_00a7aa_0088_00b6-print-c_009a_0084ae_0095_00b0aa_00ad_0097e_00be_0093aa_0087_00ba"></a>
<h2 class="section">5.4 控制 <code>print</code> 的数字输出</h2>
<a name="index-numeric_002c-output-format"></a>
<a name="index-formats_002c-numeric-output"></a>
<p>当用 <code>print</code> 语句打印数值时，<code>awk</code> 内部会将每一个数值转换成一个字符串，然后打印它。
<code>awk</code> 使用 sprintf 函数来做这样的转换（查看 <a href="#String-Functions">字串操作函数</a>）。
目前，只需要知道 <code>sprintf()</code> 接受一个格式规范（字串）用以告诉如何来对数字或者字串如何进行格式化，并且数字有很多种方式来进行格式化。
不同的格式规范会在 
<a href="#Control-Letters">格式控制字母</a> 
中讨论得更加详细。
</p>
<a name="index-sprintf_0028_0029-function"></a>
<a name="index-OFMT-variable"></a>
<a name="index-output_002c-format-specifier_002c-OFMT"></a>
<p>预定义的变量 <code>OFMT</code> 包含了 <code>print</code> 时想将数值转换成字串，
使用 <code>sprintf</code> 时的格式规范。<code>OFMT</code> 的默认的值是 <code>&quot;%.6g&quot;</code>。
<code>print</code> 打印数字的格式可能通过给 <code>OFMT</code> 赋予不同的格式规范来改变，如下面的例子所示：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN {</kbd>
&gt;   <kbd>OFMT = &quot;%.0f&quot;  # print numbers as integers (rounds)</kbd>
&gt;   <kbd>print 17.23, 17.54 }'</kbd>
-| 17 18
</pre></div>

<a name="index-dark-corner_002c-OFMT-variable"></a>
<a name="index-POSIX-awk_002c-OFMT-variable-and"></a>
<a name="index-OFMT-variable_002c-POSIX-awk-and"></a>
<p>根据 POSIX 标准，如果 <code>OFMT</code> 包含的不是浮点转换规范的其他任意数值，会产生未定义的 <code>awk</code> 行为。
(d.c.)
</p>
<hr>
<a name="Printf"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#OFMT" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Printf" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8-printf-e_00af_00adaa_008f_00a5c_00be_008eaa_008c_0096ae_0089_0093aa_008d_00b0"></a>
<h2 class="section">5.5 使用 <code>printf</code> 语句美化打印</h2>

<a name="index-printf-statement-1"></a>
<a name="index-output_002c-formatted"></a>
<a name="index-formatting-output"></a>
<p>为了比 <code>print</code> 提供更加精准地控制输出格式，可以使用 <code>printf</code>。<code>printf</code> 可以指定每个项目的宽度，以及一系列的数值输出格式（如使用的是什么基数，是否打印幂指数形式，是否打印符号，以及在小数点后要打印多个位等）。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Basic-Printf">5.5.1 使用 <code>printf</code> 语句美化打印</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Syntax of the <code>printf</code> statement.
</td></tr>
<tr><td align="left" valign="top"><a href="#Control-Letters">5.5.2 格式控制字母</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Format-control letters.
</td></tr>
<tr><td align="left" valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Format-specification modifiers.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printf-Examples">5.5.4 <code>printf</code> 范例</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Several examples.
</td></tr>
</table>

<hr>
<a name="Basic-Printf"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printf" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printf" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Control-Letters" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8-printf-e_00af_00adaa_008f_00a5c_00be_008eaa_008c_0096ae_0089_0093aa_008d_00b0-1"></a>
<h3 class="subsection">5.5.1 使用 <code>printf</code> 语句美化打印</h3>

<a name="index-printf-statement_002c-syntax-of"></a>
<p>一个简单的 <code>printf</code> 语句是这样的：
</p>
<div class="example">
<pre class="example">printf <var>format</var>, <var>item1</var>, <var>item2</var>, &hellip;
</pre></div>

<p>与 <code>print</code> 相似，整个的参数列表可以使用括号括起来。这里也是一样，
如果项目表达式中包含了 &lsquo;<samp>&gt;</samp>&rsquo; 关系表达操作符，则括号是必须的，否则会导致一个输出重定向而使用困惑
（查看 <a href="#Redirection">重定向 <code>print</code> 与 <code>printf</code> 的输出</a>）。
</p>
<a name="index-format-specifiers"></a>
<p>在 <code>print</code> 与 <code>printf</code> 之间的不同，就是 <var>format</var> 参数。
这是一个会被当成字串识别的表达式，它指定了每个参数的输出格式。它称为<em>格式字串</em>。
</p>
<p>格式字串与 ISO C 库中的函数 <code>printf()</code> 非常类似。
大多的格式文本都输出来说都是字面的。在这些文本之间分散着<em>格式指定符</em>。每个项目一个。每个格式指定符都定义了下一个输出的项目在相应位置的格式。
</p>
<p><code>printf</code> 不会自动地在输出中附加一个换行符。它只输出格式串所定义的串。因此，如果需要换行符，你需要在格式中加入。输出分隔符变量 <code>OFS</code> 以及 <code>ORS</code> 在 <code>printf</code> 语句中没有作用。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN {</kbd>
&gt;    <kbd>ORS = &quot;\nOUCH!\n&quot;; OFS = &quot;+&quot;</kbd>
&gt;    <kbd>msg = &quot;Don\47t Panic!&quot;</kbd>
&gt;    <kbd>printf &quot;%s\n&quot;, msg</kbd>
&gt; <kbd>}'</kbd>
-| Don't Panic!
</pre></div>

<p>例子中，无论是 &lsquo;<samp>+</samp>&rsquo; 还是 &lsquo;<samp>OUCH!</samp>&rsquo; 都没有出现在输出信息中。
</p>
<hr>
<a name="Control-Letters"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Printf" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printf" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Format-Modifiers" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a0_00bcaa_00bc_008fae_008e_00a7aa_0088_00b6aa_00ad_0097ae_00af_008d"></a>
<h3 class="subsection">5.5.2 格式控制字母</h3>
<a name="index-printf-statement_002c-format_002dcontrol-characters"></a>
<a name="index-format-specifiers_002c-printf-statement"></a>

<p>格式指定符以字符 &lsquo;<samp>%</samp>&rsquo; 开始，并以<em>格式控制字母</em>结束——整个格式指定符告诉 <code>printf</code> 语句如何来输出项目。
格式字母指定了要打印的值的<em>类型</em>。格式指定符的其余部分则由可选的<em>修饰符</em>组成，
这些修饰符控制<em>如何</em>来打印这些值，如域宽度。下面是格式控制字母：
</p>
<dl compact="compact">
<dt><code>%c</code></dt>
<dd><p>将数字打印成一个字符，所在 &lsquo;<samp>printf &quot;%c&quot;, 65</samp>&rsquo; 输出字母 &lsquo;<samp>A</samp>&rsquo;。
如果是一个字串，则输出字串的第一个字符。
</p>
<a name="index-dark-corner_002c-format_002dcontrol-characters"></a>
<a name="index-gawk_002c-format_002dcontrol-characters"></a>
<blockquote>
<p><b>提示:</b> POSIX 标准说是打印字中的第一个字符。在多字节语言中，<code>gawk</code> 会尝试将字串的首字节转换成一个有效的宽字节，然后打印那个字符的多字节编码。相似地，当打印一个数值时，<code>gawk</code> 允许数值的值在一个宽字符所允许的值范围内。如果转换成多字节编码出错，<code>gawk</code> 会使用数值的低 8 位来打成字符打印。
</p>
<p>其他版本的 <code>awk</code> 一般严格限制为打印字串的第一个字节，或者数值的范围在一个字节的所表示的范围内（0-255）。
</p></blockquote>


</dd>
<dt><code>%d</code>, <code>%i</code></dt>
<dd><p>打印一个十进制整数。两个控制字母是等同的。（&lsquo;<samp>%i</samp>&rsquo; 规范主要是为了兼容 ISO C。）
</p>
</dd>
<dt><code>%e</code>, <code>%E</code></dt>
<dd><p>将数值打印成科学计算方式（幂指数），例如：
</p>
<div class="example">
<pre class="example">printf &quot;%4.3e\n&quot;, 1950
</pre></div>

<p>会打印 &lsquo;<samp>1.950e+03</samp>&rsquo;，带有 4 个有效位，其中 3 个在小数点的后面。
（&lsquo;<samp>4.3</samp>&rsquo; 表示两个修饰符，会在下个子小节中进行讨论。）
&lsquo;<samp>%E</samp>&rsquo; 表示在输出中使用 &lsquo;<samp>E</samp>&rsquo; 而不是 &lsquo;<samp>e</samp>&rsquo; 。
</p>
</dd>
<dt><code>%f</code></dt>
<dd><p>打印一个浮点数，例如：
</p>
<div class="example">
<pre class="example">printf &quot;%4.3f&quot;, 1950
</pre></div>

<p>会打印 &lsquo;<samp>1950.000</samp>&rsquo;，带有 4 个有效位，3 个在小数点后面。
（&lsquo;<samp>4.3</samp>&rsquo; 表示两个修饰符，会在下个子小节中进行讨论。）
</p>
<p>在支持 IEEE 754 浮点格式的系统上，代表负无穷会格式化为 &lsquo;<samp>-inf</samp>&rsquo;，或者 &lsquo;<samp>-infinity</samp>&rsquo;，
正无穷则为 &lsquo;<samp>inf</samp>&rsquo; 或者 &lsquo;<samp>infinity</samp>&rsquo;。对于“不是数值”这种特殊情况，则格式化为 &lsquo;<samp>-nan</samp>&rsquo; 或者 &lsquo;<samp> nan</samp>&rsquo;
（查看 <a href="#Math-Definitions">要了解的其他知识</a>）。
</p>
</dd>
<dt><code>%F</code></dt>
<dd><p>类似于 &lsquo;<samp>%f</samp>&rsquo;，只是无穷大，以及“不是数值” 会使用大写字母输出。
</p>
<p>&lsquo;<samp>%F</samp>&rsquo; 是一个 ISO C 的一个扩展，不是所有的系统都支持。对于不支持的系统，<code>gawk</code> 会使用 &lsquo;<samp>%f</samp>&rsquo; 来代替。
</p>
</dd>
<dt><code>%g</code>, <code>%G</code></dt>
<dd><p>以科学方式或者浮点数方式打印浮数值，看哪个使用更少的字符，如果结果是以科学计数方式，&lsquo;<samp>%G</samp>&rsquo; 则使用 &lsquo;<samp>E</samp>&rsquo; 而不是使用 &lsquo;<samp>e</samp>&rsquo; 。
</p>
</dd>
<dt><code>%o</code></dt>
<dd><p>打印一个无符号八进制整数（查看 <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>）。
</p>
</dd>
<dt><code>%s</code></dt>
<dd><p>打印一个字串。
</p>
</dd>
<dt><code>%u</code></dt>
<dd><p>打印一个无符号整数。（使用这个格式要注意，因此在 <code>awk</code> 中的所有数值都是浮点数，这个只是为了与 ISO C 保持兼容。）
</p>
</dd>
<dt><code>%x</code>, <code>%X</code></dt>
<dd><p>打印一个无符号的十六进制整数，&lsquo;<samp>%X</samp>&rsquo; 使用字母 &lsquo;<samp>A</samp>&rsquo; 到 &lsquo;<samp>F</samp>&rsquo; 而不是 &lsquo;<samp>a</samp>&rsquo; 到 &lsquo;<samp>f</samp>&rsquo;
（查看 <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>）。
</p>
</dd>
<dt><code>%%</code></dt>
<dd><p>打印 &lsquo;<samp>%</samp>&rsquo;。这个不会消耗后面的参数，并且忽略掉所有的修饰符。
</p></dd>
</dl>

<a name="index-dark-corner_002c-format_002dcontrol-characters-1"></a>
<a name="index-gawk_002c-format_002dcontrol-characters-1"></a>
<blockquote>
<p><b>提示:</b> 当使用整数的控制字母来打印其值超过 C 整数的最大的范围时，<code>gawk</code> 会切换到 &lsquo;<samp>%g</samp>&rsquo; 这个格式指定符。
如果在命令行中使用了 &lsquo;<samp>--lint</samp>&rsquo; 选项（查看 <a href="#Options">命令行参数</a>），
<code>gawk</code> 会生成一个告警。其他版本的 <code>awk</code> 有可能打印一个无效的值，或者产生完全不同的其他结果。
(d.c.)
</p></blockquote>

<hr>
<a name="Format-Modifiers"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Control-Letters" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printf" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Printf-Examples" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="printf-c_009a_0084a_00bf_00aee_00a5_00b0c_00ac_00a6"></a>
<h3 class="subsection">5.5.3 <code>printf</code> 的修饰符</h3>

<a name="index-printf-statement_002c-modifiers"></a>
<a name="index-modifiers_002c-in-format-specifiers"></a>
<p>一个格式指示符功能包括一些修饰符以控制项目的值如何来进行打印，以及其需要多少的空间。
修饰符处于 &lsquo;<samp>%</samp>&rsquo; 与格式控制字母之间。我们使用子弹符“&bull;”来表示输出中的空格。
下面是可能的修饰符，以出现的顺序排序：
</p>
<dl compact="compact">
<dd><a name="index-differences-in-awk-and-gawk_002c-print_002fprintf-statements"></a>
<a name="index-printf-statement_002c-positional-specifiers"></a>
<a name="index-positional-specifiers_002c-printf-statement"></a>
</dd>
<dt><code><var>N</var>$</code></dt>
<dd><p>一个整数后面带一个 &lsquo;<samp>$</samp>&rsquo; 是一个位置指定符。
一般情况下，格式字串中的格式指定符是按顺序应用到后面的参数的。通过<em>位置指定符</em>，格式指定符则应用到指定的参数中，
而不是原来本应该应用在列表中的参数。
位置指定符从 0 开始计算。因此：
</p>
<div class="example">
<pre class="example">printf &quot;%s %s\n&quot;, &quot;don't&quot;, &quot;panic&quot;
printf &quot;%2$s %1$s\n&quot;, &quot;panic&quot;, &quot;don't&quot;
</pre></div>

<p>打印两次最有名的友好信息。
</p>
<p>初看之下，这个特性没有什么特别的用处。事实上，这是 <code>gawk</code> 的一个扩展，
主要用于在运行时进行信息翻译。查看 <a href="#Printf-Ordering">重排 <code>printf</code> 参数</a>，
当中所描述的为什么以及如何来使用位置指定符。目前，我们可以先忽略它。
</p>
</dd>
<dt><code>-</code> (Minus)</dt>
<dd><p>一个减号 &lsquo;<samp>-</samp>&rsquo;，用在宽度指定符之前（看本列表之后），
告诉对指定的宽度内进行左对齐。一般情况下，在指定的宽度内，参数是右对齐。因此：
</p>
<div class="example">
<pre class="example">printf &quot;%-4s&quot;, &quot;foo&quot;
</pre></div>

<p>打印 &lsquo;<samp>foo&bull;</samp>&rsquo; 。
</p>
</dd>
<dt><var>space</var></dt>
<dd><p>对于数值转换，表示正值之前缀一个空格，或者负值之间带一个减号 &lsquo;<samp>-</samp>&rsquo; 。
</p>
</dd>
<dt><code>+</code></dt>
<dd><p>加号，用在宽度指定符前（看本列表之后），告诉在数值转换上总是使用符号，就算数值格式是正数。
&lsquo;<samp>+</samp>&rsquo; 号重载了空格指定符。
</p>
</dd>
<dt><code>#</code></dt>
<dd><p>对于特定的控制字母使用“候选格式”。
对于 &lsquo;<samp>%o</samp>&rsquo; 则提供一个前导的 0。对于 &lsquo;<samp>%x</samp>&rsquo; 与 &lsquo;<samp>%X</samp>&rsquo;，则使用 &lsquo;<samp>0x</samp>&rsquo; 或者 &lsquo;<samp>0X</samp>&rsquo; 在非零的结果之前。
对于 &lsquo;<samp>%e</samp>&rsquo;，&lsquo;<samp>%E</samp>&rsquo;，&lsquo;<samp>%f</samp>&rsquo;，&lsquo;<samp>%F</samp>&rsquo;，结果中总是包含小数点。对于 &lsquo;<samp>%g</samp>&rsquo; 与 &lsquo;<samp>%G</samp>&rsquo;，后面的零不会从结果中移除。
</p>
</dd>
<dt><code>0</code></dt>
<dd><p>前导的 &lsquo;<samp>0</samp>&rsquo;（零）是一个标志指示符，指定输出中使用 0 来填充而不是使用空格。
这只用在数值格式中。这个标志也应用在如果宽度指定符中指定的宽度大于要打印的数值的宽度的情况。
</p>
</dd>
<dt><code>'</code></dt>
<dd><p>单引号或者撇号是 ISO C 的 POSIX 扩展。它表示的是浮点数值中的整数部分，或者整数的全部，
应该包含有一个百分位分隔符。这个只在支持这样的格式的语言中有用。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>cat thousands.awk</kbd>          <i>Show source program</i>
-| BEGIN { printf &quot;%'d\n&quot;, 1234567 }
$ <kbd>LC_ALL=C gawk -f thousands.awk</kbd>
-| 1234567                   <i>Results in</i> &quot;C&quot; <i>locale</i>
$ <kbd>LC_ALL=en_US.UTF-8 gawk -f thousands.awk</kbd>
-| 1,234,567                 <i>Results in US English UTF locale</i>
</pre></div>

<p>要获取关于语言设置与国际化问题的更多信息，请查看 <a href="#Locales">哪里造成差异</a>。
</p>
<blockquote>
<p><b>提示:</b> &lsquo;<samp>'</samp>&rsquo; 标志是一个非常好的特性，但是使用起来会导致一些事情复杂起来：在命令行程序中用起来非常困难。要了解引号技巧的一些信息，请看 <a href="#Quoting">Shell 引号问题</a>。
</p></blockquote>

</dd>
<dt><var>width</var></dt>
<dd><p>这是一个数值指定符，指定一个域所需要的最小宽度。
在 &lsquo;<samp>%</samp>&rsquo; 与格式控制字母之间插入一个数值，强制域的宽度扩展到指定的大小。默认的情况下会在左边的位置在空闲位置以空格填充。例如：
</p>
<div class="example">
<pre class="example">printf &quot;%4s&quot;, &quot;foo&quot;
</pre></div>

<p>会打印 &lsquo;<samp>&bull;foo</samp>&rsquo; 。
</p>
<p><var>width</var> 的值是最小宽度，不是最大。如果值所需要的 <var>width</var> 更大，会扩展到必要的宽度。因此下面：
</p>
<div class="example">
<pre class="example">printf &quot;%4s&quot;, &quot;foobar&quot;
</pre></div>

<p>会打印 &lsquo;<samp>foobar</samp>&rsquo; 。
</p>
<p>如果在 <var>width</var> 的面前加一个减号（&lsquo;<samp>-</samp>&rsquo;），则输出中的填充会在右边，而不是在左边。
</p>
</dd>
<dt><code>.<var>prec</var></code></dt>
<dd><p>一个点后面跟一个整数常量指定了打印时所使用的精度。其含义根据控制字母不同。
</p>
<dl compact="compact">
<dt><code>%d</code>, <code>%i</code>, <code>%o</code>, <code>%u</code>, <code>%x</code>, <code>%X</code></dt>
<dd><p>要打印的最小数字个数。
</p>
</dd>
<dt><code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code></dt>
<dd><p>在小数点后面的数值个数。
</p>
</dd>
<dt><code>%g</code>, <code>%G</code></dt>
<dd><p>有效数字位的最大个数。
</p>
</dd>
<dt><code>%s</code></dt>
<dd><p>从要打印的字串中打印的最大字符数。
</p></dd>
</dl>

<p>因此下面的代码：
</p>
<div class="example">
<pre class="example">printf &quot;%.4s&quot;, &quot;foobar&quot;
</pre></div>

<p>会打印 &lsquo;<samp>foob</samp>&rsquo; 。
</p></dd>
</dl>

<p>C 库中的 <code>printf</code> 的动态 <var>width</var> 与 <var>prec</var> 能力（例如，<code>&quot;%*.*s&quot;</code>）也被支持。
不需要显式地在格式字串中指定一个 <var>width</var> 与/或者 <var>prec</var> 的值，
它们也可以在参数列表中进行处理，如：
</p>
<div class="example">
<pre class="example">w = 5
p = 3
s = &quot;abcdefg&quot;
printf &quot;%*.*s\n&quot;, w, p, s
</pre></div>

<p>与下面的完全一致：
</p>
<div class="example">
<pre class="example">s = &quot;abcdefg&quot;
printf &quot;%5.3s\n&quot;, s
</pre></div>

<p>两个程序都输出 &lsquo;<samp>&bull;&bull;abc</samp>&rsquo;。
<code>awk</code> 早期的版本不支持这样的能力。如果你必需使用这样的版本，你可以通过（字串）连接的方式来构建格式格式字串来模拟这个特性：
</p>
<div class="example">
<pre class="example">w = 5
p = 3
s = &quot;abcdefg&quot;
printf &quot;%&quot; w &quot;.&quot; p &quot;s\n&quot;, s
</pre></div>

<p>在实践中这个代码不是很好读，但是确实可以工作。
</p>
<a name="index-troubleshooting_002c-fatal-errors_002c-printf-format-strings"></a>
<a name="index-POSIX-awk_002c-printf-format-strings-and"></a>
<p>C 程序员还可以在 <code>printf</code> 的格式字串中使用一些额外的修饰符（&lsquo;<samp>h</samp>&rsquo;，&lsquo;<samp>j</samp>&rsquo;，&lsquo;<samp>l</samp>&rsquo;，&lsquo;<samp>L</samp>&rsquo;，&lsquo;<samp>t</samp>&rsquo;，
与 &lsquo;<samp>z</samp>&rsquo;）。
这些在 <code>awk</code> 中都是无效的。大多数 <code>awk</code> 实现都是默默地忽略它们。
如果 &lsquo;<samp>--lint</samp>&rsquo; 在命令行中指定了（查看 <a href="#Options">命令行参数</a>），
<code>gawk</code> 会产生告警。如果指定了 &lsquo;<samp>--posix</samp>&rsquo;，则会产生一个致命错误。
</p>
<hr>
<a name="Printf-Examples"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Format-Modifiers" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printf" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Redirection" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="printf-e_008c_0083a_00be_008b"></a>
<h3 class="subsection">5.5.4 <code>printf</code> 范例</h3>

<p>下面是一个简单的如何来使用 <code>printf</code> 实现对齐表格的例子：
</p>
<div class="example">
<pre class="example">awk '{ printf &quot;%-10s %s\n&quot;, $1, $2 }' mail-list
</pre></div>

<p>这个命令打印文件 &lsquo;<tt>mail-list</tt>&rsquo; 中的人名（<code>$1</code>）为 10 个字符的串，并且左对齐。
同时也打印电话号码（<code>$2</code>）在同一行的后面。这会产生一个两行对齐的名字与电话的列表，如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ printf &quot;%-10s %s\n&quot;, $1, $2 }' mail-list</kbd>
-| Amelia     555-5553
-| Anthony    555-3412
-| Becky      555-7685
-| Bill       555-1675
-| Broderick  555-0542
-| Camilla    555-2912
-| Fabius     555-1234
-| Julie      555-6699
-| Martin     555-6480
-| Samuel     555-3430
-| Jean-Paul  555-2127
</pre></div>

<p>在这例子中，电话号码要以字串的方式打印，因为号码是以横杠进行分隔的。如果将电话号码打印成数值，则产生的输出只有三个数字： &lsquo;<samp>555</samp>&rsquo; 。这就有点蛋疼了。
</p>
<p>没有必要指定电话号码的长度，因为它们是一行中的最后一项。不需要在它们的后面填上空格。
</p>
<p>如果在列的上面打印一些头部，看起来就更加漂亮了。这可以通过 <code>BEGIN</code> 规则来实现（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>），这样的话，头部就只会在 <code>awk</code> 程序开始打印一次：
</p>
<div class="example">
<pre class="example">awk 'BEGIN { print &quot;Name      Number&quot;
             print &quot;----      ------&quot; }
           { printf &quot;%-10s %s\n&quot;, $1, $2 }' mail-list
</pre></div>

<p>在前面的例子中混合了 <code>print</code> 与 <code>printf</code> 语句。只使用 <code>printf</code> 也可以产生相同的结果：
</p>
<div class="example">
<pre class="example">awk 'BEGIN { printf &quot;%-10s %s\n&quot;, &quot;Name&quot;, &quot;Number&quot;
             printf &quot;%-10s %s\n&quot;, &quot;----&quot;, &quot;------&quot; }
           { printf &quot;%-10s %s\n&quot;, $1, $2 }' mail-list
</pre></div>

<p>在打印头部时，使用与列一样的格式指定符，可以保证头部也列一样地对齐。
</p>
<p>其中的格式指定串被使用了三个，因此可以将其存储在一个变量中，如：
</p>
<div class="example">
<pre class="example">awk 'BEGIN { format = &quot;%-10s %s\n&quot;
             printf format, &quot;Name&quot;, &quot;Number&quot;
             printf format, &quot;----&quot;, &quot;------&quot; }
           { printf format, $1, $2 }' mail-list
</pre></div>


<hr>
<a name="Redirection"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printf-Examples" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Special-FD" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0087_008daa_00ae_009aaa_0090_0091-print-a_00b8_008e-printf-c_009a_0084e_00be_0093aa_0087_00ba"></a>
<h2 class="section">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</h2>

<a name="index-output-redirection"></a>
<a name="index-redirection-of-output"></a>
<a name="index-_002d_002dsandbox-option_002c-output-redirection-with-print_002c-printf"></a>
<p>到目前，从 <code>print</code> 与 <code>printf</code> 的输出都打印在标准输出上，一般就是屏幕。<code>print</code> 与 <code>printf</code> 都可以将其输出定向到其他的地方，这就称为<em>重定向</em>。
</p>
<blockquote>
<p><b>提示:</b> 当在命令行中指定了 &lsquo;<samp>--sandbox</samp>&rsquo;（查看 <a href="#Options">命令行参数</a>），
将输出定向到文件，管道与并程会被禁用。
</p></blockquote>

<p>重定向出现在 <code>print</code> 与 <code>printf</code> 语句之后。<code>awk</code> 中的重定向如 Shell 脚本中的重定向一样，区别只是它们是写在 <code>awk</code> 程序中。
</p>
<a name="index-print-statement_002c-See-Also-redirection_002c-of-output"></a>
<a name="index-printf-statement_002c-See-Also-redirection_002c-of-output"></a>
<p>有 4 种重定向方式：定向到文件，定向附加到文件的末尾；定向到另一个命令的管道中，与定向到一个并程。
我们将其展示在 <code>print</code> 语句中，但也可以应用在 <code>printf</code> 语句：
</p>
<dl compact="compact">
<dd><a name="index-_003e-_0028right-angle-bracket_0029_002c-_003e-operator-_0028I_002fO_0029"></a>
<a name="index-right-angle-bracket-_0028_003e_0029_002c-_003e-operator-_0028I_002fO_0029"></a>
<a name="index-operators_002c-input_002foutput-3"></a>
</dd>
<dt><code>print <var>items</var> &gt; <var>output-file</var></code></dt>
<dd><p>这个类型的定向会将项目输出到一个名字为 <var>output-file</var> 的文件中。
文件名 <var>output-file</var> 可以是任意表达式。它的值会被转换成字串并用作文件名
（查看 <a href="#Expressions">表达式</a>）。
</p>
<p>当使用这种重定向时，<var>output-file</var> 在第一个输出写入前会将文件清空。
后续对同一个文件的写不再进行内容擦除，只会附加。（这与你在 Shell 中使用重定向不同。）
如果 <var>output-file</var> 不存在，则创建它。
例如下面是一个 <code>awk</code> 程序，其会将人名列表写到名为 &lsquo;<tt>name-list</tt>&rsquo; 的文件中，
并将电话号码写入到另一个名为 &lsquo;<tt>phone-list</tt>&rsquo; 的文件中：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print $2 &gt; &quot;phone-list&quot;</kbd>
&gt;        <kbd>print $1 &gt; &quot;name-list&quot; }' mail-list</kbd>
$ <kbd>cat phone-list</kbd>
-| 555-5553
-| 555-3412
&hellip;
$ <kbd>cat name-list</kbd>
-| Amelia
-| Anthony
&hellip;
</pre></div>

<p>输出的文件中，每行包含一个名字或者一个电话号码。
</p>
<a name="index-_003e-_0028right-angle-bracket_0029_002c-_003e_003e-operator-_0028I_002fO_0029"></a>
<a name="index-right-angle-bracket-_0028_003e_0029_002c-_003e_003e-operator-_0028I_002fO_0029"></a>
</dd>
<dt><code>print <var>items</var> &gt;&gt; <var>output-file</var></code></dt>
<dd><p>这个类型的重定向将项目输出到一个已经存在的名为 <var>output-file</var> 的文件中。
这个用法与单个的 &lsquo;<samp>&gt;</samp>&rsquo; 的重定向有不同时，<var>output-file</var> 文件中的旧内容（如果有）不会被清空。
<code>awk</code> 的输出会附加到文件中。如果 <var>output-file</var> 文件不存在，则创建它。
</p>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c-operator-_0028I_002fO_0029-1"></a>
<a name="index-pipe_002c-output"></a>
<a name="index-output_002c-pipes"></a>
</dd>
<dt><code>print <var>items</var> | <var>command</var></code></dt>
<dd><p>通过管道可以将输出定向到一个另一个程序而不是文件。这个方式的重定向会向 <var>command</var> 打开一个管道，
然后将 <var>items</var> 的值通过为执行的 <var>command</var> 创建的管道写到咖一个程序中。
</p>
<p>重定向参数 <var>command</var> 实际是是一个 <code>awk</code> 表达式。
它的值会被转换成要执行的 Shell 命令的字串。例如，下面的代码会产生两个文件，一个是未排序的人名，一个按字母倒序对人名进行排列：
</p>

<div class="example">
<pre class="example">awk '{ print $1 &gt; &quot;names.unsorted&quot;
       command = &quot;sort -r &gt; names.sorted&quot;
       print $1 | command }' mail-list
</pre></div>

<p>未排序的列表按照常规的方式进行重定向，而排序的列表则通过管道向 <code>sort</code> 工具输出。
</p>
<p>下个例子利用重定向将消息通过邮件列表系统邮寄出去。这个功能在一个周期执行的系统维护 <code>awk</code> 脚本中遇到问题时，非常有用：
</p>
<div class="example">
<pre class="example">report = &quot;mail bug-system&quot;
print(&quot;Awk script failed:&quot;, $0) | report
print(&quot;at record number&quot;, FNR, &quot;of&quot;, FILENAME) | report
close(report)
</pre></div>

<p><code>close()</code> 函数在这里调用，是因为在将所有的输出写到管道后关闭它是一个好的编程实践。
查看 <a href="#Close-Files-And-Pipes">关闭输入输出重定向</a>，来获取更多的信息。
</p>
<p>这个例子也说明了利用变量来表示 <var>file</var> 文件或者 <var>command</var> 命令
——没有必要总是用字串常量来表示它们。
使用变量一般来说是个好主意，因为（如果你要用相同的名字或者命令）<code>awk</code> 需要每次都要写相同的字串。
</p>
<a name="index-coprocesses"></a>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029-1"></a>
<a name="index-operators_002c-input_002foutput-4"></a>
<a name="index-differences-in-awk-and-gawk_002c-input_002foutput-operators-1"></a>
</dd>
<dt><code>print <var>items</var> |&amp; <var>command</var></code></dt>
<dd><p>这个重定向将项目打印到 <var>command</var> 的输入中。
这个方式与单个 &lsquo;<samp>|</samp>&rsquo; 重定向的不同是，这里的 <var>command</var> 输出可以用 <code>getline</code> 进行读取。
因此，command 是一个<em>并程</em>，即与 <code>awk</code> 一起执行，但是只作为 <code>awk</code> 程序的补充。
</p>
<p>这个特性是 <code>gawk</code> 的扩展，在 POSIX 类型的 <code>awk</code> 是不可用的。
查看 <a href="#Getline_002fCoprocess">从并程中使用 <code>getline</code></a>，来获取简单的说明，查看 <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>，来获取更全面的讨论。
</p></dd>
</dl>

<p>使用 &lsquo;<samp>&gt;</samp>&rsquo;，&lsquo;<samp>&gt;&gt;</samp>&rsquo;，&lsquo;<samp>|</samp>&rsquo; 或者 &lsquo;<samp>|&amp;</samp>&rsquo; 请示系统打开一个文件、管道或者并程，
只要你所指定的 <var>file</var> 文件或者 <var>command</var> 命令还没有被你的程序写入，又或者它已经在最后一次写入后关闭了。
</p>
<a name="index-troubleshooting_002c-printing"></a>
<p>使用 &lsquo;<samp>&gt;</samp>&rsquo; 重定向先打印到文件，然后用 &lsquo;<samp>&gt;&gt;</samp>&rsquo; 为后续的输出是一个常见的错误：
</p>
<div class="example">
<pre class="example"># clear the file
print &quot;Don't panic&quot; &gt; &quot;guide.txt&quot;
&hellip;
# append
print &quot;Avoid improbability generators&quot; &gt;&gt; &quot;guide.txt&quot;
</pre></div>

<p>在 Shell 中确实是这么重定向的。但是在 <code>awk</code> 中，却没有必要。
在这咱情况下，程序应该在所有的 <code>print</code> 语句上使用 &lsquo;<samp>&gt;</samp>&rsquo;，因为输出文件只会打开一次。
（在混合使用 &lsquo;<samp>&gt;</samp>&rsquo; 与 &lsquo;<samp>&gt;&gt;</samp>&rsquo; 时，也是打开一次。但是，混用操作符是一种糟糕的编程习惯，会让你程序的读取困惑。）
</p>
<a name="index-differences-in-awk-and-gawk_002c-implementation-limitations-1"></a>
<a name="index-implementation-issues_002c-gawk_002c-limits-1"></a>
<a name="index-awk_002c-implementation-issues_002c-pipes"></a>
<a name="index-gawk_002c-implementation-issues_002c-pipes"></a>
<p>如早前所述（查看 <a href="#Getline-Notes">回顾 <code>getline</code></a>），许多的 <code>awk</code> 实现限制了 <code>awk</code> 程序可以打开的管线数量为一个！
<code>gawk</code> 则没有这个限制。<code>gawk</code> 可以打开的管线的数量只能所在的操作系统的限制。
</p>
<a name="index-sidebar_002c-c_00ae_00a1e_0081_0093e_00be_0093aa_0087_00baaa_0088_00b0-sh"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>管道输出到 <code>sh</code></b>
</p>

<a name="index-shells_002c-piping-commands-into"></a>

<p>一种使用重定向的强大方式是构造一个命令行，然后将用管道输出到 Shell，sh 中。
例如，你有一堆的文件是从其他系统中取来的，并且文件名都以大写存储，
而你想把他们全部改成小写的。下面的程序即简单也很高效：
</p>
<div class="example">
<pre class="example">{ printf(&quot;mv %s %s\n&quot;, $0, tolower($0)) | &quot;sh&quot; }

END { close(&quot;sh&quot;) }
</pre></div>

<p><code>tolower()</code> 函数返回参数字串中所有的大写字母被转换为小写的串（查看 <a href="#String-Functions">字串操作函数</a>）。
程序构建了一系列的命令行，并使用 <code>mv</code> 工具对文件进行改名，然后将这些命令列表发送给 Shell 执行。
</p>
<p>查看 <a href="#Shell-Quoting">将字串用引号引起并传递给 Shell</a>，了解可以辅助产生可以发送到 Shell 的命令行函数。
</p></td></tr></table>

<hr>
<a name="Special-FD"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Redirection" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Files" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a0_0087aa_0087_0086c_009a_0084e_00a2_0084ae_0089_0093aa_00bc_0080c_009a_0084c_0089_00b9ae_00ae_008aae_0096_0087a_00bb_00b6ae_0095_00b0ae_008d_00aeae_00b5_0081"></a>
<h2 class="section">5.7 标准的预打开的特殊文件数据流</h2>
<a name="index-standard-input-1"></a>
<a name="index-input_002c-standard-1"></a>
<a name="index-standard-output"></a>
<a name="index-output_002c-standard"></a>
<a name="index-error-output"></a>
<a name="index-standard-error"></a>
<a name="index-file-descriptors"></a>
<a name="index-files_002c-descriptors_002c-See-file-descriptors"></a>

<p>一般地，正在执行的程序已经有三个输入输出流可以用来进行读写。
这就是众所周知的<em>标准输入</em>，<em>标准输出</em>以及<em>标准错误输出</em>。
这些已经打开的流（以及任意已经打开的文件或者管道）技术上可以由所谓的<em>文件描述符</em>来表示。
</p>
<p>默认情况下，这些流是你的键盘与你的屏幕，但是他们常常通过 &lsquo;<samp>&lt;</samp>&rsquo;，&lsquo;<samp>&lt;&lt;</samp>&rsquo;，&lsquo;<samp>&gt;</samp>&rsquo;，&lsquo;<samp>&gt;&gt;</samp>&rsquo;，&lsquo;<samp>&gt;&amp;</samp>&rsquo; 与 &lsquo;<samp>|</samp>&rsquo; 操作符，在 Shell 中被重定向。
标准错误一股用于写错误信息，有两个分离流（标准输出与标准错误输出）的原因是它们可以被单独地进行重定向。
</p>
<a name="index-differences-in-awk-and-gawk_002c-error-messages"></a>
<a name="index-error-handling"></a>
<p>在 <code>awk</code> 的传统实现中，在 <code>awk</code> 程序中将错误信息写到标准错误输出的唯一方式如下：
</p>
<div class="example">
<pre class="example">print &quot;Serious error detected!&quot; | &quot;cat 1&gt;&amp;2&quot;
</pre></div>

<p>通过打开一个到 Shell 命令的管线，而该命令可以访问从 <code>awk</code> 继承而来的标准错误流。
这样写没那么优雅，而且也需要开启一个独立的进程。因此，人们在 <code>awk</code> 程序不常这么干，而是通过下面的方式来输出信息到屏幕：
</p>
<div class="example">
<pre class="example">print &quot;Serious error detected!&quot; &gt; &quot;/dev/tty&quot;
</pre></div>

<p>（&lsquo;<tt>/dev/tty</tt>&rsquo; 是一个由操作系统提供的特殊文件，该文件与你的键盘与屏幕连接。它表示的是“终端” （Terminal），
<a name="DOCF33" href="#FOOT33">(33)</a>
在现在系统中是键盘与屏幕，而不是串行控制台。）这一般有相同的效果，但是并不总是如此：
尽管标准错误输出一般就是屏幕，但是它可以被重定向。当发生这种情况时，写到屏幕就不正确了。事实上，如果 <code>awk</code> 是一个后台任务，它根本主没有终端。这样，打开 &lsquo;<tt>/dev/tty</tt>&rsquo; 就会失败。
</p>
<p><code>gawk</code>，BWK <code>awk</code> 以及 <code>mawk</code> 提供了访问三个标准流的特殊文件名。
如果 <code>gawk</code> 在重定向输入输出时，文件名匹配这其中之一，它就直接使用这个文件名所代表的文件描述符。
这此特殊文件名在所有的 <code>gawk</code> 已经移植到的操作系统中都有效，并不仅仅是 POSIX 兼容的系统：
</p>
<a name="index-common-extensions_002c-_002fdev_002fstdin-special-file"></a>
<a name="index-common-extensions_002c-_002fdev_002fstdout-special-file"></a>
<a name="index-common-extensions_002c-_002fdev_002fstderr-special-file"></a>
<a name="index-extensions_002c-common_002c-_002fdev_002fstdin-special-file"></a>
<a name="index-extensions_002c-common_002c-_002fdev_002fstdout-special-file"></a>
<a name="index-extensions_002c-common_002c-_002fdev_002fstderr-special-file"></a>
<a name="index-file-names_002c-standard-streams-in-gawk"></a>
<a name="index-_002fdev_002f_2026-special-files"></a>
<a name="index-files_002c-_002fdev_002f_2026-special-files"></a>
<a name="index-_002fdev_002ffd_002fN-special-files-_0028gawk_0029"></a>
<dl compact="compact">
<dt>&lsquo;<tt>/dev/stdin</tt>&rsquo;</dt>
<dd><p>标准输入（文件描述符为 0）。
</p>
</dd>
<dt>&lsquo;<tt>/dev/stdout</tt>&rsquo;</dt>
<dd><p>标准输出（文件描述符为 1）。
</p>
</dd>
<dt>&lsquo;<tt>/dev/stderr</tt>&rsquo;</dt>
<dd><p>标准错误输出（文件描述符 2）。
</p></dd>
</dl>

<p>复用这些工具，恰当的将错误信息输出的方式就如下：
</p>
<div class="example">
<pre class="example">print &quot;Serious error detected!&quot; &gt; &quot;/dev/stderr&quot;
</pre></div>

<a name="index-troubleshooting_002c-quotes-with-file-names"></a>
<p>注意在文件上使用的双引号。如其他的重定向，其值必须是字串。常见的错误就是省略了引号，没有引号会产生令人疑惑的结果。
</p>
<p><code>gawk</code> 在 POSIX 兼容模式下，并不将这些文句特殊对待。但是，因为 BWK <code>awk</code> 支持它们，
<code>gawk</code> 也支持它们，就算使用了 &lsquo;<samp>--traditional</samp>&rsquo; 选项也是一样
（查看 <a href="#Options">命令行参数</a>）。
</p>
<hr>
<a name="Special-Files"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Special-FD" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Inherited-Files" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-a_00b8_00adc_009a_0084c_0089_00b9ae_00ae_008aae_0096_0087a_00bb_00b6aa_0090_008d"></a>
<h2 class="section">5.8 <code>gawk</code> 中的特殊文件名</h2>
<a name="index-gawk_002c-file-names-in"></a>

<p>除了标准输入，标准输出与标准错误输出，
<code>gawk</code> 还提供了访问任意已经打开文件描述符的方法。另外，还保留了用于 TCP/IP 网络的特殊文件名。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Other-Inherited-Files">5.8.1 在 <code>gawk</code> 访问其他已开文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Accessing other open files with
                                <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Special-Network">5.8.2 用于网络的特殊文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Special files for network communications.
</td></tr>
<tr><td align="left" valign="top"><a href="#Special-Caveats">5.8.3 特殊文件名说明</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Things to watch out for.
</td></tr>
</table>

<hr>
<a name="Other-Inherited-Files"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Files" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Network" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-gawk-e_00ae_00bfe_0097_00aeaa_0085_00b6a_00bb_0096aa_00b7_00b2aa_00bc_0080ae_0096_0087a_00bb_00b6"></a>
<h3 class="subsection">5.8.1 在 <code>gawk</code> 访问其他已开文件</h3>

<p>除了 <code>/dev/stdin</code>，<code>/dev/stdout</code>，与 <code>/dev/stderr</code> 这些早前提过的特殊文件名外，
<code>gawk</code> 还提供了访问已经打开的文件的语法：
</p>
<dl compact="compact">
<dt>&lsquo;<tt>/dev/fd/<var>N</var></tt>&rsquo;</dt>
<dd><p>与文件描述符 <var>N</var> 关联的文件。该文件必须由启动 <code>awk</code> 程序执行的程序（一般是 Shell ）打开的文件。
除非在调用 <code>gawk</code> 的 Shell 中多花一些功夫，不然只会有描述符 0，1 与 2 是打开的。
</p></dd>
</dl>

<p>文件名 &lsquo;<tt>/dev/stdin</tt>&rsquo;，&lsquo;<tt>/dev/stdout</tt>&rsquo;，与 &lsquo;<tt>/dev/stderr</tt>&rsquo; 实际上就是 &lsquo;<tt>/dev/fd/0</tt>&rsquo;，&lsquo;<tt>/dev/fd/1</tt>&rsquo;，
与 &lsquo;<tt>/dev/fd/2</tt>&rsquo; 的别名。但是，这些名字更有说明性。
</p>
<p>注意，对于文件描述符号大于 2 以上的文件名形式 <code>&quot;/dev/fd/<var>N</var>&quot;</code> 执行 <code>close()</code> 函数，
才会真正地执行关闭（close）操作。
</p>
<hr>
<a name="Special-Network"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Inherited-Files" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Caveats" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_00a8a_00ba_008ec_00bd_0091c_00bb_009cc_009a_0084c_0089_00b9ae_00ae_008aae_0096_0087a_00bb_00b6"></a>
<h3 class="subsection">5.8.2 用于网络的特殊文件</h3>
<a name="index-networks_002c-support-for"></a>
<a name="index-TCP_002fIP_002c-support-for"></a>

<p><code>gawk</code> 程序可以打开双向通信的 TCP/IP 连接，正如一个客户端与一个服务端一样。
这可以通过下面形式的特殊文件名来实现：
</p>
<div class="example">
<pre class="example">&lsquo;<tt>/<var>net-type</var>/<var>protocol</var>/<var>local-port</var>/<var>remote-host</var>/<var>remote-port</var></tt>&rsquo;
</pre></div>

<p><var>net-type</var> 是 &lsquo;<samp>inet</samp>&rsquo;，&lsquo;<samp>inet4</samp>&rsquo;， 或者 &lsquo;<samp>inet6</samp>&rsquo; 之一。
<var>protocol</var> 是 &lsquo;<samp>tcp</samp>&rsquo; 或者 &lsquo;<samp>udp</samp>&rsquo; 之一，其他的参数则代表了要启动一个网络连接所需要的其他信息。
这些文件名与 &lsquo;<samp>|&amp;</samp>&rsquo; 一起使用用来进行并程通信（查看 <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>）。这是一个高级特性，为了完整性在这里先说明一下。完整的讨论要到 <a href="#TCP_002fIP-Networking">利用 <code>gawk</code> 进行网络通信</a>。
</p>
<hr>
<a name="Special-Caveats"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Network" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Files" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Close-Files-And-Pipes" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0089_00b9ae_00ae_008aae_0096_0087a_00bb_00b6aa_0090_008de_00af_00b4ae_0098_008e"></a>
<h3 class="subsection">5.8.3 特殊文件名说明</h3>

<p>如果要使用 <code>gawk</code> 提供的一些特殊文件名，则下面有一些要记住的点：
</p>
<ul>
<li><a name="index-compatibility-mode-_0028gawk_0029_002c-file-names"></a>
<a name="index-file-names_002c-in-compatibility-mode"></a>
</li><li>
对于三个预打开的标准文件名的识别只有在 POSIX 模式下才会被禁止。

</li><li>
对于其他特殊文件名的识别，只有 <code>gawk</code> 处于兼容模式时才会被禁止（要么使用 &lsquo;<samp>--traditional</samp>&rsquo; ，
要么是使用 &lsquo;<samp>--posix</samp>&rsquo; 选项，查看 <a href="#Options">命令行参数</a>）。

</li><li>
<code>gawk</code> <em>总是</em>会解释这些特殊文件名。
例如，使用 &lsquo;<samp>/dev/fd/4</samp>&rsquo; 为输出，实际上写入的是描述符为 4 的文件，而不是使用 <code>dup()</code> 复制 4 描述符的新文件。
大多数情况下，这没有什么问题。但是，<em>不要</em>关闭任意与文件描述符 0，1，2 相关的文件，这个相当重要。这么做的话，会导致不可预知的行为。
</li></ul>

<hr>
<a name="Close-Files-And-Pipes"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Special-Caveats" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Output-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_00b3e_0097_00ade_00be_0093aa_0085_00a5e_00be_0093aa_0087_00bae_0087_008daa_00ae_009aaa_0090_0091"></a>
<h2 class="section">5.9 关闭输入输出重定向</h2>
<a name="index-files_002c-output_002c-See-output-files"></a>
<a name="index-input-files_002c-closing"></a>
<a name="index-output_002c-files_002c-closing"></a>
<a name="index-pipe_002c-closing"></a>
<a name="index-coprocesses_002c-closing"></a>
<a name="index-getline-command_002c-coprocesses_002c-using-from-1"></a>

<p>在 <code>awk</code> 程序执行期间，如果同样的文件名或者同一个 Shell 命令被 <code>getline</code> 使用过多于一次
（查看 <a href="#Getline">用 <code>getline</code> 输入数据</a>），则文件（或者命令的执行）只在第一次发生。从那以后，从中读取第一个输入记录。
通过 <code>getline</code> 再次读取同一个文件或者命令时，第二条记录从其中获取，以此类推。
</p>
<p>相似地，当文件或者管道被打开用于输出时，<code>awk</code> 会记录文件名或者与其相关的命令，后续对于同一个文件或者命令写入，会被附加到前一个写操作之后。直到 <code>awk</code> 退出后，文件或者管道才会被关闭。
</p>
<a name="index-close_0028_0029-function"></a>
<p>这意思是说，为了再次从头开始读取同一个文件，或者重新执行一个 Shell 命令，你需要一些特别步骤（而不是从同一个命令中读取更多的输出）。
<code>close()</code> 函数就是用来执行这个步骤：
</p>
<div class="example">
<pre class="example">close(<var>filename</var>)
</pre></div>

<p>或者：
</p>
<div class="example">
<pre class="example">close(<var>command</var>)
</pre></div>

<p><var>filename</var> 与 <var>command</var> 参数可以是任意的表达式。
它的值必须<em>完全</em>匹配用以打开的文件或者启动的命令行的字串（空格与其他“无关”的字符也包括在内）。例如，如果你像这样打开一个管道：
</p>
<div class="example">
<pre class="example">&quot;sort -r names&quot; | getline foo
</pre></div>

<p>然后你必须这样来关闭它：
</p>
<div class="example">
<pre class="example">close(&quot;sort -r names&quot;)
</pre></div>

<p>只要函数调用执行过，下一个从那个文件或者管道进行 <code>getline</code> 时，
或者下一个 <code>print</code> 与 <code>printf</code> 到那个文件或者管道，会被重新打开或者重新执行命令。
由于你用来关闭的文件或者管线必须完全匹配你用来打开的文件或者执行的命令，
所以用一个变量来存储文件名或者命令是一个好的编程实践。上面的例子因此可以变成这样：
</p>
<div class="example">
<pre class="example">sortcom = &quot;sort -r names&quot;
sortcom | getline foo
&hellip;
close(sortcom)
</pre></div>

<p>这可以帮助你避免 <code>awk</code> 程序中那些很难查找的输出错误。这也有一些理由为什么要关闭输出文件：
</p>
<ul>
<li>
为了写这样一个文件，这个文件之后会在同一个 <code>awk</code> 程序中读取它。
在写完之后要关闭它，然后再使用 <code>getline</code> 进行读取。

</li><li>
为了在 <code>awk</code> 程序中，连续地写大量的文件。
如果文件没有被关闭，<code>awk</code> 有可能最终会超过系统对于同一个进程中所能打开的文件数的限制。因此最好是在写完每个文件时关闭它。

</li><li>
为了完成一个命令。当输出重定向是通过管道进行的。
从这个管道读取的命令会持续尝试从管道中读取，只要管道是打开的。通常情况下，相关的命令直到管道关闭的情况下才能继续干自己的事情。
例如，如果输出被重定向到了 <code>mail</code> 程序，消息直到管道被关闭了才实际地发送完。

</li><li>
为了执行第二次，利用相同的参数，执行相同的程序。这与比第一次执行输入更多的数据不是一件事情！

<p>例如，假设一种程序会将输出通过管道输出给 <code>mail</code> 程序。如果输出了几行重定向到了这个管道而没有关闭，
则它们会生成一个包括几行数据的简单的消息（邮件）。另一方面，如果程序每输出一行就关闭一次管道，则每一行都成一个一独立的消息（邮件）。
</p></li></ul>

<a name="index-differences-in-awk-and-gawk_002c-close_0028_0029-function"></a>
<a name="index-portability_002c-close_0028_0029-function-and"></a>
<a name="index-close_0028_0029-function_002c-portability"></a>
<p>如果你使了比系统所允许你打开的文件数更多的文件，<code>gawk</code> 会尝试复用你的数据文件中已经打开的文件。
<code>gawk</code> 这样的能力依赖于你的操作系统所提供的工具，因此并不一定总是会有用。所以，无论对于是好的实践也好，还是好的可移植性建议也好，当处理完一个文件时，
就应该通过 <code>close()</code> 将它们关闭。事实上，如果你使用了大量的管道，在使用完后进行关闭是很重要的。例如，考虑下面的代码：
</p>
<div class="example">
<pre class="example">{
    &hellip;
    command = (&quot;grep &quot; $1 &quot; /some/file | my_prog -q &quot; $3)
    while ((command | getline) &gt; 0) {
        <var>process output of</var> command
    }
    # need close(command) here
}
</pre></div>

<p>在这个例子中创建了基于每个记录的管线，如注释中所述的，没有调用 <code>close()</code> 函数，
则 <code>awk</code> 会创建一个子进程来执行命令，直到最终由于请求更多的管线而耗尽文件描述符。
</p>
<p>尽管每个命令都已经执行完成（通过 <code>getline</code> 的 end-of-file 的返回值指示），子进程却没有结束；
<a name="DOCF34" href="#FOOT34">(34)</a>
更重要的是，与管道关联的描述符直到 <code>awk</code> 退出后，才会调用 <code>close()</code> 进行关闭释放。
</p>
<p><code>close()</code> 如果接收的不是一个文件、管道或者并程这样的打开用于重定向的参数，则默默地什么也不干。
在这种情况下，它的返回值是负值，表示错误。另外，<code>gawk</code> 会设置 <code>ERRNO</code> 的值为指示对应的错误。
</p>
<p>也要注意到 &lsquo;<samp>close(FILENAME)</samp>&rsquo;，针对从命令行中读取文件名这样的隐式循环没有什么“魔法”效应。
更有可能的是，对于文件的关闭，在重定向中不会再打开，因此 <code>awk</code> 会什么也不做，而是返回一个负值。
</p>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029_002c-pipes_002c-closing"></a>
<p>当使用 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符与并程进行通信时，关闭双向通信中的一端偶尔的情况下会非常有用。
这只需要在调用 <code>close()</code> 时提供第二个参数就可以完成。
如其他地方调用 <code>close()</code> 类似，第一个参数是命令名，或者是用于开启并程的特殊文件。
而第二个参数是一个字串，其值是 <code>&quot;to&quot;</code> 或者是 <code>&quot;from&quot;</code>，大小写无关。这是一个高级特性，
会到 <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>，进行详细的讨论，并提供更多的实际例子。
</p>
<a name="index-sidebar_002c-a_00bd_00bfc_0094_00a8-close_0028_0029-c_009a_0084e_00bf_0094aa_009b_009eaa_0080_00bc"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>使用 <code>close()</code> 的返回值</b>
</p>

<a name="index-dark-corner_002c-close_0028_0029-function"></a>
<a name="index-close_0028_0029-function_002c-return-value"></a>
<a name="index-return-value_002c-close_0028_0029-function"></a>
<a name="index-differences-in-awk-and-gawk_002c-close_0028_0029-function-1"></a>
<a name="index-Unix-awk_002c-close_0028_0029-function-and"></a>

<p>在许多 Unix <code>awk</code> 的老版本中，<code>close()</code> 函数实际上是一条语句。
(d.c.)
尝试利用 <code>close()</code> 的返回值是一个语法错误：
</p>
<div class="example">
<pre class="example">command = &quot;&hellip;&quot;
command | getline info
retval = close(command)  # syntax error in many Unix awks
</pre></div>

<a name="index-gawk_002c-ERRNO-variable-in-1"></a>
<a name="index-ERRNO-variable_002c-with-close_0028_0029-function"></a>
<p><code>gawk</code> 将 <code>close()</code> 当成一个函数。如果其参数表示从未打开的东西（文件、管道、并程），则返回值 -1 ，
或者是系统问题导致文件或者进程的关闭，则也会返回 -1 。
在这个情况下，<code>gawk</code> 将预定义的变量 <code>ERRNO</code> 的值设定为描述问题的字串。
</p>
<p>在 <code>gawk</code> 中，当关闭管道或者并程时（输入或输出），其返回值就是命令的退出状态。
<a name="DOCF35" href="#FOOT35">(35)</a>
否则，它就是从系统的 <code>close()</code> 或者 C 函数 <code>close()</code> 的关闭输入输出文件时的返回值。
如果成功，则值返回为 0，失败下返回 -1 。
</p>
<p>POSIX 标准非常模糊地说，<code>close()</code> 在成功的时候返回 0，而失败时返回非零值。
一般情况下，不同的实现在关闭管道时会报告不同的结果，因此，返回值是不可移植的。
(d.c.)
在 POSIX 模式下（查看 <a href="#Options">命令行参数</a>），<code>gawk</code> 在关闭管道时，只返回 0。
</p></td></tr></table>


<hr>
<a name="Output-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Close-Files-And-Pipes" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Output-Exercises" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-15"></a>
<h2 class="section">5.10 总结</h2>

<ul>
<li>
<code>print</code> 打印逗号分隔的表达式。每个表达式在输出时都由 <code>OFS</code> 的值进行分隔，并以 <code>ORS</code> 的值结束。<code>OFMT</code> 提供了对数值 <code>print</code> 输出时的格式转换。

</li><li>
<code>printf</code> 语句提供了非常好的输出控制粒度，通过格式控制字母来输出不同的数据类型。同时，用不同的标志来修改格式控制字母的行为。

</li><li>
<code>print</code> 与 <code>printf</code> 的输出都可以重定向到文件、管道与并程。

</li><li>
<code>gawk</code> 提供了特殊的文件名用于访问标准输入、标准输出与标准错误输出，以及进行网络通信。

</li><li>
使用 <code>close()</code> 来关闭打开的文件、管道以并并程的重定向。对于并程来说，可以通过关闭某个方向的通信。

</li></ul>

<hr>
<a name="Output-Exercises"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Output-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bb_0083a_00b9_00a0-3"></a>
<h2 class="section">5.11 练习</h2>

<ol>
<li>
通过在输出中使用 <code>OFS</code> 变量，重写下面的程序：

<div class="example">
<pre class="example">awk 'BEGIN { print &quot;Month Crates&quot;
             print &quot;----- ------&quot; }
           { print $1, &quot;     &quot;, $2 }' inventory-shipped
</pre></div>

<p>它来自于 <a href="#Output-Separators">输出分隔符</a>。
</p>
</li><li>
使用 <code>printf</code> 语句来对齐头部与数据表，例子来自由 <a href="#Print"><code>print</code> 语句</a>，&lsquo;<tt>inventory-shipped</tt>&rsquo; 文件。

</li><li>
在下面的代码中，如果你没有用双引号在重定向输出时会发生什么：

<div class="example">
<pre class="example">BEGIN { print &quot;Serious error detected!&quot; &gt; /dev/stderr }
</pre></div>

</li></ol>


<hr>
<a name="Expressions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Printing" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Output-Exercises" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Values" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h1 class="chapter">6 表达式</h1>
<a name="index-expressions"></a>

<p>表达式是 <code>awk</code> 模式与动作的基本构造块。表达式求值后可用于打印，测试或者传递给函数。另外，表达式还可以通过赋值操作符将一个新值赋给一个变量。
</p>
<p>表达式本身可以成为一个模式，或者动作语句。多数其他类型的语句包含一个或者多个表达式，来指定要操作的数据。如在其他语言中一样，
<code>awk</code> 中的表达式可以包含变量、数组参考、常量以及函数调用，还可以是这些内容与不同的操作符的各种组合。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Values">6.1 常量、变量与转换</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Constants, Variables, and Regular Expressions.
</td></tr>
<tr><td align="left" valign="top"><a href="#All-Operators">6.2 操作符：对值进行处理</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               <code>gawk</code>&rsquo;s operators.
</td></tr>
<tr><td align="left" valign="top"><a href="#Truth-Values-and-Conditions">6.3 真值与条件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Testing for true and false.
</td></tr>
<tr><td align="left" valign="top"><a href="#Function-Calls">6.4 函数调用</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              A function call is an expression.
</td></tr>
<tr><td align="left" valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How various operators nest.
</td></tr>
<tr><td align="left" valign="top"><a href="#Locales">6.6 哪里造成差异</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     How the locale affects things.
</td></tr>
<tr><td align="left" valign="top"><a href="#Expressions-Summary">6.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Expressions summary.
</td></tr>
</table>

<hr>
<a name="Values"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Constants" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b8_00b8e_0087_008fa_0080_0081aa_008f_0098e_0087_008fa_00b8_008ee_00bd_00acae_008d_00a2"></a>
<h2 class="section">6.1 常量、变量与转换</h2>

<p>表达式由值与处理这些值的操作组成。本小节描述在表达式中使用的基本元素对象。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Constants">6.1.1 常量表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   String, numeric and regexp constants.
</td></tr>
<tr><td align="left" valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      When and how to use a regexp constant.
</td></tr>
<tr><td align="left" valign="top"><a href="#Variables">6.1.3 变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Variables give names to values for later use.
</td></tr>
<tr><td align="left" valign="top"><a href="#Conversion">6.1.4 在字串与数值之间进行转换</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  The conversion of strings to numbers and vice
                                versa.
</td></tr>
</table>

<hr>
<a name="Constants"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Values" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Values" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Scalar-Constants" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b8_00b8e_0087_008fe_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h3 class="subsection">6.1.1 常量表达式</h3>

<a name="index-constants_002c-types-of"></a>

<p>最简单的表达式类型就是<em>常量</em>，它们总是有不变的值。有三个常量：数值常量、字串常量与表达式常量。
</p>
<p>如果你所需要的值不需要变化，那么你可以在适当的上下文中使用它们。数值常量又有不同的形式，但是在内部，它们都以相同的方式进行存储。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Scalar-Constants">6.1.1.1 数值与字串常量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Numeric and string constants.
</td></tr>
<tr><td align="left" valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          What are octal and hex numbers.
</td></tr>
<tr><td align="left" valign="top"><a href="#Regexp-Constants">6.1.1.3 正则表达式常量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Regular Expression constants.
</td></tr>
</table>

<hr>
<a name="Scalar-Constants"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Constants" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Constants" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Nondecimal_002dnumbers" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0aa_0080_00bca_00b8_008eaa_00ad_0097a_00b8_00b2aa_00b8_00b8e_0087_008f"></a>
<h4 class="subsubsection">6.1.1.1 数值与字串常量</h4>

<a name="index-constants_002c-numeric"></a>
<a name="index-numeric-constants"></a>
<p><em>数值常量</em>表示数值。此数值可以是整数，十进制小数或者是科学计数形式（幂指数）的形式。
<a name="DOCF36" href="#FOOT36">(36)</a>
下面的例子只所有形式的常量的值都是一样的：
</p>
<div class="example">
<pre class="example">105
1.05e+2
1050e-1
</pre></div>

<a name="index-string-constants"></a>
<p><em>字串常量</em>由双引号括起来的字符序列组成。如：
</p>
<div class="example">
<pre class="example">&quot;parrot&quot;
</pre></div>

<a name="index-differences-in-awk-and-gawk_002c-strings"></a>
<a name="index-strings_002c-length-limitations"></a>
<p>表示字串内容为 &lsquo;<samp>parrot</samp>&rsquo; 。在 <code>gawk</code> 中的字串可以有任意长度，
可以包括任何可能的 8 比特的 ASCII 字符，包括 ASCII 的 <small>NUL</small> 字符（字符编码为 0）。
其他的 <code>awk</code> 实现有可能在处理一些字符编码时存在一些困难。
</p>
<hr>
<a name="Nondecimal_002dnumbers"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Scalar-Constants" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Constants" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Constants" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_00abe_00bf_009baa_0088_00b6a_00b8_008eaa_008d_0081aa_0085_00ade_00bf_009baa_0088_00b6ae_0095_00b0aa_0080_00bc"></a>
<h4 class="subsubsection">6.1.1.2 八进制与十六进制数值</h4>
<a name="index-octal-numbers"></a>
<a name="index-hexadecimal-numbers"></a>
<a name="index-numbers_002c-octal"></a>
<a name="index-numbers_002c-hexadecimal"></a>

<p>在 <code>awk</code> 中，所有的数值都是十进制数（以 10 为进制）。很多的其他编程变速器允许你指定其他进制的数，
一般为八进制（以 8 为进制）和十六进制（以 16 为进制）。在八进制中，数值为 0，1，2，4，5，6，7，10，11，12 等等。
正如十进制中的 &lsquo;<samp>11</samp>&rsquo;，是 1 乘 10，然后加 1，因此八进制中的 &lsquo;<samp>11</samp>&rsquo;，表示是 1 乘 8，然后加 1。
在十进制中它等于 9。对于十六进制，有 16 个数字位。由于我们日常的十进制数值系统中只有 10 个数字位（&lsquo;<samp>0</samp>&rsquo; - &lsquo;<samp>9</samp>&rsquo;），
因此，&lsquo;<samp>a</samp>&rsquo; 到 &lsquo;<samp>f</samp>&rsquo; 这 6 个字符用来表示剩下的部分。
（大小写通常是无关的，十六进制的 &lsquo;<samp>a</samp>&rsquo; 与 &lsquo;<samp>A</samp>&rsquo; 有相同的值。）因此，十六进制中的 &lsquo;<samp>11</samp>&rsquo; 表示的是 1 乘 16，然后加 1，在进制中则是 17。
</p>
<p>通过 &lsquo;<samp>11</samp>&rsquo; 这个普通字串，你无法知道它是什么进制的。
因此，在 C，C++ 以及其他的从 C 派生出来的语言中。有一个特殊的符号用来指明进制。八进制以 &lsquo;<samp>0</samp>&rsquo; 开头，而十六进制则以 &lsquo;<samp>0x</samp>&rsquo; 或者 &lsquo;<samp>0X</samp>&rsquo; 开头。
</p>
<dl compact="compact">
<dt><code>11</code></dt>
<dd><p>十进制值的 11
</p>
</dd>
<dt><code>011</code></dt>
<dd><p>八进制的 11，十进制的 9
</p>
</dd>
<dt><code>0x11</code></dt>
<dd><p>十六进制的 11，十进制的 17
</p></dd>
</dl>

<p>这个例子体现了其中的不同：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { printf &quot;%d, %d, %d\n&quot;, 011, 11, 0x11 }'</kbd>
-| 9, 11, 17
</pre></div>

<p>当在你的程序中，所处理的数据不能方便地进行表示成字串或者正则表达式时，使用这些的八进制或者十六进制常数则非常有用，例如各种不同的二进制数据。
</p>
<a name="index-gawk_002c-octal-numbers-and"></a>
<a name="index-gawk_002c-hexadecimal-numbers-and"></a>
<p><code>gawk</code> 可以让你在程序文件中使用八进制或者十六进制数值。但是，这样的数值在输入时会区别对待，
默认这么做会导致旧的程序无法正常执行。（如果你确实要这么做，使用 &lsquo;<samp>--non-decimal-data</samp>&rsquo; 这个命令行选项，
查看 <a href="#Nondecimal-Data">允许非十进制数数据输入</a>）如果你有八进制或者十六进制的数据，你可以使用 <code>strtonum()</code>
（查看 <a href="#String-Functions">字串操作函数</a>）函数来将这些数据转换为数值。
大多数时候，你在使用内建的位操作函数时，你都会使用八进制或者十六进制数据。
可以查看 <a href="#Bitwise-Functions">位操作函数</a>，来获取更多的信息。
</p>
<p>不像早期的 C 实现，&lsquo;<samp>8</samp>&rsquo; 与 &lsquo;<samp>9</samp>&rsquo; 不是有效的八进制常数。例如，<code>gawk</code> 会将 &lsquo;<samp>018</samp>&rsquo; 当成是十进制的 18：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { print &quot;021 is&quot;, 021 ; print 018 }'</kbd>
-| 021 is 17
-| 18
</pre></div>

<a name="index-compatibility-mode-_0028gawk_0029_002c-octal-numbers"></a>
<a name="index-compatibility-mode-_0028gawk_0029_002c-hexadecimal-numbers"></a>
<p>八进制与十六进制源代码常量是 <code>gawk</code> 的扩展。如果 <code>gawk</code> 处于兼容模式（查看 <a href="#Options">命令行参数</a>），
则它们是不可用的。
</p>
<a name="index-sidebar_002c-aa_00b8_00b8e_0087_008fc_009a_0084e_00bf_009baa_0088_00b6a_00b8_008da_00bc_009aaa_00bd_00b1aa_0093_008daa_00ae_0083c_009a_0084aa_0080_00bc"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>常量的进制不会影响它的值</b>
</p>


<p>只要数值常量被转换成了数值的内部表示，<code>gawk</code> 就不再记住常量的原始格式，<code>gawk</code> 总是会使用内部的值。这在将数值转换成字串时有一个特殊的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { printf &quot;0x11 is &lt;%s&gt;\n&quot;, 0x11 }'</kbd>
-| 0x11 is &lt;17&gt;
</pre></div>
</td></tr></table>

<hr>
<a name="Regexp-Constants"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Nondecimal_002dnumbers" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Constants" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Using-Constant-Regexps" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008faa_00b8_00b8e_0087_008f"></a>
<h4 class="subsubsection">6.1.1.3 正则表达式常量</h4>

<a name="index-regexp-constants-1"></a>
<a name="index-_007e-_0028tilde_0029_002c-_007e-operator-3"></a>
<a name="index-tilde-_0028_007e_0029_002c-_007e-operator-3"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-3"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-3"></a>
<p><em>正则表达式常量</em>是一个包含在一对斜杠中的正则表达式描述。
例如 <code>/^beginning&nbsp;and&nbsp;end$/</code>。
<code>awk</code> 程序中使用的大多数正则表达式都是常量，但是 &lsquo;<samp>~</samp>&rsquo; 与 &lsquo;<samp>!~</samp>&rsquo; 匹配操作符也可以匹配计算型，即动态型正则表大式（典型的情况下，它们就是包含正则表达式的普通的字串或者变量，但是是更复杂的表达式而已）。
</p>
<hr>
<a name="Using-Constant-Regexps"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Constants" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Values" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Variables" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008faa_00b8_00b8e_0087_008f"></a>
<h3 class="subsection">6.1.2 使用正则表达式常量</h3>

<a name="index-dark-corner_002c-regexp-constants"></a>
<p>当在 &lsquo;<samp>~</samp>&rsquo; 或者 &lsquo;<samp>!~</samp>&rsquo; 操作的右手边时，正则表达式仅权表示要匹配的正则表达式。
但是正则表达式常量（例如 <code>/foo/</code>）可以当成简单的表达式来使用。
当正则表达式常量单独出现时，与它在模式中出现时有相同的含义（如 &lsquo;<samp>($0 ~ /foo/)</samp>&rsquo;）
(d.c.)
查看 <a href="#Expression-Patterns">以表达式为模式</a>。这表示下面的两个代码片段：
</p>
<div class="example">
<pre class="example">if ($0 ~ /barfly/ || $0 ~ /camelot/)
    print &quot;found&quot;
</pre></div>

<p>与：
</p>
<div class="example">
<pre class="example">if (/barfly/ || /camelot/)
    print &quot;found&quot;
</pre></div>

<p>是完全等同的。这个规则的一个非常奇怪的结果就是下面的布林表达式是有效的，但是并不是作者所认为的那样执行：
</p>
<div class="example">
<pre class="example"># Note that /foo/ is on the left of the ~
if (/foo/ ~ $1) print &quot;found foo&quot;
</pre></div>

<a name="index-gawk_002c-regexp-constants-and"></a>
<a name="index-regexp-constants_002c-in-gawk"></a>
<p>这个代码“很明显”地是要测试 <code>$1</code> 是不是匹配正则表达式 <code>/foo/</code>。
但是实际上，表达式 &lsquo;<samp>/foo/ ~ $1</samp>&rsquo; 表示的是 &lsquo;<samp>($0 ~ /foo/) ~ $1</samp>&rsquo;。
换句话说，首先匹配输入记录与正则表达式 <code>/foo/</code>，所得到的结果要么是 0，要么是 1。
这就要看匹配的是成功还是失败。匹配的结果然后再与记录的第一个域进行匹配。
由于你不可能是想做这样的测试，<code>gawk</code> 会针对程序中这样的结构发出一个告警。这个规则的另一个结果就是如下的匹配语句：
</p>
<div class="example">
<pre class="example">matches = /foo/
</pre></div>

<p>是要么将 0，要么是将 1 赋值给变量 <code>matches</code>，内容依赖于当前的输入记录。
</p>
<a name="index-differences-in-awk-and-gawk_002c-regexp-constants"></a>
<a name="index-dark-corner_002c-regexp-constants_002c-as-arguments-to-user_002ddefined-functions"></a>
<a name="index-gensub_0028_0029-function-_0028gawk_0029"></a>
<a name="index-sub_0028_0029-function"></a>
<a name="index-gsub_0028_0029-function"></a>
<p>正则表达式也可以用于 <code>gensub()</code>，<code>sub()</code> 与 <code>gsub()</code> 函数的第一个参数，
或者是 <code>match()</code> 函数的第二个参数，以及 <code>split()</code> 与 <code>patsplit()</code> 函数的第三个参数
（查看 <a href="#String-Functions">字串操作函数</a>）。<code>awk</code> 的现代版本，包括 <code>gawk</code>，
允许 <code>split()</code> 的第三个参数是一个正则表达式常量，但是旧一点的版本不允许。
(d.c.)
由于一些内置的函数接受正则表达式会它的参数，因此将其作为用户自定义函数（查看 <a href="#User_002ddefined">用户自定义函数</a>）的参数时，使用正则表达式会带来困惑。如：
</p>
<div class="example">
<pre class="example">function mysub(pat, repl, str, global)
{
    if (global)
        gsub(pat, repl, str)
    else
        sub(pat, repl, str)
    return str
}

{
    &hellip;
    text = &quot;hi! hi yourself!&quot;
    mysub(/hi/, &quot;howdy&quot;, text, 1)
    &hellip;
}
</pre></div>

<p>在这个例子中，程序员想将正则表达式常量传递给用户自定义函数 <code>mysub()</code>，
该函数又将其传给 <code>sub()</code> 或者 <code>gsub()</code>。
但是真正发生的事情是，<code>pat</code> 参数会被赋值为 1 或者 0，这就要看 <code>$0</code> 是否匹配 <code>/hi/</code>。
<code>gawk</code> 会针对正则表达式常旦传递给用户自定义函数这种情况发出一个警告，因此将一个真值通过这种方式来传递有可能不是有意的。
</p>
<hr>
<a name="Variables"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Using-Constant-Regexps" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Values" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Using-Variables" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008f_0098e_0087_008f"></a>
<h3 class="subsection">6.1.3 变量</h3>

<a name="index-variables_002c-user_002ddefined"></a>
<a name="index-user_002ddefined_002c-variables"></a>
<p><em>变量</em>是在你程序的某个点存储值，以备程序的其他部分后续使用的方式。它们可以在程序文本的整个部分被操作，
也可以在 <code>awk</code> 的命令行中被赋值。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Using-Variables">6.1.3.1 在程序中使用变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Using variables in your programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Assignment-Options">6.1.3.2 在命令行中进行变量赋值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Setting variables on the command line and a
                                summary of command-line syntax. This is an
                                advanced method of input.
</td></tr>
</table>

<hr>
<a name="Using-Variables"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Variables" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Assignment-Options" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8c_00a8_008baa_00ba_008fa_00b8_00ada_00bd_00bfc_0094_00a8aa_008f_0098e_0087_008f"></a>
<h4 class="subsubsection">6.1.3.1 在程序中使用变量</h4>


<p>变量可让你给值赋予一个名字，然后通过这个名字来使用它。变量在多个例子中都使用到了。变量的名字必须是一个字母、数字或者下划线的序列，并且不可以以数字开头。
在这里，<em>字母</em>是任何的 52 个大小与小字的英文字母。其他的在非英语语言设置中定义的字符不可用于变量句。大小写在变量名中是区分的，<code>a</code> 与 <code>A</code> 是不同的变量。
</p>
<p>变量本身就是一个有效的表达式：
因为它代表了变量的当前值。变量通过<em>赋值操作符</em>、<em>递增操作符</em>与<em>递减操作符</em>可以赋予一个新值
（查看 <a href="#Assignment-Ops">赋值表达式</a>）。
另外，<code>sub()</code> 与 <code>gsub()</code> 函数可以改变变量的值，
而 <code>match()</code>，<code>split()</code> 与 <code>patsplit()</code> 函数可以改变数组参数的值（查看 <a href="#String-Functions">字串操作函数</a>）。
</p>
<a name="index-variables_002c-built_002din"></a>
<a name="index-variables_002c-initializing"></a>
<p>少数几个变量有一些内置的含义，如 <code>FS</code>（域分隔符）以及 <code>NF</code>（当前记录的域数目）。
查看 <a href="#Built_002din-Variables">预定义变量</a>，可获取预定义的变量列表。这些预定义的变量可以像其他变量一样被使用与赋值，但是它们的值也可以被 <code>awk</code> 自动使用与更改。所有的预定义的变量的名字都是大写的。
</p>
<p><code>awk</code> 的变量可以被赋值为数值与字串。某个变量所持有值的类型在程序的生命期中是可以改变的。
默认情况下，没有初始化的变量的值是一个空串，如果转换为数值则为 0。
没有必要显式地在 <code>awk</code> 中初始化变量，这些是在 C 语言中以及其他传统语言中才需要做的。
</p>
<hr>
<a name="Assignment-Options"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Using-Variables" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Conversion" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8aa_0091_00bda_00bb_00a4e_00a1_008ca_00b8_00ade_00bf_009be_00a1_008caa_008f_0098e_0087_008fe_00b5_008baa_0080_00bc"></a>
<h4 class="subsubsection">6.1.3.2 在命令行中进行变量赋值</h4>
<a name="index-variables_002c-assigning-on-command-line"></a>
<a name="index-command-line_002c-variables_002c-assigning-on"></a>

<p><code>awk</code> 变量可以在命令行上通过<em>赋值操作符</em>来设置（查看 <a href="#Other-Arguments">其他命令行参数</a>）。这样的赋值有如下形式：
</p>
<div class="example">
<pre class="example"><var>variable</var>=<var>text</var>
</pre></div>

<a name="index-_002dv-option-1"></a>
<p>通过这样的方式，变量要么在 <code>awk</code> 程序运行开始或者在输入文件之间进行设置。当 &lsquo;<samp>-v</samp>&rsquo; 选项先于赋值，如下面的形式：
</p>
<div class="example">
<pre class="example">-v <var>variable</var>=<var>text</var>
</pre></div>

<p>则变量将在程序的开始，甚至在 <code>BEGIN</code> 规则执行之间就设置了。
&lsquo;<samp>-v</samp>&rsquo; 选项以及他的赋值必须在所有的文件名参数以及程序代码之前。
（查看 <a href="#Options">命令行参数</a>，来获取关于 &lsquo;<samp>-v</samp>&rsquo; 选项的更多信息。）
否则，变量赋值的执行决定于它在输入文件中的位置——要先处理先于该选项之前的文件。如：
</p>
<div class="example">
<pre class="example">awk '{ print $n }' n=4 inventory-shipped n=2 mail-list
</pre></div>

<p>会打印所有输入记录的域数值 <code>n</code>。在第一个文件读取之前，命令行参数设置变量 <code>n</code> 的值为 4。
这会打印来自 &lsquo;<tt>inventory-shipped</tt>&rsquo; 文件行中的第 4 个域。当处理完第一个文件后，但是在开始第 2 个文件之前，
<code>n</code> 被设置成 2，因此会打印来自 &lsquo;<tt>mail-list</tt>&rsquo; 文件的行的第 2 个域：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print $n }' n=4 inventory-shipped n=2 mail-list</kbd>
-| 15
-| 24
&hellip;
-| 555-5553
-| 555-3412
&hellip;
</pre></div>

<a name="index-dark-corner_002c-command_002dline-arguments"></a>
<p>命令行参数还可以在 <code>ARGV</code> 数组中获取，并利用 <code>awk</code> 程序进行显示检查（查看 <a href="#ARGC-and-ARGV">使用 <code>ARGC</code> 与 <code>ARGV</code></a>）。
<code>awk</code> 会处理命令行赋值参数的值中转义序列（查看 <a href="#Escape-Sequences">转义序列</a>）。
(d.c.)
</p>
<hr>
<a name="Conversion"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Assignment-Options" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Values" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Strings-And-Numbers" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8aa_00ad_0097a_00b8_00b2a_00b8_008eae_0095_00b0aa_0080_00bca_00b9_008be_0097_00b4e_00bf_009be_00a1_008ce_00bd_00acae_008d_00a2"></a>
<h3 class="subsection">6.1.4 在字串与数值之间进行转换</h3>

<p>“数值到字串”以及“字串到数值”的转换一般都是直接的。但是要了解几个细微的地方，
通过这小节来说明 <code>awk</code> 中这些重要的细节。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         How <code>awk</code> Converts Between Strings And
                                Numbers.
</td></tr>
<tr><td align="left" valign="top"><a href="#Locale-influences-conversions">6.1.4.2 语言设置会影响转换</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> How the locale may affect conversions.
</td></tr>
</table>

<hr>
<a name="Strings-And-Numbers"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Conversion" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Conversion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Locale-influences-conversions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-aa_00a6_0082a_00bd_0095e_00bd_00acae_008d_00a2aa_00ad_0097a_00b8_00b2a_00b8_008eae_0095_00b0aa_0080_00bc"></a>
<h4 class="subsubsection">6.1.4.1 <code>awk</code> 如何转换字串与数值</h4>

<a name="index-converting_002c-strings-to-numbers"></a>
<a name="index-strings_002c-converting"></a>
<a name="index-numbers_002c-converting"></a>
<a name="index-converting_002c-numbers-to-strings"></a>
<p>如果 <code>awk</code> 程序上下文要求，字串会转换成数值，数值也可以转换成字串。例如，
在表达式 &lsquo;<samp>foo + bar</samp>&rsquo; 中如果 <code>foo</code> 或者 <code>bar</code> 如果是一个串，它就会转在执行加操作之前转换成数值。
如果数值出现在字串的连接操作里，它们就会转换成字串。考虑如下的代码：
</p>
<div class="example">
<pre class="example">two = 2; three = 3
print (two three) + 4
</pre></div>

<p>这个代码会打印（数值）值 27。<code>two</code> 与 <code>three</code> 的数值值被转换成字串并连接在一起。
结果字串被转换成数值 23，用于与 4 进行相加。
</p>
<a name="index-null-strings_002c-converting-numbers-to-strings"></a>
<a name="index-type-conversion"></a>
<p>由于某种原因，如果你需要强制数值被转换成字串，则将这个数值与空串（<code>&quot;&quot;</code>）连接。
强制一个字串要转换成数值，则把这个字串加上 0 即可。
字串转换成数值是通过将字串的数字形式的前缀串解释当成数值：<code>&quot;2.5&quot;</code> 会被转换成 2.5，<code>&quot;1e3&quot;</code> 会被转换成 1000，
<code>&quot;25fix&quot;</code> 会被转换 25。无法转换成数值的字串则会转换成 0。
</p>
<a name="index-CONVFMT-variable"></a>
<p>将数值转换成字串上的准确方式是由 <code>awk</code> 的预定义变量 <code>CONVFMT</code> 进行控制的
（查看 <a href="#Built_002din-Variables">预定义变量</a>）。数值转换成字串是使用 <code>sprintf()</code> 函数并将 <code>CONVFMT</code> 当做模式指定符
（查看 <a href="#String-Functions">字串操作函数</a>）。
</p>
<p><code>CONVFMT</code> 的值默认是 <code>&quot;%.6g&quot;</code>，表示的是创建的值最多有 6 个有效数字位。
对于一些应用来说，你可以将其更改得更加精确。在大多数现在机器上，17 位的数值通常足够将捕获浮点数的值了。 
<a name="DOCF37" href="#FOOT37">(37)</a>
</p>
<a name="index-dark-corner_002c-CONVFMT-variable"></a>
<p>如果你将 <code>CONVFMT</code> 的值设置成一个无法告知 <code>sprintf()</code> 如何来以一种有用的方式格式化浮点数的字串，
则会产生奇怪的结果。例如，如果你忘记了格式指定符中的 &lsquo;<samp>%</samp>&rsquo;，<code>awk</code> 会将所有数值转换成一样的字串常量。
</p>
<p>作为一个特殊例子，如果数值是一个整数，转换成字串的结果<em>总是</em>一个整数，无论 <code>CONVFMT</code> 的值是什么。如下面的代码片段：
</p>
<div class="example">
<pre class="example">CONVFMT = &quot;%2.2f&quot;
a = 12
b = a &quot;&quot;
</pre></div>

<p><code>b</code> 的值为 <code>&quot;12&quot;</code>，而不是 <code>&quot;12.00&quot;</code>。
(d.c.)
</p>
<a name="index-sidebar_002c-POSIX-ae_00a0_0087aa_0087_0086aa_0089_008d-awk-c_0094_00a8-OFMT-e_00bf_009be_00a1_008caa_00ad_0097c_00ac_00a6a_00b8_00b2e_00bd_00acae_008d_00a2"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>POSIX 标准前 <code>awk</code> 用 <code>OFMT</code> 进行字符串转换</b>
</p>

<a name="index-POSIX-awk_002c-OFMT-variable-and-1"></a>
<a name="index-OFMT-variable-1"></a>
<a name="index-portability_002c-new-awk-vs_002e-old-awk"></a>
<a name="index-awk_002c-new-vs_002e-old_002c-OFMT-variable"></a>
<p>在 POSIX 标准之前，<code>awk</code> 用 <code>OFMT</code> 的值来把数字转换成字符串。
当用 <code>print</code> 打印数字的时候，<code>OFMT</code> 指定了输出格式。
<code>CONVFMT</code> 是为了把打印操作和转换操作的区分开而引入的。
<code>CONVFMT</code> 和 <code>OFMT</code> 都有相同的默认值：<code>&quot;%.6g&quot;</code>。
在大部分的 case 中，旧的 <code>awk</code> 程序不改变他们的行为。
查看 <a href="#Print"><code>print</code> 语句</a> 关于更多 <code>print</code> 的描述。
</p></td></tr></table>

<hr>
<a name="Locale-influences-conversions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Strings-And-Numbers" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Conversion" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#All-Operators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_00ade_00a8_0080e_00ae_00bec_00bd_00aea_00bc_009aaa_00bd_00b1aa_0093_008de_00bd_00acae_008d_00a2"></a>
<h4 class="subsubsection">6.1.4.2 语言设置会影响转换</h4>

<p>当要在字串与数值之间进行转换时，什么地方会对此产生影响？本地字符设置与语言，即 <em>locale</em>，会影响数值的格式。
特别是，对于 <code>awk</code> 程序，它还会影响十进制小数点字符以及百分位字符。
<code>&quot;C&quot;</code> 语言设置或者大多数的英语语言，使用点符号（&lsquo;<samp>.</samp>&rsquo;）当做为十进制数小数点，并且没有百分位。
但是，许多（如果不是大多数）的欧洲以及非英语语言区域使用逗号（&lsquo;<samp>,</samp>&rsquo;）作为十进制小数点字符。
欧洲语言通常在需要的时候使用空格或者点来作为百分位。
</p>
<a name="index-dark-corner_002c-locale_0027s-decimal-point-character"></a>
<p>POSIX 标准规定，当读取 <code>awk</code> 程序源代码，以及在读取命令行赋值变量时，总是使用点号作为十进制小数点
（查看 <a href="#Other-Arguments">其他命令行参数</a>）。但是，当解释输入数据时、进行 <code>print</code> 或者 <code>printf</code> 输出，以及进行数值与字串转换时，则使用本地的十进制小数点。
(d.c.) 
在所有的情况下，源代码中的数值，以及输入数据不可以有百分位分隔符。下面的代码在 GNU/Linux 系统解释了这些差异：
</p>
<div class="example">
<pre class="example">$ <kbd>export POSIXLY_CORRECT=1</kbd>                        <i>Force POSIX behavior</i>
$ <kbd>gawk 'BEGIN { printf &quot;%g\n&quot;, 3.1415927 }'</kbd>
-| 3.14159
$ <kbd>LC_ALL=en_DK.utf-8 gawk 'BEGIN { printf &quot;%g\n&quot;, 3.1415927 }'</kbd>
-| 3,14159
$ <kbd>echo 4,321 | gawk '{ print $1 + 1 }'</kbd>
-| 5
$ <kbd>echo 4,321 | LC_ALL=en_DK.utf-8 gawk '{ print $1 + 1 }'</kbd>
-| 5,321
</pre></div>

<p><code>en_DK.utf-8</code> 是丹麦英语语言，在这个设置中，逗号是作为小数点使用的。
在正常的 <code>&quot;C&quot;</code> 语言设置中，<code>gawk</code> 将 &lsquo;<samp>4,321</samp>&rsquo; 当成是 4，
而在丹麦语言设置中，则被完全当成了一个数值，其包含分数为 4.321。
</p>
<p>一些早期的 <code>gawk</code> 版本完全按照标准进行编译。但是很多的非英语语言的用户抱怨这样的行为，
因为他们用点表示十进制里的小数点，所以，默认的行为又恢复到使用点来做为小数点符号。你可以使用 &lsquo;<samp>--use-lc-numeric</samp>&rsquo;
（查看 <a href="#Options">命令行参数</a>）选项来强制 <code>gawk</code> 使用本地语言设置中的十进制小数点。
（<code>gawk</code> 在 POSIX 模式中也使用本地语言设置中的十进制小数点，不管是通过 &lsquo;<samp>--posix</samp>&rsquo; 选项或者
是 <code>POSIXLY_CORRECT</code> 环境变量来指定。）
</p>
<p><a href="#table_002dlocale_002daffects">Table 6.1</a> 说明了什么时候会使用本地语言设置中的十进制小数点符号，
什么时候使用点作为十进制小数点符号。还有一些特性还没有涉及到。
</p>
<div class="float"><a name="table_002dlocale_002daffects"></a>

<table>
<thead><tr><th width="15%">Feature</th><th width="20%">Default</th><th width="45%">&lsquo;<samp>--posix</samp>&rsquo; or &lsquo;<samp>--use-lc-numeric</samp>&rsquo;</th></tr></thead>
<tr><td width="15%"><code>%'g</code></td><td width="20%">Use locale</td><td width="45%">Use locale</td></tr>
<tr><td width="15%"><code>%g</code></td><td width="20%">Use period</td><td width="45%">Use locale</td></tr>
<tr><td width="15%">Input</td><td width="20%">Use period</td><td width="45%">Use locale</td></tr>
<tr><td width="15%"><code>strtonum()</code></td><td width="20%">Use period</td><td width="45%">Use locale</td></tr>
</table>
</div><p><strong>Table 6.1: 本地语言设置中的十进制小数点与圆点
</strong>
</p>
<p>最后，现在的正式标准以及 IEEE 标准的浮点数表示法对于 <code>gawk</code> 转换一些特定的字串为数值的方式，
都有一些不常见但是非常重要的影响。相关的细节呈现在 <a href="#POSIX-Floating-Point-Problems">标准与既存实践</a>。
</p>
<hr>
<a name="All-Operators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Locale-influences-conversions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Arithmetic-Ops" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0093_008da_00bd_009cc_00ac_00a6i_00bc_009aaa_00af_00b9aa_0080_00bce_00bf_009be_00a1_008caa_00a4_0084c_0090_0086"></a>
<h2 class="section">6.2 操作符：对值进行处理</h2>

<p>这一小节介绍利用常量与变量值的<em>操作符</em>。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Arithmetic operations (&lsquo;<samp>+</samp>&rsquo;, &lsquo;<samp>-</samp>&rsquo;,
                                etc.)
</td></tr>
<tr><td align="left" valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Concatenating strings.
</td></tr>
<tr><td align="left" valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Changing the value of a variable or a field.
</td></tr>
<tr><td align="left" valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Incrementing the numeric value of a variable.
</td></tr>
</table>

<hr>
<a name="Arithmetic-Ops"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#All-Operators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#All-Operators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Concatenation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00ae_0097ae_009c_00afae_0093_008da_00bd_009cc_00ac_00a6"></a>
<h3 class="subsection">6.2.1 算术操作符</h3>
<a name="index-arithmetic-operators"></a>
<a name="index-operators_002c-arithmetic"></a>

<p><code>awk</code> 语言使用常用的算术操作符来对表达式求值。
所有的这些算术表达式都具有正常的优先级，并按你所期望的方式工作。
</p>
<p>下面的例子使用一个文件名为 &lsquo;<tt>grades</tt>&rsquo; 的文件，其中包含了学生名字与每个学生的三个测试成绩（班级确实小）：
</p>
<div class="example">
<pre class="example">Pat   100 97 58
Sandy  84 72 93
Chris  72 92 89
</pre></div>

<p>下面的程序读取文件 &lsquo;<tt>grades</tt>&rsquo; 并打印平均成绩：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ sum = $2 + $3 + $4 ; avg = sum / 3</kbd>
&gt;        <kbd>print $1, avg }' grades</kbd>
-| Pat 85
-| Sandy 83
-| Chris 84.3333
</pre></div>

<p>下面的列表列出了 <code>awk</code> 中的算术操作符，并按优先级降序排序：
</p>
<dl compact="compact">
<dd><a name="index-common-extensions_002c-_002a_002a-operator"></a>
<a name="index-extensions_002c-common_002c-_002a_002a-operator"></a>
<a name="index-POSIX-awk_002c-arithmetic-operators-and"></a>
</dd>
<dt><code><var>x</var> ^ <var>y</var></code></dt>
<dt><code><var>x</var> ** <var>y</var></code></dt>
<dd><p>幂乘，表示 <var>x</var> 的 <var>y</var> 次幂。
&lsquo;<samp>2 ^ 3</samp>&rsquo; 的值为 8，字符序列 &lsquo;<samp>**</samp>&rsquo; 与 &lsquo;<samp>^</samp>&rsquo; 等同。(c.e.)
</p>
</dd>
<dt><code>- <var>x</var></code></dt>
<dd><p>取负。
</p>
</dd>
<dt><code>+ <var>x</var></code></dt>
<dd><p>一元加，表达式会被转换成数值。
</p>
</dd>
<dt><code><var>x</var> * <var>y</var></code></dt>
<dd><p>乘。
</p>
<a name="index-troubleshooting_002c-division"></a>
<a name="index-division"></a>
</dd>
<dt><code><var>x</var> / <var>y</var></code></dt>
<dd><p>除。由于在 <code>awk</code> 中的所有数值都是浮点数，结果<em>不会</em>舍入输出为整数——&lsquo;<samp>3 / 4</samp>&rsquo; 的值为 0.75。
（这很容易出错，尤其对 C 程序员，会忘记 <code>awk</code> 中的<em>所有</em>数值都是浮点数，看起来是整数的除，产生一个实数，而不是整数。）
</p>
</dd>
<dt><code><var>x</var> % <var>y</var></code></dt>
<dd><p>求余，进一步的讨论会在下面。
</p>
</dd>
<dt><code><var>x</var> + <var>y</var></code></dt>
<dd><p>加。
</p>
</dd>
<dt><code><var>x</var> - <var>y</var></code></dt>
<dd><p>减。
</p></dd>
</dl>

<p>一元加以减都有相同的优先级，乘法操作符都有相同优先级，加与减具有相同的优先级。
</p>
<a name="index-differences-in-awk-and-gawk_002c-trunc_002dmod-operation"></a>
<a name="index-trunc_002dmod-operation"></a>
<p>当计算 &lsquo;<samp><var>x</var> % <var>y</var></samp>&rsquo; 的余数时，商会向零舍入舍出，并被 <var>y</var> 乘。
这个结果再被从 <var>x</var> 减去。本操作有时候会称为 “trunc-mode” 操作，下面的关系总是会成立：
</p>
<div class="example">
<pre class="example">b * int(a / b) + (a % b) == a
</pre></div>

<p>这种定义下，如果在 &lsquo;<samp><var>x</var> % <var>y</var></samp>&rsquo; 在 <var>x</var> 为负值时，其也为负值，
这可能不是预期的结果：
</p>
<div class="example">
<pre class="example">-17 % 8 = -1
</pre></div>

<p>在其他的 <code>awk</code> 实现中，余数的符号可能跟机器有关。
</p>
<a name="index-portability_002c-_002a_002a-operator-and"></a>
<a name="index-_002a-_0028asterisk_0029_002c-_002a_002a-operator"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a_002a-operator"></a>
<blockquote>
<p><b>提示:</b> POSIX 标准中只指定了 &lsquo;<samp>^</samp>&rsquo; 作为幂乘。为了最大的可移植性，不要使用 &lsquo;<samp>**</samp>&rsquo; 操作符。
</p></blockquote>

<hr>
<a name="Concatenation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arithmetic-Ops" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#All-Operators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Assignment-Ops" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ad_0097a_00b8_00b2e_00bf_009eae_008e_00a5"></a>
<h3 class="subsection">6.2.2 字串连接</h3>
<a name="index-Kernighan_002c-Brian-4"></a>
<blockquote>
<p><i>
在那个时候看起来确实是个好主意。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Brian Kernighan</em>
</p>
<a name="index-string-operators"></a>
<a name="index-operators_002c-string"></a>
<a name="index-concatenating"></a>
<p>只有一个字串操作符：连接。实际上并没有特定的操作符来表示它。相反，连接操作是通过将表达式写成两两相邻。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print &quot;Field number one: &quot; $1 }' mail-list</kbd>
-| Field number one: Amelia
-| Field number one: Anthony
&hellip;
</pre></div>

<p>在字串常量 &lsquo;<samp>:</samp>&rsquo; 后面没有空格，整行输出在一起。比如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print &quot;Field number one:&quot; $1 }' mail-list</kbd>
-| Field number one:Amelia
-| Field number one:Anthony
&hellip;
</pre></div>

<a name="index-troubleshooting_002c-string-concatenation"></a>
<p>由于字串连接没有显式的操作符，因此通常需要保证这发生成合适的时间，这是通过将要连接的项用括号包起来。
例如，你可能想要下面的代码来连接起 <code>file</code> 与 <code>name</code>：
</p>
<div class="example">
<pre class="example">file = &quot;file&quot;
name = &quot;name&quot;
print &quot;something meaningful&quot; &gt; file name
</pre></div>

<a name="index-Brian-Kernighan_0027s-awk-5"></a>
<a name="index-mawk-utility-2"></a>
<p>这在 Unix <code>awk</code> 中会产生一个语法错误。
<a name="DOCF38" href="#FOOT38">(38)</a>
应该如下使用：
</p>
<div class="example">
<pre class="example">print &quot;something meaningful&quot; &gt; (file name)
</pre></div>

<a name="index-order-of-evaluation_002c-concatenation"></a>
<a name="index-evaluation-order_002c-concatenation"></a>
<a name="index-side-effects"></a>
<p>在字串连接两边，括号在除了 &lsquo;<samp>=</samp>&rsquo; 右边的所有情况下都应该使用。在特别注意在字串连接中所使用的表达式。特别是，表达式的求值顺序用来进行字串连接，在 <code>awk</code> 语言中是没有定义的。如下面的例子：
</p>
<div class="example">
<pre class="example">BEGIN {
    a = &quot;don't&quot;
    print (a &quot; &quot; (a = &quot;panic&quot;))
}
</pre></div>

<p>是否是第二个赋值操作发生在 <code>a</code> 的值返回之前还是之后这是不确定的。
结果可以是 &lsquo;<samp>don't panic</samp>&rsquo;，或者是 &lsquo;<samp>panic panic</samp>&rsquo;。
</p>
<p>在与其他的操作符混合时，连接操作的优先级通常是反直觉的。如下面的例子：
</p>

<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print -12 &quot; &quot; -24 }'</kbd>
-| -12-24
</pre></div>

<p>很“明显”的是要连接 -12，一个空格与 -24。
但是空格消失到哪里去了呢？答案是在操作符的优先组合与 <code>awk</code> 的自动转换规则里。为了得到所想要的结果，像下面这样写：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print -12 &quot; &quot; (-24) }'</kbd>
-| -12 -24
</pre></div>

<p>这强制 <code>awk</code> 将 &lsquo;<samp>-24</samp>&rsquo; 中的 &lsquo;<samp>-</samp>&rsquo; 当成是一元操作符。否则，它会这么来分析：
</p>
<div class="display">
<pre class="display">    -12 (<code>&quot;&nbsp;&quot;</code> - 24)
&rArr; -12 (0 - 24)
&rArr; -12 (-24)
&rArr; -12-24
</pre></div>

<p>如早先所提，当连接操作与其他操作符混合时，<em>用括号括起来</em>。否则，你无法确认你会得到什么结果。
</p>
<hr>
<a name="Assignment-Ops"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Concatenation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#All-Operators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Increment-Ops" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00b5_008baa_0080_00bce_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h3 class="subsection">6.2.3 赋值表达式</h3>
<a name="index-assignment-operators"></a>
<a name="index-operators_002c-assignment"></a>
<a name="index-expressions_002c-assignment"></a>
<a name="index-_003d-_0028equals-sign_0029_002c-_003d-operator"></a>
<a name="index-equals-sign-_0028_003d_0029_002c-_003d-operator"></a>
<p><em>赋值表达式</em>是将一个（通常不一样的）值存入某个变量的表达式。
例如，我们将变量 <code>z</code> 的值赋为 1：
</p>
<div class="example">
<pre class="example">z = 1
</pre></div>

<p>当这个表达式执行后，变量 <code>z</code> 的值就为 1。不管 <code>z</code> 的旧值是什么，都将丢弃。
</p>
<p>赋值也可以存储字串值。例如，下面将值 <code>&quot;this food is good&quot;</code> 存储到变量 <code>message</code> 中：
</p>
<div class="example">
<pre class="example">thing = &quot;food&quot;
predicate = &quot;good&quot;
message = &quot;this &quot; thing &quot; is &quot; predicate
</pre></div>

<a name="index-side-effects_002c-assignment-expressions"></a>
<p>这个例子也呈现了字串连接操作。
&lsquo;<samp>=</samp>&rsquo; 符号称为<em>赋值操作符</em>。这也是最简单的操作符，因为其右边的操作数的值会原封不动地存下来。大多数操作符（加，连接等）除非要计算值，否则都没有实际效果。如果值没有被使用，也没有理由使用这个操作符。赋值操作符则不同：因为它确实产生一个值，但是就算你忽略它，赋值仍然使自己走完变量的变化过程。我们称这个效应为<em>副作用</em>。
</p>
<a name="index-lvalues_002frvalues"></a>
<a name="index-rvalues_002flvalues"></a>
<a name="index-assignment-operators_002c-lvalues_002frvalues"></a>
<a name="index-operators_002c-assignment-1"></a>
<p>赋值左边的操作数不需要是一个变量（查看 <a href="#Variables">变量</a>），其也可以是一个域（查看 <a href="#Changing-Fields">更改域内容</a>）
或者一个数组元素（查看 <a href="#Arrays"><code>awk</code> 数组</a>）。所有这些都称为值，这意味着它们可以出现在赋值操作符左边。
右边的操作数可以是表达式，其会产生一个新的值来赋值存储在指定的变量、域或者数组元素。（这样的值称为<em>右值（rvalues）</em>。）
</p>
<a name="index-variables_002c-types-of"></a>
<p>要注意的是，变量<em>没有</em>固定的类型。变量的类型就是其最后被赋值的数据的类型。
在下面的程序片段中，变量 <code>foo</code> 先具有数值类型，然后具有字串类型：
</p>
<div class="example">
<pre class="example">foo = 1
print foo
foo = &quot;bar&quot;
print foo
</pre></div>

<p>当第二个赋值给了 <code>foo</code> 一个字串值，而这之前其具有数值类型就丢弃了。
</p>
<p>字串值中，如果不是一个以一个数值开头的话，其对应的数值值为 0。在执行了下面的代码后，<code>foo</code> 的值为 5：
</p>
<div class="example">
<pre class="example">foo = &quot;a string&quot;
foo = foo + 5
</pre></div>

<blockquote>
<p><b>提示:</b> 将变量作为一个数值，然后作为字串有时候会产生困惑，而且也是一个不好的编程风格。
前面的两个例子只是用来说明 <code>awk</code> 如何工作，而<em>不是</em>告诉大家这么来写程序的！
</p></blockquote>

<p>赋值是一个表达式，因此它有值——一个与其被赋予的相同的值。
因此 &lsquo;<samp>z = 1</samp>&rsquo; 是一个具有值为 1 的表达式。这个特性的一个结果就是你可以将多个赋值写在一起，如：
</p>
<div class="example">
<pre class="example">x = y = z = 5
</pre></div>

<p>这个例子中，5 这个值被赋给了三个变量（<code>x</code>，<code>y</code> 与 <code>z</code>）。
这是因为 &lsquo;<samp>z = 5</samp>&rsquo; 的值为 5，然后再存于 <code>y</code> 中，因此 &lsquo;<samp>y = z = 5</samp>&rsquo; 的值为 5，最后存到 <code>x</code> 中。
</p>
<p>赋值可以被用于任何可称为表达式的地方。例如，
这么写 &lsquo;<samp>x != (y = 1)</samp>&rsquo; 是有效的形式，其将 <code>y</code> 的值设成 1，然后测试 <code>x</code> 是否等于 1。
但是这样的风格会导致程序难以阅读，这样的赋值嵌套应该要避免，除非是在一次性的程序里。
</p>
<a name="index-_002b-_0028plus-sign_0029_002c-_002b_003d-operator"></a>
<a name="index-plus-sign-_0028_002b_0029_002c-_002b_003d-operator"></a>
<p>除了 &lsquo;<samp>=</samp>&rsquo; 外，还有几个其他的操作符用于执行与变量旧值的算术运算。
例如，操作符 &lsquo;<samp>+=</samp>&rsquo; 将右边的值加到变量的旧值以生成新值。所以，
下面的赋值会在 <code>foo</code> 值的基础上加上 5：
</p>
<div class="example">
<pre class="example">foo += 5
</pre></div>

<p>这与下面的代码是等同的：
</p>
<div class="example">
<pre class="example">foo = foo + 5
</pre></div>

<p>用哪一种形式，都可以清晰地表示你程序的意图。
</p>
<p>有几个种情况使用 &lsquo;<samp>+=</samp>&rsquo; （或者任意的赋值表操作符）与简单地将左边的操作数作为右边的表达式的重复是<em>不</em>一样的，如：
</p>
<a name="index-Rankin_002c-Pat-1"></a>
<div class="example">
<pre class="example"># Thanks to Pat Rankin for this example
BEGIN  {
    foo[rand()] += 5
    for (x in foo)
       print x, foo[x]

    bar[rand()] = bar[rand()] + 5
    for (x in bar)
       print x, bar[x]
}
</pre></div>

<a name="index-operators_002c-assignment_002c-evaluation-order"></a>
<a name="index-assignment-operators_002c-evaluation-order"></a>
<p><code>bar</code> 这个下标一般在实际中都是不相同的，因为 <code>rand()</code> 每次调用时都产生不同的值。
（数组与 <code>rand()</code> 函数都还没有讨论到，查看 <a href="#Arrays"><code>awk</code> 数组</a>，与 
<a href="#Numeric-Functions">数值函数</a>
，来获取更多的信息。）
这个例子说明了赋值操作符的一个重要事实：表达式的左边只会求值<em>一次</em>。
</p>
<p>但是对于表达式的求值顺序，是先左边还是右边则是依赖于实现的。如下面：
</p>
<div class="example">
<pre class="example">i = 1
a[i += 2] = i + 1
</pre></div>

<p><code>a[3]</code> 的值可以是 2， 也可以是 4。
</p>
<p><a href="#table_002dassign_002dops">Table 6.2</a> 列出了所有的算术赋值操作符，在每种情况下，右边的操作数是一个值会被转换为值的表达式。
</p>
<a name="index-_002d-_0028hyphen_0029_002c-_002d_003d-operator"></a>
<a name="index-hyphen-_0028_002d_0029_002c-_002d_003d-operator"></a>
<a name="index-_002a-_0028asterisk_0029_002c-_002a_003d-operator"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a_003d-operator"></a>
<a name="index-_002f-_0028forward-slash_0029_002c-_002f_003d-operator"></a>
<a name="index-forward-slash-_0028_002f_0029_002c-_002f_003d-operator"></a>
<a name="index-_0025-_0028percent-sign_0029_002c-_0025_003d-operator"></a>
<a name="index-percent-sign-_0028_0025_0029_002c-_0025_003d-operator"></a>
<a name="index-_005e-_0028caret_0029_002c-_005e_003d-operator"></a>
<a name="index-caret-_0028_005e_0029_002c-_005e_003d-operator"></a>
<a name="index-_002a-_0028asterisk_0029_002c-_002a_002a_003d-operator"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a_002a_003d-operator"></a>
<div class="float"><a name="table_002dassign_002dops"></a>

<table>
<thead><tr><th width="30%">操作符</th><th width="70%">效果</th></tr></thead>
<tr><td width="30%"><var>lvalue</var> <code>+=</code> <var>increment</var></td><td width="70%">将 <var>increment</var> 添加到 <var>lvalue</var> 的值上。</td></tr>
<tr><td width="30%"><var>lvalue</var> <code>-=</code> <var>decrement</var></td><td width="70%">在 <var>lvalue</var> 的值上减去 decrement。</td></tr>
<tr><td width="30%"><var>lvalue</var> <code>*=</code> <var>coefficient</var></td><td width="70%">将 <var>lvalue</var> 的值乘上一个 coefficient。</td></tr>
<tr><td width="30%"><var>lvalue</var> <code>/=</code> <var>divisor</var></td><td width="70%">将 <var>lvalue</var> 的值除上一个 divisor。</td></tr>
<tr><td width="30%"><var>lvalue</var> <code>%=</code> <var>modulus</var></td><td width="70%">设置 <var>lvalue</var> 的值与其值与 <var>modulus</var> 求模。
<a name="index-common-extensions_002c-_002a_002a_003d-operator"></a>
<a name="index-extensions_002c-common_002c-_002a_002a_003d-operator"></a>
<a name="index-awk-language_002c-POSIX-version"></a>
<a name="index-POSIX-awk-1"></a></td></tr>
<tr><td width="30%"><var>lvalue</var> <code>^=</code> <var>power</var></td><td width="70%">将 <var>lvalue</var> 的值进行幂乘 power。</td></tr>
<tr><td width="30%"><var>lvalue</var> <code>**=</code> <var>power</var></td><td width="70%">将 <var>lvalue</var> 的值进行幂乘 power。(c.e.)</td></tr>
</table>
</div><p><strong>Table 6.2: 算术赋值操作符
</strong>
</p>
<a name="index-POSIX-awk_002c-_002a_002a_003d-operator-and"></a>
<a name="index-portability_002c-_002a_002a_003d-operator-and"></a>
<blockquote>
<p><b>提示:</b> POSIX 中只指定了 &lsquo;<samp>^=</samp>&rsquo; 。为了移植性，不要使用 &lsquo;<samp>**=</samp>&rsquo; 操作符。
</p></blockquote>

<a name="index-sidebar_002c-_002f_003d-a_00b8_008eae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fa_00b9_008be_0097_00b4c_009a_0084a_00ba_008ca_00b9_0089ae_0080_00a7"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>&lsquo;<samp>/=</samp>&rsquo; 与正则表达式之间的二义性</b>
</p>

<a name="index-dark-corner_002c-regexp-constants_002c-_002f_003d-operator-and"></a>
<a name="index-_002f-_0028forward-slash_0029_002c-_002f_003d-operator_002c-vs_002e-_002f_003d_2026_002f-regexp-constant"></a>
<a name="index-forward-slash-_0028_002f_0029_002c-_002f_003d-operator_002c-vs_002e-_002f_003d_2026_002f-regexp-constant"></a>
<a name="index-regexp-constants_002c-_002f_003d_2026_002f_002c-_002f_003d-operator-and"></a>


<a name="index-dark-corner_002c-_002f_003d-operator-vs_002e-_002f_003d_2026_002f-regexp-constant"></a>
<a name="index-ambiguity_002c-syntactic_003a-_002f_003d-operator-vs_002e-_002f_003d_2026_002f-regexp-constant"></a>
<a name="index-syntactic-ambiguity_003a-_002f_003d-operator-vs_002e-_002f_003d_2026_002f-regexp-constant"></a>
<a name="index-_002f_003d-operator-vs_002e-_002f_003d_2026_002f-regexp-constant"></a>
<p>在 <code>/=</code> 赋值操作符与正则表达式常量（哪个记录的第一个字符是 &lsquo;<samp>=</samp>&rsquo;）之间有一个语法上的二义性。
(d.c.)
这在一些商业性的 <code>awk</code> 版本里更显眼。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk /==/ /dev/null</kbd>
error--&gt; awk: syntax error at source line 1
error--&gt;  context is
error--&gt;         &gt;&gt;&gt; /= &lt;&lt;&lt;
error--&gt; awk: bailing out at source line 1
</pre></div>

<p>解决方法是：
</p>
<div class="example">
<pre class="example">awk '/[=]=/' /dev/null
</pre></div>

<p><code>gawk</code> 没有这个问题，BWK <code>awk</code> 与 <code>mawk</code> 也没有。
</p></td></tr></table>

<hr>
<a name="Increment-Ops"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Assignment-Ops" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#All-Operators" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Truth-Values-and-Conditions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0080_0092aa_00a2_009ea_00b8_008ee_0080_0092aa_0087_008fae_0093_008da_00bd_009cc_00ac_00a6"></a>
<h3 class="subsection">6.2.4 递增与递减操作符</h3>

<a name="index-increment-operators"></a>
<a name="index-operators_002c-decrement_002fincrement"></a>
<p><em>递增</em>与<em>递减操作符</em>对变量的值进行递增与递减 1。
赋值操作符可以做相同的事情，因此递增操作符并没有给 <code>awk</code> 带来额外的功能，
但是它们对于一些常见的操作的缩写非常方便。
</p>
<a name="index-side-effects-1"></a>
<a name="index-_002b-_0028plus-sign_0029_002c-_002b_002b-operator"></a>
<a name="index-plus-sign-_0028_002b_0029_002c-_002b_002b-operator"></a>
<a name="index-side-effects_002c-decrement_002fincrement-operators"></a>
<p>用于<em>加一</em>的操作符写作 &lsquo;<samp>++</samp>&rsquo; 。它可以用在递增的变量的前面与后面。在变量 <code>v</code> 前面递增写成 &lsquo;<samp>++v</samp>&rsquo;，
这会对 <code>v</code> 值进行加一——新的值也是一个表达式。（赋值表达式 &lsquo;<samp>v += 1</samp>&rsquo; 与其等同。）
在变量后面递增为后缀递增。这与前面的形式一样，不同的是递增表达式的值是变量的<em>旧</em>值。
因此，如果 <code>foo</code> 的值 为 4，则表达式 &lsquo;<samp>foo++</samp>&rsquo; 的值为 4，但是变量的值会变成 5。
换句话说，操作符返回变量的旧值，但是作为副作用会对其递增。
</p>
<p>后缀递增 &lsquo;<samp>foo++</samp>&rsquo; 几乎与 &lsquo;<samp>(foo += 1) - 1</samp>&rsquo; 相同。
但是又不完全相同，因为在 <code>awk</code> 中所有的数值都是浮点数——在浮点数中，&lsquo;<samp>foo + 1 - 1</samp>&rsquo; 不一定与 <code>foo</code> 相同。
但是这个差异非常小，只要你要处理的的值非常小（小于
10@sup{12}）。
</p>
<a name="index-_0024-_0028dollar-sign_0029_002c-incrementing-fields-and-arrays"></a>
<a name="index-dollar-sign-_0028_0024_0029_002c-incrementing-fields-and-arrays"></a>
<p>域与数组元素也可以像变量一样递增。（当你想执行一个域参考，又对变量进行递增时，使用 &lsquo;<samp>$(i++)</samp>&rsquo; 。
括号是必须的，因为域操作符 &lsquo;<samp>$</samp>&rsquo; 先于递增操作符。）
</p>
<a name="index-decrement-operators"></a>
<p>递增操作符 &lsquo;<samp>--</samp>&rsquo; 与 &lsquo;<samp>++</samp>&rsquo; 类型，只是其用于减而不是用于加。
与 &lsquo;<samp>++</samp>&rsquo; 一样，其用可用在左传的前面进行前缀递减，在后面进行后缀递减。下面是对于递增与递减操作符表达式的汇总：
</p>
<dl compact="compact">
<dd><a name="index-_002b-_0028plus-sign_0029_002c-_002b_002b-operator-1"></a>
<a name="index-plus-sign-_0028_002b_0029_002c-_002b_002b-operator-1"></a>
</dd>
<dt><code>++<var>lvalue</var></code></dt>
<dd><p>给 <var>lvalue</var> 递增 1，并返回新值作为表达式的值。
</p>
</dd>
<dt><code><var>lvalue</var>++</code></dt>
<dd><p>给 <var>lvalue</var> 递增 1，并返回<em>旧</em>值作为表达式的值。
</p>
<a name="index-_002d-_0028hyphen_0029_002c-_002d_002d-operator"></a>
<a name="index-hyphen-_0028_002d_0029_002c-_002d_002d-operator"></a>
</dd>
<dt><code>--<var>lvalue</var></code></dt>
<dd><p>给 <var>lvalue</var> 递减 1，并返回新值作为表达式的值。（这个与表达式 &lsquo;<samp>++<var>lvalue</var></samp>&rsquo; 一样，只是用于减，而不是用于加。）
</p>
</dd>
<dt><code><var>lvalue</var>--</code></dt>
<dd><p>给 <var>lvalue</var> 递减1，并返回<em>旧</em>值作为表达式的值。（这个与表达式 &lsquo;<samp><var>lvalue</var>++</samp>&rsquo; 一样，
只是用于减，而不是用于加。）
</p></dd>
</dl>

<a name="index-sidebar_002c-ae_0093_008da_00bd_009cc_00ac_00a6ae_00b1_0082aa_0080_00bce_00a1_00baaa_00ba_008f"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>操作符求值顺序</b>
</p>

<a name="index-precedence"></a>
<a name="index-operators_002c-precedence"></a>
<a name="index-portability_002c-operators"></a>
<a name="index-evaluation-order"></a>
<a name="index-Marx_002c-Groucho"></a>
<blockquote>
<p><i>医生，当我这么干的时候就会受伤！<br>
那么你就别这么干啊！</i>
</p></blockquote>
<p align="center">&mdash; <em>Groucho Marx</em>
</p>
<p>当我们像下面这样做，会发生什么？
</p>
<div class="example">
<pre class="example">b = 6
print b += b++
</pre></div>

<p>或者一些更奇怪的：
</p>
<div class="example">
<pre class="example">b = 6
b += ++b + b++
print b
</pre></div>

<a name="index-side-effects-2"></a>
<p>换句话说，当执行不同的后缀操作符（&lsquo;<samp>b++</samp>&rsquo;）时，会有哪些副作用产生？产生的副作用是<em>由实现来定义的</em>，
即依赖于 <code>awk</code> 的特定版本。第一个例子的结果可能是 12 或者 13，对于第二个例子则可能是 22 或者是 23。
</p>
<p>一句话，这么干是不建议的并且其移植性完全不可依赖。你要在你的程序中避免这样的代码。
</p></td></tr></table>

<hr>
<a name="Truth-Values-and-Conditions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Increment-Ops" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Truth-Values" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_009c_009faa_0080_00bca_00b8_008eae_009d_00a1a_00bb_00b6"></a>
<h2 class="section">6.3 真值与条件</h2>

<p>在特定的上下文中，表达式的值会用来作为“真值”，如，用来决定接下来程序应该执行什么。
这一小节中会描述 <code>awk</code> 如何定义 &lsquo;<samp>true</samp>&rsquo; 与 &lsquo;<samp>false</samp>&rsquo; 以及值如何进行比较。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                What is &ldquo;true&rdquo; and what is &ldquo;false&rdquo;.
</td></tr>
<tr><td align="left" valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       How variables acquire types and how this
                                affects comparison of numbers and strings with
                                &lsquo;<samp>&lt;</samp>&rsquo;, etc.
</td></tr>
<tr><td align="left" valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Combining comparison expressions using boolean
                                operators &lsquo;<samp>||</samp>&rsquo; (&ldquo;or&rdquo;), &lsquo;<samp>&amp;&amp;</samp>&rsquo;
                                (&ldquo;and&rdquo;) and &lsquo;<samp>!</samp>&rsquo; (&ldquo;not&rdquo;).
</td></tr>
<tr><td align="left" valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Conditional expressions select between two
                                subexpressions under control of a third
                                subexpression.
</td></tr>
</table>

<hr>
<a name="Truth-Values"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Truth-Values-and-Conditions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Truth-Values-and-Conditions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Typing-and-Comparison" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-c_009a_0084c_009c_009fa_00b8_008eaa_0081_0087"></a>
<h3 class="subsection">6.3.1 <code>awk</code> 的真与假</h3>
<a name="index-truth-values"></a>
<a name="index-logical-false_002ftrue"></a>
<a name="index-false_002c-logical"></a>
<a name="index-true_002c-logical"></a>

<a name="index-null-strings-2"></a>
<p>许多的编程语言对于“true”与“false”概念都有特殊的表示方式。
这样的语言通常使用特殊的常量 <code>true</code> 与 <code>false</code>，以及对应的大写。
但是 <code>awk</code> 却不同。它从 C 中借鉴了 true 与 false 的概念。
在 <code>awk</code> 中，所有非 0 的数值<em>或者</em>非空串都是 true。
而其他的值（0 或者空串，<code>&quot;&quot;</code>）都是 false。下面的程序会打印 &lsquo;<samp>A strange truth value</samp>&rsquo; 三次：
</p>
<div class="example">
<pre class="example">BEGIN {
   if (3.1415927)
       print &quot;A strange truth value&quot;
   if (&quot;Four Score And Seven Years Ago&quot;)
       print &quot;A strange truth value&quot;
   if (j = 57)
       print &quot;A strange truth value&quot;
}
</pre></div>

<a name="index-dark-corner_002c-_00220_0022-is-actually-true"></a>
<p>这个“非 0 非空”的规则有一个令人惊讶的结果：字串 <code>&quot;0&quot;</code> 为真，因为它非空。
(d.c.)
</p>
<hr>
<a name="Typing-and-Comparison"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Truth-Values" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Truth-Values-and-Conditions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Variable-Typing" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008f_0098e_0087_008fc_00b1_00bbaa_009e_008ba_00b8_008eae_00af_0094e_00be_0083e_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h3 class="subsection">6.3.2 变量类型与比较表达式</h3>
<blockquote>
<p><i>指南都是确定的，但是现实常常不精确。</i>
</p></blockquote>
<p align="center">&mdash; <em>Douglas Adams, @cite{The Hitchhiker's Guide to the Galaxy}</em>
</p>
<a name="index-comparison-expressions"></a>
<a name="index-expressions_002c-comparison"></a>
<a name="index-expressions_002c-matching_002c-See-comparison-expressions"></a>
<a name="index-matching_002c-expressions_002c-See-comparison-expressions"></a>
<a name="index-relational-operators_002c-See-comparison-operators"></a>
<a name="index-operators_002c-relational_002c-See-operators_002c-comparison"></a>
<a name="index-variable-typing"></a>
<a name="index-variables_002c-types-of_002c-comparison-expressions-and"></a>
<p>与其他的语言不同，<code>awk</code> 中的变量没有固定的类型。
相反，它们即可以是数值，也可以是字串，这主要依赖于所赋给它的值来确定。我们现在来看看变量是如何来确定类型的，
以及 <code>awk</code> 如何来比较这些变量。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Variable-Typing">6.3.2.1 字串类型与数值类型</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             String type versus numeric type.
</td></tr>
<tr><td align="left" valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        The comparison operators.
</td></tr>
<tr><td align="left" valign="top"><a href="#POSIX-String-Comparison">6.3.2.3 POSIX 中的字串比较规则</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     String comparison with POSIX rules.
</td></tr>
</table>

<hr>
<a name="Variable-Typing"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Typing-and-Comparison" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Typing-and-Comparison" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Comparison-Operators" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ad_0097a_00b8_00b2c_00b1_00bbaa_009e_008ba_00b8_008eae_0095_00b0aa_0080_00bcc_00b1_00bbaa_009e_008b"></a>
<h4 class="subsubsection">6.3.2.1 字串类型与数值类型</h4>

<a name="index-numeric_002c-strings"></a>
<a name="index-strings_002c-numeric"></a>
<a name="index-POSIX-awk_002c-numeric-strings-and"></a>
<p>POSIX 标准中引入了<em>数值式字串</em>的概念，
简单地说就是看起来像是一个数值的字串——如 <code>&quot;&nbsp;+2&quot;</code>。
这个概念也用来确定变量的类型。变量的类型是非常重要的，因为两变量的类型决定了它们之间如何进行比较。变量类型的确定依赖下面的规则：
</p>

<ul>
<li>
数值常量或者是数值操作结果具有<em>数值</em>属性。

</li><li>
字串常量或者字串操作结果具有<em>字串</em>属性。

</li><li>
域，<code>getline</code> 输出，<code>FILENAME</code>，<code>ARGV</code> 元素，
<code>ENVIRON</code> 元素以及由 <code>match()</code>，<code>split()</code> 与 <code>patsplit()</code> 生成的数组的元素，
如果是数值字串，则具有 <em>strnum</em> 属性。否则就具有<em>字串</em>属性。
未初始化的变量也具有 <em>strnum</em> 属性。

</li><li>
属性通过赋值操作符进行传递，但是使用则不会改变。
</li></ul>

<p>最后的规则尤其重要。在下面的程序中，<code>a</code> 具有数值类型，就算之后它被用于字串操作中：
</p>
<div class="example">
<pre class="example">BEGIN {
     a = 12.345
     b = a &quot; is a cute number&quot;
     print b
}
</pre></div>

<p>当两个操作数进行比较时，要么是进行字串比较，要么是进行数值比较。这依赖于操作数的属性，如下面的对称阵列：
</p>
<div class="display">
<pre class="display">        +&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
        |       STRING          NUMERIC         STRNUM
&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
        |
STRING  |       string          string          string
        |
NUMERIC |       string          numeric         numeric
        |
STRNUM  |       string          numeric         numeric
&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
</pre></div>

<p>基本的思想就是，用户的输入看起来像数值——也<em>仅仅</em>在用户输入中——就会被当成数值对待，
就算它实际上是由字符组成的字串。所以，如这样的字串常量 <code>&quot;&nbsp;+3.14&quot;</code>，
当它出现在程序原代码中，是一个字串——就算它是一个数值——也<em>永远</em>不会在比较目的中被当成数值。
</p>
<p>简单地说，当操作数是一个“纯粹”的字串，如字串常量，则就会执行字串比较。否则就会执行数值比较。
</p>
<p>对此还要强调一下：所有的用户输入都由字符组成，因此首先它是字串类型，输出的字串看起来像是数值的就会赋给 strnum 属性。
所以，下面这个6字符的输出串 &lsquo;<samp>&nbsp;+3.14</samp>&rsquo; 会具有 strnum 属性。
相反地，下面的 8 字符串 <code>&quot;&nbsp;+3.14&quot;</code> 出现在程序文本中则组成了一个字串常量。
下面的例子中，当比较两个不同的常量时为真，因此打印 &lsquo;<samp>1</samp>&rsquo;，否则打印 &lsquo;<samp>0</samp>&rsquo; ：
</p>
<div class="example">
<pre class="example">$ <kbd>echo ' +3.14' | awk '{ print($0 == &quot; +3.14&quot;) }'</kbd>    <i>True</i>
-| 1
$ <kbd>echo ' +3.14' | awk '{ print($0 == &quot;+3.14&quot;) }'</kbd>     <i>False</i>
-| 0
$ <kbd>echo ' +3.14' | awk '{ print($0 == &quot;3.14&quot;) }'</kbd>      <i>False</i>
-| 0
$ <kbd>echo ' +3.14' | awk '{ print($0 == 3.14) }'</kbd>        <i>True</i>
-| 1
$ <kbd>echo ' +3.14' | awk '{ print($1 == &quot; +3.14&quot;) }'</kbd>    <i>False</i>
-| 0
$ <kbd>echo ' +3.14' | awk '{ print($1 == &quot;+3.14&quot;) }'</kbd>     <i>True</i>
-| 1
$ <kbd>echo ' +3.14' | awk '{ print($1 == &quot;3.14&quot;) }'</kbd>      <i>False</i>
-| 0
$ <kbd>echo ' +3.14' | awk '{ print($1 == 3.14) }'</kbd>        <i>True</i>
-| 1
</pre></div>

<hr>
<a name="Comparison-Operators"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Variable-Typing" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Typing-and-Comparison" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#POSIX-String-Comparison" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00af_0094e_00be_0083ae_0093_008da_00bd_009cc_00ac_00a6"></a>
<h4 class="subsubsection">6.3.2.2 比较操作符</h4>

<p><em>比较表达式</em>在数值或者字串中进行比较，比如说相等性。它们通常使用<em>关系操作符</em>来表现，
这些操作是 C 中对应的操作的超集。表 <a href="#table_002drelational_002dops">Table 6.3</a> 中有说明。
</p>
<a name="index-_003c-_0028left-angle-bracket_0029_002c-_003c-operator"></a>
<a name="index-left-angle-bracket-_0028_003c_0029_002c-_003c-operator"></a>
<a name="index-_003c-_0028left-angle-bracket_0029_002c-_003c_003d-operator"></a>
<a name="index-left-angle-bracket-_0028_003c_0029_002c-_003c_003d-operator"></a>
<a name="index-_003e-_0028right-angle-bracket_0029_002c-_003e_003d-operator"></a>
<a name="index-right-angle-bracket-_0028_003e_0029_002c-_003e_003d-operator"></a>
<a name="index-_003e-_0028right-angle-bracket_0029_002c-_003e-operator"></a>
<a name="index-right-angle-bracket-_0028_003e_0029_002c-_003e-operator"></a>
<a name="index-_003d-_0028equals-sign_0029_002c-_003d_003d-operator"></a>
<a name="index-equals-sign-_0028_003d_0029_002c-_003d_003d-operator"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_003d-operator"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_003d-operator"></a>
<a name="index-_007e-_0028tilde_0029_002c-_007e-operator-4"></a>
<a name="index-tilde-_0028_007e_0029_002c-_007e-operator-4"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-4"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-4"></a>
<a name="index-in-operator"></a>
<div class="float"><a name="table_002drelational_002dops"></a>

<table>
<thead><tr><th width="25%">Expression</th><th width="75%">Result</th></tr></thead>
<tr><td width="25%"><var>x</var> <code>&lt;</code> <var>y</var></td><td width="75%">如果 <var>x</var> 小于 <var>y</var> 则为真</td></tr>
<tr><td width="25%"><var>x</var> <code>&lt;=</code> <var>y</var></td><td width="75%">如果 <var>x</var> 小于或者等于 <var>y</var> 则为真</td></tr>
<tr><td width="25%"><var>x</var> <code>&gt;</code> <var>y</var></td><td width="75%">如果 <var>x</var> 大于 <var>y</var> 则为真</td></tr>
<tr><td width="25%"><var>x</var> <code>&gt;=</code> <var>y</var></td><td width="75%">如果 <var>x</var> 大于或者等于 <var>y</var> 则为真</td></tr>
<tr><td width="25%"><var>x</var> <code>==</code> <var>y</var></td><td width="75%">如果 <var>x</var> 等于 <var>y</var> 则为真</td></tr>
<tr><td width="25%"><var>x</var> <code>!=</code> <var>y</var></td><td width="75%">如果 <var>x</var> 不等于 <var>y</var> 则为真</td></tr>
<tr><td width="25%"><var>x</var> <code>~</code> <var>y</var></td><td width="75%">如果字串 <var>x</var> 与 <var>y</var> 所代表的正则表达式匹配则为真</td></tr>
<tr><td width="25%"><var>x</var> <code>!~</code> <var>y</var></td><td width="75%">如果字串 <var>x</var> 与 <var>y</var> 表示的正则表达式不匹配则为真</td></tr>
<tr><td width="25%"><var>subscript</var> <code>in</code> <var>array</var></td><td width="75%">如果数组 <var>array</var> 存在下标 <var>subscript</var> 所指明的元素则为真</td></tr>
</table>
</div><p><strong>Table 6.3: 关系操作符
</strong>
</p>
<p>比较表达式的结果为 true，则值为 1，反之则为 0。
当不同的类型之间进行比较时，数值类型的操作符会按照 <code>CONVFMT</code> （查看 <a href="#Conversion">在字串与数值之间进行转换</a>）的格式转换为字串。
</p>
<p>字串的比较每个串的第一个字符，然后第二个字符，依次进行比较。因此，<code>&quot;10&quot;</code> 小于 <code>&quot;9&quot;</code>。
如果两个串中，一个串是另一个串的前缀，短的串小于长的串。所以，<code>&quot;abc&quot;</code> 小于 <code>&quot;abcd&quot;</code>。
</p>
<a name="index-troubleshooting_002c-_003d_003d-operator"></a>
<p>很容易不小将 &lsquo;<samp>==</samp>&rsquo; 操作符少打一个 &lsquo;<samp>=</samp>&rsquo; 符号。
结果还是一个有效的 <code>awk</code> 代码，但是程序执行的可就不是你的意图了：
</p>
<div class="example">
<pre class="example">if (a = b)   # oops! should be a == b
   &hellip;
else
   &hellip;
</pre></div>

<p>除非 <code>b</code> 碰巧为 0 或者是空串，否则 <code>if</code> 的测试部分总会是成功的（为 true）。
因此操作符看起来这么像，此类的错误会非常难发现。
</p>
<p>下面的表达式列表说明了 <code>awk</code> 执行的比较类型，以及比较的结果：
</p>
<dl compact="compact">
<dt><code>1.5 &lt;= 2.0</code></dt>
<dd><p>数值比较（true）
</p>
</dd>
<dt><code>&quot;abc&quot; &gt;= &quot;xyz&quot;</code></dt>
<dd><p>字串比较（false）
</p>
</dd>
<dt><code>1.5 != &quot; +2&quot;</code></dt>
<dd><p>字串比较（true）
</p>

</dd>
<dt><code>&quot;1e2&quot; &lt; &quot;3&quot;</code></dt>
<dd><p>字串比较（true）
</p>
</dd>
<dt><code>a = 2; b = &quot;2&quot;</code></dt>
<dt><code>a == b</code></dt>
<dd><p>字串比较（true）
</p>
</dd>
<dt><code>a = 2; b = &quot; +2&quot;</code></dt>
<dt><code>a == b</code></dt>
<dd><p>字串比较（false）
</p></dd>
</dl>

<p>在下面的例子中：
</p>
<div class="example">
<pre class="example">$ <kbd>echo 1e2 3 | awk '{ print ($1 &lt; $2) ? &quot;true&quot; : &quot;false&quot; }'</kbd>
-| false
</pre></div>

<a name="index-comparison-expressions_002c-string-vs_002e-regexp"></a>
<p>结果为 &lsquo;<samp>false</samp>&rsquo; ，因为 <code>$1</code> 与 <code>$2</code> 都是用户输入。它们都是数值字串——因此两个都有 strnum 属性，
所以执行的是数值比较。比较规则的目的以及数值字串的使用是试图产生“最少惊讶”的行为，同时还会“做正确的事”。
</p>
<p>字串比较与正则表达式比较是非常不同的，如：
</p>
<div class="example">
<pre class="example">x == &quot;foo&quot;
</pre></div>

<p>具有值 1，或者 true，如果变量 <code>x</code> 确实为 &lsquo;<samp>foo</samp>&rsquo; 。相反：
</p>
<div class="example">
<pre class="example">x ~ /foo/
</pre></div>

<p>则当 <code>x</code> 包含 &lsquo;<samp>foo</samp>&rsquo; 时为 1，如 <code>&quot;Oh, what a fool am I!&quot;</code>（天啊，我真是蠢得要死！）
</p>
<a name="index-_007e-_0028tilde_0029_002c-_007e-operator-5"></a>
<a name="index-tilde-_0028_007e_0029_002c-_007e-operator-5"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-5"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-5"></a>
<p>&lsquo;<samp>~</samp>&rsquo; 与 &lsquo;<samp>!~</samp>&rsquo; 右边的操作数可以是正则表达式常量（<code>/</code>&hellip;<code>/</code>），
也可以是一个普通的表达式。在后面的情况下，表达式的值会当成字串，并作为动态正则表达式（查看 <a href="#Regexp-Usage">如何使用正则表达式</a>，
与 <a href="#Computed-Regexps">使用动态正则表达式</a>）。
</p>
<a name="index-awk_002c-regexp-constants-and"></a>
<a name="index-regexp-constants-2"></a>
<p>带斜杠的正则表达式常量其本身也是一个表达式。<code>/<var>regexp</var>/</code> 是下面比较操作表达式的缩写形式：
</p>
<div class="example">
<pre class="example">$0 ~ /<var>regexp</var>/
</pre></div>

<p><code>/foo/</code> <em>不是</em> &lsquo;<samp>$0 ~ /foo/</samp>&rsquo; 的缩写的一个特殊地方就是它在操作符 &lsquo;<samp>~</samp>&rsquo; 或者 &lsquo;<samp>!~</samp>&rsquo; 的右边。
查看 <a href="#Using-Constant-Regexps">使用正则表达式常量</a>，在此处会有更详细的讨论。
</p>
<hr>
<a name="POSIX-String-Comparison"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Comparison-Operators" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Typing-and-Comparison" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Boolean-Ops" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="POSIX-a_00b8_00adc_009a_0084aa_00ad_0097a_00b8_00b2ae_00af_0094e_00be_0083e_00a7_0084aa_0088_0099"></a>
<h4 class="subsubsection">6.3.2.3 POSIX 中的字串比较规则</h4>

<p>POSIX 标准规定，字串的比较是按照本地语言设置的<em>分类顺序</em>进行的。这个顺序字符是按照本语言设置经过排序的
（更多的讨论可查看 <a href="#Locales">哪里造成差异</a>）。
这个顺序完全不同于进行直接的字符对字符的比较所得到的结果。 
<a name="DOCF39" href="#FOOT39">(39)</a>
</p>
<p>由于这样的行为与既有的实践有巨大的差异，<code>gawk</code> 只在 POSIX 模式下（查看 <a href="#Options">命令行参数</a>）实现了。
下面的例子解释了在 <code>en_US.UTF-8</code> 语言设置下的差异：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { printf(&quot;ABC &lt; abc = %s\n&quot;,</kbd>
&gt;                     <kbd>(&quot;ABC&quot; &lt; &quot;abc&quot; ? &quot;TRUE&quot; : &quot;FALSE&quot;)) }'</kbd>
-| ABC &lt; abc = TRUE
$ <kbd>gawk --posix 'BEGIN { printf(&quot;ABC &lt; abc = %s\n&quot;,</kbd>
&gt;                             <kbd>(&quot;ABC&quot; &lt; &quot;abc&quot; ? &quot;TRUE&quot; : &quot;FALSE&quot;)) }'</kbd>
-| ABC &lt; abc = FALSE
</pre></div>


<hr>
<a name="Boolean-Ops"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#POSIX-String-Comparison" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Truth-Values-and-Conditions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Conditional-Exp" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b8_0083ae_009e_0097e_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h3 class="subsection">6.3.3 布林表达式</h3>
<a name="index-and-Boolean_002dlogic-operator"></a>
<a name="index-or-Boolean_002dlogic-operator"></a>
<a name="index-not-Boolean_002dlogic-operator"></a>
<a name="index-expressions_002c-Boolean"></a>
<a name="index-Boolean-expressions"></a>
<a name="index-operators_002c-Boolean_002c-See-Boolean-expressions"></a>
<a name="index-Boolean-operators_002c-See-Boolean-expressions"></a>
<a name="index-logical-operators_002c-See-Boolean-expressions"></a>
<a name="index-operators_002c-logical_002c-See-Boolean-expressions"></a>

<p><em>布林表达式</em>是由比较表达式或者是匹配表达式组成，
利用操作“or”（&lsquo;<samp>||</samp>&rsquo;），“and”（&lsquo;<samp>&amp;&amp;</samp>&rsquo;），还有“not”（&lsquo;<samp>!</samp>&rsquo;）组合而成，并利用括号来控制表达式的嵌入。
布林表达式的真值通过计算组成该表达式的直值组合而得。布林表达式也称为<em>逻辑表达式</em>。两者是一样的。
</p>
<p>布林表达式可以用在所有的比较与匹配表达式可以使用的地方。可以用在 <code>if</code>，<code>while</code>，<code>do</code> 与 <code>for</code> 语言中
（查看 <a href="#Statements">动作中的控制语句</a>）。当布林表达式的结果要存在变量中或者在算法表达式中使用，则其值为数值类型（真则为 1，否则为 0）。
</p>
<p>其次，每一个布林表达式都是有效的模式，因此你可以将其用在模式中，以控制规则的执行。布林操作符有如下这些：
</p>
<dl compact="compact">
<dt><code><var>boolean1</var> &amp;&amp; <var>boolean2</var></code></dt>
<dd><p>如果 <var>boolean1</var> 与 <var>boolean2</var> 都为 true，则返回 true。例如，下面的语句，
如果输入记录中包含 &lsquo;<samp>edu</samp>&rsquo; 与 &lsquo;<samp>li</samp>&rsquo; 则打印它：
</p>
<div class="example">
<pre class="example">if ($0 ~ /edu/ &amp;&amp; $0 ~ /li/) print
</pre></div>

<a name="index-side-effects_002c-Boolean-operators"></a>
<p>子表达式 <var>boolean2</var> 只有在 <var>boolean1</var> 求值为 true 时，才会进行求值。
如果 <var>boolean2</var> 表达式包含有副作用的表达式，则会产生不同的结果。
在 &lsquo;<samp>$0 ~ /foo/ &amp;&amp; ($2 == bar++)</samp>&rsquo; 例子中，变量 <code>bar</code> 在记录中不包含子串 &lsquo;<samp>foo</samp>&rsquo; 时，不会进行递增。
</p>
</dd>
<dt><code><var>boolean1</var> || <var>boolean2</var></code></dt>
<dd><p><var>boolean1</var> 或者 <var>boolean2</var> 之一为 true 是返回 true。例如，
下面的语句中，如果输入中包含 &lsquo;<samp>edu</samp>&rsquo; <em>或者</em> &lsquo;<samp>li</samp>&rsquo;，则打印这些记录：
</p>
<div class="example">
<pre class="example">if ($0 ~ /edu/ || $0 ~ /li/) print
</pre></div>

<p>子表达式 <var>boolean2</var> 只有在 <var>boolean1</var> 的值为 false 才会进行求值。
因此如果 <var>boolean2</var> 表达式有副作用，则会带来不同的结果。（所以，这里的测试并不是真正地测试记录中是否包含 &lsquo;<samp>edu</samp>&rsquo; 与 &lsquo;<samp>li</samp>&rsquo; 二者——只要匹配 &lsquo;<samp>edu</samp>&rsquo;，整个测试就成功。）
</p>
</dd>
<dt><code>! <var>boolean</var></code></dt>
<dd><p>如果 <var>boolean</var> 为 false，则为 true。下面的代码，当 <code>HOME</code> 环境变量不存在这种不正常事件时，则打印 &lsquo;<samp>no home!</samp>&rsquo;：
</p>
<div class="example">
<pre class="example">BEGIN { if (! (&quot;HOME&quot; in ENVIRON))
            print &quot;no home!&quot; }
</pre></div>

<p>（<code>in</code> 操作符在 <a href="#Reference-to-Elements">指向数组元素</a>，这里描述）
</p></dd>
</dl>

<a name="index-short_002dcircuit-operators"></a>
<a name="index-operators_002c-short_002dcircuit"></a>
<a name="index-_0026-_0028ampersand_0029_002c-_0026_0026-operator"></a>
<a name="index-ampersand-_0028_0026_0029_002c-_0026_0026-operator"></a>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c_007c-operator"></a>
<a name="index-vertical-bar-_0028_007c_0029_002c-_007c_007c-operator"></a>
<p>&lsquo;<samp>&amp;&amp;</samp>&rsquo; 与 &lsquo;<samp>||</samp>&rsquo; 操作符因为它们的执行方式被称为短路操作符。对于完整表达式的求值，如果其结果只需要由其部分求值即可得到，则我们称这个表达式 &lsquo;<samp>被短路了</samp>&rsquo; 。
</p>
<a name="index-line-continuations"></a>
<p>如果语句由 &lsquo;<samp>&amp;&amp;</samp>&rsquo; 或者 &lsquo;<samp>||</samp>&rsquo; 结束，可以简单地在其后进行换行就可以进行续行。但是在其前面，如果你不加上一个反斜杠，都不能进行换行（查看 <a href="#Statements_002fLines"><code>awk</code> 语句与行</a>）。
</p>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021--operator"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021-operator"></a>
<a name="index-newlines-2"></a>
<a name="index-variables_002c-flag"></a>
<a name="index-flag-variables"></a>
<p>使用 &lsquo;<samp>!</samp>&rsquo; 操作符的表达式的值要么是 1，要么是 0，则要视其应用所在的表达式的值。
&lsquo;<samp>!</samp>&rsquo; 操作符在将标志变量的值从 false 转换为 true，再转回来的情况下很有用。例如，下面的程序就是一种打印特殊括号之间的行的方式：
</p>
<div class="example">
<pre class="example">$1 == &quot;START&quot;   { interested = ! interested; next }
interested      { print }
$1 == &quot;END&quot;     { interested = ! interested; next }
</pre></div>

<p>变量 <code>interested</code> 与共他所有的 <code>awk</code> 变量一样，一开始被初始化为 0，其表示 false。
当行发现了第一个域为 &lsquo;<samp>START</samp>&rsquo; 的行后，<code>interested</code> 变量的值则利用用 &lsquo;<samp>!</samp>&rsquo; 变为 true。
下一个规则中，如果 <code>interested</code> 为 true，则打印这些行。
当发现第一个域为 &lsquo;<samp>END</samp>&rsquo; 的行后，则 <code>interested</code> 变量又会转回 false。 
<a name="DOCF40" href="#FOOT40">(40)</a>
</p>

<p>更通常的是，&lsquo;<samp>!</samp>&rsquo; 操作符是用在 <code>if</code> 与 <code>while</code> 语句中，在这些语句中，写否定逻辑含义更加明确：
</p>
<div class="example">
<pre class="example">if (! <var>some condition</var> || <var>some other condition</var>) {
    <var>&hellip; do whatever processing &hellip;</var>
}
</pre></div>

<a name="index-next-statement"></a>
<blockquote>
<p><b>提示:</b> <code>next</code> 语句将在 <a href="#Next-Statement"><code>next</code> 语句</a>，讨论。
<code>next</code> 告诉 <code>awk</code> 跳过剩下的规则，并读取下一个记录，并从最开始来处理各个规则。
写在这里的原因是避免打印括起文本的 &lsquo;<samp>START</samp>&rsquo; 与 &lsquo;<samp>END</samp>&rsquo; 行。
</p></blockquote>

<hr>
<a name="Conditional-Exp"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Boolean-Ops" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Truth-Values-and-Conditions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Calls" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009d_00a1a_00bb_00b6e_00a1_00a8e_00be_00beaa_00bc_008f"></a>
<h3 class="subsection">6.3.4 条件表达式</h3>
<a name="index-conditional-expressions"></a>
<a name="index-expressions_002c-conditional"></a>
<a name="index-expressions_002c-selecting"></a>

<p><em>条件表达式</em>是一种拥有三个操作数的特殊的表达式。该表达式可以让你使用一个表达式的值，即可以从其他两个表达式中选择一个。
<code>awk</code> 中的条件表达式与 C 语言中的表达式一样，如下所示：
</p>
<div class="example">
<pre class="example"><var>selector</var> ? <var>if-true-exp</var> : <var>if-false-exp</var>
</pre></div>

<p>这里有三个子表达式。第一个子表达式是 <var>selector</var>，它总是首先被计算。如果结果为 &lsquo;<samp>true</samp>&rsquo;（非零或者非空），
则 <var>if-true-exp</var> 则接着被计算，其值将成为整个表达式的值。否则，<var>if-true-exp</var> 被计算，其值成为整个表达式的值。
例如，下面的表达式产生 <code>x</code> 的绝对值：
</p>
<div class="example">
<pre class="example">x &gt;= 0 ? x : -x
</pre></div>

<a name="index-side-effects_002c-conditional-expressions"></a>
<p>条件表达式的每一次计算，<var>if-true-exp</var> 与 <var>if-false-exp</var> 只会有一个被使用，
另外一个就被忽略了。如果表达式中有副作用，这就变得相当重要。例如，下面的条件表达式提取数组 <code>a</code> 或者 <code>b</code> 的元素 <code>i</code>，
并递增 <code>i</code>：
</p>
<div class="example">
<pre class="example">x == y ? a[i++] : b[i++]
</pre></div>

<p>这保证了 <code>i</code> 只会被递增一次，当表达式被计算时，两个递增表达式只会执行一个。
查看 <a href="#Arrays"><code>awk</code> 数组</a>，来获取更多的关于数组的信息。
</p>
<a name="index-differences-in-awk-and-gawk_002c-line-continuations"></a>
<a name="index-line-continuations_002c-gawk"></a>
<a name="index-gawk_002c-line-continuation-in"></a>
<p>作为一个小的 <code>gawk</code> 扩展，使用 &lsquo;<samp>?:</samp>&rsquo; 的语句可以在两个符号中的任意字符处进行换行。
但是，在这两个字符前进行换行，如果不加反斜杠是不行的（查看 <a href="#Statements_002fLines"><code>awk</code> 语句与行</a>）。
如何使用了 &lsquo;<samp>--posix</samp>&rsquo; 参数（查看 <a href="#Options">命令行参数</a>），这个扩展也不被禁用了。
</p>
<hr>
<a name="Function-Calls"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Conditional-Exp" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Precedence" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0087_00bdae_0095_00b0e_00b0_0083c_0094_00a8"></a>
<h2 class="section">6.4 函数调用</h2>
<a name="index-function-calls"></a>

<p><em>函数</em>是一个特殊计算过程的名字。这样你可以通过名字在程序的任何位置来请求执行。
例如，函数 <code>sqrt()</code> 计算数值的平方根。
</p>
<a name="index-functions_002c-built_002din"></a>
<p><code>awk</code> 中有固定的<em>内建</em>函数集合，它们可以在任意的 <code>awk</code> 程序中使用。
<code>sqrt()</code> 就是其中之一。查看 <a href="#Built_002din">内置函数</a>，内建函数的列表以及其说明。
另外，你也可以定义只有你的程序使用的函数。查看 <a href="#User_002ddefined">用户自定义函数</a>，来获取自定义函数的方法。
<code>gawk</code> 也可以让你使用 C 或者 C++ 来编写函数，并在你的程序中调用（查看 <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>）。
</p>
<a name="index-arguments_002c-in-function-calls"></a>
<p>函数的使用带有一个<em>函数调用</em>表达式，其包括函数名，后面直接跟着在括号中的<em>参数</em>列表。
参数是为调用函数计算过程而提供的原始资料的表达式。当多于一个参数时，它们则通过逗号分隔。
如果没有参数，则只要在函数名后写 &lsquo;<samp>()</samp>&rsquo; 即可。下面的例子展现了带参与不带参的函数调用。
</p>
<div class="example">
<pre class="example">sqrt(x^2 + y^2)        <i>one argument</i>
atan2(y, x)            <i>two arguments</i>
rand()                 <i>no arguments</i>
</pre></div>

<a name="index-troubleshooting_002c-function-call-syntax"></a>
<blockquote>
<p><b>注意:</b> 不要在函数名与开括号之间输出任何空格！
用户自定义的函数名看起来就像是变量名——因此空格会导致表达式看起来是变量与括号中的表达式的连接操作。
而对于内建的函数，在括号之前的空格是可选的，但是最好不要形成插入空格的习惯，以避免在调用用户自定义函数的时候犯错。
</p></blockquote>

<p>每个函数都有特定的参数。例如，<code>sqrt()</code> 函数必须用单参数调用，即要计算平方根的数值：
</p>
<div class="example">
<pre class="example">sqrt(<var>argument</var>)
</pre></div>

<p>一些内建的函数有一个或者多个的可选参数。如果没有提供那些参数，则函数会使用合适的默认值。
查看 <a href="#Built_002din">内置函数</a>，来获取更多细节。如果在调用用户自定义的函数时省略了参数，则这些参数将会当成本变量（在定义函数时的括号中的变量——译者注）。这些本地变量当被使用时，如果需要的是一个字串，则其为空串，如果需要的数值，则其值为 0（查看 <a href="#User_002ddefined">用户自定义函数</a>）。
</p>
<p>作为一个高级特性，<code>gawk</code> 提供了间接调用函数的方式，
这是一种在运行时进行函数选择的方式，而不是在你写程序的时候就确定要调用的函数。
我们后面再对这个进行讨论，可以查看 <a href="#Indirect-Calls">间接函数调用</a>。
</p>
<a name="index-side-effects_002c-function-calls"></a>
<p>如其他的表达式一样，函数调用也会生成一个值，通常称为返回值，这个值是根据函数的参数进行计算所得到的值。
在这个例子中，&lsquo;<samp>sqrt(<var>argument</var>)</samp>&rsquo; 的返回值就是 <var>argument</var> 的平方根。
下面的程序一行行地读取数值，然扣打印它们的平方根：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print &quot;The square root of&quot;, $1, &quot;is&quot;, sqrt($1) }'</kbd>
<kbd>1</kbd>
-| The square root of 1 is 1
<kbd>3</kbd>
-| The square root of 3 is 1.73205
<kbd>5</kbd>
-| The square root of 5 is 2.23607
<kbd>Ctrl-d</kbd>
</pre></div>

<p>函数调用有副作用，例如将值赋给一个指定的变量或者执行 I/O 操作。这个程序展现了 <code>match()</code> 函数
（查看 <a href="#String-Functions">字串操作函数</a>）如何来更改变量 <code>RSTART</code> 与 <code>RLENGTH</code>：
</p>
<div class="example">
<pre class="example">{
    if (match($1, $2))
        print RSTART, RLENGTH
    else
        print &quot;no match&quot;
}
</pre></div>

<p>这是运行例子：
</p>
<div class="example">
<pre class="example">$ <kbd>awk -f matchit.awk</kbd>
<kbd>aaccdd  c+</kbd>
-| 3 2
<kbd>foo     bar</kbd>
-| no match
<kbd>abcdefg e</kbd>
-| 5 1
</pre></div>

<hr>
<a name="Precedence"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Calls" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Locales" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0093_008da_00bd_009cc_00ac_00a6a_00bc_0098aa_0085_0088c_00ba_00a7i_00bc_0088ae_0093_008da_00bd_009cc_00ac_00a6c_009a_0084aa_00b5_008caa_00a5_0097i_00bc_0089"></a>
<h2 class="section">6.5 操作符优先级（操作符的嵌套）</h2>
<a name="index-precedence-1"></a>
<a name="index-operators_002c-precedence-1"></a>

<p><em>操作符的优先级</em>决定了不同的操作符紧接着出现在一个表达式中时如何结合。
例如，&lsquo;<samp>*</samp>&rsquo; 比 &lsquo;<samp>+</samp>&rsquo; 有更高的优先级，所以 &lsquo;<samp>a + b * c</samp>&rsquo; 表示先将 <code>b</code> 与 <code>c</code> 相乘，
然后再与 <code>a</code> 相加（如 &lsquo;<samp>a + (b * c)</samp>&rsquo;）
</p>
<p>正常的操作优先级可以通过使用括号来进行重新排序。一想到优先级规则就像是说，括号是该放在哪个位置。事实上，当操作符的组合不常出现时，使用括号总是很明智的做法。就算是很有经验的操作员，也偶尔忘记确切的规则，因此会犯错误。显式地使用括号则可以避免这样的错误。
</p>
<p>当有相同优先级的操作符出现在一起时，先对最左边的操作符进行结合。对于赋值、条件以及幂乘它们则是以相反的顺序进行结合的。
所以 &lsquo;<samp>a - b + c</samp>&rsquo; 结合成 &lsquo;<samp>(a - b) + c</samp>&rsquo;， 而 &lsquo;<samp>a = b = c</samp>&rsquo; 则是结合成 &lsquo;<samp>a = (b = c)</samp>&rsquo;。
</p>
<p>一般情况下，前缀一元操作符对于优先级并不重要，因为只有一个解释它们的方式：内层的优先。
所以，&lsquo;<samp>$++i</samp>&rsquo; 表示 &lsquo;<samp>$(++i)</samp>&rsquo;，而 &lsquo;<samp>++$x</samp>&rsquo; 则表示 &lsquo;<samp>++($x)</samp>&rsquo;。
但是，当另一个操作符跟着操作数后面，则一元操作符的优先级就重要起来了。
&lsquo;<samp>$x^2</samp>&rsquo; 表示 &lsquo;<samp>($x)^2</samp>&rsquo;，但是 &lsquo;<samp>-x^2</samp>&rsquo; 则为 &lsquo;<samp>-(x^2)</samp>&rsquo;，因为 &lsquo;<samp>-</samp>&rsquo; 的优先级低于 &lsquo;<samp>^</samp>&rsquo;，而 &lsquo;<samp>$</samp>&rsquo; 则有较高的优先级。
另外，操作符也不能以一种违反优先级规则的方式进行组合，例如 &lsquo;<samp>$$0++--</samp>&rsquo; 并不是一个有效的表达式，
因为第一个 &lsquo;<samp>$</samp>&rsquo; 有比 &lsquo;<samp>++</samp>&rsquo; 更高的优先级，为了避免产生问题，表达式可以写成 &lsquo;<samp>$($0++)--</samp>&rsquo;。
</p>
<p>下面的列表列出了 <code>awk</code> 的操作符，并按优先级的降序排序：
</p>
<dl compact="compact">
<dt><code>(</code>&hellip;<code>)</code></dt>
<dd><p>结合。
</p>
<a name="index-_0024-_0028dollar-sign_0029_002c-_0024-field-operator-1"></a>
<a name="index-dollar-sign-_0028_0024_0029_002c-_0024-field-operator-1"></a>
</dd>
<dt><code>$</code></dt>
<dd><p>域引用。
</p>
<a name="index-_002b-_0028plus-sign_0029_002c-_002b_002b-operator-2"></a>
<a name="index-plus-sign-_0028_002b_0029_002c-_002b_002b-operator-2"></a>
<a name="index-_002d-_0028hyphen_0029_002c-_002d_002d-operator-1"></a>
<a name="index-hyphen-_0028_002d_0029_002c-_002d_002d-operator-1"></a>
</dd>
<dt><code>++ --</code></dt>
<dd><p>递增，递减。
</p>
<a name="index-_005e-_0028caret_0029_002c-_005e-operator"></a>
<a name="index-caret-_0028_005e_0029_002c-_005e-operator"></a>
<a name="index-_002a-_0028asterisk_0029_002c-_002a_002a-operator-1"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a_002a-operator-1"></a>
</dd>
<dt><code>^ **</code></dt>
<dd><p>幂乘。这个操作符的结合由右往左。
</p>
<a name="index-_002b-_0028plus-sign_0029_002c-_002b-operator"></a>
<a name="index-plus-sign-_0028_002b_0029_002c-_002b-operator"></a>
<a name="index-_002d-_0028hyphen_0029_002c-_002d-operator"></a>
<a name="index-hyphen-_0028_002d_0029_002c-_002d-operator"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021-operator"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021-operator-1"></a>
</dd>
<dt><code>+ - !</code></dt>
<dd><p>一元加，一元减，以及逻辑“非”。
</p>
<a name="index-_002a-_0028asterisk_0029_002c-_002a-operator_002c-as-multiplication-operator"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a-operator_002c-as-multiplication-operator"></a>
<a name="index-_002f-_0028forward-slash_0029_002c-_002f-operator"></a>
<a name="index-forward-slash-_0028_002f_0029_002c-_002f-operator"></a>
<a name="index-_0025-_0028percent-sign_0029_002c-_0025-operator"></a>
<a name="index-percent-sign-_0028_0025_0029_002c-_0025-operator"></a>
</dd>
<dt><code>* / %</code></dt>
<dd><p>乘，除，取余。
</p>
<a name="index-_002b-_0028plus-sign_0029_002c-_002b-operator-1"></a>
<a name="index-plus-sign-_0028_002b_0029_002c-_002b-operator-1"></a>
<a name="index-_002d-_0028hyphen_0029_002c-_002d-operator-1"></a>
<a name="index-hyphen-_0028_002d_0029_002c-_002d-operator-1"></a>
</dd>
<dt><code>+ -</code></dt>
<dd><p>加，减。
</p>
</dd>
<dt>String concatenation</dt>
<dd><p>没有针对字串连接的特别符号。操作数简单地一个接一个输入（查看 <a href="#Concatenation">字串连接</a>）。
</p>
<a name="index-_003c-_0028left-angle-bracket_0029_002c-_003c-operator-1"></a>
<a name="index-left-angle-bracket-_0028_003c_0029_002c-_003c-operator-1"></a>
<a name="index-_003c-_0028left-angle-bracket_0029_002c-_003c_003d-operator-1"></a>
<a name="index-left-angle-bracket-_0028_003c_0029_002c-_003c_003d-operator-1"></a>
<a name="index-_003e-_0028right-angle-bracket_0029_002c-_003e_003d-operator-1"></a>
<a name="index-right-angle-bracket-_0028_003e_0029_002c-_003e_003d-operator-1"></a>
<a name="index-_003e-_0028right-angle-bracket_0029_002c-_003e-operator-1"></a>
<a name="index-right-angle-bracket-_0028_003e_0029_002c-_003e-operator-1"></a>
<a name="index-_003d-_0028equals-sign_0029_002c-_003d_003d-operator-1"></a>
<a name="index-equals-sign-_0028_003d_0029_002c-_003d_003d-operator-1"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_003d-operator-1"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_003d-operator-1"></a>
<a name="index-_003e-_0028right-angle-bracket_0029_002c-_003e_003e-operator-_0028I_002fO_0029-1"></a>
<a name="index-right-angle-bracket-_0028_003e_0029_002c-_003e_003e-operator-_0028I_002fO_0029-1"></a>
<a name="index-operators_002c-input_002foutput-5"></a>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c-operator-_0028I_002fO_0029-2"></a>
<a name="index-vertical-bar-_0028_007c_0029_002c-_007c-operator-_0028I_002fO_0029-1"></a>
<a name="index-operators_002c-input_002foutput-6"></a>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029-2"></a>
<a name="index-vertical-bar-_0028_007c_0029_002c-_007c_0026-operator-_0028I_002fO_0029-1"></a>
<a name="index-operators_002c-input_002foutput-7"></a>
</dd>
<dt><code>&lt; &lt;= == != &gt; &gt;= &gt;&gt; | |&amp;</code></dt>
<dd><p>关系与重定向。关系操作符与重定向有相同的优先级。如 &lsquo;<samp>&gt;</samp>&rsquo; 这样的字符，即为关系操作符，也可以作为重定向符。上下文环境用来区别使用的是哪种含义。
</p>
<a name="index-print-statement_002c-I_002fO-operators-in"></a>
<a name="index-printf-statement_002c-I_002fO-operators-in"></a>
<p>注意在 <code>print</code> 与 <code>printf</code> 语句中的 I/O 重定向，是语句级的，而不是表达式级的。重定向不会产生表达式，不可以成为别一个操作符的操作数。结果就是，不用括号而在一个低优先级的操作符附近使用重定向操作符是没有意义的。这样的组合
（如 &lsquo;<samp>print foo &gt; a ? b : c</samp>&rsquo; 会导致语法错误。正确地写法应该是 &lsquo;<samp>print foo &gt; (a ? b : c)</samp>&rsquo;。
</p>
<a name="index-_007e-_0028tilde_0029_002c-_007e-operator-6"></a>
<a name="index-tilde-_0028_007e_0029_002c-_007e-operator-6"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-6"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-6"></a>
</dd>
<dt><code>~ !~</code></dt>
<dd><p>匹配与不匹配。
</p>
<a name="index-in-operator-1"></a>
</dd>
<dt><code>in</code></dt>
<dd><p>数组成员判定。
</p>
<a name="index-_0026-_0028ampersand_0029_002c-_0026_0026-operator-1"></a>
<a name="index-ampersand-_0028_0026_0029_002c-_0026_0026-operator-1"></a>
</dd>
<dt><code>&amp;&amp;</code></dt>
<dd><p>逻辑“与”。
</p>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c_007c-operator-1"></a>
<a name="index-vertical-bar-_0028_007c_0029_002c-_007c_007c-operator-1"></a>
</dd>
<dt><code>||</code></dt>
<dd><p>逻辑“或”。
</p>
<a name="index-_003f-_0028question-mark_0029_002c-_003f_003a-operator"></a>
<a name="index-question-mark-_0028_003f_0029_002c-_003f_003a-operator"></a>
</dd>
<dt><code>?:</code></dt>
<dd><p>条件，这个操作符的结合是从右到左。
</p>
<a name="index-_002b-_0028plus-sign_0029_002c-_002b_003d-operator-1"></a>
<a name="index-plus-sign-_0028_002b_0029_002c-_002b_003d-operator-1"></a>
<a name="index-_002d-_0028hyphen_0029_002c-_002d_003d-operator-1"></a>
<a name="index-hyphen-_0028_002d_0029_002c-_002d_003d-operator-1"></a>
<a name="index-_002a-_0028asterisk_0029_002c-_002a_003d-operator-1"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a_003d-operator-1"></a>
<a name="index-_002a-_0028asterisk_0029_002c-_002a_002a_003d-operator-1"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a_002a_003d-operator-1"></a>
<a name="index-_002f-_0028forward-slash_0029_002c-_002f_003d-operator-1"></a>
<a name="index-forward-slash-_0028_002f_0029_002c-_002f_003d-operator-1"></a>
<a name="index-_0025-_0028percent-sign_0029_002c-_0025_003d-operator-1"></a>
<a name="index-percent-sign-_0028_0025_0029_002c-_0025_003d-operator-1"></a>
<a name="index-_005e-_0028caret_0029_002c-_005e_003d-operator-1"></a>
<a name="index-caret-_0028_005e_0029_002c-_005e_003d-operator-1"></a>
</dd>
<dt><code>= += -= *= /= %= ^= **=</code></dt>
<dd><p>赋值操作符，这些操作符结合由右至左。
</p></dd>
</dl>

<a name="index-POSIX-awk_002c-_002a_002a-operator-and"></a>
<a name="index-portability_002c-operators_002c-not-in-POSIX-awk"></a>
<blockquote>
<p><b>提示:</b> &lsquo;<samp>|&amp;</samp>&rsquo; 、 &lsquo;<samp>**</samp>&rsquo; 与 &lsquo;<samp>**=</samp>&rsquo; 都没有由 POSIX 指定，为了移植性，请不要使用它们。
</p></blockquote>

<hr>
<a name="Locales"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Precedence" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0093_00aae_0087_008ce_0080_00a0ae_0088_0090aa_00b7_00aeaa_00bc_0082"></a>
<h2 class="section">6.6 哪里造成差异</h2>
<a name="index-locale_002c-definition-of"></a>

<p>现代操作系统都有<em>本地语言</em>的概念：即告诉系统本地字符集与语言的一种方式。
ISO C 标准定义了一种默认的 <code>&quot;C&quot;</code> 语言设置，这是一种很多 C 程序员所使用的一种典型环境。
</p>
<p>以前，语言设置用来影响正则表达式的匹配，但是现在事情不再是这样的（查看 <a href="#Ranges-and-Locales">正则表达式范围与本地语言设置：又臭又长陈年旧事</a>）。
</p>
<p>本地语言设置也会影响记录的分割。对于正常的 &lsquo;<samp>RS = &quot;\n&quot;</samp>&rsquo; 这种情况，
语言设置大多是不相关的。对于其他单字符记录分隔符，在环境变量中设置 &lsquo;<samp>LC_ALL=C</samp>&rsquo; 将使你在读取记录时有更好的性能。否则，
<code>gawk</code> 得调用几个函数，针对<em>每一个输出字符</em>进行调用，以查找记录的分隔符。
</p>
<p>语言设置也会影响日期与时间的格式（查看 <a href="#Time-Functions">时间函数</a>）。
例如，对于 2015 年 9 月 4 号的一般缩写方式，在美国是“9/4/15”。但在欧洲的许多国家，则是“4.9.15”。
因此，&lsquo;<samp>%x</samp>&rsquo; 在 <code>&quot;US&quot;</code> 语言设置中可能产生 &lsquo;<samp>9/4/15</samp>&rsquo;，而在 <code>&quot;EUROPE&quot;</code> 语言设置中，可能产生 &lsquo;<samp>4.9.15</samp>&rsquo;。
</p>
<p>根据 POSIX 标准，字串比较也会受到语言设置的影响（与正则表达式类似）。具体的细节在 <a href="#POSIX-String-Comparison">POSIX 中的字串比较规则</a>。
</p>
<p>最后，语言设置也会影响 <code>gawk</code> 在分析输入数据时所使用的十进制小数点符号的值。
关于这一点的细节则在 <a href="#Conversion">在字串与数值之间进行转换</a>。
</p>
<hr>
<a name="Expressions-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Locales" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-2"></a>
<h2 class="section">6.7 总结</h2>

<ul>
<li>
表达式是程序中基本的计算元素。它们由常量、变量、函数调用以及用操作符组合起来的各种值组成。

</li><li>
<code>awk</code> 提供三种常量：数值常量，字串常量以及正则表达式常量。
<code>gawk</code> 可以让你以八进制以及十六进制的方式来指定数值常量（相关的基数为 8 与 16），也可以以十进制方式进行指定（基数为 10）。
在特定的上下文中，单独的正则表达式，
如 <code>/foo/</code> 与 &lsquo;<samp>$0 ~ /foo/</samp>&rsquo; 有一样的含义。

</li><li>
变量在计算的过程中持有值。有一些内置变量来提供 <code>awk</code> 程序的相关信息，还有一些变量用来控制 <code>awk</code> 的行为。

</li><li>
在 <code>awk</code> 需要的时候，数值会自动地转换为字串，字串也会转换为数值。
数值转换的方式就好像通过以 <code>CONVFMT</code> 格式来调用 <code>sprintf()</code> 进行格式化一样。语言设置可以影响转换。

</li><li>
<code>awk</code> 提供了常用的算术操作符（加、减、乘、除，取模），还有一元的加与减。同时也提供比较操作符，布林操作符，以及数组元素成员测试操作符和正则表达式匹配操作符。字串连接通过将通过简单地将表达式顺序排放来完成，而不需要显式的操作符。
三元操作符 &lsquo;<samp>?:</samp>&rsquo; 则提供了在表达式中进行“if-else”的测试。

</li><li>
赋值操作符为通用的算术操作提供了方便的缩略。

</li><li>
在 <code>awk</code> 中，如果非零<em>或者</em>非空，则被认为是 true，否则为 false。

</li><li>
变量的类型依赖于赋值，并且在生命期中可以变化。类型决定了它在比较中的行为（是以字串方式还是以数值方式进行）。

</li><li>
函数调用的返回值 可以做为一个更大的表达式的一部分。用于在调用函数时向函数传递的参数的表达式会在调用之前进行求值。
<code>awk</code> 即提供了内置的函数，也提供用户自定义的函数，相关的细节在 <a href="#Functions">函数</a>。

</li><li>
操作符的优先级指定了操作执行的顺序，除非使用了括号来更改。
<code>awk</code> 的操作符优先级与 C 中的优先级兼容。

</li><li>
语言设置可以影响 <code>awk</code> 程序输出数据的格式，偶尔也影响作为数据输入的格式。

</li></ul>


<hr>
<a name="Patterns-and-Actions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Expressions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expressions-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Overview" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a8_00a1aa_00bc_008fa_0080_0081aa_008a_00a8a_00bd_009ca_00b8_008eaa_008f_0098e_0087_008f"></a>
<h1 class="chapter">7 模式、动作与变量</h1>
<a name="index-patterns"></a>

<p>如我们已经看到的，每一个 <code>awk</code> 语句都由与模式及与其关联的动作组成。本章述如何来创建模式与动作，包括你在动作中可以做的操作的类型，
以及 <code>awk</code> 的预定义变量。
</p>
<p>“模式-动作”规则以及可在动作中使用的语句组成了 <code>awk</code> 编程的核心。在一定意义上，到此为止所涉及的内容是建立程序的基础。目前可以弄些有用的时候了。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Pattern-Overview">7.1 模式元素</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            What goes into a pattern.
</td></tr>
<tr><td align="left" valign="top"><a href="#Using-Shell-Variables">7.2 在程序中使用 Shell 变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       How to use shell variables with <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Action-Overview">7.3 动作</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             What goes into an action.
</td></tr>
<tr><td align="left" valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Describes the various control statements in
                                detail.
</td></tr>
<tr><td align="left" valign="top"><a href="#Built_002din-Variables">7.5 预定义变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Summarizes the predefined variables.
</td></tr>
<tr><td align="left" valign="top"><a href="#Pattern-Action-Summary">7.6 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Patterns and Actions summary.
</td></tr>
</table>

<hr>
<a name="Pattern-Overview"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Patterns" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a8_00a1aa_00bc_008faa_0085_0083c_00b4_00a0"></a>
<h2 class="section">7.1 模式元素</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Regexp-Patterns">7.1.1 以正则表达式为模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Using regexps as patterns.
</td></tr>
<tr><td align="left" valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Any expression can be used as a pattern.
</td></tr>
<tr><td align="left" valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Pairs of patterns specify record ranges.
</td></tr>
<tr><td align="left" valign="top"><a href="#BEGIN_002fEND">7.1.4 <code>BEGIN</code> 与 <code>END</code> 特殊模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Specifying initialization and cleanup rules.
</td></tr>
<tr><td align="left" valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Two special patterns for advanced control.
</td></tr>
<tr><td align="left" valign="top"><a href="#Empty">7.1.6 空模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       The empty pattern, which matches every record.
</td></tr>
</table>

<a name="index-patterns_002c-types-of"></a>
<p>在 <code>awk</code> 中的模式控制着规则的执行，当模式匹配当前的输入记录时，就执行它的规则。下面总结了 <code>awk</code> 模式的类型：
</p>
<dl compact="compact">
<dt><code>/<var>regular expression</var>/</code></dt>
<dd><p>正则表达式。当输入记录的文本适配于正则表达式则匹配。（查看 <a href="#Regexp">正则表达式</a>。）
</p>
</dd>
<dt><code><var>expression</var></code></dt>
<dd><p>单独的表达式。当这个表达式的值为非零（如果是数值的话）或者非空（如果是字串的话）则匹配。（查看 <a href="#Expression-Patterns">以表达式为模式</a>。）
</p>
</dd>
<dt><code><var>begpat</var>, <var>endpat</var></code></dt>
<dd><p>一对由逗号分隔的模式，指定了记录的<em>范围</em>。
范围包括匹配 <var>begpat</var> 的开始的记录以及最后一个匹配 <var>endpat</var> 的记录（查看 <a href="#Ranges">用模式指定记录范围</a>。）
</p>
</dd>
<dt><code>BEGIN</code></dt>
<dt><code>END</code></dt>
<dd><p>指定 <code>awk</code> 程序开始与结束行为的特殊模式。（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>。）
</p>
</dd>
<dt><code>BEGINFILE</code></dt>
<dt><code>ENDFILE</code></dt>
<dd><p>针对每个文件为基础的在开始与结束中执行的动作的特殊模式。（查看 <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>。）
</p>
</dd>
<dt><code><var>empty</var></code></dt>
<dd><p>空模式匹配每一条记录。（查看 <a href="#Empty">空模式</a>。）
</p></dd>
</dl>

<hr>
<a name="Regexp-Patterns"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Overview" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Overview" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Expression-Patterns" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_00a5ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fa_00b8_00baae_00a8_00a1aa_00bc_008f"></a>
<h3 class="subsection">7.1.1 以正则表达式为模式</h3>
<a name="index-patterns_002c-expressions-as"></a>
<a name="index-regular-expressions_002c-as-patterns-1"></a>

<p>正则表达式是本网页中出现的第一种模式。此类模式只是简单的处于模式规则中的正则表达工常量。
它表示 &lsquo;<samp>$0 ~ /<var>pattern</var>/</samp>&rsquo;。当输出记录匹配正则表达式是，则规则匹配。如：
</p>
<div class="example">
<pre class="example">/foo|bar|baz/  { buzzwords++ }
END            { print buzzwords, &quot;buzzwords seen&quot; }
</pre></div>

<hr>
<a name="Expression-Patterns"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Regexp-Patterns" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Overview" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Ranges" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_00a5e_00a1_00a8e_00be_00beaa_00bc_008fa_00b8_00baae_00a8_00a1aa_00bc_008f"></a>
<h3 class="subsection">7.1.2 以表达式为模式</h3>
<a name="index-expressions_002c-as-patterns"></a>

<p><code>awk</code> 表达是有效的 <code>awk</code> 模式。如果表达式的值是非零（如果结果为数值）或者非空（如果结果为字串）就表示模式是匹配的。表达式每次匹配输入记录的时候都需要重新计算一次。如果表达式使用的是域，
如 <code>$1</code>，则它的值直接依赖于新的输入记录文本，不然，它就只依赖于 <code>awk</code> 程序到目前为止已经执行的结果。
</p>
<a name="index-comparison-expressions_002c-as-patterns"></a>
<a name="index-patterns_002c-comparison-expressions-as"></a>
<p>使用在 <a href="#Typing-and-Comparison">变量类型与比较表达式</a>，描述的比较操作符的比较表达式，是很常用的模式类型。
正则表达式匹配与不匹配也是非常常用的表达式。
&lsquo;<samp>~</samp>&rsquo; 与 &lsquo;<samp>!~</samp>&rsquo; 操作符的左边的操作数是一个字串。右手的操作数要么是一个被斜杠包住的常量正则表达式（<code>/<var>regexp</var>/</code>），
要么是一个动态的正则表达式（查看 <a href="#Computed-Regexps">使用动态正则表达式</a>）。下面的例子中打印其第一个域为 &lsquo;<samp>li</samp>&rsquo; 的所有记录的第二个域：
</p>
<a name="index-_002f-_0028forward-slash_0029_002c-patterns-and"></a>
<a name="index-forward-slash-_0028_002f_0029_002c-patterns-and"></a>
<a name="index-_007e-_0028tilde_0029_002c-_007e-operator-7"></a>
<a name="index-tilde-_0028_007e_0029_002c-_007e-operator-7"></a>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-7"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-7"></a>
<div class="example">
<pre class="example">$ <kbd>awk '$1 == &quot;li&quot; { print $2 }' mail-list</kbd>
</pre></div>

<p>（这里没有输出，因为没有人的名字为 &lsquo;<samp>li</samp>&rsquo;）。与下面的正则表达式匹配相比，则会匹配任意的记录中第一个域中包含 &lsquo;<samp>li</samp>&rsquo; 的记录：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '$1 ~ /li/ { print $2 }' mail-list</kbd>
-| 555-5553
-| 555-6699
</pre></div>

<a name="index-regexp-constants_002c-as-patterns"></a>
<a name="index-patterns_002c-regexp-constants-as"></a>
<p>正则表达式常量是表达式模式的一种特例。表达式 <code>/li/</code> 中，如果 &lsquo;<samp>li</samp>&rsquo; 出现在当前的记录中，则其值为 1。
因此，作为模式，<code>/li/</code> 匹配任意的包含 &lsquo;<samp>li</samp>&rsquo; 的记录。
</p>
<a name="index-Boolean-expressions_002c-as-patterns"></a>
<p>布林表达式也是常用的模式。模式是否匹配输入记录，则依赖于其子表达式是否匹配。例如，下面的命令打印 &lsquo;<tt>mail-list</tt>&rsquo;  文件中，
既包含 &lsquo;<samp>edu</samp>&rsquo; 也包含 &lsquo;<samp>li</samp>&rsquo; 的记录：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '/edu/ &amp;&amp; /li/' mail-list</kbd>
-| Samuel       555-3430     samuel.lanceolis@shu.edu        A
</pre></div>

<p>下面的命令打印 &lsquo;<tt>mail-list</tt>&rsquo; 文件中包含 &lsquo;<samp>edu</samp>&rsquo; <em>或者</em> &lsquo;<samp>li</samp>&rsquo; （或者包含二者）的所有的记录。
</p>
<div class="example">
<pre class="example">$ <kbd>awk '/edu/ || /li/' mail-list</kbd>
-| Amelia       555-5553     amelia.zodiacusque@gmail.com    F
-| Broderick    555-0542     broderick.aliquotiens@yahoo.com R
-| Fabius       555-1234     fabius.undevicesimus@ucb.edu    F
-| Julie        555-6699     julie.perscrutabor@skeeve.com   F
-| Samuel       555-3430     samuel.lanceolis@shu.edu        A
-| Jean-Paul    555-2127     jeanpaul.campanorum@nyu.edu     R
</pre></div>

<p>下面的命令打印 &lsquo;<tt>mail-list</tt>&rsquo; 文件中不包含串 &lsquo;<samp>li</samp>&rsquo; 的所有记录：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '! /li/' mail-list</kbd>
-| Anthony      555-3412     anthony.asserturo@hotmail.com   A
-| Becky        555-7685     becky.algebrarum@gmail.com      A
-| Bill         555-1675     bill.drowning@hotmail.com       A
-| Camilla      555-2912     camilla.infusarum@skynet.be     R
-| Fabius       555-1234     fabius.undevicesimus@ucb.edu    F
-| Martin       555-6480     martin.codicibus@hotmail.com    A
-| Jean-Paul    555-2127     jeanpaul.campanorum@nyu.edu     R
</pre></div>

<a name="index-BEGIN-pattern_002c-Boolean-patterns-and"></a>
<a name="index-END-pattern_002c-Boolean-patterns-and"></a>
<a name="index-BEGINFILE-pattern_002c-Boolean-patterns-and"></a>
<a name="index-ENDFILE-pattern_002c-Boolean-patterns-and"></a>
<p>在模式中布林表达式操作符的子表达式可以是正则表达式常量、比较、或者任意的 <code>awk</code> 表达式。
范围模式不是表达式，因此它们不可以出现在布林表达式中。而特殊模式 <code>BEGIN</code>，<code>END</code>，<code>BEGINFILE</code> 与 <code>ENDFILE</code>，
它们不会匹配任何的输入记录，也不是表达式，所以也不能出现在布林模式中。
</p>
<p>可以出现在模式中的不同的操作符优先级，在这里 <a href="#Precedence">操作符优先级（操作符的嵌套）</a>，进行讨论。
</p>
<hr>
<a name="Ranges"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Expression-Patterns" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Overview" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#BEGIN_002fEND" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_00a8ae_00a8_00a1aa_00bc_008fae_008c_0087aa_00ae_009ae_00ae_00b0aa_00bd_0095e_008c_0083aa_009b_00b4"></a>
<h3 class="subsection">7.1.3 用模式指定记录范围</h3>

<a name="index-range-patterns"></a>
<a name="index-patterns_002c-ranges-in"></a>
<a name="index-lines_002c-matching-ranges-of"></a>
<a name="index-_002c-_0028comma_0029_002c-in-range-patterns"></a>
<a name="index-comma-_0028_002c_0029_002c-in-range-patterns"></a>
<p><em>范围模式</em>由两个逗号分隔的模式组成，以这样的方式 &lsquo;<samp><var>begpat</var>, <var>endpat</var></samp>&rsquo; 出现。
这个用来对连续的记录进行匹配。第一个模式 <var>begpat</var> 控制范围从何处开始，而 <var>endpat</var> 则控制在何处结束。例如下面的代码：
</p>
<div class="example">
<pre class="example">awk '$1 == &quot;on&quot;, $1 == &quot;off&quot;' myfile
</pre></div>

<p>打印 &lsquo;<tt>myfile</tt>&rsquo; 中 &lsquo;<samp>on</samp>&rsquo; 与 &lsquo;<samp>off</samp>&rsquo; 中的所有记录（包含）。
</p>
<p>范围模式通过将输入记录与 <var>begpat</var> 开始。当记录匹配 <var>begpat</var> 时，
范围就会被打开，同时范围模式也会匹配这个记录。只要范围模式保持<em>打开状态</em>，其就会匹配所读取的每个记录。
同时，输入记录也会与 <var>endpat</var>  进行匹配，
当匹配成功时，范围模式就会在下一条记录之前<em>关闭</em>。
然后，范围模式又回头检查 <var>begpat</var> 与每条记录的匹配情况。
</p>
<a name="index-if-statement_002c-actions_002c-changing"></a>
<p>打开范围模式的记录与关闭范围模式的记录都匹配范围模式。如果你不想处理这些记录，你可以在规则中通过 <code>if</code> 语句来区分它们，并关注你所感兴趣的记录上。
</p>
<p>也有可能在同一条记录上打开与关闭范围模式。如果记录满足两个条件，则动作就针对那条记录执行。例如，如果在两个相同的标志间有文本
（如 &lsquo;<samp>%</samp>&rsquo; 符号），且每一行包含一个这样的标志，则忽略这两个符号。第一种尝试组合范围模式的方式是描述分隔符，
然后跟着 <code>next</code> 语句（还没有讨论到，请看 <a href="#Next-Statement"><code>next</code> 语句</a>）。
这使得 <code>awk</code> 会跳过处理当前的记录而开始下一个输入记录。程序看起来如下：
</p>
<div class="example">
<pre class="example">/^%$/,/^%$/    { next }
               { print }
</pre></div>

<a name="index-lines_002c-skipping-between-markers"></a>
<p>这个程序不会成功，因为范围模式在包含 &lsquo;<samp>%</samp>&rsquo; 的同一行开启并关闭。为了完成这个任务，应该使用一个标志的方式来写程序：
</p>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021-operator-1"></a>
<div class="example">
<pre class="example">/^%$/     { skip = ! skip; next }
skip == 1 { next } # skip lines with `skip' set
</pre></div>

<p>在范围模式中，逗号（&lsquo;<samp>,</samp>&rsquo;）在所有的操作符中具有最低的优先级（它将在最后进行求值）。所以，下面的程序试图用另一种更简单的测试来生成范围模式：
</p>
<div class="example">
<pre class="example">echo Yes | awk '/1/,/2/ || /Yes/'
</pre></div>

<p>这个程序的意图本来是 &lsquo;<samp>(/1/,/2/) || /Yes/</samp>&rsquo; 。
但是 <code>awk</code> 将其解释成了 &lsquo;<samp>/1/, (/2/ || /Yes/)</samp>&rsquo;。没有办法改变或者解决这个问题，范围模式不可以与其他的模式进行组合。
</p>
<div class="example">
<pre class="example">$ <kbd>echo Yes | gawk '(/1/,/2/) || /Yes/'</kbd>
error--&gt; gawk: cmd. line:1: (/1/,/2/) || /Yes/
error--&gt; gawk: cmd. line:1:           ^ syntax error
</pre></div>

<a name="index-range-patterns_002c-line-continuation-and"></a>
<p>一个有趣的点是， POSIX 允许你在范围模式的逗号后面进行换行，虽然这看起来不那么好看。
(d.c.)
</p>
<hr>
<a name="BEGIN_002fEND"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Ranges" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Overview" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Using-BEGIN_002fEND" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="BEGIN-a_00b8_008e-END-c_0089_00b9ae_00ae_008aae_00a8_00a1aa_00bc_008f"></a>
<h3 class="subsection">7.1.4 <code>BEGIN</code> 与 <code>END</code> 特殊模式</h3>

<a name="index-BEGIN-pattern-1"></a>
<a name="index-END-pattern"></a>
<p>到目前为止所描述的模式都用来匹配输入记录。<code>BEGIN</code> 与 <code>END</code> 特殊模式则不同。它们为 <code>awk</code> 程序提供开始与结束操作。
<code>BEGIN</code> 与 <code>END</code> 规则必须有动作。这些规则没有默认的动作因为在运行时没有当前记录。<code>BEGIN</code> 与 <code>END</code> 规则常常被那些老的 <code>awk</code> 程序员称为“<code>BEGIN</code> 与 <code>END</code> 块”。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Using-BEGIN_002fEND">7.1.4.1 开始与结束动作</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How and why to use BEGIN/END rules.
</td></tr>
<tr><td align="left" valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           I/O issues in BEGIN/END rules.
</td></tr>
</table>

<hr>
<a name="Using-BEGIN_002fEND"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#BEGIN_002fEND" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#BEGIN_002fEND" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#I_002fO-And-BEGIN_002fEND" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00bc_0080aa_00a7_008ba_00b8_008ec_00bb_0093ae_009d_009faa_008a_00a8a_00bd_009c"></a>
<h4 class="subsubsection">7.1.4.1 开始与结束动作</h4>

<a name="index-BEGIN-pattern-2"></a>
<a name="index-END-pattern-1"></a>
<p><code>BEGIN</code> 规则只执行一次，并且是在读取记录之前执行。相应地，<code>END</code> 规则也只执行一次，并且在所有的记录已经读取完成之后执行。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '</kbd>
&gt; <kbd>BEGIN { print &quot;Analysis of \&quot;li\&quot;&quot; }</kbd>
&gt; <kbd>/li/  { ++n }</kbd>
&gt; <kbd>END   { print &quot;\&quot;li\&quot; appears in&quot;, n, &quot;records.&quot; }' mail-list</kbd>
-| Analysis of &quot;li&quot;
-| &quot;li&quot; appears in 4 records.
</pre></div>

<a name="index-BEGIN-pattern_002c-operators-and"></a>
<a name="index-END-pattern_002c-operators-and"></a>
<p>此程序查找在输入文件 &lsquo;<tt>mail-list</tt>&rsquo; 中，包含字串 &lsquo;<samp>li</samp>&rsquo; 串的记录。<code>BEGIN</code> 规则打印报告的标题。
没有必须通过 <code>BEGIN</code> 规则来初始化变量 <code>n</code> 为零，
因为 <code>awk</code> 会自动处理（查看 <a href="#Variables">变量</a>）。第二个规则是当输入记录中包含 &lsquo;<samp>li</samp>&rsquo; 时，就递增变量 <code>n</code>。
<code>END</code> 规则在程序执行完成后，打印变量 <code>n</code> 的值。
</p>
<p><code>BEGIN</code> 与 <code>END</code> 特殊规则不可以用在范围规则中，也不可以与布林操作符一起使用（实际上，它们不可以与任何操作符一起使用）。
一个 <code>awk</code> 程序可以有多个 <code>BEGIN</code> 与/或 <code>END</code> 规则。它们会按照出现的顺序被执行：所有的 <code>BEGIN</code> 规则在启动时执行，
而所有的 <code>END</code> 规则在结束时执行。<code>BEGIN</code> 与 <code>END</code> 规则可以与其他的规则交叉混合。
这样的特性是在 <code>awk</code> 的 1987 年的版本被加入，并加入到 POSIX 标准中。最开始（1978）的 <code>awk</code> 版本要求 <code>BEGIN</code> 规则要放在程序的开始处，<code>END</code> 规则则需要放在程序的结尾处，并且两者都只能出现一次。目前不再需要这样，但是按照这样的模板来写程序却是个好习惯，因为这样可以使程序组织得更好，并且增强可读性。
</p>
<p>多个 <code>BEGIN</code> 与 <code>END</code> 规则在写库函数的时候非常有用，因为每个库文件都可以有它们自己的 <code>BEGIN</code> 与/或 <code>END</code> 规则来处理初始化与/或结束工作。在命令行中指定的库函数的名字，可以控制与其相关的 <code>BEGIN</code> 与 <code>END</code> 规则执行的顺序。因此，你要仔细地处理库文件中的这些规则，使得它们的执行顺序不会带来影响。
查看 <a href="#Options">命令行参数</a>，来获取更多的使用库函数的相关信息。查看 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a>。
</p>
<p>如果 <code>awk</code> 只有 <code>BEGIN</code> 规则而没有其他的规则，则程序在执行了 <code>BEGIN</code> 规则之后就退出了。 但是，
如果 <code>END</code> 规则存在，则输入会被读取，就算程序中没有其他的规则存在。因为如果在 <code>END</code> 规则中检查 <code>FNR</code> 与 <code>NR</code> 变量，因此这么做就是很有必要的。
</p>
<hr>
<a name="I_002fO-And-BEGIN_002fEND"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Using-BEGIN_002fEND" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#BEGIN_002fEND" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#BEGINFILE_002fENDFILE" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="BEGIN-a_00b8_008e-END-e_00a7_0084aa_0088_0099a_00b8_00adc_009a_0084e_00be_0093aa_0085_00a5e_00be_0093aa_0087_00ba"></a>
<h4 class="subsubsection">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</h4>


<a name="index-input_002foutput_002c-from-BEGIN-and-END"></a>
<p>在 <code>BEGIN</code> 与 <code>END</code> 规则中进行 I/O 操作时，要注意几点（其中的某些还比较微妙）。
首先要关注的是在 <code>BEGIN</code> 中 <code>$0</code> 的值。由于 <code>BEGIN</code> 的执行在任何的输入之前，所以也就没有输入记录，也没有域。
对于 <code>$0</code> 以及域的访问都将产生空串或者 0 值，这视上下文的情况。
要使 <code>$0</code> 中有实值，可以以不带变量的形式执行 <code>getline</code>（查看 <a href="#Getline">用 <code>getline</code> 输入数据</a>）。另一个方式就是给 <code>$0</code> 赋值。
</p>
<a name="index-Brian-Kernighan_0027s-awk-6"></a>
<a name="index-differences-in-awk-and-gawk_002c-BEGIN_002fEND-patterns"></a>
<a name="index-POSIX-awk_002c-BEGIN_002fEND-patterns"></a>
<a name="index-print-statement_002c-BEGIN_002fEND-patterns-and"></a>
<a name="index-BEGIN-pattern_002c-print-statement-and"></a>
<a name="index-END-pattern_002c-print-statement-and"></a>
<p>第二点则跟第一点有点类似，但是是在另一个方向上。传统上，大部份是由于实现的问题，
<code>$0</code> 与 <code>NF</code> 在 <code>END</code> 规则中都是<em>未定义</em>的。
POSIX 标准指出 <code>NF</code> 在 <code>END</code> 规则中是可用的。它包含的是最后一行记录中的域数目。很大可能是由于疏忽，在标准中却没有说也要保留 <code>$0</code> 的值，尽管在逻辑上大家都认为是该保留下来的。事实上，所有的 BMW <code>awk</code>，<code>mawk</code>，以及 <code>gawk</code> 都在 <code>END</code> 规则中保留了 <code>$0</code> 的值。但是也要注意，一些其他的实现，与一些旧版本的 UNIX <code>awk</code> 版本却没有这么处理。
</p>
<p>第三点，则是前面两点的延续。在 <code>BEGIN</code> 与 <code>END</code> 规则中的 <code>print</code> 的含义总是一样的：
&lsquo;<samp>print $0</samp>&rsquo; 。如果 <code>$0</code> 的值是空串，则打印一个空的记录。
很多使用 <code>awk</code> 很长时间的程序员在 <code>BEGIN</code> 与 <code>END</code> 规则中使用这种光头 <code>print</code> 来表示 &lsquo;<samp>print&nbsp;&quot;&quot;</samp>&rsquo;，
这依赖于 <code>$0</code> 的值为空串。通常来说，在 <code>BEGIN</code> 规则中可以实现这样的意图，但是至少在 <code>gawk</code> 中，在 <code>END</code> 规则中这么写是一个坏主意。同时这么写也是一种很蹩脚的风格，因为如果确实需要输出一个空串，你就在显式地进行打印就可以了。
</p>
<a name="index-next-statement_002c-BEGIN_002fEND-patterns-and"></a>
<a name="index-nextfile-statement_002c-BEGIN_002fEND-patterns-and"></a>
<a name="index-BEGIN-pattern_002c-next_002fnextfile-statements-and"></a>
<a name="index-END-pattern_002c-next_002fnextfile-statements-and"></a>
<p>最后，<code>next</code> 与 <code>nextfile</code> 语句在 <code>BEGIN</code> 规则中是不允许使用的，
因为隐式的 read-a-record-and-match-against-the-rules 循环都还没有开始呢。
相似的，这样的语句在 <code>END</code> 规则中也是无效的，因为输入已经完成。（查看 <a href="#Next-Statement"><code>next</code> 语句</a> ，与
 <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>。）
</p>
<hr>
<a name="BEGINFILE_002fENDFILE"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#I_002fO-And-BEGIN_002fEND" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Overview" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Empty" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="BEGINFILE-a_00b8_008e-ENDFILE-c_0089_00b9ae_00ae_008aae_00a8_00a1aa_00bc_008f"></a>
<h3 class="subsection">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</h3>
<a name="index-BEGINFILE-pattern"></a>
<a name="index-ENDFILE-pattern"></a>
<a name="index-differences-in-awk-and-gawk_002c-BEGINFILE_002fENDFILE-patterns"></a>

<p>本小节中描述的是 <code>gawk</code> 的特性。
</p>
<p>有两种特殊的规则，即 <code>BEGINFILE</code> 与 <code>ENDFILE</code>，可以让你在命令行指定的文件处理过程中打入“勾子”。
与 <code>BEGIN</code> 跟 <code>END</code> 类似
（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>），
程序中的所有的 <code>BEGINFILE</code> 规则都会安按照 <code>gawk</code> 读取的顺序合并起来，而所有 <code>ENDFILE</code> 规则也会被合并。
</p>
<p><code>BEGINFILE</code> 规则的执行体会在 <code>gawk</code> 读取文件的第一个记录前执行。<code>FILENAME</code> 将被设置成当前文件的名字，<code>FNR</code> 会被设置成 0。
</p>
<p><code>BEGINFILE</code> 为你提供了完成两个任务的一个机会，这些任务如果没有这个机制是不可能实现的：
</p>
<ul>
<li>
你可以测试文件是否可读。正常情况下，如果命令行上指定的文件无法打开读取是一个致使错误。但是，你可以绕过这样的致使错误，并移动到命令行中的下一个文件。

<a name="index-gawk_002c-ERRNO-variable-in-2"></a>
<a name="index-ERRNO-variable_002c-with-BEGINFILE-pattern"></a>
<a name="index-nextfile-statement_002c-BEGINFILE_002fENDFILE-patterns-and"></a>
<p>你可以检查 <code>ERRNO</code> 的值不是一个空值，如果非空，就表示 <code>gawk</code> 没办法打开一个文件。
此时，你的程序可以执行 <code>nextfile</code> 语句（查看 <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>）。
这使得 <code>gawk</code> 可以完整地跳过这个文件。否则，<code>gawk</code> 遇到致命错误时会退出。
</p>
</li><li>
如果你编写了修改记录处理方式的扩展（通过插入一个“输入分析器”，查看 <a href="#Input-Parsers">定制输入分析器</a>），
你就可以在这个点上，在处理文件之前调用它们。（这是一个<em>非常</em>高级的特性，当前只被 <a href="http://sourceforge.net/projects/gawkextlib"><code>gawkextlib</code> 项目</a> 使用。）
</li></ul>

<p><code>ENDFILE</code> 规则会在 <code>gawk</code> 处理完一个文件的输入后执行。对于最后一个输入文件，它将会在调用 <code>END</code> 之前进行调用。
<code>ENDFILE</code> 就算是针对空文件也会执行。
</p>
<p>正常的情况下，当错误出现在正常的输入处理循环中的读取时，错误就会是致命的，
如果提供了 <code>ENDFILE</code> 规则，这样的错误就不再是致命的，只是 <code>ERRNO</code> 被设置而已。这使得能够在 <code>awk</code> 程序一级捕获到处理 I/O 的错误。
</p>
<a name="index-next-statement_002c-BEGINFILE_002fENDFILE-patterns-and"></a>
<p><code>next</code> 语句（查看 <a href="#Next-Statement"><code>next</code> 语句</a>）不准使用在 <code>BEGINFILE</code> 或者 <code>ENDFILE</code> 规则中。
而 <code>nextfile</code> 只可以使用在 <code>BEGINFILE</code> 规则中，而不能使用在 <code>ENDFILE</code> 规则中。
</p>
<a name="index-getline-statement_002c-BEGINFILE_002fENDFILE-patterns-and"></a>
<p><code>getline</code> 语句（查看 <a href="#Getline">用 <code>getline</code> 输入数据</a>）在 <code>BEGINFILE</code> 和 <code>ENDFILE</code> 两个规则中都被限制使用：只有重定向形式的 <code>getline</code> 可以在其中使用。
</p>
<p><code>BEGINFILE</code> 与 <code>ENDFILE</code> 是 <code>gawk</code> 的扩展。在多数的 <code>awk</code> 实现中，或者 <code>gawk</code> 的兼容模式下（查看 <a href="#Options">命令行参数</a>），它们没有特殊含义。
</p>

<hr>
<a name="Empty"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#BEGINFILE_002fENDFILE" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Overview" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Using-Shell-Variables" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00a9_00baae_00a8_00a1aa_00bc_008f"></a>
<h3 class="subsection">7.1.6 空模式</h3>

<a name="index-empty-pattern"></a>
<a name="index-patterns_002c-empty"></a>
<p>一个空模式（如不存在模式）被视为匹配<em>所有的</em>输入记录。例如，下面的程序：
</p>
<div class="example">
<pre class="example">awk '{ print $1 }' mail-list
</pre></div>

<p>打印每一个记录的第一个域。
</p>
<hr>
<a name="Using-Shell-Variables"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Empty" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Action-Overview" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8c_00a8_008baa_00ba_008fa_00b8_00ada_00bd_00bfc_0094_00a8-Shell-aa_008f_0098e_0087_008f"></a>
<h2 class="section">7.2 在程序中使用 Shell 变量</h2>
<a name="index-shells_002c-variables"></a>
<a name="index-awk-programs_002c-shell-variables-in"></a>

<p><code>awk</code> 程序常用于一个用 Shell 写成的大程序中的一个组件。例如，使用一个 Shell 变量来存放 <code>awk</code> 程序要搜索的模式。有两个方式来取得 Shell 变量的值，并插入到 <code>awk</code> 程序中。
</p>
<a name="index-shells_002c-quoting"></a>
<p>一种通用的方式是使用 Shell 引号来在脚本中替代变量的值，由此来插入到程序中。例如，下面的程序：
</p>
<div class="example">
<pre class="example">printf &quot;Enter search pattern: &quot;
read pattern
awk &quot;/$pattern/ &quot;'{ nmatches++ }
     END { print nmatches, &quot;found&quot; }' /path/to/data
</pre></div>

<p><code>awk</code> 程序将引号文本的片段视作为连接操作来形成程序。第一部分就被双引号引起来，这允许使用 Shell 变量 <code>pattern</code> 作为替代。
第二部分是单引号的部分。
</p>
<p>通过引号方式的变量替换虽然可以工作，但是有可能导致潜在的混乱。这需要对 Shell 的引号规则有比较好的理解（查看 <a href="#Quoting">Shell 引号问题</a>），
并且当读取程序，匹配引号的时候会比较麻烦。
</p>
<p>更好的方法是使用 <code>awk</code> 的变量赋值特性（查看 <a href="#Assignment-Options">在命令行中进行变量赋值</a>）来将 Shell 变量的值赋给 <code>awk</code> 变量。
然后使用动态正则表达式来匹配模式（查看 <a href="#Computed-Regexps">使用动态正则表达式</a>）。下面的代码显示使用这个技巧来重写上面的功能：
</p>
<div class="example">
<pre class="example">printf &quot;Enter search pattern: &quot;
read pattern
awk -v pat=&quot;$pattern&quot; '$0 ~ pat { nmatches++ }
       END { print nmatches, &quot;found&quot; }' /path/to/data
</pre></div>

<p>现在，<code>awk</code> 程序只需要单引号的串。赋值操作 &lsquo;<samp>-v pat=&quot;$pattern&quot;</samp>&rsquo; 还是需要双引号的，以防止在 <code>$pattern</code> 的值中出现空格。
<code>awk</code> 变量 <code>pat</code> 也可以使用名字 <code>pattern</code>，
但是看起来就令人比较困惑得多。使用变量的方式也提供了更多的灵活性，因为变量可以在程序中的任何地方使用——用于打印、作为数组下标，或者其他的用途——并且不需要在使用的地方使用双引号。
</p>
<hr>
<a name="Action-Overview"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Using-Shell-Variables" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008a_00a8a_00bd_009c"></a>
<h2 class="section">7.3 动作</h2>
<a name="index-actions"></a>

<p><code>awk</code> 程序或者脚本由一连串的规则与函数定义交叉形成。（函数会在后面论及。查看 <a href="#User_002ddefined">用户自定义函数</a>）规则中包含了模式与动作，两者之一可以省略，但不可以都省略。
<em>动作</em>的目的是告知 <code>awk</code> 在某个模式被找到后如何执行。因此，概括起来，<code>awk</code> 程序看起来都像这样：
</p>
<div class="display">
<pre class="display">[<var>pattern</var>]  <code>{ <var>action</var> }</code>
 <var>pattern</var>  [<code>{ <var>action</var> }</code>]
&hellip;
<code>function <var>name</var>(<var>args</var>) { &hellip; }</code>
&hellip;
</pre></div>

<a name="index-_007b_007d-_0028braces_0029_002c-actions-and"></a>
<a name="index-braces-_0028_007b_007d_0029_002c-actions-and"></a>
<a name="index-separators_002c-for-statements-in-actions"></a>
<a name="index-newlines_002c-separating-statements-in-actions"></a>
<a name="index-_003b-_0028semicolon_0029_002c-separating-statements-in-actions-1"></a>
<a name="index-semicolon-_0028_003b_0029_002c-separating-statements-in-actions-1"></a>
<p>动作由一个或者多个 <code>awk</code> <em>语句</em>组成，并且由花括号包起来（&lsquo;<samp>{<span class="roman">&hellip;</span>}</samp>&rsquo;）。
每条语句都指定了一个要处理的过程。语句由换行符或者分号分隔。
动作两边的花括号是必须使用的，就算只有一个语句，甚至没有语句也一样。但是，如果你整个地省略了动作，也要省略花括号。
省略动作与 &lsquo;<samp>{ print $0 }</samp>&rsquo; 等同。
</p>
<div class="example">
<pre class="example">/foo/  { }     <i>match <code>foo</code>, do nothing --- empty action</i>
/foo/          <i>match <code>foo</code>, print the record --- omitted action</i>
</pre></div>

<p><code>awk</code> 支持下面的语句类型：
</p>
<dl compact="compact">
<dd><a name="index-side-effects_002c-statements"></a>
</dd>
<dt>表达式</dt>
<dd><p>调用函数或者赋值给变量（查看 <a href="#Expressions">表达式</a>）。
这类型语句的执行就是简单地求值。如果表达式有副作用，这就非常有用（查看 <a href="#Assignment-Ops">赋值表达式</a>）。
</p>
</dd>
<dt>控制语句</dt>
<dd><p>指定 <code>awk</code> 程序的控制流。<code>awk</code> 语言可以让你写 C 风格的结构（<code>if</code>，<code>for</code>，<code>while</code>，以及 <code>do</code>），
也有一些自己特殊的结构（查看 <a href="#Statements">动作中的控制语句</a>）。
</p>
</dd>
<dt>复合语句</dt>
<dd><p>包括在花括号中一个或者多个语句。复合语句用于在 <code>if</code>，<code>while</code>，<code>do</code>，或者 <code>for</code> 的语句体中，将几个语句顺序地放在一起。
</p>
</dd>
<dt>输入语句</dt>
<dd><p>使用 <code>getline</code> 命令（查看 <a href="#Getline">用 <code>getline</code> 输入数据</a>）。
在 <code>awk</code> 中也提供 <code>next</code> 语句（查看 <a href="#Next-Statement"><code>next</code> 语句</a>）与 <code>nextfile</code> 语句（查看 <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>）。
</p>
</dd>
<dt>输出语句</dt>
<dd><p>如 <code>print</code> 与 <code>printf</code>，查看 <a href="#Printing">打印输出</a>。
</p>
</dd>
<dt>删除语句</dt>
<dd><p>用于删除数组元素。查看 <a href="#Delete"><code>delete</code> 语句</a>。
</p></dd>
</dl>

<hr>
<a name="Statements"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Action-Overview" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#If-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008a_00a8a_00bd_009ca_00b8_00adc_009a_0084ae_008e_00a7aa_0088_00b6e_00af_00adaa_008f_00a5"></a>
<h2 class="section">7.4 动作中的控制语句</h2>
<a name="index-control-statements"></a>
<a name="index-statements_002c-control_002c-in-actions"></a>
<a name="index-actions_002c-control-statements-in"></a>

<p>如 <code>if</code>，<code>while</code> 等等的<em>控制语句</em>，用来控制 <code>awk</code> 程序的执行流。大多数的 <code>awk</code> 控制语句都是使用与 C 类似的模式。
</p>
<a name="index-compound-statements_002c-control-statements-and"></a>
<a name="index-statements_002c-compound_002c-control-statements-and"></a>
<a name="index-body_002c-in-actions"></a>
<a name="index-_007b_007d-_0028braces_0029_002c-statements_002c-grouping"></a>
<a name="index-braces-_0028_007b_007d_0029_002c-statements_002c-grouping"></a>
<a name="index-newlines_002c-separating-statements-in-actions-1"></a>
<a name="index-_003b-_0028semicolon_0029_002c-separating-statements-in-actions-2"></a>
<a name="index-semicolon-_0028_003b_0029_002c-separating-statements-in-actions-2"></a>
<p>所有的控制语句都以一个特殊关键词开始，如 <code>if</code> 与 <code>while</code> 等，以将它们与一般的表达式进行区分。很多的控制语句还包含其他的语句。
例如，<code>if</code> 语句包含其他的语句，可能执行也可能不执行。
被包含的语句称为相应语句的<em>语句体</em>。为了在语句体中包含多于一个语句，则将他们包含在一个有花括号的<em>复合语句</em>中，
将通过换行或者分号来分隔它们。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#If-Statement">7.4.1 <code>if</code>-<code>else</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Conditionally execute some <code>awk</code>
                                statements.
</td></tr>
<tr><td align="left" valign="top"><a href="#While-Statement">7.4.2 <code>while</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Loop until some condition is satisfied.
</td></tr>
<tr><td align="left" valign="top"><a href="#Do-Statement">7.4.3 <code>do</code>-<code>while</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Do specified action while looping until some
                                condition is satisfied.
</td></tr>
<tr><td align="left" valign="top"><a href="#For-Statement">7.4.4 <code>for</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Another looping statement, that provides
                                initialization and increment clauses.
</td></tr>
<tr><td align="left" valign="top"><a href="#Switch-Statement">7.4.5 <code>switch</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Switch/case evaluation for conditional
                                execution of statements based on a value.
</td></tr>
<tr><td align="left" valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Immediately exit the innermost enclosing loop.
</td></tr>
<tr><td align="left" valign="top"><a href="#Continue-Statement">7.4.7 <code>continue</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Skip to the end of the innermost enclosing
                                loop.
</td></tr>
<tr><td align="left" valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Stop processing the current input record.
</td></tr>
<tr><td align="left" valign="top"><a href="#Nextfile-Statement">7.4.9 <code>nextfile</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Stop processing the current file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Exit-Statement">7.4.10 <code>exit</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Stop execution of <code>awk</code>.
</td></tr>
</table>

<hr>
<a name="If-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#While-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="if_002delse-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.1 <code>if</code>-<code>else</code> 语句</h3>

<a name="index-if-statement"></a>
<p><code>if</code>-<code>else</code> 语句是 <code>awk</code> 的“决策-执行”语句，看起来如下：
</p>
<div class="display">
<pre class="display"><code>if (<var>condition</var>) <var>then-body</var></code> [<code>else <var>else-body</var></code>]
</pre></div>

<p><var>condition</var> 是一个表达式，用来控制后面的语句的执行。如果 <var>condition</var> 为 true，则执行 <var>then-body</var> 的部分，
否则执行 <var>else-body</var> 的部分。
这个语句的 <code>else</code> 部分是可选的。<var>condition</var> 的值如果为 0 或者为空串，则被认为是 false，其他情况则为 true。参考如下：
</p>
<div class="example">
<pre class="example">if (x % 2 == 0)
    print &quot;x is even&quot;
else
    print &quot;x is odd&quot;
</pre></div>

<p>在这个例子中，如果表达式 &lsquo;<samp>x % 2 == 0</samp>&rsquo; 为真（比如，x 的值是偶数，可被 2 整除），则第一个 <code>print</code> 语句被执行，
否则，就执行第二个 <code>print</code> 语句。如果 <code>else</code> 关键词与 <var>then-body</var> 出现在一行中，
并且 <var>then-body</var> 不是一个复合语句（没有被花括号包含），则必须要用分号将 <var>then-body</var> 的部分与 <code>else</code> 部分进行分隔。
如，上面的例子代码可以写在这样：
</p>
<div class="example">
<pre class="example">if (x % 2 == 0) print &quot;x is even&quot;; else
        print &quot;x is odd&quot;
</pre></div>

<p>如果没有 &lsquo;<samp>;</samp>&rsquo;，则 <code>awk</code> 无法解释上面的语句，因此会生成一个语法错误。在实际的程序中不要这么写，
因为程序的人类阅读者有可能不会看到 <code>else</code>，因为它没出现在它自己所应在行的第一位置。
</p>
<hr>
<a name="While-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#If-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Do-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="while-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.2 <code>while</code> 语句</h3>
<a name="index-while-statement"></a>
<a name="index-loops"></a>
<a name="index-loops_002c-while"></a>
<a name="index-loops_002c-See-Also-while-statement"></a>

<p>在程序中，循环是程序的一部份，并且可被连续两次或者多次地执行。
<code>while</code> 语句是 <code>awk</code> 中最简单的循环语句。只要条件为 true，就会一直重复执行。例如：
</p>
<div class="example">
<pre class="example">while (<var>condition</var>)
  <var>body</var>
</pre></div>

<a name="index-body_002c-in-loops"></a>
<p><var>body</var> 语句称为<em>循环体</em>，而 <var>condition</var> 是一个表达式，用来控制循环的执行。
<code>while</code> 语句所做的第一件事情就是测试 <var>condition</var> 的值。
如果为 true，则执行语句 <var>body</var>。
完成后，<var>condition</var> 会被再次测试，如果依然为 true，则 <var>body</var> 会再次被执行。这个过程一直持续到 <var>condition</var> 不再为 true。
如果 <var>condition</var> 一开始就为 false，而循环体就根本不会执行，<code>awk</code> 会继续执行循环后的语句。
下面的例子打印每个记录的头三个域，一个一行：
</p>
<div class="example">
<pre class="example">awk '
{
    i = 1
    while (i &lt;= 3) {
        print $i
        i++
    }
}' inventory-shipped
</pre></div>

<p>这个循环的循环休是一个包含在花括号中的复合语句，包含两个语句。循环按下面的方式执行：首先，<code>i</code> 的值被设置为 1。
然后 <code>while</code> 语句会测试 <code>i</code> 的值是否为小于等于 3。当 <code>i</code> 为 1 时，这肯定为 true，因此第 <code>i</code> 个域就打印出来。
然后执行 &lsquo;<samp>i++</samp>&rsquo; ，递增 <code>i</code> 的值，并重复循环。当 <code>i</code> 为 4 时，结束循环。
</p>
<p>在条件与循环体之间的换行不是必须的，但是，使用换行会使得程序更加清晰，除非循环体是一个复合语句或者是非常简单。开花括号后面的换行开启复合语句，也不是必须的，但是程序不这么处理就比较难阅读。
</p>
<hr>
<a name="Do-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#While-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#For-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="do_002dwhile-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.3 <code>do</code>-<code>while</code> 语句</h3>
<a name="index-do_002dwhile-statement"></a>
<a name="index-loops_002c-do_002dwhile"></a>

<p><code>do</code> 循环是 <code>while</code> 循环的变体。
<code>do</code> 循环中先会执行 <var>body</var> 一次，如果条件为 true，则会重复执行 <var>body</var>。它看起来如下：
</p>
<div class="example">
<pre class="example">do
  <var>body</var>
while (<var>condition</var>)
</pre></div>

<p>就算是 <var>condition</var> 一开始为 false，<var>body</var> 也会至少执行一次（并且只执行一次，除非 <var>body</var> 内将 <var>condition</var> 变成 true）。
与 <code>while</code> 语句比较起来：
</p>
<div class="example">
<pre class="example">while (<var>condition</var>)
    <var>body</var>
</pre></div>

<p>这个语句中，如果 <var>condition</var> 一开始为 false，则 <var>body</var> 一次也不会被执行。下面是 <code>do</code> 语句的一个例子：
</p>
<div class="example">
<pre class="example">{
    i = 1
    do {
        print $0
        i++
    } while (i &lt;= 10)
}
</pre></div>

<p>这个程序打印记录 10 次。但是，这并不是一个非常理想的例子，因此在这种情况下，
普通的 <code>while</code> 循环就可以完成了。这个反映了一种实际使用经验：只有很少的情况下，才需要真正使用 <code>do</code> 语句。
</p>
<hr>
<a name="For-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Do-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Switch-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="for-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.4 <code>for</code> 语句</h3>
<a name="index-for-statement"></a>
<a name="index-loops_002c-for_002c-iterative"></a>

<p><code>for</code> 语句可以更方便地统计循环的迭代次数。<code>for</code> 语句的一般格式如下：
</p>
<div class="example">
<pre class="example">for (<var>initialization</var>; <var>condition</var>; <var>increment</var>)
  <var>body</var>
</pre></div>

<p><var>initialization</var>，<var>condition</var> 与 <var>increment</var> 的部分可以是任意的 <code>awk</code> 表达式，而 <var>body</var> 表示任意的 <code>awk</code> 语句。
</p>
<p><code>for</code> 语句以执行 <var>initialization</var> 开始，然后，只要 <var>condition</var> 为 true，则会重复执行 <var>body</var> 与 <var>increment</var>。
典型的情况下，<var>initialization</var> 将某个变量设置成 0 或者 1，<var>increment</var> 将其增加 1，然后 <var>condition</var> 将其与所要迭代的次数进行比较。例如：
</p>
<div class="example">
<pre class="example">awk '
{
    for (i = 1; i &lt;= 3; i++)
        print $i
}' inventory-shipped
</pre></div>

<p>这个例子中，会打印每个记录的前三个域，每行打印一个域。
</p>
<p>在 <var>initialization</var> 部分，如果不使用多个赋值语句，如 &lsquo;<samp>x = y = 0</samp>&rsquo;，不可能设置多于一个变量的值。这只有在所有的初始值都是一样的才有意义。（但是不可能在 <code>for</code> 循环前，用几个赋值语句来初始化其他变量的值。）
</p>
<p>在 <var>increment</var> 部分也是一样。对其他的变量的递增，需要在循环结束时用独立的语句来进行递增。C 类型的复合表达式，使用 C 的逗号操作符，在这样的上下文中很有用，但是在 <code>awk</code> 中不被支持。
</p>
<p>在多数情况下，<var>increment</var> 是一个递增表达式，就如前面的例子中的一样。但是却并不是必须的，它也可以是任意的表达式。例如，下面的语句打印 1 到 100 之间的 2 次幂的值：
</p>
<div class="example">
<pre class="example">for (i = 1; i &lt;= 100; i *= 2)
    print i
</pre></div>

<p>如果在 <code>for</code> 后面括号中的表达式什么也不需要做，则可以省略它们。如 &lsquo;<samp>for&nbsp;(;&nbsp;x&nbsp;&gt;&nbsp;0;)</samp>&rsquo; 与 &lsquo;<samp>while&nbsp;(x&nbsp;&gt;&nbsp;0)</samp>&rsquo; 是等同的。
如果 <var>condition</var> 被省略了，则其将被视作 true，这样可以有效地产生一个<em>无限循环</em>（不会终止的循环）。
</p>
<p>在多数情况下，<code>for</code> 循环是 <code>while</code> 循环的一个简写方式，如下面所示：
</p>
<div class="example">
<pre class="example"><var>initialization</var>
while (<var>condition</var>) {
  <var>body</var>
  <var>increment</var>
}
</pre></div>

<a name="index-loops_002c-continue-statements-and"></a>
<p>唯一的例外是在循环中使用 <code>continue</code> 语句时（查看 <a href="#Continue-Statement"><code>continue</code> 语句</a>）。
将 <code>for</code> 循环改为 <code>while</code> 循环，也能够改变循环内的 <code>continue</code> 语句的结果。
</p>
<p><code>awk</code> 语言除了 <code>while</code> 还要加上一个 <code>for</code> 循环，主要是因为 <code>for</code> 循环通常有更少的敲击输入，同时也是一种很自然的过程。统计迭代次数在循环中是一种很普遍的事情。将这种统计作为循环的一部份要比在循环内部来做这些事情要更容易。
</p>
<a name="index-in-operator-2"></a>
<p>这是另一种版本的 <code>for</code> 循环，<code>for</code> 迭代数组的所有下标：
</p>
<div class="example">
<pre class="example">for (i in array)
    <var>do something with</var> array[i]
</pre></div>

<p>查看 <a href="#Scanning-an-Array">遍历数组元素</a>，来获取更多的关于 <code>for</code> 循环的信息。
</p>
<hr>
<a name="Switch-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#For-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Break-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="switch-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.5 <code>switch</code> 语句</h3>
<a name="index-switch-statement"></a>
<a name="index-case-keyword"></a>
<a name="index-default-keyword"></a>

<p>本小节描述的是一个 <code>gawk</code> 专有的特性。如果 <code>gawk</code> 是在兼容模式下（查看 <a href="#Options">命令行参数</a>），则这个特性就不可用。
</p>
<p><code>switch</code> 语句允许对表达式求值，并针对匹配的值来执行不同的语句。
<code>case</code> 语句用来顺序地检查所定义的匹配。如果没有合适的 <code>case</code>，如果提供了 <code>default</code> 段，则 <code>default</code> 段会被执行。
</p>
<p>每个 <code>case</code> 中包含一个常量，可以是数值，字串或者正则表达式。<code>switch</code> 表达式被求值后，会按顺序对 <code>case</code> 中的学常量进行比较。
常量的类型决定了比较的类型：数值的，还是字串的。一个正则表达式常量执行的是针对初始表达式的值的正则表达式匹配。一般地，<code>switch</code> 语句看起来如下：
</p>
<div class="example">
<pre class="example">switch (<var>expression</var>) {
case <var>value or regular expression</var>:
    <var>case-body</var>
default:
    <var>default-body</var>
}
</pre></div>

<p><code>switch</code> 的控制流与 C 中的执行一致。只要与给定的 <code>case</code> 匹配了，<code>case</code> 语句体中的语句就会被执行，直到遇到 <code>break</code>，<code>continue</code>，<code>next</code>，<code>nextfile</code>，或者是 <code>exit</code>，或者是 <code>switch</code> 语句本身的结束。
</p>
<div class="example">
<pre class="example">while ((c = getopt(ARGC, ARGV, &quot;aksx&quot;)) != -1) {
    switch (c) {
    case &quot;a&quot;:
        # report size of all files
        all_files = TRUE;
        break
    case &quot;k&quot;:
        BLOCK_SIZE = 1024       # 1K block size
        break
    case &quot;s&quot;:
        # do sums only
        sum_only = TRUE
        break
    case &quot;x&quot;:
        # don't cross filesystems
        fts_flags = or(fts_flags, FTS_XDEV)
        break
    case &quot;?&quot;:
    default:
        usage()
        break
    }
}
</pre></div>

<p>要注意的是，如果这里没有指定任何语句，则会停止执行匹配的 <code>case</code> 语句，则执行流程会落入下一个 <code>case</code> 中，直到执行中止。
在这个例子中，<code>&quot;?&quot;</code> 的 <code>case</code> 中，会落入到 <code>default</code> <code>case</code> 中执行，并在其中调用 <code>usage()</code> 函数。
其中所调用的 <code>getopt()</code> 函数在 <a href="#Getopt-Function">处理命令行选项</a> 描述。）
</p>
<hr>
<a name="Break-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Switch-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Continue-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="break-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.6 <code>break</code> 语句</h3>
<a name="index-break-statement"></a>
<a name="index-loops_002c-exiting"></a>
<a name="index-loops_002c-break-statement-and"></a>

<p><code>break</code> 语句跳出最包含该语句的最内层的 <code>for</code>，<code>while</code>，<code>do</code> 循环。下面的例子查找任意整数的最小因数，并判断是否为质数：
</p>
<div class="example">
<pre class="example"># find smallest divisor of num
{
    num = $1
    for (divisor = 2; divisor * divisor &lt;= num; divisor++) {
        if (num % divisor == 0)
            break
    }
    if (num % divisor == 0)
        printf &quot;Smallest divisor of %d is %d\n&quot;, num, divisor
    else
        printf &quot;%d is prime\n&quot;, num
}
</pre></div>

<p>当第一个 <code>if</code> 语句中的余数是 0 时，<code>awk</code> 就直接跳出循环。这表示 <code>awk</code> 会执行直接跟在循环后面的语句。
（这与 <code>exit</code> 非常不同，<code>exit</code> 会停止整个 <code>awk</code> 程序，查看 <a href="#Exit-Statement"><code>exit</code> 语句</a>。）
</p>
<p>下面的程序解释了在 <code>for</code> 或者 <code>while</code> 循环语句中的 <var>condition</var>，如何用 <code>if</code> 中的 <code>break</code> 来代替：
</p>
<div class="example">
<pre class="example"># find smallest divisor of num
{
    num = $1
    for (divisor = 2; ; divisor++) {
        if (num % divisor == 0) {
            printf &quot;Smallest divisor of %d is %d\n&quot;, num, divisor
            break
        }
        if (divisor * divisor &gt; num) {
            printf &quot;%d is prime\n&quot;, num
            break
        }
    }
}
</pre></div>

<p><code>break</code> 语句也用来中断 <code>switch</code> 中的语句。这在 <a href="#Switch-Statement"><code>switch</code> 语句</a>，进行了描述。
</p>
<a name="index-POSIX-awk_002c-break-statement-and"></a>
<a name="index-dark-corner_002c-break-statement"></a>
<a name="index-gawk_002c-break-statement-in"></a>
<a name="index-Brian-Kernighan_0027s-awk-7"></a>
<p>在循环体或者 <code>switch</code> 外面使用 <code>break</code> 没有意义。但是，虽然没有在文档中记录下来，<code>awk</code> 的历史版本中将循环外的 <code>break</code> 语句，当成是一个 <code>next</code> 语句（查看 <a href="#Next-Statement"><code>next</code> 语句</a>）。
(d.c.)
近来的 BWK <code>awk</code> 版本不再允许这样的用法，<code>gawk</code> 也不允许。
</p>
<hr>
<a name="Continue-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Break-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Next-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="continue-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.7 <code>continue</code> 语句</h3>

<a name="index-continue-statement"></a>
<p>与 <code>break</code> 类型，<code>continue</code> 语句只要 <code>for</code>，<code>while</code>，以及 <code>do</code> 循环中使用，它路过循环体后面的部分，使得下一个循环立即开始。
与 <code>break</code> 相比，它只是跳出循环。
</p>
<p><code>for</code> 循环中的 <code>continue</code> 语句，引导 <code>awk</code> 路过循环体后面的部分，并执行 <code>for</code> 语句中的递增表达式（increment-expression）。
下面的程序解释了这样的情形：
</p>
<div class="example">
<pre class="example">BEGIN {
     for (x = 0; x &lt;= 20; x++) {
         if (x == 5)
             continue
         printf &quot;%d &quot;, x
     }
     print &quot;&quot;
}
</pre></div>

<p>这个程序打印 0 到 20 之间的数，除了 5 外，因为在这个数值时 <code>printf</code> 被跳过了。因为 &lsquo;<samp>x++</samp>&rsquo; 并没有被跳过，因此，x 的值不会卡在 5 上。
下面的 <code>while</code> 循环与前面的 <code>for</code> 循环相比：
</p>
<div class="example">
<pre class="example">BEGIN {
     x = 0
     while (x &lt;= 20) {
         if (x == 5)
             continue
         printf &quot;%d &quot;, x
         x++
     }
     print &quot;&quot;
}
</pre></div>

<p>这个程序中，只要 x 达到 5 就会成为一个死循环，因为递增语句（&lsquo;<samp>x++</samp>&rsquo;）永远不会执行。
</p>
<a name="index-POSIX-awk_002c-continue-statement-and"></a>
<a name="index-dark-corner_002c-continue-statement"></a>
<a name="index-gawk_002c-continue-statement-in"></a>
<a name="index-Brian-Kernighan_0027s-awk-8"></a>
<p>与 <code>switch</code> 语句对应，<code>continue</code> 语句并没有特别的含义，在循环体之外也没有什么特别的含义。
<code>awk</code> 的历史版本将循环体之外的 <code>continue</code> 与循环体之外的的 <code>break</code> 一样对待：就像它是一个 <code>next</code> 语句一样
（查看 <a href="#Next-Statement"><code>next</code> 语句</a>）。
(d.c.)
BWK <code>awk</code> 的后面的版本不再这么处理，<code>gawk</code> 也不这么做。
</p>
<hr>
<a name="Next-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Continue-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Nextfile-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="next-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.8 <code>next</code> 语句</h3>
<a name="index-next-statement-1"></a>

<p><code>next</code> 语句强制 <code>awk</code> 立即停止当前记录的处理并处理下一条记录。
这表示针对当前的记录不再进一步进行规则的匹配，当前规则的余下部分也不被执行。
</p>
<p>与 <code>getline</code> 函数（查看 <a href="#Getline">用 <code>getline</code> 输入数据</a>）进行对比。<code>getline</code> 也会导致 <code>awk</code> 立即读取下一条记录，
但是并没有改变控制流（即，当前的动作会在新的记录上执行）。
</p>
<a name="index-awk-programs_002c-execution-of"></a>
<p>在最高级上，<code>awk</code> 程序是这样的一个循环，即读取一条记录，然后与每一个模式进行匹配。
如果你把这样的一个循环看成是一个 <code>for</code> 语句，其循环体包含了这些规则，然后，<code>next</code> 语句则与 <code>continue</code> 语句类似。它会跳过这个隐式循环的后面部分，然后执行递增（也就是读取下一条记录）。
</p>
<p>例如，假设一个 <code>awk</code> 程序处理的记录只有 4 个域，并且当输入不规范时不会导致失败。
为了避免后面程序的复杂性，用下面的方式，在开头处这一个这样的“排除”代码：
</p>
<div class="example">
<pre class="example">NF != 4 {
    printf(&quot;%s:%d: skipped: NF != 4\n&quot;, FILENAME, FNR) &gt; &quot;/dev/stderr&quot;
    next
}
</pre></div>

<p>由于有一 <code>next</code> 语句，程序后面的规则就不会再看到那些不规范的记录。错误的信息会被重定向到标准错误输出流上，正如错误信息应该这么被处处理一样。要取得更多的信息，请查看 <a href="#Special-Files"><code>gawk</code> 中的特殊文件名</a>。
</p>
<p>如果 <code>next</code> 语句导致了输入文件的结束，则在 <code>END</code> 规则里的代码就会被执行，查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>。
</p>
<p><code>next</code> 语句不可以使用在 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 规则中，查看 <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>。
</p>
<a name="index-BEGIN-pattern_002c-next_002fnextfile-statements-and-1"></a>
<a name="index-END-pattern_002c-next_002fnextfile-statements-and-1"></a>
<a name="index-POSIX-awk_002c-next_002fnextfile-statements-and"></a>
<a name="index-next-statement_002c-user_002ddefined-functions-and"></a>
<a name="index-functions_002c-user_002ddefined_002c-next_002fnextfile-statements-and"></a>
<p>根据 POSIX 标准，如果 <code>next</code> 语句用在 <code>BEGIN</code> 与 <code>END</code> 规则中，其行为是未定义的。
<code>gawk</code> 将其视为语法错误。尽管 POSIX 没有禁止，但大多数的 <code>awk</code> 实现不准在函数体内
（查看 <a href="#User_002ddefined">用户自定义函数</a>）使用 <code>next</code> 语句。与共他的处的 <code>next</code> 语句一样，
在函数内的 <code>next</code> 语句也是读取下一条记录然后从程序的第一个规则开始处理。
</p>
<hr>
<a name="Nextfile-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Next-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Exit-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="nextfile-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.9 <code>nextfile</code> 语句</h3>
<a name="index-nextfile-statement"></a>

<p><code>nextfile</code> 与 <code>next</code> 语句类似。但是不是放弃处理当前记录，<code>nextfile</code> 则是通知 <code>awk</code> 停止处理当前的数据文件。
</p>
<p>随着 <code>nextfile</code> 的执行，<code>FILENAME</code> 也会更新以反映命令行列表中的下一个数据文件。
<code>FNR</code> 则被重置为 0，处理流程回到程序中的第一个规则中。
如果 <code>nextfile</code> 语句导致了输入的结束，则在 <code>END</code> 规则中的代码就会被执行。一个例外就是这个 <code>nextfile</code> 是在执行 <code>END</code> 规则中被调用的，在这种情况下，会导致程序退出。
查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>。
</p>
<p>当有很多的数据文件要处理，但是不需要处理每个文件中的每个记录的情况下，<code>nextfile</code> 语句非常有用。
如果没有 <code>nextfile</code>，为了要处理下一个数据文件，程序就得断续输入那些不需要的记录。<code>nextfile</code> 语句以一种更为高效的方式来完成这样的目标。
</p>
<p>在 <code>gawk</code> 中，<code>nextfile</code> 的执行会导致一些其他的事情发生：如果 <code>gawk</code> 当前没有执行 <code>END</code> 或者 <code>ENDFILE</code> 规则，
则会导致所有 <code>ENDFILE</code> 被执行，<code>ARGIND</code> 会被递增，所有的 <code>BEGINFILE</code> 会被执行。（<code>ARGIND</code> 还没有介绍。
查看 <a href="#Built_002din-Variables">预定义变量</a>。）
</p>
<p>对于 <code>gawk</code>，在 <code>BEGINFILE</code> 规则中跳过一个会导致 <code>gawk</code> 因为致命错误而退出的文件也非常有用。
在这种情况下，<code>ENDFILE</code> 不会被执行。查看 <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>。
</p>
<p>尽管有可能看到用 &lsquo;<samp>close(FILENAME)</samp>&rsquo; 来完成如 <code>nextfile</code> 一样的功能，但是事实却不是这样的。
<code>close()</code> 保留用来关闭打开用于重定向的文件、管道以及并程。它与主过程没有关系，它们不处理 <code>awk</code> 的 <code>ARGV</code> 中的文件。
</p>
<blockquote>
<p><b>提示:</b> 许多年了，<code>nextfile</code> 一直是一个扩展。在 2012 年 9 月，它报授受并包含在 POSIX 标准中，查看 <a href="http://austingroupbugs.net/view.php?id=607">Austin Group 的网站</a>。
</p></blockquote>

<a name="index-functions_002c-user_002ddefined_002c-next_002fnextfile-statements-and-1"></a>
<a name="index-nextfile-statement_002c-user_002ddefined-functions-and"></a>
<a name="index-Brian-Kernighan_0027s-awk-9"></a>
<a name="index-mawk-utility-3"></a>
<p>BWK <code>awk</code> 与 <code>mawk</code> 的最新版本也支持 <code>nextfile</code>。但是，它们不允许在函数体
（查看 <a href="#User_002ddefined">用户自定义函数</a>）中使用 <code>nextfile</code> 语句。<code>gawk</code> 则允许。
在函数体内的 <code>nextfile</code> 会读取下一个记录，然后从程序的第一条规则开始处理，这与其他处的 <code>nextfile</code> 语句一样。
</p>
<hr>
<a name="Exit-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Nextfile-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Statements" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din-Variables" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="exit-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">7.4.10 <code>exit</code> 语句</h3>

<a name="index-exit-statement"></a>
<p><code>exit</code> 语句会导致 <code>awk</code> 立即停止执行当前的规则，并停止处理输入，所有剩下的输入都将被忽略。<code>exit</code> 的写法如下：
</p>
<div class="display">
<pre class="display"><code>exit</code> [<var>return code</var>]
</pre></div>

<a name="index-BEGIN-pattern_002c-exit-statement-and"></a>
<a name="index-END-pattern_002c-exit-statement-and"></a>
<p>当在 <code>BEGIN</code> 规则中执行 <code>exit</code> 语句时，程序会立即停止一切处理。也没有输入记录被读取，如果提供了 <code>END</code> 规则，
会作为执行 <code>exit</code> 语句的一部份，而被执行（查看 <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）。如果在 <code>END</code> 规则中使用 <code>exit</code>，会导致程序立即停止。
</p>
<p><code>exit</code> 语句如果不是 <code>BEGIN</code> 或者 <code>END</code> 规则一部份，则会停止任何后续的针对当前记录的自动规则的执行，并不再读取剩下的输入记录，
然后如果有 <code>END</code> 规则，则执行。<code>gawk</code> 也会跳过 <code>ENDFILE</code> 规则，因此不会执行。
</p>
<p>在这样的情况下，如果你不想 <code>END</code> 规则被执行，可以将某个变量的值设置成非零值，然后在 <code>END</code> 规则中的 <code>exit</code> 语句前，
判断这个变量的值。查看 <a href="#Assert-Function">断言</a>，来参考这样的具体例子。
</p>
<a name="index-dark-corner_002c-exit-statement"></a>
<p>如果给 <code>exit</code> 语句提供了参数，它的值将作为 <code>awk</code> 进程的退出状态码。如果没有提供，<code>awk</code> 则会以“成功”的方式退出。
在第一次调用 <code>exit</code> 时提供了参数，而第二次从 <code>END</code> 规则中调用，但是没有提供参数的情况下，<code>awk</code> 会使用之前提供的退出值。
查看 <a href="#Exit-Status"><code>gawk</code> 的退出状态</a>，来取得更多信息。
</p>
<a name="index-programming-conventions_002c-exit-statement"></a>
<p>例如，如果一个错误条件出现，很难或者无法处理。一般的作法是程序会以一个非零状态退出。
<code>awk</code> 程序通过带非零值的 <code>exit</code> 语句来处理，如下面的例子所示：
</p>
<div class="example">
<pre class="example">BEGIN {
    if ((&quot;date&quot; | getline date_now) &lt;= 0) {
        print &quot;Can't get system date&quot; &gt; &quot;/dev/stderr&quot;
        exit 1
    }
    print &quot;current date is&quot;, date_now
    close(&quot;date&quot;)
}
</pre></div>

<blockquote>
<p><b>提示:</b> 为了完全的可移植性，<code>exit</code> 的值应该在 0 于是 126 （含）之间。负值与 127 或者更大的值，在不同的平台之间可能不会产生一致的结果。
</p></blockquote>


<hr>
<a name="Built_002din-Variables"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Exit-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#User_002dmodified" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00a2_0084aa_00ae_009aa_00b9_0089aa_008f_0098e_0087_008f"></a>
<h2 class="section">7.5 预定义变量</h2>
<a name="index-predefined-variables"></a>
<a name="index-variables_002c-predefined"></a>

<p>大多数的 <code>awk</code> 变量是我们自己使用，如果他们没有被赋值，则不会改变，并且如果你不检查它们，对你也没有什么影响。但是，
有一些的 <code>awk</code> 变量有一些特殊的内置含义。<code>awk</code> 会自动检查它们当中的一些值，
因此使你可以告诉 <code>awk</code> 执行一些特定的事情。有一些是被 <code>awk</code> 自动设置的，所以它们为你的程序带来一些 <code>awk</code> 执行时的内部信息。
</p>
<a name="index-gawk_002c-predefined-variables-and"></a>
<p>本小节记录了所有的 <code>gawk</code> 预定义的变量，它们中的大多数也记录在了描述它所应用的场景中的章中。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Built-in variables that you change to control
                                <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Built-in variables where <code>awk</code> gives
                                you information.
</td></tr>
<tr><td align="left" valign="top"><a href="#ARGC-and-ARGV">7.5.3 使用 <code>ARGC</code> 与 <code>ARGV</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Ways to use <code>ARGC</code> and <code>ARGV</code>.
</td></tr>
</table>

<hr>
<a name="User_002dmodified"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din-Variables" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din-Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Auto_002dset" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008e_00a7aa_0088_00b6-awk-c_009a_0084aa_0086_0085c_00bd_00aeaa_008f_0098e_0087_008f"></a>
<h3 class="subsection">7.5.1 控制 <code>awk</code> 的内置变量</h3>
<a name="index-predefined-variables_002c-user_002dmodifiable"></a>
<a name="index-user_002dmodifiable-variables"></a>

<p>下面是按字母顺序列出的变量，你可更改它们的值来控制 <code>awk</code> 所执行的特定事情。
</p>
<p>这些变量如果是 <code>gawk</code> 特有的，则会被标志一个井号（&lsquo;<samp>#</samp>&rsquo;）。
这些变量是 <code>gawk</code> 的扩展。在一些其他的 <code>awk</code> 实现中，或者在 <code>gawk</code> 的兼容模式（查看 <a href="#Options">命令行参数</a>）下，它们没有特殊含义。（如果变量有什么例外，则会在变量的说明中列出。）
</p>
<dl compact="compact">
<dd><a name="index-BINMODE-variable"></a>
<a name="index-binary-input_002foutput"></a>
<a name="index-input_002foutput_002c-binary"></a>
<a name="index-differences-in-awk-and-gawk_002c-BINMODE-variable"></a>
</dd>
<dt><code>BINMODE #</code></dt>
<dd><p>在非 POSIX 系统上，这个变量指定了所有 I/O 所使用的二进制模式。数值 1，2，3 分别指定为输入文件，输出文件与所有文件相应地要使用二进制 I/O 模式。
小于 0 的值，则当成 0 对待，而大于 3 的值，则会被当为 3 对待。
相应的，字串“r”与“w”分别指定输入输出要使用二进制 I/O。
字串“rw”或者“wr”表示所有的文件使用二进制 I/O。其他的字串值则被当成“rw”，但是 <code>gawk</code> 会产生一告警。
<code>BINMODE</code> 在 <a href="#PC-Using">在 PC 操作系统上使用 <code>gawk</code></a>，这里有更详细的说明，<code>mawk</code>（查看 <a href="#Other-Versions">其他可自由获取的 <code>awk</code></a>）也支持这个变量，但是只使用数值。
</p>
<a name="index-CONVFMT-variable-1"></a>
<a name="index-POSIX-awk_002c-CONVFMT-variable-and"></a>
<a name="index-numbers_002c-converting_002c-to-strings"></a>
<a name="index-strings_002c-converting_002c-numbers-to"></a>
</dd>
<dt><code><code>CONVFMT</code></code></dt>
<dd><p>用于控制数值转换成字串的格式（查看 <a href="#Conversion">在字串与数值之间进行转换</a>）。
在效果上，它的工作原理是将其作为 <code>sprintf()</code> 函数的第一个参数（查看 <a href="#String-Functions">字串操作函数</a>）。
它的默认值是 <code>&quot;%.6g&quot;</code>。<code>CONVFMT</code> 由 POSIX 标准引入。
</p>
<a name="index-gawk_002c-FIELDWIDTHS-variable-in-1"></a>
<a name="index-FIELDWIDTHS-variable-1"></a>
<a name="index-differences-in-awk-and-gawk_002c-FIELDWIDTHS-variable"></a>
<a name="index-field-separators_002c-FIELDWIDTHS-variable-and"></a>
<a name="index-separators_002c-field_002c-FIELDWIDTHS-variable-and"></a>
</dd>
<dt><code>FIELDWIDTHS #</code></dt>
<dd><p>一个由空格分隔的列，由以告诉 <code>gawk</code> 如何用固定的列边界来分割输入。给 <code>FIELDWIDTHS</code> 赋值，
会覆盖用 <code>FS</code> 与 <code>FPAT</code> 进行域分割的方式。查看 <a href="#Constant-Size">读取固定宽度数据</a> ，来获取更多信息。
</p>
<a name="index-gawk_002c-FPAT-variable-in-1"></a>
<a name="index-FPAT-variable-1"></a>
<a name="index-differences-in-awk-and-gawk_002c-FPAT-variable"></a>
<a name="index-field-separators_002c-FPAT-variable-and"></a>
<a name="index-separators_002c-field_002c-FPAT-variable-and"></a>
</dd>
<dt><code>FPAT #</code></dt>
<dd><p>告诉 <code>gawk</code> 域的分割是由匹配正则表达式（一个字串）的文本进行的。
对 <code>FPAT</code> 的赋值会覆盖 <code>FS</code> 与 <code>FIELDWIDTHS</code> 的域分割方式。查看 <a href="#Splitting-By-Content">以内容定义域</a>，来获取更多的信息。
</p>
<a name="index-FS-variable-1"></a>
<a name="index-separators_002c-field"></a>
<a name="index-field-separators-1"></a>
</dd>
<dt><code>FS</code></dt>
<dd><p>输入的域分隔符（查看 <a href="#Field-Separators">指定记录如何进行分隔</a>）。
它的值是一个单独的字符或者是一个多字符的正则表达式，该表达式匹配输入记录中域之间的分隔内容。
如果它的值为空串（<code>&quot;&quot;</code>），则输入记录中的每个字符都是分隔符。（这个行为是 <code>gawk</code> 扩展。
POSIX <code>awk</code> 没有指定当 <code>FS</code> 的值为窗口时的行为。因此，其他版本的 <code>awk</code> 也有可能将 <code>&quot;&quot;</code> 特殊对待。）
</p>
<a name="index-POSIX-awk_002c-FS-variable-and"></a>
<p>它的默认值是 <code>&quot;&nbsp;&quot;</code>，即只包含一个空格的字串。这是一个特殊的例外，这个值表示所有空格，TABs 与/或换行序列，
都是一个分隔符。 
<a name="DOCF41" href="#FOOT41">(41)</a>
同时，在记录前后的空格，TABs 与换行符也被忽略掉。
</p>
<p>你也可以在命令行中用 &lsquo;<samp>-F</samp>&rsquo; 来指定 <code>FS</code> 的值：
</p>
<div class="example">
<pre class="example">awk -F, '<var>program</var>' <var>input-files</var>
</pre></div>

<a name="index-gawk_002c-field-separators-and"></a>
<p>如果 <code>gawk</code> 使用了 <code>FIELDWIDTHS</code> 或者 <code>FPAT</code> 用来进行域分割，
对 <code>FS</code> 的赋值会导致 <code>gawk</code> 退回到常规的，基于 <code>FS</code> 的域分割方式。
一个简单的方法就是就是使用 &lsquo;<samp>FS = FS</samp>&rsquo;，并加上一些解释型注释。
</p>
<a name="index-gawk_002c-IGNORECASE-variable-in-1"></a>
<a name="index-IGNORECASE-variable"></a>
<a name="index-differences-in-awk-and-gawk_002c-IGNORECASE-variable"></a>
<a name="index-case-sensitivity_002c-and-string-comparisons"></a>
<a name="index-case-sensitivity_002c-and-regexps"></a>
<a name="index-regular-expressions_002c-case-sensitivity-1"></a>
</dd>
<dt><code>IGNORECASE #</code></dt>
<dd><p>如果 <code>IGNORECASE</code> 是一个非零值或者非空串，则字串的比较与所有的正则表达式匹配都是大小写无关的。
这应用于用 &lsquo;<samp>~</samp>&rsquo; 与 &lsquo;<samp>!~</samp>&rsquo; 进行的正则匹配， 也用于 <code>gensub()</code>，<code>gsub()</code>，<code>index()</code>，<code>match()</code>，
<code>pat<code>split()</code></code>，<code>split()</code> 与 <code>sub()</code> 等函数，还有以 <code>RS</code> 进行分割的记录，
用 <code>FS</code> 与 <code>FPAT</code> 进行分割的域中。
但是，<code>IGNORECASE</code> 的值<em>不会</em>影响用下标索引数组元素，也不会影响当使用半字符的分割符时的域分割。
查看 <a href="#Case_002dsensitivity">匹配时的大小写</a>。
</p>
<a name="index-gawk_002c-LINT-variable-in"></a>
<a name="index-LINT-variable"></a>
<a name="index-differences-in-awk-and-gawk_002c-LINT-variable"></a>
<a name="index-lint-checking"></a>
</dd>
<dt><code>LINT #</code></dt>
<dd><p>当这个变量为 true（非零或者非空），<code>gawk</code> 表现得就像在命令行参数中指定了 &lsquo;<samp>--lint</samp>&rsquo; 参数一样效果
（查看 <a href="#Options">命令行参数</a>）。当它的值为 <code>&quot;fatal&quot;</code> 时，lint 告警会成为致命（fatal）错误。如果值是 <code>&quot;invalid&quot;</code> 时，
则只有真的是无效的事情的告警才会生成。（这还没有完全实现。）任意的其他 true 值都打印非致命告警。
给 <code>LINT</code>  变量赋值为 false，会关闭 lint 告警。
</p>
<p>此变量是一个 <code>gawk</code> 扩展。在其他的 <code>awk</code> 实现中则并不特殊。与其他的特殊变量不同的是，
改变 <code>LINT</code> 变量不会影响 lint 告警的产生，就算 <code>gawk</code> 是处于兼容模式。
虽然 &lsquo;<samp>--lint</samp>&rsquo; 与 &lsquo;<samp>--traditional</samp>&rsquo; 选项单独地控制 <code>gawk</code> 行为的不同方面，但是程序执行中的 lint 告警的控制是与 <code>awk</code> 被执行的方式是无关的。
</p>
<a name="index-OFMT-variable-2"></a>
<a name="index-numbers_002c-converting_002c-to-strings-1"></a>
<a name="index-strings_002c-converting_002c-numbers-to-1"></a>
</dd>
<dt><code>OFMT</code></dt>
<dd><p>控制 <code>print</code> 语句中，数字到字串的转换方式的字串（查看 <a href="#Conversion">在字串与数值之间进行转换</a>）。
它的工作方式是将其作为传递给 <code>sprintf()</code> 函数的第一个参数（查看 <a href="#String-Functions">字串操作函数</a>）。
它的默认值是 <code>&quot;%.6g&quot;</code>。早期的 <code>awk</code> 版本使用 <code>OFMT</code> 来指定将数值转换为字串的格式的一般表达式，
但是这个现在由 <code>CONVFMT</code> 来完成。
</p>
<a name="index-sprintf_0028_0029-function_002c-OFMT-variable-and"></a>
<a name="index-print-statement_002c-OFMT-variable-and"></a>
<a name="index-OFS-variable-2"></a>
<a name="index-separators_002c-field-1"></a>
<a name="index-field-separators-2"></a>
</dd>
<dt><code>OFS</code></dt>
<dd><p>输出域分隔符（查看 <a href="#Output-Separators">输出分隔符</a>）。它被输出在通过 <code>print</code> 语句打印的域之间。
它的默认值是 <code>&quot;&nbsp;&quot;</code>，即一个空格的字串。
</p>
<a name="index-ORS-variable-1"></a>
</dd>
<dt><code>ORS</code></dt>
<dd><p>输出记录的分隔符。它会被输出在每个 <code>print</code> 语句的后面。其默认值是 <code>&quot;\n&quot;</code>，
即换行符。（查看 <a href="#Output-Separators">输出分隔符</a>）
</p>
<a name="index-PREC-variable"></a>
</dd>
<dt><code>PREC #</code></dt>
<dd><p>任意精度浮点数的工作精度，默认为 53 位（查看 <a href="#Setting-precision">设置精度</a>）。
</p>
<a name="index-ROUNDMODE-variable"></a>
</dd>
<dt><code>ROUNDMODE #</code></dt>
<dd><p>用于任意精度数值算术计算的舍入舍出模式，默认为 <code>&quot;N&quot;</code>
（即 IEEE 754 标准中的 <code>roundTiesToEven</code>）。
</p>
<a name="index-RS-variable-1"></a>
<a name="index-separators_002c-for-records-2"></a>
<a name="index-record-separators-1"></a>
</dd>
<dt><code><code>RS</code></code></dt>
<dd><p>输入记录的分隔符。它的默认值是包含一个换行符的字串，表示输入的记录由一行的文本组成。它的值也可以是空串，在这种情况下，记录由于一连串的空行分隔。如果它是一个正则表达式，则记录是由匹配正则表达式的文本进行分割。
（查看 <a href="#Records">输入如何拆分为记录</a>。）
</p>
<p><code>RS</code> 可以使用正则表达式的能力是 <code>gawk</code> 的扩展。在多数的其他 <code>awk</code> 实现中，或者 <code>gawk</code> 是处于兼容模式下（查看 <a href="#Options">命令行参数</a>），只有 <code>RS</code> 中的第一个字符被用来进行分割记录。
</p>
<a name="index-SUBSEP-variable"></a>
<a name="index-separators_002c-subscript"></a>
<a name="index-subscript-separators"></a>
</dd>
<dt><code><code>SUBSEP</code></code></dt>
<dd><p>下标分隔符。它的默认值是 <code>&quot;\034&quot;</code> ，并用来作为多维数组下标索引的一部分。因此，
表达式 &lsquo;<samp>foo[&quot;A&quot;,&nbsp;&quot;B&quot;]</samp>&rsquo; 实际上是访问 <code>foo[&quot;A\034B&quot;]</code>
（查看 <a href="#Multidimensional">多维数组</a>）。
</p>
<a name="index-gawk_002c-TEXTDOMAIN-variable-in"></a>
<a name="index-TEXTDOMAIN-variable"></a>
<a name="index-differences-in-awk-and-gawk_002c-TEXTDOMAIN-variable"></a>
<a name="index-internationalization_002c-localization"></a>
</dd>
<dt><code>TEXTDOMAIN #</code></dt>
<dd><p>用于在 <code>awk</code> 层中的程序的国际化。它设置默认的文本域，其用来在源文本中用来标识字串常量，也用于 <code>dcgettext()</code>，<code>dcngettext()</code> 与 <code>bindtextdomain()</code> 函数
（查看 <a href="#Internationalization"><code>gawk</code> 的国际化</a>）。<code>TEXTDOMAIN</code> 的默认值为 <code>&quot;messages&quot;</code>。
</p></dd>
</dl>

<hr>
<a name="Auto_002dset"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#User_002dmodified" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din-Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#ARGC-and-ARGV" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bc_00a0e_0080_0092a_00bf_00a1ae_0081_00afc_009a_0084aa_0086_0085c_00bd_00aeaa_008f_0098e_0087_008f"></a>
<h3 class="subsection">7.5.2 传递信息的内置变量</h3>

<a name="index-predefined-variables_002c-conveying-information"></a>
<a name="index-variables_002c-predefined-conveying-information"></a>
<p>下面的变量，以字母顺序排列，<code>awk</code> 在特定的情况下会自动设置它的值，以向程序传递信息。
</p>
<p>如果是 <code>gawk</code> 特有的变量，则被用井号标识（&lsquo;<samp>#</samp>&rsquo;）。
这些变量是 <code>gawk</code> 的扩展。对于其他的 <code>awk</code> 实现，或者在兼容模式下的 <code>gawk</code>（查看 <a href="#Options">命令行参数</a>），则它们没有特别含义：
</p>
<dl compact="compact">
<dd><a name="index-ARGC_002fARGV-variables"></a>
<a name="index-arguments_002c-command_002dline-1"></a>
<a name="index-command-line_002c-arguments-1"></a>
</dd>
<dt><code>ARGC</code>, <code>ARGV</code></dt>
<dd><p>命令行中的参数被存在了名为 <code>ARGV</code> 的数组中，并可以被 <code>awk</code> 程序使用。<code>ARGC</code> 是命令行中参数的个数。
查看 <a href="#Other-Arguments">其他命令行参数</a>。与大多数的 <code>awk</code> 数组不同，<code>ARGV</code> 的下标从 0 到 <code>ARGC</code> - 1。
在下面的例子中：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN {</kbd>
&gt;         <kbd>for (i = 0; i &lt; ARGC; i++)</kbd>
&gt;             <kbd>print ARGV[i]</kbd>
&gt;      <kbd>}' inventory-shipped mail-list</kbd>
-| awk
-| inventory-shipped
-| mail-list
</pre></div>

<p><code>ARGV[0]</code> 包含 &lsquo;<samp>awk</samp>&rsquo;，<code>ARGV[1]</code> 包含 &lsquo;<samp>inventory-shipped</samp>&rsquo;，<code>ARGV[2]</code> 包含 &lsquo;<samp>mail-list</samp>&rsquo;。
<code>ARGC</code> 的值为 3，比 <code>ARGV</code> 数组最后一个元素的下标大 1，因为元素是从 0 开始编号的。
</p>
<a name="index-programming-conventions_002c-ARGC_002fARGV-variables"></a>
<p><code>ARGC</code> 与 <code>ARGV</code> 的名字，与其下标为从 0 到 <code>ARGC</code> - 1，都是从 C 语言中访问命令行参数的方法继承而来。
</p>
<a name="index-dark-corner_002c-value-of-ARGV_005b0_005d"></a>
<p><code>ARGV[0]</code> 的值会因为系统不同可能不同。同时，你应该注意程序文本与 <code>awk</code> 的命令行选项都<em>没有</em>包含在 <code>ARGV</code> 中。
查看 <a href="#ARGC-and-ARGV">使用 <code>ARGC</code> 与 <code>ARGV</code></a>，来获取使用这些 <code>awk</code> 变量的信息。
(d.c.)
</p>
<a name="index-ARGIND-variable"></a>
<a name="index-differences-in-awk-and-gawk_002c-ARGIND-variable"></a>
</dd>
<dt><code>ARGIND #</code></dt>
<dd><p>当前正在被处理的文件在 <code>ARGV</code> 中的索引。每次 <code>gawk</code> 打开一个数据文件进行处理，
它就会设置 <code>ARGIND</code> 的值为文件名在 <code>ARGV</code> 中的索引。
当 <code>gawk</code> 处理输入文件时，&lsquo;<samp>FILENAME == ARGV[ARGIND]</samp>&rsquo; 的值总是为 true。
</p>
<a name="index-files_002c-processing_002c-ARGIND-variable-and"></a>
<p>这个变量在处理文件时很有用，它可以让你知道数据文件中已经处理了多少，以及用来区分在命令行中两个连续的同名文件。
</p>
<a name="index-file-names_002c-distinguishing"></a>
<p>当你在 <code>awk</code> 程序中改变 <code>ARGIND</code> 变量的值时，<code>gawk</code> 会在打开下一个文件时，自动设置它为新的值。
</p>
<a name="index-ENVIRON-array"></a>
<a name="index-environment-variables_002c-in-ENVIRON-array"></a>
</dd>
<dt><code>ENVIRON</code></dt>
<dd><p>一个包含环境变量以其值的关联数组。数组的索引是环境变量名，元素则是特定环境变量的值。
例如 <code>ENVIRON[&quot;HOME&quot;]</code> 的值可以是 <code>&quot;/home/arnold&quot;</code>。
改变这个数组不会影响传递到任意的通过 <code>system()</code> 函数或者重定向启动的程序的环境变量。（在后续的 <code>gawk</code> 版本，有可能会有影响。）
</p>
<p>有一些操作系统没有环境变量。在这样的系统中，<code>ENVIRON</code> 数组为空
（除了 <code>ENVIRON[&quot;AWKPATH&quot;]</code> 与 <code>ENVIRON[&quot;AWKLIBPATH&quot;]</code>，
查看 <a href="#AWKPATH-Variable">环境变量 <code>AWKPATH</code></a>，与 
<a href="#AWKLIBPATH-Variable">环境变量 <code>AWKLIBPATH</code></a>）。
</p>
<a name="index-gawk_002c-ERRNO-variable-in-3"></a>
<a name="index-ERRNO-variable"></a>
<a name="index-differences-in-awk-and-gawk_002c-ERRNO-variable"></a>
<a name="index-error-handling_002c-ERRNO-variable-and"></a>
</dd>
<dt><code>ERRNO #</code></dt>
<dd><p>如果在为 <code>getline</code> 进行重定向、读取时，或者进行 <code>close()</code> 操作中，发生了系统错误，
则 <code>ERRNO</code> 会包含一个描述错误的字串。
</p>
<p>另外，<code>gawk</code> 会在每一个命令行中的输入文件的操作前清空 <code>ERRNO</code>。
这样可以在 <code>BEGINFILE</code> 模式中检查文件的可读性（查看 <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>）。
</p>
<p>其他情况，<code>ERRNO</code> 的作用就类似于 C 变量 <code>errno</code>。
除了则才所提到的几个种情况，<code>gawk</code> <em>绝不会</em>清除它（即将其设置为 0，或者 <code>&quot;&quot;</code>）。
因此，只有在 I/O 操作返回一个失败的值的情况下，你才可寄希望于它的值有意义，例如 <code>getline</code> 返回 -1。
当然，你也可以在执行 I/O 操作之前自己清理它。
</p>
<a name="index-FILENAME-variable-1"></a>
<a name="index-dark-corner_002c-FILENAME-variable-1"></a>
</dd>
<dt><code>FILENAME</code></dt>
<dd><p>当前输入文件的名字。如果在命令行中没有输入文件时，<code>awk</code> 会从标准输入中读取数据，同时 <code>FILENAME</code> 的值会设置成 <code>&quot;-&quot;</code>。
<code>FILENAME</code> 每次读取新文件的时候都会改变（查看 <a href="#Reading-Files">读取输入文件</a>）。
在 <code>BEGIN</code> 规则内，<code>FILENAME</code> 的值为 <code>&quot;&quot;</code>，因为这时还没有输入文件被处理。
<a name="DOCF42" href="#FOOT42">(42)</a>
(d.c.)
但是，在 <code>BEGIN</code> 规则中使用 <code>getline</code> （查看 <a href="#Getline">用 <code>getline</code> 输入数据</a>）可以使 <code>FILENAME</code> 有一个值。
</p>
<a name="index-FNR-variable-1"></a>
</dd>
<dt><code>FNR</code></dt>
<dd><p>当前文件的当前记录数。<code>awk</code> 每读一个新记录的时候，会递增 <code>FNR</code>（查看 <a href="#Records">输入如何拆分为记录</a>）。
<code>awk</code> 每次开始读取一个新文件的时候，会将 <code>FNR</code> 设置为 0。
</p>
<a name="index-NF-variable-1"></a>
</dd>
<dt><code>NF</code></dt>
<dd><p>当前输入记录的域数值。<code>NF</code> 每读一个新记录，并且域已经生成的时候，就会被重置，或者是 <code>$0</code> 改变也会重置
（查看 <a href="#Fields">检查域</a>）。
</p>
<p>与在本节中描述的其他大多数变量不同，给 <code>NF</code> 赋值对 <code>awk</code> 的内部工作有一些潜在的效果。具体地说，
给 <code>NF</code> 赋值可能创建新的域，或者是从当前的记录中删除域。查看 <a href="#Changing-Fields">更改域内容</a>。
</p>
<a name="index-FUNCTAB-array"></a>
<a name="index-gawk_002c-FUNCTAB-array-in"></a>
<a name="index-differences-in-awk-and-gawk_002c-FUNCTAB-variable"></a>
</dd>
<dt><code>FUNCTAB #</code></dt>
<dd><p>一个数组，其索引以及对应的值全部都是内建的，用户定义的，以及程序中扩展的函数。
</p>
<blockquote>
<p><b>提示:</b> 在 <code>FUNCTAB</code> 上尝试用 <code>delete</code> 语句会导致致使错误。而对其元素进行赋值，也会导致命令错误。
</p></blockquote>

<a name="index-NR-variable-1"></a>
</dd>
<dt><code>NR</code></dt>
<dd><p>从程序执行开始到现在为止，<code>awk</code> 已经处理的记录的个数（查看 <a href="#Records">输入如何拆分为记录</a>）。
<code>awk</code> 每读一个新记录就会对其进行递增。
</p>
<a name="index-gawk_002c-PROCINFO-array-in"></a>
<a name="index-PROCINFO-array"></a>
<a name="index-differences-in-awk-and-gawk_002c-PROCINFO-array"></a>
</dd>
<dt><code>PROCINFO #</code></dt>
<dd><p>这个数组的元素为运行中的程序的信息提供了访问手段。下面的元素（按字母顺序）保证可用：
</p>
<dl compact="compact">
<dd><a name="index-effective-group-ID-of-gawk-user"></a>
</dd>
<dt><code>PROCINFO[&quot;egid&quot;]</code></dt>
<dd><p>系统调用 <code>getegid()</code> 的值。
</p>
</dd>
<dt><code>PROCINFO[&quot;euid&quot;]</code></dt>
<dd><a name="index-effective-user-ID-of-gawk-user"></a>
<p>系统调用 <code>geteuid()</code> 的值。
</p>
</dd>
<dt><code>PROCINFO[&quot;FS&quot;]</code></dt>
<dd><p>如果域分割方式是 <code>FS</code>，则其值为 “<code>FS</code>”，如果是 <code>FIELDWIDTHS</code> 分割方式起作用，则其值为 “<code>FIELDWIDTHS</code>”，
如果是 <code>FPAT</code> 方式进行分割，则其值为 <code>&quot;FPAT&quot;</code>。
</p>
</dd>
<dt><code>PROCINFO[&quot;gid&quot;]</code></dt>
<dd><a name="index-group-ID-of-gawk-user"></a>
<p>系统调用 <code>getgid()</code> 的值。
</p>
</dd>
<dt><code>PROCINFO[&quot;identifiers&quot;]</code></dt>
<dd><a name="index-program-identifiers"></a>
<p>一个子数组，由在 <code>awk</code> 程序文件中所使用的标识符名字进行索引。一个<em>标识符</em>简单地说就是变量的名字
（变量是一个标量或者是一个数组），也可以是内建函数，用户自定义函数，或者是函数扩展。对每一个标识符，元素的值可能是下面其中之一：
</p>
<dl compact="compact">
<dt><code>&quot;array&quot;</code></dt>
<dd><p>标识符是一个数组。
</p>
</dd>
<dt><code>&quot;builtin&quot;</code></dt>
<dd><p>标识符是一个内建函数。
</p>
</dd>
<dt><code>&quot;extension&quot;</code></dt>
<dd><p>标识符是一个函数扩展，并通过 <code>@load</code> 或者 &lsquo;<samp>-l</samp>&rsquo; 进行装载。
</p>
</dd>
<dt><code>&quot;scalar&quot;</code></dt>
<dd><p>标识符是一个标量。
</p>
</dd>
<dt><code>&quot;untyped&quot;</code></dt>
<dd><p>标识符是无类型的（可用于标量或者是数组，<code>gawk</code> 还不知道而已）。
</p>
</dd>
<dt><code>&quot;user&quot;</code></dt>
<dd><p>标识符是一个用户自定义的函数。
</p></dd>
</dl>

<p>其值显示了 <code>gawk</code> 完成程序的分析后，
对所了解到的标识符的情况，它们的值在程序的运行过程中<em>不能</em>更新。
</p>
</dd>
<dt><code>PROCINFO[&quot;pgrpid&quot;]</code></dt>
<dd><a name="index-process-group-ID-of-gawk-process"></a>
<p>当前进程的组 ID。
</p>
</dd>
<dt><code>PROCINFO[&quot;pid&quot;]</code></dt>
<dd><a name="index-process-ID-of-gawk-process"></a>
<p>当前进程的进程 ID。
</p>
</dd>
<dt><code>PROCINFO[&quot;ppid&quot;]</code></dt>
<dd><a name="index-parent-process-ID-of-gawk-process"></a>
<p>当前进程的父进程的进程 ID。
</p>
</dd>
<dt><code>PROCINFO[&quot;strftime&quot;]</code></dt>
<dd><p><code>strftime()</code> 时间函数的默认格式串。对这个值进行赋值可以改变默认串，查看 <a href="#Time-Functions">时间函数</a>。
</p>
</dd>
<dt><code>PROCINFO[&quot;uid&quot;]</code></dt>
<dd><p>系统调用 <code>getuid()</code> 的值。
</p>
</dd>
<dt><code>PROCINFO[&quot;version&quot;]</code></dt>
<dd><a name="index-version-of-gawk"></a>
<a name="index-gawk-version"></a>
<p><code>gawk</code> 的版本号。
</p></dd>
</dl>

<p>下面在数组中的额外元素，如果你的 <code>gawk</code> 版本支持任意精度的算术运算（查看 <a href="#Arbitrary-Precision-Arithmetic">算术运算与 <code>gawk</code> 中的任意精度算术运算</a>），
则它们会在数组中存在，并提供关于 MPFR 以及 GMP 库的相关信息。
</p>
<dl compact="compact">
<dt><code>PROCINFO[&quot;gmp_version&quot;]</code></dt>
<dd><a name="index-version-of-GNU-MP-library"></a>
<p>GNU MP 库的版本。
</p>
<a name="index-version-of-GNU-MPFR-library"></a>
</dd>
<dt><code>PROCINFO[&quot;mpfr_version&quot;]</code></dt>
<dd><p>GNU MPFR 库的版本。
</p>
</dd>
<dt><code>PROCINFO[&quot;prec_max&quot;]</code></dt>
<dd><a name="index-maximum-precision-supported-by-MPFR-library"></a>
<p>MPFR 支持的最大精度。
</p>
</dd>
<dt><code>PROCINFO[&quot;prec_min&quot;]</code></dt>
<dd><a name="index-minimum-precision-required-by-MPFR-library"></a>
<p>MPFR 所要求的最小精度。
</p></dd>
</dl>

<p>下面的附加元素，如果你的 <code>gawk</code> 版本支持动态装载扩展函数（查看 <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>），则会在数组中存在，并向你提供这些扩展 API 的版本信息：
</p>
<dl compact="compact">
<dt><code>PROCINFO[&quot;api_major&quot;]</code></dt>
<dd><a name="index-version-of-gawk-extension-API"></a>
<a name="index-extension-API_002c-version-number"></a>
<p>扩展 API 的主版本。
</p>
</dd>
<dt><code>PROCINFO[&quot;api_minor&quot;]</code></dt>
<dd><p>扩展 API 的次版本。
</p></dd>
</dl>

<a name="index-supplementary-groups-of-gawk-process"></a>
<p>在某些系统中，有可能存在 <code>&quot;group1&quot;</code> 到值为 <var>N</var> 的 <code>&quot;group<var>N</var>&quot;</code> 的元素存在。
<var>N</var> 是进程所有的补充组的数值。使用 <code>in</code> 操作符来测试这些元素（查看 <a href="#Reference-to-Elements">指向数组元素</a>）。
</p>
<p>下面的附加元素允许你改变 <code>gawk</code> 的行为：
</p>
<dl compact="compact">
<dt><code>PROCINFO[&quot;<var>command</var>&quot;, &quot;pty&quot;]</code></dt>
<dd><p>可以使用 pseudo-tty 代替双向管道进行双向通信。查看 <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a> 关于更多信息。
</p>
</dd>
<dt><code>PROCINFO[&quot;<var>input_name</var>&quot;, &quot;READ_TIMEOUT&quot;]</code></dt>
<dd><p>在从重定向输入中读取数据的时候，设置一个超时提示。
查看 <a href="#Read-Timeout">带超时的输入读取</a> 关于更多信息。
</p>
</dd>
<dt><code>PROCINFO[&quot;sorted_in&quot;]</code></dt>
<dd><p>如果这个元素在 <code>PROCINFO</code> 中存在，则它的值控制针对数组索引在 &lsquo;<samp>for (<var>indx</var> in <var>array</var>)</samp>&rsquo; 循环中的处理顺序。
这是一个高级特性，因此我们后再详细讨论。查看 <a href="#Scanning-an-Array">遍历数组元素</a>。
</p></dd>
</dl>

<a name="index-RLENGTH-variable"></a>
</dd>
<dt><code>RLENGTH</code></dt>
<dd><p><code>match()</code> 函数匹配的子串的长度（查看 <a href="#String-Functions">字串操作函数</a>）。
<code>RLENGTH</code> 在调用 <code>match()</code> 函数时被设置。它的值是匹配串的长度，如果没有匹配找到，则值为 -1。
</p>
<a name="index-RSTART-variable"></a>
</dd>
<dt><code>RSTART</code></dt>
<dd><p>调用 <code>match()</code> 函数所匹配的子串的开始字符的下标（查看 <a href="#String-Functions">字串操作函数</a>）。
<code>RSTART</code> 在调用 <code>match()</code> 函数的时候被设置。它的值是匹配串的在串中的位置，如果没有匹配串，则其值为 0。
</p>
<a name="index-gawk_002c-RT-variable-in-2"></a>
<a name="index-RT-variable-2"></a>
<a name="index-differences-in-awk-and-gawk_002c-RT-variable"></a>
</dd>
<dt><code>RT #</code></dt>
<dd><p>输入文件中匹配由 <code>RS</code>，即记录分隔符，表示的串。每次读取一个记录时，则其值会被设置。
</p>
<a name="index-gawk_002c-SYMTAB-array-in"></a>
<a name="index-SYMTAB-array"></a>
<a name="index-differences-in-awk-and-gawk_002c-SYMTAB-variable"></a>
</dd>
<dt><code>SYMTAB #</code></dt>
<dd><p>在程序中由名字进行索引的所有全局定义的变量与数组的数组。
<code>SYMTAB</code> 使得 <code>gawk</code> 的符号表可由 <code>awk</code> 程序员看到。它在 <code>gawk</code> 分析程序的时候建立，并在程序开始执行前完成。
</p>
<p>这个数组可以用来间接地读取与写入一个数量的值：
</p>
<div class="example">
<pre class="example">foo = 5
SYMTAB[&quot;foo&quot;] = 4
print foo    # prints 4
</pre></div>

<p><code>isarray()</code> 函数（查看 <a href="#Type-Functions">获取类型信息</a>）可以用来测试 <code>SYMTAB</code> 中的元素是否为数组。
类似地，你也不可以对 <code>SYMTAB</code> 中的元素使用 delete 语句。
</p>
<p>你也可以使用没有定义的标识符作为 <code>SYMTAB</code> 的下标：
</p>
<div class="example">
<pre class="example">SYMTAB[&quot;xxx&quot;] = 5
print SYMTAB[&quot;xxx&quot;]
</pre></div>

<p>如下情况，其运行与预期一致：<code>SYMTAB</code> 就是一个普通的数组。唯一的不同就是你不可以删除 <code>SYMTAB[&quot;xxx&quot;]</code>。
</p>
<a name="index-Schorr_002c-Andrew-1"></a>
<p><code>SYMTAB</code> 比初看起来要有趣得多。Andrew Schorr 指出来，可以用其作为 <code>awk</code> 的数组指针。看看他的例子：
</p>
<div class="example">
<pre class="example"># Indirect multiply of any variable by amount, return result

function multiply(variable, amount)
{
    return SYMTAB[variable] *= amount
}
</pre></div>

<p>你可以这么用它：
</p>
<div class="example">
<pre class="example">BEGIN {
    answer = 10.5
    multiply(&quot;answer&quot;, 4)
    print &quot;The answer is&quot;, answer
}
</pre></div>

<p>当这段程序运行的时候，产生这样的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f answer.awk</kbd>
-| The answer is 42
</pre></div>

<blockquote>
<p><b>提示:</b> 为了避免严重的长时间旅行悖论，
<a name="DOCF43" href="#FOOT43">(43)</a>
不管是 <code>FUNCTAB</code> 还是 <code>SYMTAB</code> 都不能作为 <code>SYMTAB</code> 数组中的元素。
</p></blockquote>
</dd>
</dl>

<a name="index-sidebar_002c-ae_0094_00b9aa_008f_0098-NR-a_00b8_008e-FNR"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>改变 <code>NR</code> 与 <code>FNR</code></b>
</p>

<a name="index-NR-variable_002c-changing"></a>
<a name="index-FNR-variable_002c-changing"></a>
<a name="index-dark-corner_002c-FNR_002fNR-variables"></a>
<p>每次读取一个记录时，<code>awk</code> 就是递增 <code>NR</code> 与 <code>FNR</code> 的值，而不是直接将它们设置成已读记录的绝对值。这意味着，程序可以改变这些变量的值，并且在每个记录间都将被递增。
(d.c.)
下面的例子可以说明：
</p>
<div class="example">
<pre class="example">$ <kbd>echo '1</kbd>
&gt; <kbd>2</kbd>
&gt; <kbd>3</kbd>
&gt; <kbd>4' | awk 'NR == 2 { NR = 17 }</kbd>
&gt; <kbd>{ print NR }'</kbd>
-| 1
-| 17
-| 18
-| 19
</pre></div>

<p>在 <code>FNR</code> 被加入到 <code>awk</code> 语言之前（查看 <a href="#V7_002fSVR3_002e1">在 V7 与 SVR3.1 之间的变化</a>），
很多的 <code>awk</code> 程序使用这个特性来跟踪文件中的记录数，这只需要在 <code>FILENAME</code> 变化时，将 <code>NR</code> 的值设置成 0 即可。
</p></td></tr></table>

<hr>
<a name="ARGC-and-ARGV"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Auto_002dset" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din-Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Action-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8-ARGC-a_00b8_008e-ARGV"></a>
<h3 class="subsection">7.5.3 使用 <code>ARGC</code> 与 <code>ARGV</code></h3>
<a name="index-ARGC_002fARGV-variables_002c-how-to-use"></a>
<a name="index-arguments_002c-command_002dline-2"></a>
<a name="index-command-line_002c-arguments-2"></a>

<p>在 <a href="#Auto_002dset">传递信息的内置变量</a>，中有提供下面的程序来描述包含在 <code>ARGC</code> 与 <code>ARGV</code> 中的信息：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN {</kbd>
&gt;        <kbd>for (i = 0; i &lt; ARGC; i++)</kbd>
&gt;            <kbd>print ARGV[i]</kbd>
&gt;      <kbd>}' inventory-shipped mail-list</kbd>
-| awk
-| inventory-shipped
-| mail-list
</pre></div>

<p>在这个例子中，<code>ARGV[0]</code> 包含 &lsquo;<samp>awk</samp>&rsquo;，<code>ARGV[1]</code> 包含 &lsquo;<samp>inventory-shipped</samp>&rsquo;，
而 <code>ARGV[2]</code> 包含 &lsquo;<samp>mail-list</samp>&rsquo; 。注意 <code>awk</code> 程序并没有在 <code>ARGV</code> 中。其他的命令行选项，以及它们的参数都没有进入到这个数组中。
这也包括通过 &lsquo;<samp>-v</samp>&rsquo; 参数（查看 <a href="#Options">命令行参数</a>）进行变量赋值的部分。
在命令行中的正常的变量赋值<em>被</em>当成参数对待，
并且会在 <code>ARGV</code> 中出现。有下面的名为 &lsquo;<tt>showargs.awk</tt>&rsquo; 的文件：
</p>
<div class="example">
<pre class="example">BEGIN {
    printf &quot;A=%d, B=%d\n&quot;, A, B
    for (i = 0; i &lt; ARGC; i++)
        printf &quot;\tARGV[%d] = %s\n&quot;, i, ARGV[i]
}
END   { printf &quot;A=%d, B=%d\n&quot;, A, B }
</pre></div>

<p>运行程序会产生如下输出：
</p>
<div class="example">
<pre class="example">$ <kbd>awk -v A=1 -f showargs.awk B=2 /dev/null</kbd>
-| A=1, B=0
-|        ARGV[0] = awk
-|        ARGV[1] = B=2
-|        ARGV[2] = /dev/null
-| A=1, B=2
</pre></div>

<p>程序可以改变 <code>ARGC</code> 与 <code>ARGV</code> 的元素值。当每次 <code>awk</code> 达到文件尾时，
它会使用 <code>ARGV</code> 的下一个元素作为输入文件。
通过在那个位置存入一个不同的串，程序就可以改变要读取的文件。使用 <code>&quot;-&quot;</code> 来表示标准输入。
存储额外的元素并递增 <code>ARGC</code> 的值，可以处理额外的文件。
</p>
<p>如果 <code>ARGC</code> 的值被递减了，则会从将输入文件从列表的尾部删除。通过在其他地方记录 <code>ARGC</code> 的旧值，
程序可以将取消的参数当做其他东西来对待，而不是文件名。
</p>
<p>为了从列表的中间将文件排除，可以将空串（<code>&quot;&quot;</code>）存到 <code>ARGV</code> 中来代替文件名。作用一个特殊的特性，
<code>awk</code> 会忽略那些用空串替换掉的文件。另一个选择就是用 <code>delete</code> 语句来移除 <code>ARGV</code> 中的元素（查看 <a href="#Delete"><code>delete</code> 语句</a>）。
</p>
<p>所有这些动作一般都要在 <code>BEGIN</code> 规则中完成，也就是在程序实际处理输入前。查看 <a href="#Split-Program">将大文件分片</a>，
以及
<a href="#Tee-Program">将输出复制到多个文件中</a>
中的例子，来获取从 <code>ARGV</code> 中删除元素的各种方法。
</p>
<p>为了取得输入 <code>awk</code> 程序中的选项，用 &lsquo;<samp>--</samp>&rsquo; 来结束 <code>awk</code> 的选项，
然后再提供 <code>awk</code> 程序的选项，如下面的方式：
</p>
<div class="example">
<pre class="example">awk -f myprog.awk -- -v -q file1 file2 &hellip;
</pre></div>

<p>下面的处理 <code>ARGV</code> 的代码片段，就是用来检查，移除前面所提到的命令行选项：
</p>
<div class="example">
<pre class="example">BEGIN {
    for (i = 1; i &lt; ARGC; i++) {
        if (ARGV[i] == &quot;-v&quot;)
            verbose = 1
        else if (ARGV[i] == &quot;-q&quot;)
            debug = 1
        else if (ARGV[i] ~ /^-./) {
            e = sprintf(&quot;%s: unrecognized option -- %c&quot;,
                    ARGV[0], substr(ARGV[i], 2, 1))
            print e &gt; &quot;/dev/stderr&quot;
        } else
            break
        delete ARGV[i]
    }
}
</pre></div>

<a name="index-differences-in-awk-and-gawk_002c-ARGC_002fARGV-variables"></a>
<p>在 <code>gawk</code> 中用 &lsquo;<samp>--</samp>&rsquo; 来结束 <code>awk</code> 的选项不是必须的，除非指定了 &lsquo;<samp>--posix</samp>&rsquo; ，
<code>gawk</code> 会默默地将不能够识别的选项放到 <code>ARGV</code> 中以备 <code>awk</code> 程序来处理。一看到不认识的选项，
<code>gawk</code> 会停止查找其他的可能可以识别的选项。前面的命令行在 <code>gawk</code> 中可以如下：
</p>
<div class="example">
<pre class="example">gawk -f myprog.awk -q -v file1 file2 &hellip;
</pre></div>

<p>由于 &lsquo;<samp>-q</samp>&rsquo; 不是一个有效的 <code>gawk</code> 选项，它以及后面的 &lsquo;<samp>-v</samp>&rsquo; 选项都会被传递给 <code>awk</code> 程序。
（查看 <a href="#Getopt-Function">处理命令行选项</a>，来查看分析命令选项的库函数。）
</p>
<p>当设计你的程序的时候，你应该选择那些不与 <code>gawk</code> 冲突的选项，
因为它将后续的要传递给你的程序的选项之前先处理掉自己可以接受的选项。使用以 &lsquo;<samp>#!</samp>&rsquo; 并使用 &lsquo;<samp>-E</samp>&rsquo; 参数也许有帮助
（查看 <a href="#Executable-Scripts">可执行的 <code>awk</code> 程序</a>，以及 
<a href="#Options">命令行参数</a>）。
</p>
<hr>
<a name="Pattern-Action-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#ARGC-and-ARGV" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-17"></a>
<h2 class="section">7.6 总结</h2>

<ul>
<li>
模式-行为对组成了 <code>awk</code> 程序的基本元素。模式要是么一个普通的表达式，范围表达式，或者是正则表达式常量，
或者是特殊关键字 <code>BEGIN</code>，<code>END</code>，<code>BEGINFILE</code>，<code>ENDFILE</code>，或者为空。
动作在当前记录匹配模式后执行。空的（省略）的模式匹配所有的记录。

</li><li>
从 <code>BEGIN</code> 与 <code>END</code> 模式中进行 I/O 有一定的限制，对于 <code>BEGINFILE</code> 以及 <code>ENDFILE</code> 也是如此，
而且限制更多。后两者可以让你在处理文件之间打入“勾子”，因此可你使用从可以导致致使错误的文件中恢复回来（例如文件不能被打开）。

</li><li>
Shell 变量可以通过仔细地使用 Shell 引号来用在 <code>awk</code> 程序中。
用 <code>awk</code> 的 &lsquo;<samp>-v</samp>&rsquo; 选项来传递 Shell 变量到 <code>awk</code> 变量会更加容易。

</li><li>
动作由花括号包含的语句组成 。语句由表达式，控制语句，复合语句，输入输出语句以及删除文句组成。

</li><li>
<code>awk</code> 的控制语句是 <code>if</code>-<code>else</code>，<code>while</code>，<code>for</code> 和 <code>do</code>-<code>while</code>。
<code>gawk</code> 添加了 <code>switch</code> 语句。<code>for</code> 语句有两个用处：一个是执行一般的循环，另一个是用来迭代数组。

</li><li>
<code>break</code> 与 <code>continue</code> 可以让你早点或者开启下一个循环替代（或者跳出 <code>switch</code>）。

</li><li>
<code>next</code> 与 <code>nextfile</code> 可以让你读取下一个记录并从你程序的开头执行，或者路过下一个输入文件并重新开始。

</li><li>
<code>exit</code> 语句用来结束你的程序。当从动作中执行时（或者在函数体内执行时），它将控制流传递到 <code>END</code> 语句。从 <code>END</code> 语句体中执行时，则会直接退出。你可以传递一个可选的数值参数来作为 <code>awk</code> 的退出状态。

</li><li>
一些预定义的函数可以控制 <code>awk</code> ，主要是用于 I/O。其他的变量用来向你的程序传递信息。

</li><li>
<code>ARGC</code> 与 <code>ARGV</code> 可以让你的程序使用命令行参数。从 <code>BEGIN</code> 规则中操作它们，
可以使你控制 <code>awk</code> 如何来处理数据文件。

</li></ul>

<hr>
<a name="Arrays"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Patterns-and-Actions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pattern-Action-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Basics" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-ae_0095_00b0c_00bb_0084"></a>
<h1 class="chapter">8 <code>awk</code> 数组</h1>
<a name="index-arrays"></a>

<p><em>数组</em>是被称为<em>元素</em>的值的表。数组的元素都由<em>索引</em>来区分，
索引即可以是数值也可以是字串。
</p>
<p>本章描述 <code>awk</code> 中的数组如保来工作，如何使用元素，如何来扫描数组成的每个元素，以及如可来删除数组元素。同时，
也描述 <code>awk</code> 如何来模拟多维数组，以及在使用数组时的一些不太明显的地方。
本章还会讨论 <code>gawk</code> 中用于对数组排序的工具，然后以简要介绍关于 <code>gawk</code> 支持真正的多维数组的能力为结尾。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Array-Basics">8.1 数组基础</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                The basics of arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    How to use numbers as subscripts in
                                <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Using Uninitialized variables as subscripts.
</td></tr>
<tr><td align="left" valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      The <code>delete</code> statement removes an element
                                from an array.
</td></tr>
<tr><td align="left" valign="top"><a href="#Multidimensional">8.5 多维数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Emulating multidimensional arrays in
                                <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arrays-of-Arrays">8.6 多维数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            True multidimensional arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arrays-Summary">8.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Summary of arrays.
</td></tr>
</table>

<hr>
<a name="Array-Basics"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Intro" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0c_00bb_0084aa_009f_00bac_00a1_0080"></a>
<h2 class="section">8.1 数组基础</h2>

<p>本小节描述一些基础：一次处理数组中的一个元素，以及遍历数组中的所有元素。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Introduction to Arrays
</td></tr>
<tr><td align="left" valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       How to examine one element of an array.
</td></tr>
<tr><td align="left" valign="top"><a href="#Assigning-Elements">8.1.3 给数组元素赋值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          How to change an element of an array.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Example">8.1.4 基本数组实例</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Basic Example of an Array
</td></tr>
<tr><td align="left" valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           A variation of the <code>for</code> statement. It
                                loops through the indices of an array&rsquo;s
                                existing elements.
</td></tr>
<tr><td align="left" valign="top"><a href="#Controlling-Scanning">8.1.6 在 <code>gawk</code> 中使用预定义的数组遍历顺序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Controlling the order in which arrays are
                                scanned.
</td></tr>
</table>

<hr>
<a name="Array-Intro"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Basics" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Reference-to-Elements" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0c_00bb_0084a_00bb_008bc_00bb_008d"></a>
<h3 class="subsection">8.1.1 数组介绍</h3>

<a name="index-Wall_002c-Larry"></a>
<blockquote>
<p><i>
对一个关联数组进行线性扫描就好像用一个已经装弹的 Uzi 枪将人敲死。（喻大才小用——译者）
</i>
</p></blockquote>
<p align="center">&mdash; <em>Larry Wall</em>
</p>
<p><code>awk</code> 语言提供了一维数组用以存储一组相关的串或者数字。每一个 <code>awk</code> 数组都必须有一个名字。数组名字与变量名有一样的语法，任意有效的变量名也都是一个有效的数组名。但是在同一个程序中，一名不能两用（同时作为数组又作为变量）。
</p>
<p>在 <code>awk</code> 中的数组表面上与在其他的编程语言中的数组相似，但是它们却有着本质的不同。
在 <code>awk</code> 中，没有必要指定数组的大小就可以使用。而且，任意的数字或者字串，不仅仅是连续的整数，都可以用来作数组的索引。
</p>
<p>其他大多数语言，数组必须经<em>声明</em>才可用，包括指定在数组中包含什么样元素与组件。在这样的语言中，声明 会导致内存的连续块分配用来存储这些元素。通常情况下，数组中的索引必须是一个非负整数。例如，索引 0 指定了数组中的第一个元素，实际上就是存储在内存块中开始的元素，等等。没有可能为数组添加更多的元素，因为它只包含声明时所给定的元素个数。（一些其他语言可以使用任意的起始与结束索引，如 &lsquo;<samp>15 .. 27</samp>&rsquo;，
但是数组的大小一经声明后，就是固定的。）
</p>
<p>一个 4 个元素的连续数组看起来如 
<a href="#figure_002darray_002delements">Figure 8.1</a>,
所示，元素的值假设为 8，<code>&quot;foo&quot;</code>，<code>&quot;&quot;</code> 跟 30。
</p>
<div class="float"><a name="figure_002darray_002delements"></a>

<img src="array-elements.png" alt="连续数组">
</div><p><strong>Figure 8.1: 连续数组
</strong>
</p>

<p>其中仅值会被存储起来，索引则是在值的顺序中隐含的。这里，8 的索引为 0，因为 8 出现在 0 的位置，其之前没有元素存在。
</p>
<a name="index-arrays_002c-indexing"></a>
<a name="index-indexing-arrays"></a>
<a name="index-associative-arrays"></a>
<a name="index-arrays_002c-associative"></a>
<p><code>awk</code> 的数组也是不同的——它们都是<em>关联性</em>的。
这就是说，每个数组都是“成对值”集合——下面是索引与其关联的数组元素值：
</p>
<table>
<thead><tr><th width="10%"></th><th width="10%">Index</th><th width="10%">Value</th></tr></thead>
<tr><td width="10%"></td><td width="10%"><code>3</code></td><td width="10%"><code>30</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>1</code></td><td width="10%"><code>&quot;foo&quot;</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>0</code></td><td width="10%"><code>8</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>2</code></td><td width="10%"><code>&quot;&quot;</code></td></tr>
</table>


<p>成对值以随意的顺序出现，因为他们与顺序无关。 
<a name="DOCF44" href="#FOOT44">(44)</a>
</p>
<p>关联数组的一个好处就是新的成对值可以在任意时间进行添加。例如，假如第 10 个元素被加到数组中，而其值为 <code>&quot;number&nbsp;ten&quot;</code>。
则结果为：
</p>
<table>
<thead><tr><th width="10%"></th><th width="10%">Index</th><th width="20%">Value</th></tr></thead>
<tr><td width="10%"></td><td width="10%"><code>10</code></td><td width="20%"><code>&quot;number ten&quot;</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>3</code></td><td width="20%"><code>30</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>1</code></td><td width="20%"><code>&quot;foo&quot;</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>0</code></td><td width="20%"><code>8</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>2</code></td><td width="20%"><code>&quot;&quot;</code></td></tr>
</table>


<a name="index-sparse-arrays"></a>
<a name="index-arrays_002c-sparse"></a>
<p>现在数组是<em>稀疏</em>的，即有些索引是缺失的。它有元素 0&ndash;3 与 10，但是没有元素 4，5，6，7，8 与 9。
</p>
<p>关联数组的另一个结果就是索引不必是非负的整数。任何数值，甚至是字串都可以作为索引。例如，下面的数组将英语单词翻译为法语：
</p>
<table>
<thead><tr><th width="10%"></th><th width="10%">Index</th><th width="10%">Value</th></tr></thead>
<tr><td width="10%"></td><td width="10%"><code>&quot;dog&quot;</code></td><td width="10%"><code>&quot;chien&quot;</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>&quot;cat&quot;</code></td><td width="10%"><code>&quot;chat&quot;</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>&quot;one&quot;</code></td><td width="10%"><code>&quot;un&quot;</code></td></tr>
<tr><td width="10%"></td><td width="10%"><code>1</code></td><td width="10%"><code>&quot;un&quot;</code></td></tr>
</table>


<p>在这里，我们决定将数值 1 翻译为拼写与数值形式——这个例子说明了一个数组即可以用数字也可以用字串作为索引。
（事实上，数组下标总是字串。这里面，数值用于数组下标如何工作，有一些微妙的地方，这会在 <a href="#Numeric-Array-Subscripts">用数值作为数组下标</a>，进行更详细的说明。）在这里，数值 <code>1</code> 没有双引号引起来，
因为 <code>awk</code> 会自动地将其转换为字串。
</p>
<a name="index-gawk_002c-IGNORECASE-variable-in-2"></a>
<a name="index-case-sensitivity_002c-array-indices-and"></a>
<a name="index-arrays_002c-and-IGNORECASE-variable"></a>
<a name="index-IGNORECASE-variable_002c-and-array-indices"></a>
<p><code>IGNORECASE</code> 的值不会影响在数组进行下标操作时结果。用来存储与返回数组元素必须使用相同的字串。
当 <code>awk</code> 创建一个数组（比如在 <code>split()</code> 内建函数中），那个数组的索引就是从 1 开始的连续整数。（查看 <a href="#String-Functions">字串操作函数</a>）
</p>
<p><code>awk</code> 的数组是非常高效的——访问元素的时间与数组中的元素数量无关。
</p>
<hr>
<a name="Reference-to-Elements"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Intro" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Assigning-Elements" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008c_0087aa_0090_0091ae_0095_00b0c_00bb_0084aa_0085_0083c_00b4_00a0"></a>
<h3 class="subsection">8.1.2 指向数组元素</h3>
<a name="index-arrays_002c-referencing-elements"></a>
<a name="index-array-members"></a>
<a name="index-elements-of-arrays"></a>

<p>使用数组的主要方式就是使用它的元素。<em>数组参考</em>是一个如下面这样的表达式：
</p>
<div class="example">
<pre class="example"><var>array</var>[<var>index-expression</var>]
</pre></div>

<p>在这里，<var>array</var> 是数组的名字。表达式 <var>index-expression</var> 是数组中所需要元素的索引。
</p>
<p>数组参考的值是数组指定元素的当前值。例如 <code>foo[4.3]</code> 是一个表达式参考，
是指数组 <code>foo</code> 在索引 &lsquo;<samp>4.3</samp>&rsquo; 的元素。
</p>
<a name="index-arrays_002c-unassigned-elements"></a>
<a name="index-unassigned-array-elements"></a>
<a name="index-empty-array-elements"></a>
<p>对未存在数组数组元素的参考，会产生一个 <code>&quot;&quot;</code> 值，即空串。
这也包括了那些还没有被赋值的元素，以及已经删除的元素（查看 <a href="#Delete"><code>delete</code> 语句</a>）。
</p>
<a name="index-non_002dexistent-array-elements"></a>
<a name="index-arrays_002c-elements-that-don_0027t-exist"></a>
<blockquote>
<p><b>提示:</b> 对不存在元素的参考会<em>自动地</em>创建这个数组元素，并将窗口作为它的值。（在某种情况下，这却是不幸的，因为这会浪费 <code>awk</code> 中的内存。）
</p>
<p><code>awk</code> 新手程序员常常犯通过检查其值是否为空来检查元素存不存在的错误：
</p>
<div class="example">
<pre class="example"># Check if &quot;foo&quot; exists in a:         <i>Incorrect!</i>
if (a[&quot;foo&quot;] != &quot;&quot;) &hellip;
</pre></div>

<p>这是不正确的，有两个原因：第一，如果之前不存在 <code>a[&quot;foo&quot;]</code>，则会<em>创建</em>它。
第二，（看起来不寻常）将数组元素的值设置成空串是有效的。
</p></blockquote>

<a name="index-in-operator_002c-testing-if-array-element-exists"></a>
<p>为了确定特定索引的元素是否存在数组中，使用下面的表达式：
</p>
<div class="example">
<pre class="example"><var>indx</var> in <var>array</var>
</pre></div>

<a name="index-side-effects_002c-array-indexing"></a>
<p>这个表达式测试特定的索引 <var>indx</var> 是否存在，并且不会产生如果元素不存在会创建这个元素的副作用。
如果 <code><var>array</var>[<var>indx</var>]</code> 存在，则表达式的具有值 1 （true），否则为 0 （false）。
（我们在这里使用的是 <var>indx</var>，是因为 &lsquo;<samp>index</samp>&rsquo; 是内建函数的名字。）
例如，这个语句测试数组 <code>frequencies</code> 是不存在索引 &lsquo;<samp>2</samp>&rsquo; ：
</p>
<div class="example">
<pre class="example">if (2 in frequencies)
    print &quot;Subscript 2 is present.&quot;
</pre></div>

<p>注意，这<em>不是</em>测试数组 <code>frequencies</code> 是否包含<em>值</em>为 2 的元素。
除了扫描所有的元素，否则的话没有其他的办法。同时，这也<em>不会</em>创建 <code>frequencies[2]</code>，
而下面的代码则会（是不正确的）：
</p>
<div class="example">
<pre class="example">if (frequencies[2] != &quot;&quot;)
    print &quot;Subscript 2 is present.&quot;
</pre></div>

<hr>
<a name="Assigning-Elements"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reference-to-Elements" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Example" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bb_0099ae_0095_00b0c_00bb_0084aa_0085_0083c_00b4_00a0e_00b5_008baa_0080_00bc"></a>
<h3 class="subsection">8.1.3 给数组元素赋值</h3>
<a name="index-arrays_002c-elements_002c-assigning-values"></a>
<a name="index-elements-in-arrays_002c-assigning-values"></a>

<p>数组元素可以像 <code>awk</code> 变量一样被赋值：
</p>
<div class="example">
<pre class="example"><var>array</var>[<var>index-expression</var>] = <var>value</var>
</pre></div>

<p><var>array</var> 是数组的名字。表达式 <var>index-expression</var> 是 <var>value</var> 要被赋值的元素的索引。
表达式的值是赋给数组元素的值。
</p>
<hr>
<a name="Array-Example"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Assigning-Elements" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Scanning-an-Array" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009f_00baae_009c_00acae_0095_00b0c_00bb_0084aa_00ae_009ea_00be_008b"></a>
<h3 class="subsection">8.1.4 基本数组实例</h3>
<a name="index-arrays_002c-an-example-of-using"></a>

<p>下面的程序提取一系列的行，每一行以数字开始，并按行号的顺序打印它们。行号第一次读取的时候不是顺序的——相反，它们是打乱的。程序对行进行排序，使数组用行号作为下标。程序然后按照行号的顺序打印它们。这是个非常简单的程序，但是在遇到重复的行号，空格或者不是以数值开始的行的时候会导致困惑：
</p>
<div class="example">
<pre class="example">{
    if ($1 &gt; max)
        max = $1
    arr[$1] = $0
}

END {
    for (x = 1; x &lt;= max; x++)
        print arr[x]
}
</pre></div>

<p>第一个规则跟踪当前已经看到的最大的行号，同时也将每一行存储在数组 <code>arr</code> 中，
并以行号作为索引。每二个规则则是打印所有的行。当程序执行时，有下面的输入：
</p>
<div class="example">
<pre class="example">5  I am the Five man
2  Who are you?  The new number two!
4  . . . And four on the floor
1  Who is number one?
3  I three you.
</pre></div>

<p>Its output is:
</p>
<div class="example">
<pre class="example">1  Who is number one?
2  Who are you?  The new number two!
3  I three you.
4  . . . And four on the floor
5  I am the Five man
</pre></div>

<p>如果行号是重复的，已经存在的行的最后一行将覆盖其他的。
在行号间的空隙可以通过在程序的 <code>END</code> 规则中做一个简单的增强就可以处理，如下：
</p>
<div class="example">
<pre class="example">END {
    for (x = 1; x &lt;= max; x++)
        if (x in arr)
            print arr[x]
}
</pre></div>

<hr>
<a name="Scanning-an-Array"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Example" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Controlling-Scanning" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0081_008daa_008e_0086ae_0095_00b0c_00bb_0084aa_0085_0083c_00b4_00a0"></a>
<h3 class="subsection">8.1.5 遍历数组元素</h3>
<a name="index-elements-in-arrays_002c-scanning"></a>
<a name="index-scanning-arrays"></a>
<a name="index-arrays_002c-scanning"></a>
<a name="index-loops_002c-for_002c-array-scanning"></a>

<p>在使用数组的程序中，常常需要使用循环来执行针对数组中每个元素的操作。在其他的语言中，数组是连续的，并且过些限制为非负整数，处理起来就非常的简单：所有有效的索引都可以为最低索引到最大的索引。这个技巧在 <code>awk</code> 中并不可用，因此任意的数字与字串都可以作为数组的索引。因此，<code>awk</code> 有一个特殊的 <code>for</code> 语句来扫描数组：
</p>
<div class="example">
<pre class="example">for (<var>var</var> in <var>array</var>)
    <var>body</var>
</pre></div>

<a name="index-in-operator_002c-use-in-loops"></a>
<p>这个循环为程序中使用过的数组 <var>array</var> 中的每一个索引执行一次 <var>body</var>，
并将 <var>var</var> 变量设置成索引值。
</p>
<a name="index-arrays_002c-for-statement-and"></a>
<a name="index-for-statement_002c-looping-over-arrays"></a>
<p>下面的程序使用这种形式的 <code>for</code> 语句。第一个规则扫描输入记录，并且注意出现在输入中的单词（至少出现一次），
通过用其中一个单词作为索引来并将值 1 存到存储数组 <code>used</code> 中。
第二个规则扫描已经使用过的元素来查找所有的在输入中出现的不同的单词。然后打印其长度大于 10 个字符的单词，
同时也打印此类单词出现的次数。查看 <a href="#String-Functions">字串操作函数</a>，来获取内建函数 <code>length()</code> 的更多信息。
</p>
<div class="example">
<pre class="example"># Record a 1 for each word that is used at least once
{
    for (i = 1; i &lt;= NF; i++)
        used[$i] = 1
}

# Find number of distinct words more than 10 characters long
END {
    for (x in used) {
        if (length(x) &gt; 10) {
            ++num_long_words
            print x
        }
    }
    print num_long_words, &quot;words longer than 10 characters&quot;
}
</pre></div>

<p>查看 <a href="#Word-Sorting">生成字使用统计</a>，来获取更多的更多更详细的此类例子。
</p>
<a name="index-arrays_002c-elements_002c-order-of-access-by-in-operator"></a>
<a name="index-elements-in-arrays_002c-order-of-access-by-in-operator"></a>
<a name="index-in-operator_002c-order-of-array-access"></a>
<p>通过这个语句访问数组中的元素的顺序则是由 <code>awk</code> 内部对数组元素的安排确定的，
并且在标准的 <code>awk</code> 中是无法控制与改变的。如果新元素被在循环体内的语句加入到数组 <var>array</var> 中，
前面的规则可会导致问题的产生，即在 <code>for</code> 循环中什么时候指向它们是不可预测的。相似的，改变循环体内的 <var>var</var> 会导致奇怪的结果。
因此最好别做这样的事情。
</p>
<p>作为信息点，<code>gawk</code> 开始循环之前，挂起被迭代的元素的列表，并不可以改变它。
但是不是所有的 <code>awk</code> 版本都这么做。考虑下面的程序，名为 &lsquo;<tt>loopcheck.awk</tt>&rsquo;：
</p>
<div class="example">
<pre class="example">BEGIN {
    a[&quot;here&quot;] = &quot;here&quot;
    a[&quot;is&quot;] = &quot;is&quot;
    a[&quot;a&quot;] = &quot;a&quot;
    a[&quot;loop&quot;] = &quot;loop&quot;
    for (i in a) {
        j++
        a[j] = j
        print i
    }
}
</pre></div>

<p>这是用 <code>gawk</code>（与 <code>mawk</code>）执行时的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f loopcheck.awk</kbd>
-| here
-| loop
-| a
-| is
</pre></div>

<p>而下面是 BWK <code>awk</code> 的执行结果：
</p>
<div class="example">
<pre class="example">$ <kbd>nawk -f loopcheck.awk</kbd>
-| loop
-| here
-| is
-| a
-| 1
</pre></div>

<hr>
<a name="Controlling-Scanning"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Scanning-an-Array" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Basics" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Numeric-Array-Subscripts" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-gawk-a_00b8_00ada_00bd_00bfc_0094_00a8e_00a2_0084aa_00ae_009aa_00b9_0089c_009a_0084ae_0095_00b0c_00bb_0084e_0081_008daa_008e_0086e_00a1_00baaa_00ba_008f"></a>
<h3 class="subsection">8.1.6 在 <code>gawk</code> 中使用预定义的数组遍历顺序</h3>

<p>本子小节描述的是 <code>gawk</code> 特有的特性。
</p>
<p>在默认情况下，当 <code>for</code> 在遍历数组时，其顺序是未定义的，即是说，<code>awk</code> 的实现决定了在遍历数组时的顺序。这个顺序通常是基于数组的内部实现，并在不同版本的 <code>awk</code> 有差异。
</p>
<a name="index-array-scanning-order_002c-controlling"></a>
<a name="index-controlling-array-scanning-order"></a>
<p>尽管你通常做的都是一些简单的事情，如“通过以升序的方式比较索引来遍历数组”，或者是“通过以降序的方式比较值来遍历数组”。
<code>gawk</code> 通过两种机制让你来执行这样的控制：
</p>
<ul>
<li>
设置 <code>PROCINFO[&quot;sorted_in&quot;]</code> 的值为预定义值之一。后面会讲到。

</li><li>
设置 <code>PROCINFO[&quot;sorted_in&quot;]</code> 为用户自定义的函数用来比较数组中的元素。这个高级特性在后面的章节 <a href="#Array-Sorting">控制数组排序与遍历</a>，
中进行描述。
</li></ul>

<a name="index-PROCINFO_002c-values-of-sorted_005fin"></a>
<p>下面是可获取的 <code>PROCINFO[&quot;sorted_in&quot;]</code> 值：
</p>
<dl compact="compact">
<dt><code>&quot;@unsorted&quot;</code></dt>
<dd><p>数组元素以任意顺序处理，这是默认的 <code>awk</code> 行为。
</p>
</dd>
<dt><code>&quot;@ind_str_asc&quot;</code></dt>
<dd><p>以字串比较索引升序方式，这是最基本的排序。（在内部，数组索引总是字串，因此 &lsquo;<samp>a[2*5] = 1</samp>&rsquo; 中的索引是 <code>&quot;10&quot;</code>，
而不是数字的 10。）
</p>
</dd>
<dt><code>&quot;@ind_num_asc&quot;</code></dt>
<dd><p>以索引升序的方式，但是强制索引以数值对待。对于不是数值的索引，就当成是 0 的方式进行定位。
</p>
</dd>
<dt><code>&quot;@val_type_asc&quot;</code></dt>
<dd><p>以元素值的升序方式排序（而不是索引）。排序是通过给元素所赋值的类型进行的（查看 <a href="#Typing-and-Comparison">变量类型与比较表达式</a>）。
所有的数值都在字串之前，后面再接子数组。（子数组还没有讨论到，查看 <a href="#Arrays-of-Arrays">多维数组</a>）。
</p>
</dd>
<dt><code>&quot;@val_str_asc&quot;</code></dt>
<dd><p>按元素值的升序排序（不是按索引）。标量值与字串进行比较，如果有子数组，则最后与其比较。
</p>
</dd>
<dt><code>&quot;@val_num_asc&quot;</code></dt>
<dd><p>按元素值的升序排序（不是按索引）。标量值与字串进行比较，如果有子数组，则最后与其比较。当数值相同时，用字串比较来确定顺序。这保证了在不同版本的 C <code>qsort()</code> 函数间的一致结果，
<a name="DOCF45" href="#FOOT45">(45)</a>
在内部它被 <code>gawk</code> 用来执行排序。
</p>
</dd>
<dt><code>&quot;@ind_str_desc&quot;</code></dt>
<dd><p>与 <code>&quot;@ind_str_asc&quot;</code> 相似，但是字串顺序是从高到低，即降序。
</p>
</dd>
<dt><code>&quot;@ind_num_desc&quot;</code></dt>
<dd><p>与 <code>&quot;@ind_num_asc&quot;</code> 相似，但是数值索引是从高到低，即降序。
</p>
</dd>
<dt><code>&quot;@val_type_desc&quot;</code></dt>
<dd><p>与 <code>&quot;@val_type_asc&quot;</code> 相似，但是基于元素值的类型则是从高到低。如果有子数组，则最先比较子数组。
</p>
</dd>
<dt><code>&quot;@val_str_desc&quot;</code></dt>
<dd><p>与 <code>&quot;@val_str_asc&quot;</code> 相似，但是基于元素值的字串则是从高到低。如果有子数组，则最先比较子数组。
</p>
</dd>
<dt><code>&quot;@val_num_desc&quot;</code></dt>
<dd><p>与 <code>&quot;@val_num_asc&quot;</code> 相似，但是基于元素值的数值则是从高到低。如果有子数组，则最先比较子数组。
</p></dd>
</dl>

<p>数组的遍历顺序是在 <code>for</code> 循环开始执行之前就确定的。在循环体内改变 <code>PROCINFO[&quot;sorted_in&quot;]</code> 的值不会影响循环。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk '</kbd>
&gt; <kbd>BEGIN {</kbd>
&gt; <kbd>   a[4] = 4</kbd>
&gt; <kbd>   a[3] = 3</kbd>
&gt; <kbd>   for (i in a)</kbd>
&gt; <kbd>       print i, a[i]</kbd>
&gt; <kbd>}'</kbd>
-| 4 4
-| 3 3
$ <kbd>gawk '</kbd>
&gt; <kbd>BEGIN {</kbd>
&gt; <kbd>   PROCINFO[&quot;sorted_in&quot;] = &quot;@ind_str_asc&quot;</kbd>
&gt; <kbd>   a[4] = 4</kbd>
&gt; <kbd>   a[3] = 3</kbd>
&gt; <kbd>   for (i in a)</kbd>
&gt; <kbd>       print i, a[i]</kbd>
&gt; <kbd>}'</kbd>
-| 3 3
-| 4 4
</pre></div>

<p>当通过元素值的方式来排序，如果某个值为子数组，则其被认为比任意的字串与数组都大，而不管子数组中包含的内容，
而所有的子数组都当成相同来对待。而它们之间的相对顺序则由它们的索引字串来决定 。
</p>
<p>下面是一些在进行排序数组遍历时要记住的点：
</p>
<ul>
<li>
<code>PROCINFO[&quot;sorted_in&quot;]</code> 的值是全局的，它影响所有的数组遍历 <code>for</code> 循环。
如果你要在你的代码中改变它，则你需要确定它是否存在，同时要保存与恢复它的值：

<div class="example">
<pre class="example">&hellip;
if (&quot;sorted_in&quot; in PROCINFO) {
    save_sorted = PROCINFO[&quot;sorted_in&quot;]
    PROCINFO[&quot;sorted_in&quot;] = &quot;@val_str_desc&quot; # or whatever
}
&hellip;
if (save_sorted)
    PROCINFO[&quot;sorted_in&quot;] = save_sorted
</pre></div>

</li><li>
如早前所提到的，默认的数组遍历由 <code>&quot;@unsorted&quot;</code> 表示。
你也可以给 <code>PROCINFO[&quot;sorted_in&quot;]</code> 赋一个空串来获得这样的默认行为，
或者只需要用 <code>delete</code> 语句将 <code>&quot;sorted_in&quot;</code> 从 <code>PROCINFO</code> 中删除。
（<code>delete</code> 语句还没有讨论到，请查看 <a href="#Delete"><code>delete</code> 语句</a>。）
</li></ul>

<p>另外，<code>gawk</code> 提供了内建的用于数组排序的函数，查看 <a href="#Array-Sorting-Functions">用 <code>gawk</code> 对数组进行值与键的排序</a>。
</p>
<hr>
<a name="Numeric-Array-Subscripts"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Controlling-Scanning" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Uninitialized-Subscripts" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_00a8ae_0095_00b0aa_0080_00bca_00bd_009ca_00b8_00baae_0095_00b0c_00bb_0084a_00b8_008bae_00a0_0087"></a>
<h2 class="section">8.2 用数值作为数组下标</h2>

<a name="index-numbers_002c-as-array-subscripts"></a>
<a name="index-arrays_002c-numeric-subscripts"></a>
<a name="index-subscripts-in-arrays_002c-numbers-as"></a>
<a name="index-CONVFMT-variable_002c-and-array-subscripts"></a>
<p>要记住数组的一个重要点就是<em>数组的下标总是字串</em>。
当数值用于下标，它会在用于下标前被转换为字串（查看 <a href="#Conversion">在字串与数值之间进行转换</a>）。
这意味着，预定义变量 <code>CONVFMT</code> 会影响你的程序访问数组的元素。例如：
</p>
<div class="example">
<pre class="example">xyz = 12.153
data[xyz] = 1
CONVFMT = &quot;%2.2f&quot;
if (xyz in data)
    printf &quot;%s is in data\n&quot;, xyz
else
    printf &quot;%s is not in data\n&quot;, xyz
</pre></div>

<p>程序会打印 &lsquo;<samp>12.15 is not in data</samp>&rsquo;。
第一条语句给了 <code>xyz</code> 一个数值值。
<code>data[xyz]</code> 用字串 <code>&quot;12.153&quot;</code> 赋给 <code>data</code> 的下标
（使用默认的 <code>CONVFMT</code> 转换值 <code>&quot;%.6g&quot;</code>）。
因此，数组元素 <code>data[&quot;12.153&quot;]</code> 被赋值为 1。程序然后改变 <code>CONVFMT</code> 的值。
测试语句 &lsquo;<samp>(xyz in data)</samp>&rsquo; 产生一个 <code>xyz</code> 的新字串值——这次则是 <code>&quot;12.15&quot;</code>
——因为 <code>CONVFMT</code> 的值只允许有两个有效位。这个测试会失败，因为 <code>&quot;12.15&quot;</code> 与 <code>&quot;12.153&quot;</code> 是不同的。
</p>
<a name="index-converting-integer-array-subscripts"></a>
<a name="index-integer-array-indices"></a>
<p>根据转换规则（查看 <a href="#Conversion">在字串与数值之间进行转换</a>），整数总是会转换为整数的字串，不管 <code>CONVFMT</code> 的值是什么。因此下面的例子可以工作：
</p>
<div class="example">
<pre class="example">for (i = 1; i &lt;= maxsub; i++)
    <i>do something with</i> array[i]
</pre></div>

<p>“整数总是转换为整数字串”规则在数组索引中有另一个结果。八进制与十六进制常量
（查看 <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>）
在内部会转换为数值，它们的原型形式会被丢弃。这就是说，<code>array[17]</code>，<code>array[021]</code> 与 <code>array[0x11]</code> 都是指向同一个元素！
</p>
<p>与 <code>awk</code> 许多的事情一样，大部份时间下，事情都与你所期望它所应该是那样的方式工作。但是对于实际规则具有精确知识是非常有用的，因为它们有时会让你的程序表现出一些很微妙的结果。
</p>
<hr>
<a name="Uninitialized-Subscripts"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Numeric-Array-Subscripts" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Delete" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_00a8ae_009c_00aaaa_0088_009daa_00a7_008baa_008c_0096c_009a_0084ae_0095_00b0aa_0080_00bca_00bd_009ca_00b8_00baae_0095_00b0c_00bb_0084a_00b8_008bae_00a0_0087"></a>
<h2 class="section">8.3 用未初始化的数值作为数组下标</h2>

<a name="index-variables_002c-uninitialized_002c-as-array-subscripts"></a>
<a name="index-uninitialized-variables_002c-as-array-subscripts"></a>
<a name="index-subscripts-in-arrays_002c-uninitialized-variables-as"></a>
<a name="index-arrays_002c-subscripts_002c-uninitialized-variables-as"></a>
<p>假如有必要写一个程序来将输入的数据逆序打印。一个合理的尝试来这么做（带上一些测试数据）可能如下：
</p>
<div class="example">
<pre class="example">$ <kbd>echo 'line 1</kbd>
&gt; <kbd>line 2</kbd>
&gt; <kbd>line 3' | awk '{ l[lines] = $0; ++lines }</kbd>
&gt; <kbd>END {</kbd>
&gt;     <kbd>for (i = lines - 1; i &gt;= 0; i--)</kbd>
&gt;        <kbd>print l[i]</kbd>
&gt; <kbd>}'</kbd>
-| line 3
-| line 2
</pre></div>

<p>不幸的是，第一行的数据不会出现在输出中！
</p>
<p>初看起来，我们认为这个程序应该可以工作。变量 <code>lines</code> 是未初始化的，
而一个未初始化的变量具有值为 0。因此，<code>awk</code> 应该会打印 <code>l[0]</code> 的值。
</p>
<p>这里的问题是 <code>awk</code> 数组中的下标<em>总是</em>字符串。
未初始化的变量被用作字符串时，其值为 <code>&quot;&quot;</code>，而不是 0。
所以，&lsquo;<samp>line 1</samp>&rsquo; 最终被存在 <code>l[&quot;&quot;]</code> 中。下面的版本则可以正确工作：
</p>
<div class="example">
<pre class="example">{ l[lines++] = $0 }
END {
    for (i = lines - 1; i &gt;= 0; i--)
       print l[i]
}
</pre></div>

<p>在这里，&lsquo;<samp>++</samp>&rsquo; 强制 <code>lines</code> 成为一数值，所在使得其“旧值”
（因为是未初始化的变量，因此就无所谓旧值，这里是为表述方便。——译者）为数值 0。然后其被转换为 <code>&quot;0&quot;</code> 作为数组的下标。
</p>
<a name="index-null-strings_002c-as-array-subscripts"></a>
<a name="index-dark-corner_002c-array-subscripts"></a>
<a name="index-lint-checking_002c-array-subscripts"></a>
<p>就算不是特别常用，空串（<code>&quot;&quot;</code>）也是一个有效的数组下标。
(d.c.)
<code>gawk</code> 会对使用空串作为下标发出警告，但这只在命令行参数中指定了 &lsquo;<samp>--lint</samp>&rsquo; 参数（查看 <a href="#Options">命令行参数</a>）。
</p>
<hr>
<a name="Delete"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Uninitialized-Subscripts" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Multidimensional" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="delete-e_00af_00adaa_008f_00a5"></a>
<h2 class="section">8.4 <code>delete</code> 语句</h2>
<a name="index-delete-statement"></a>
<a name="index-deleting-elements-in-arrays"></a>
<a name="index-arrays_002c-elements_002c-deleting"></a>
<a name="index-elements-in-arrays_002c-deleting"></a>

<p>为了删除数组的一个独立元素，可以使用 <code>delete</code> 语句：
</p>
<div class="example">
<pre class="example">delete <var>array</var>[<var>index-expression</var>]
</pre></div>

<p>一旦数组中的一个元素被删除，那个元素的值就不再可用。
就好像那个元素从来没有被使用到或者也从来没有被赋值。下面的例子从数组中删除一个元素：
</p>
<div class="example">
<pre class="example">for (i in frequencies)
    delete frequencies[i]
</pre></div>

<p>这个例子删除数组 <code>frequencies</code> 的所有元素。只要一个元素被删除了，
后续的 <code>for</code> 语句来扫描数组时就不会再报告被删除的元素，并且用 <code>in</code> 操作符来检查被删除的元素的是否存在会返回 0（即 false）：
</p>
<div class="example">
<pre class="example">delete foo[4]
if (4 in foo)
    print &quot;This will never be printed&quot;
</pre></div>

<a name="index-null-strings_002c-and-deleting-array-elements"></a>
<p>要注意的是，删除一个元素给元素赋一个空值（空串，<code>&quot;&quot;</code>）是<em>两码事</em>。如：
</p>
<div class="example">
<pre class="example">foo[4] = &quot;&quot;
if (4 in foo)
  print &quot;This is printed, even though foo[4] is empty&quot;
</pre></div>

<a name="index-lint-checking_002c-array-elements"></a>
<p>删除一个不存在的元素并不是一个错误。但是，如果在命令行中指定了 &lsquo;<samp>--lint</samp>&rsquo; 参数（查看 <a href="#Options">命令行参数</a>），
当删除数组中不存在的元素的时候，<code>gawk</code> 会产生一个告警信息。
</p>
<a name="index-common-extensions_002c-delete-to-delete-entire-arrays"></a>
<a name="index-extensions_002c-common_002c-delete-to-delete-entire-arrays"></a>
<a name="index-arrays_002c-deleting-entire-contents"></a>
<a name="index-deleting-entire-arrays"></a>
<a name="index-delete-array"></a>
<a name="index-differences-in-awk-and-gawk_002c-array-elements_002c-deleting"></a>
<p>通过在 <code>delete</code> 语句后面的数组中，不写下标时，可以用一个语句就可删除数组的所有元素，如下：
</p>

<div class="example">
<pre class="example">delete <var>array</var>
</pre></div>

<p>使用这种版本的 <code>delete</code> 语句大概要比使用等同的一次删除一个元素的循环要快大概 3 倍。
</p>
<p>这种类型的 <code>delete</code> 语句也被 BWK <code>awk</code> 与 <code>mawk</code> 所支持，很多其他版本的实现也支持。
</p>
<a name="index-Brian-Kernighan_0027s-awk-10"></a>
<blockquote>
<p><b>提示:</b> 很多年以来，使用 <code>delete</code> 语句不带下标是一个通用的扩展。在 2012 年的 9 月，它被接受并包含到 POSIX 标准中。
查看 <a href="http://austingroupbugs.net/view.php?id=544">Austin Group 网站</a>。
</p></blockquote>

<a name="index-portability_002c-deleting-array-elements"></a>
<a name="index-Brennan_002c-Michael-3"></a>
<p>下面的语句提供了一种可移植但是不是特别明显的方式来将数组清除： 
<a name="DOCF46" href="#FOOT46">(46)</a>
</p>
<div class="example">
<pre class="example">split(&quot;&quot;, array)
</pre></div>

<a name="index-split_0028_0029-function_002c-array-elements_002c-deleting"></a>
<p><code>split()</code> 函数（查看 <a href="#String-Functions">字串操作函数</a>）会首先清除目标数组。这个调用请求分割一个空串。因为没有数据用来分割，函数只是简单地清除数组然后返回。
</p>
<blockquote>
<p><b>CAUTION:</b> 注意：删除数组中的所有元素不会改变它的类型，你不可清除一个数组，然后使用数组的名字来作为一个标量名（比如一个常规的变量）。例如，下面的例子不会工作：
</p>
<div class="example">
<pre class="example">a[1] = 3
delete a
a = 3
</pre></div>
</blockquote>

<hr>
<a name="Multidimensional"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Delete" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Multiscanning" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a4_009ac_00bb_00b4ae_0095_00b0c_00bb_0084"></a>
<h2 class="section">8.5 多维数组</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Multiscanning">8.5.1 遍历多维数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Scanning multidimensional arrays.
</td></tr>
</table>

<a name="index-subscripts-in-arrays_002c-multidimensional"></a>
<a name="index-arrays_002c-multidimensional"></a>
<p><em>多维数组</em>是这样的数组，其元素的标识是通过一连串的索引而不是单个索引来标识的。例如，两维数组需要两个索引。
一般的方式（包括 <code>awk</code> 在内的许多语言）要参考到两维数 <code>grid</code> 中的元素，则用 <code>grid[<var>x</var>,<var>y</var>]</code>。
</p>
<a name="index-SUBSEP-variable_002c-and-multidimensional-arrays"></a>
<p>在 <code>awk</code> 中的多维数组是通过将索引连接成字串来实现的。<code>awk</code> 将索引转换为字串
（查看 <a href="#Conversion">在字串与数值之间进行转换</a>）然后将它他连接在一起，并在它们之间存放分隔符。
这样可以创建一个单一的字串来描述分离索引的值。合并后的字串用作普通的一维数组的一个索引。分隔符则使用内建变量 <code>SUBSEP</code> 的值。
</p>
<p>例如，假设我们对表达式 &lsquo;<samp>foo[5,12] = &quot;value&quot;</samp>&rsquo; 求值，并且 <code>SUBSEP</code> 的值为 <code>&quot;@&quot;</code> 的时候。
数值 5 与 12 会被转换成字串并且用 &lsquo;<samp>@</samp>&rsquo; 连接它们，从而产生 <code>&quot;5@12&quot;</code>；
所以，数组元素 <code>foo[&quot;5@12&quot;]</code> 的值被设置成 <code>&quot;value&quot;</code>。
</p>
<p>一旦元素被存储，<code>awk</code> 就不再记得它是存成单个的索引还是用一串索引。
&lsquo;<samp>foo[5,12]</samp>&rsquo; 与 &lsquo;<samp>foo[5&nbsp;SUBSEP&nbsp;12]</samp>&rsquo; 总是等同的。
</p>
<p><code>SUBSEP</code> 的默认值是 <code>&quot;\034&quot;</code>，这包含了非打印字符，并不会出现在 <code>awk</code> 程序中，
或者不会出现在输入数据中。使用一个不太可能的字符的用处来自于这样的事实，
即索引值中包含一个串匹配 <code>SUBSEP</code> 可以导致合并后的字串的含义不明。
如 <code>SUBSEP</code> 是 <code>&quot;@&quot;</code>，则 &lsquo;<samp>foo[&quot;a@b&quot;,&nbsp;&quot;c&quot;]</samp>&rsquo; 与 &lsquo;<samp>foo[&quot;a&quot;,&nbsp;&quot;b@c&quot;]</samp>&rsquo; 则没办法区分开来，因为两者都会存成 &lsquo;<samp>foo[&quot;a@b@c&quot;]</samp>&rsquo; 。
</p>
<a name="index-in-operator_002c-index-existence-in-multidimensional-arrays"></a>
<p>要测试一个特定的索引序列是否存在于多维数组中，使用与一维数组相同的 <code>in</code> 操作符。
将整个序列写在气括号中，并用逗号分隔，并做为 <code>in</code> 的左操作数：
</p>
<div class="example">
<pre class="example">if ((<var>subscript1</var>, <var>subscript2</var>, &hellip;) in <var>array</var>)
    &hellip;
</pre></div>

<p>下面是一个将输入作为一个域的二维数组的例子，然后将数组顺时针转 90 度（注下），再打印结果。假设所有的行都相相同数目的元素：
</p>
<div class="example">
<pre class="example">{
     if (max_nf &lt; NF)
          max_nf = NF
     max_nr = NR
     for (x = 1; x &lt;= NF; x++)
          vector[x, NR] = $x
}

END {
     for (x = 1; x &lt;= max_nf; x++) {
          for (y = max_nr; y &gt;= 1; --y)
               printf(&quot;%s &quot;, vector[x, y])
          printf(&quot;\n&quot;)
     }
}
</pre></div>

<p>如果输入如下：
</p>
<div class="example">
<pre class="example">1 2 3 4 5 6
2 3 4 5 6 1
3 4 5 6 1 2
4 5 6 1 2 3
</pre></div>

<p>则程序会产生下面的输出：
</p>
<div class="example">
<pre class="example">4 3 2 1
5 4 3 2
6 5 4 3
1 6 5 4
2 1 6 5
3 2 1 6
</pre></div>

<hr>
<a name="Multiscanning"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Multidimensional" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Multidimensional" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays-of-Arrays" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0081_008daa_008e_0086aa_00a4_009ac_00bb_00b4ae_0095_00b0c_00bb_0084-1"></a>
<h3 class="subsection">8.5.1 遍历多维数组</h3>

<p>没有特殊的 <code>for</code> 语句用来进行“多维”数组的遍历。也不会有这么一个，因为事实上，<code>awk</code> 根本就没有二维数组或者元素。
只有一个多维<em>方式</em>来访问数组。
</p>
<a name="index-subscripts-in-arrays_002c-multidimensional_002c-scanning"></a>
<a name="index-arrays_002c-multidimensional_002c-scanning"></a>
<a name="index-scanning-multidimensional-arrays"></a>
<p>但是，如果你的程序有这样的数组总是像多维数组一样来访问，你可以用 <code>split()</code> 函数
（查看 <a href="#String-Functions">字串操作函数</a>）来获得 <code>for</code> 语句一样的扫描效果（查看 <a href="#Scanning-an-Array">遍历数组元素</a>）。
它是以下面的方式来工作的：
</p>
<div class="example">
<pre class="example">for (combined in array) {
    split(combined, separate, SUBSEP)
    &hellip;
}
</pre></div>

<p>这里将变量 <code>combined</code> 为数组中每个索引的连接组合，然后用 <code>SUBSEP</code> 的值，
将它分割为独立的索引。单独的索引然后就可以成为数组 <code>separate</code> 的元素。
</p>
<p>因此，如果前面的值存在 <code>array[1, &quot;foo&quot;]</code> 里，则会有索引为 <code>&quot;1\034foo&quot;</code> 的元素存在数组中。
（回忆一下 <code>SUBSEP</code> 的默认值是 “\034”。）
早早晚晚，<code>for</code> 语句会找到索引，并将变量 <code>combined</code> 设置成 <code>&quot;1\034foo&quot;</code> 来进行迭代。
然后 <code>split()</code> 函数会像下面这样来调用：
</p>
<div class="example">
<pre class="example">split(&quot;1\034foo&quot;, separate, &quot;\034&quot;)
</pre></div>

<p>结果会将 <code>separate[1]</code> 设置成 <code>&quot;1&quot;</code>，<code>separate[2]</code> 为 <code>&quot;foo&quot;</code>。
太神奇了，原来的分离的索引序列又被恢复了。
</p>

<hr>
<a name="Arrays-of-Arrays"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Multiscanning" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a4_009ac_00bb_00b4ae_0095_00b0c_00bb_0084-1"></a>
<h2 class="section">8.6 多维数组</h2>
<a name="index-arrays-of-arrays"></a>

<p><code>gawk</code> 超越了标准的 <code>awk</code> 的多维数组的访问，并提供了真正的多维数组。子数组的元素通过它们在方括号中的下标来取得，就是主数组元素一样。
例如，下面创建一个两元素的子数组，索引为主数组 <code>a</code> 的 <code>1</code>：
</p>
<div class="example">
<pre class="example">a[1][1] = 1
a[1][2] = 2
</pre></div>

<p>这里模拟了一个真正的两维数组。每一个子数组元素包含另一个子数组作为值，进而也可以包含其他的数组。通过这样的方式，你可以创建三维或者多维的数组。
索引可以是 <code>awk</code> 所任意表达式，包括用逗号分隔的标量（例如常规的 <code>awk</code> 模拟多维的下标）。因此，下面代码在 <code>gawk</code> 中是有效的：
</p>
<div class="example">
<pre class="example">a[1][3][1, &quot;name&quot;] = &quot;barney&quot;
</pre></div>

<p>每一个子数组与主数组可以有不同的长度。实际上，数组的元素，或者它的子数组不必要都包含相同类型。
这意味着，主数组与它的子数组在结构上，可以是非矩形的，即是锯齿形的。
你可以给主数组 <code>a</code> 索引为 <code>4</code> 的元素赋值一个标量，就算是 <code>a[1]</code> 本身是一个数组而不是一个标量：
</p>
<div class="example">
<pre class="example">a[4] = &quot;An element in a jagged array&quot;
</pre></div>

<p><em>维度</em>，<em>行</em>，<em>列</em>这样的术语用在这样的数组中是没有含义的，但是我们使用“维度”表示要访问一个已经存在的元素的所需要的索引数的最大值。
任意元素的类型，一旦被赋值，就不能通过赋值一个不同类型的值来改变它的类型。你必须先删除当前的元素，这样使 <code>gawk</code> 可以有效地丢弃在那个索引下的元素：
</p>
<div class="example">
<pre class="example">delete a[4]
a[4][5][6][7] = &quot;An element in a four-dimensional array&quot;
</pre></div>

<p>这里删除索引为 <code>4</code> 的标量值，然后插入一个包含一个标量的三层的内嵌子数组。你也可以删除整个的子数组的子数组的了数组：
</p>
<div class="example">
<pre class="example">delete a[4][5]
a[4][5] = &quot;An element in subarray a[4]&quot;
</pre></div>

<p>但是要记住，你不可以删除主数组 <code>a</code>，然后将其用作一个标量。
</p>
<p>内置函数中使用数组作为参数时，函数也可以使用子数组。例如，下面的代码段使用 <code>length()</code>
（查看 <a href="#String-Functions">字串操作函数</a>）来确定主数组 <code>a</code> 与其子数组的元素个数：
</p>
<div class="example">
<pre class="example">print length(a), length(a[1]), length(a[1][3])
</pre></div>

<p>对主数组 <code>a</code> 的输出结果如下：
</p>
<div class="example">
<pre class="example">2, 3, 1
</pre></div>

<p>&lsquo;<samp><var>subscript</var> in <var>array</var></samp>&rsquo; 表达式（查看 <a href="#Reference-to-Elements">指向数组元素</a>）
工作原理与正规的 <code>awk</code> 数组以及多维数组的方式相似。
例如测试语句 &lsquo;<samp>1 in a</samp>&rsquo;，&lsquo;<samp>3 in a[1]</samp>&rsquo; 与 &lsquo;<samp>(1, &quot;name&quot;) in a[1][3]</samp>&rsquo; 对于数组 <code>a</code> 都会求值为 1（true）。
</p>
<p>&lsquo;<samp>for (item in array)</samp>&rsquo; 语句（查看 <a href="#Scanning-an-Array">遍历数组元素</a>）可以嵌套，用来扫描一个多维数组的所有元素，
只要它在结构上是矩形的。为了打印两维多维数组的内容（标量）（在数组中，它的第一层本身是一个数组，但不必是有相同的长度），你可以使用下面的代码：
</p>
<div class="example">
<pre class="example">for (i in array)
    for (j in array[i])
        print array[i][j]
</pre></div>

<p><code>isarray()</code> 函数（查看 <a href="#Type-Functions">获取类型信息</a>）
可以让你测试数组的元素是否为数组：
</p>
<div class="example">
<pre class="example">for (i in array) {
    if (isarray(array[i]) {
        for (j in array[i]) {
            print array[i][j]
        }
    }
    else
        print array[i]
}
</pre></div>

<p>如果一个事先知道是一个锯齿形的数组，你通常要通过控制语句来解决遍历问题。例如，下面的代码打印主数组 <code>a</code> 的元素：
</p>
<div class="example">
<pre class="example">for (i in a) {
    for (j in a[i]) {
        if (j == 3) {
            for (k in a[i][j])
                print a[i][j][k]
        } else
            print a[i][j]
    }
}
</pre></div>

<p>查看 <a href="#Walking-Arrays">遍历多维数组</a>，来获取用户自定义的函数，其功能就是用来遍历任意维度的多维数组。
</p>
<p>回忆一下参考一个未初始化的数组元素会产生一个 <code>&quot;&quot;</code> 值，即空串。
这有一个非常重要的含义，即当你想使用一个子数组作为参数向函数传递，如下面的代码所呈现的：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { split(&quot;a b c d&quot;, b[1]); print b[1][1] }'</kbd>
error--&gt; gawk: cmd. line:1: fatal: split: second argument is not an array
</pre></div>

<p>要解决这样的问题，首先要通过创建一个任意的索引，以强制 <code>b[1]</code> 成是一个数组：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { b[1][1] = &quot;&quot;; split(&quot;a b c d&quot;, b[1]); print b[1][1] }'</kbd>
-| a
</pre></div>

<hr>
<a name="Arrays-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays-of-Arrays" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-18"></a>
<h2 class="section">8.7 总结</h2>

<ul>
<li>
标准的 <code>awk</code> 提供一维关联数组（通过字串进行索引的数组）。所有的数组都是关联的，数值索引会被自动转换为字串。

</li><li>
数组元素通过 <code><var>array</var>[<var>indx</var>]</code> 进行参考。参考一个不存在的元素，则会创建这个元素。

</li><li>
正确的查看是否给定索引的元素是否存在数组中的方式是使用 <code>in</code> 操作符：&lsquo;<samp><var>indx</var> in <var>array</var></samp>&rsquo;

</li><li>
使用 &lsquo;<samp>for (<var>indx</var> in <var>array</var>) &hellip;</samp>&rsquo; 来描述数组中的每个元素。
在环境体中，<var>indx</var> 会轮流地设置为元素的索引值。

</li><li>
用 &lsquo;<samp>for (<var>indx</var> in <var>array</var>)</samp>&rsquo; 来遍历数组的顺序在 POSIX <code>awk</code> 中是未定义的，并且不同的版本实现是不同的。
<code>gawk</code> 使用通过设置预定义变量 <code>PROCINFO[&quot;sorted_in&quot;]</code> 的值来控制遍历的顺序。

</li><li>
使用 &lsquo;<samp>delete <var>array</var>[<var>indx</var>]</samp>&rsquo; 来删除单个元素。要删除数组中的所有元素，
则使用 &lsquo;<samp>delete <var>array</var></samp>&rsquo; 。后者的特性多年来都是一个通用扩展，但是现在已经标准化了，
但是可能不是所有的被商业版本的 <code>awk</code> 都支持。

</li><li>
标准的 <code>awk</code> 通过用逗号来分隔不同的下标来模拟多维数组。这些下标值会被合并成一个单独的串，
并且使用 <code>SUBSEP</code> 的值来进行分离。通过这种方式创建的下标是没有保存的，所以改变 <code>SUBSEP</code> 的值会导致未预期的结果。
你可以使用 &lsquo;<samp>(<var>sub1</var>, <var>sub2</var>, &hellip;) in <var>array</var></samp>&rsquo; 来查看一个多维数组的相应下标是否存在数组中。

</li><li>
<code>gawk</code> 提供了真正的多维数组。在这样的数组中，你可以在方括号中使用独立的集合来表示每一维。例如 <code>data[row][col]</code>。
数组元素即可以是标量（数值或者字串），也可以是其他的数组类型。

</li><li>
使用 <code>isarray()</code> 内置函数来确定一个数组元素是不是子数组。

</li></ul>


<hr>
<a name="Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arrays" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arrays-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0087_00bdae_0095_00b0"></a>
<h1 class="chapter">9 函数</h1>

<a name="index-functions_002c-built_002din-1"></a>
<a name="index-built_002din-functions"></a>
<p>本章描述 <code>awk</code> 的内置函数，它们被分成三类：数值类，字串类与 I/O 类。
<code>gawk</code> 还提供额外的一些函数用来表示时间的值、或者进行位操作，数组排序，提供类型信息，国际化与本地化程序。
</p>
<p>除了内置函数，<code>awk</code> 也提供写新函数的能力，这样可以在程序的后面进行调用。
本章的下半部份描述了<em>用户自定义</em>函数。
最后，我们探讨间接函数调用，一种 <code>gawk</code> 才有的扩展，这样可以让你在运行时来确定最终来调用什么样的函数。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Built_002din">9.1 内置函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Summarizes the built-in functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#User_002ddefined">9.2 用户自定义函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Describes User-defined functions in detail.
</td></tr>
<tr><td align="left" valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Choosing the function to call at runtime.
</td></tr>
<tr><td align="left" valign="top"><a href="#Functions-Summary">9.4 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Summary of functions.
</td></tr>
</table>

<hr>
<a name="Built_002din"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Calling-Built_002din" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0086_0085c_00bd_00aeaa_0087_00bdae_0095_00b0"></a>
<h2 class="section">9.1 内置函数</h2>

<p><em>内置</em>函数在你的 <code>awk</code> 程序总是可用的。本小节定义了所有的 <code>awk</code> 中的函数，它们中的一些在其他的小节中已经被提到过，在这里进行汇总，你可以方便地参考。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How to call built-in functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Functions that work with numbers, including
                                <code>int()</code>, <code>sin()</code> and <code>rand()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Functions for string manipulation, such as
                                <code>split()</code>, <code>match()</code> and
                                <code>sprintf()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Functions for files and shell commands.
</td></tr>
<tr><td align="left" valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Functions for dealing with timestamps.
</td></tr>
<tr><td align="left" valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Functions for bitwise operations.
</td></tr>
<tr><td align="left" valign="top"><a href="#Type-Functions">9.1.7 获取类型信息</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Functions for type information.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Functions for string translation.
</td></tr>
</table>

<hr>
<a name="Calling-Built_002din"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Numeric-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00b0_0083c_0094_00a8aa_0086_0085c_00bd_00aeaa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">9.1.1 调用内置函数</h3>

<p>为了调用 <code>awk</code> 的内置函数，只需要输入函数的名字，后面跟着放置在括号内的参数列表即可。
例如，&lsquo;<samp>atan2(y + z, 1)</samp>&rsquo; 为调用函数 <code>atan2()</code>，并带有两个参数。
</p>
<a name="index-programming-conventions_002c-functions_002c-calling"></a>
<a name="index-whitespace_002c-functions_002c-calling"></a>
<p>内建函数中函数名与开括号之间的空格会被忽略，但是这不是一个好的编程习惯，应该要避免在它们之间输入空格。用户自定义的函数不允许在这个位置有空格，因此一个简单的编程习惯就可以避免这样的错误——就是不要在函数名后面插入空格。
</p>
<a name="index-troubleshooting_002c-gawk_002c-fatal-errors_002c-function-arguments"></a>
<a name="index-gawk_002c-function-arguments-and"></a>
<a name="index-differences-in-awk-and-gawk_002c-function-arguments-_0028gawk_0029"></a>
<p>每个内置函数都接收特定数目的参数。在某些情况下，参数可以省略。对于省略参数的默认值函数与函数间是不同的，并且会单独进行说明。
一些 <code>awk</code> 实现中，有一些额外会被忽略。但是，在 <code>gawk</code> 中，给内置函数一个额外的参数是一个致使错误。
</p>
<p>当函数被调用时，生成函数实际参数的表达式会在调用执行前进行求值。例如，下面的代码片段中：
</p>
<div class="example">
<pre class="example">i = 4
j = sqrt(i++)
</pre></div>

<a name="index-evaluation-order_002c-functions"></a>
<a name="index-functions_002c-built_002din_002c-evaluation-order"></a>
<a name="index-built_002din-functions_002c-evaluation-order"></a>
<p>变量 <code>i</code> 会在调用 <code>sqrt()</code> 之前递增为值 5，但是调用时会用值 4 作为实际的参数。作为函数参数的表达式的求值的顺序是未定义的。所以，要避免写从左到右，或者从右到左进行求值的程序。如：
</p>
<div class="example">
<pre class="example">i = 5
j = atan2(++i, i *= 2)
</pre></div>

<p>如果求值的顺序是从左到右，则 <code>i</code> 会为 6，然后成为 12。则会用 6 与 12 两个值调用 <code>atan2()</code>。但是如果顺序为从右到左，<code>i</code> 首先为 10，然后为 11，则 <code>atan2()</code> 会用 11，与 10 来进行调用。
</p>
<hr>
<a name="Numeric-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Calling-Built_002din" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#String-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0aa_0080_00bcaa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">9.1.2 数值函数</h3>
<a name="index-numeric-functions"></a>

<p>下面的列表描述了所有的用于数值处理的内置函数。可选的参数用方括号&nbsp;([&nbsp;]): 包含起来：
</p>
<dl compact="compact">
<dt><code>atan2(<var>y</var>, <var>x</var>)</code></dt>
<dd><a name="index-atan2_0028_0029-function"></a>
<a name="index-arctangent"></a>
<p>返回 <code><var>y</var> / <var>x</var></code> 弧度的反正切值。你可以使用 &lsquo;<samp>pi = atan2(0, -1)</samp>&rsquo; 来求得 <i>pi</i> 的值。
</p>
</dd>
<dt><code>cos(<var>x</var>)</code></dt>
<dd><a name="index-cos_0028_0029-function"></a>
<a name="index-cosine"></a>
<p>返回 <var>x</var> 的余弦值，<var>x</var> 为弧度。
</p>
</dd>
<dt><code>exp(<var>x</var>)</code></dt>
<dd><a name="index-exp_0028_0029-function"></a>
<a name="index-exponent"></a>
<p>返回 <var>x</var> 的自然幂（<code>e ^ <var>x</var></code>）或者 <var>x</var> 的值超过范围则报错。<var>x</var> 的范围依赖于你的机器的浮点数表示。
</p>
</dd>
<dt><code>int(<var>x</var>)</code></dt>
<dd><a name="index-int_0028_0029-function"></a>
<a name="index-round-to-nearest-integer"></a>
<p>返回最接近于 <var>x</var> 的整数，其值在 <var>x</var> 与 0 之间，并向 0 进行截取。
如 <code>int(3)</code> 为 3，<code>int(3.9)</code> 为 3，<code>int(-3.9)</code> 为 -3，<code>int(-3)</code> 也为 -3。
</p>
</dd>
<dt><code>log(<var>x</var>)</code></dt>
<dd><a name="index-log_0028_0029-function"></a>
<a name="index-logarithm"></a>
<p>如果 <var>x</var> 为正数，返回 <var>x</var> 的自然对数，否则在 IEEE 754 的系统上返回 <code>NaN</code> （“not a number”）。
此外，如果 <var>x</var> 为负数，<code>gawk</code> 还会打印一个警告信息。
</p>
</dd>
<dt><code>rand()</code></dt>
<dd><a name="index-rand_0028_0029-function"></a>
<a name="index-random-numbers_002c-rand_0028_0029_002fsrand_0028_0029-functions"></a>
<p>返回一个随机数。<code>rand()</code> 的值一致地分布在 0 与 1 之间，值可以为 0，但不会等于 1。 
<a name="DOCF47" href="#FOOT47">(47)</a>
</p>
<p>通常情况下，你需要的是随机的整数。下面是一个用户自定义的函数，此函数可以用来产生小于 <var>n</var> 的随机非负整数：
</p>
<div class="example">
<pre class="example">function randint(n)
{
    return int(n * rand())
}
</pre></div>

<p>乘法产生一个随机数大于等于 0，但小于 <code>n</code>。使用 <code>int()</code> 因此可以使得结果成为 0 到 <code>n</code> - 1 之间的整数。
</p>
<p>下面的例子使用一个相似的函数来产生在 1 到 <var>n</var> 之间的随机整数。这个程序会为每个输入记录打印一个新的随机数：
</p>
<div class="example">
<pre class="example"># Function to roll a simulated die.
function roll(n) { return 1 + int(rand() * n) }

# Roll 3 six-sided dice and
# print total number of points.
{
    printf(&quot;%d points\n&quot;, roll(6) + roll(6) + roll(6))
}
</pre></div>

<a name="index-seeding-random-number-generator"></a>
<a name="index-random-numbers_002c-seed-of"></a>
<blockquote>
<p><b>注意:</b> 在大多数的 <code>awk</code> 实现中，包括 <code>gawk</code>，每次运行 <code>awk</code> 时，<code>rand()</code> 都从相同的开始数，或者种子起产生随机数。
<a name="DOCF48" href="#FOOT48">(48)</a>
所以，程序每次运行都产生相同的结果。在 <code>awk</code> 一次运行中产生的数值是随机的，但是每次运行时产生的随机数却是可预测的。这用一调试时非常有用，但是如果你想程序每次使用的时候做不同的事情，你必须改变 seed 为每次运行都不相同的值。要这么做，就调用 <code>srand()</code> 函数。
</p></blockquote>

</dd>
<dt><code>sin(<var>x</var>)</code></dt>
<dd><a name="index-sin_0028_0029-function"></a>
<a name="index-sine"></a>
<p>返回弧度 <var>x</var> 的正弦值。
</p>
</dd>
<dt><code>sqrt(<var>x</var>)</code></dt>
<dd><a name="index-sqrt_0028_0029-function"></a>
<a name="index-square-root"></a>
<p>返回 <var>x</var> 的正平方根。<code>gawk</code> 在 <var>x</var> 为负值时会打印一个告警。<code>sqrt(4)</code> 的值是 2。
</p>
</dd>
<dt><code>srand(</code>[<var>x</var>]<code>)</code></dt>
<dd><a name="index-srand_0028_0029-function"></a>
<p>设置开始点，或者种子，用来产生相对于 <var>x</var> 的随机数。
</p>
<p>每一个种子都会产生特定序列的随机数。
<a name="DOCF49" href="#FOOT49">(49)</a>
所以，如果种子每次都设置成相同的值，则随机数每次都会产生一样。
</p>
<blockquote>
<p><b>注意:</b> 不同的 <code>awk</code> 实现使用不同的内部随机数产生器。不要希望 <code>awk</code> 程序被不同版本的 <code>awk</code> 执行时会产生相同的随机数序列。
</p></blockquote>

<p>如果在 &lsquo;<samp>srand()</samp>&rsquo; 函数中省略了 <var>x</var>，则会使用当前的日期与当天的时间来作为种子。这种方式下取得的随机数是真正不可预测的。
</p>
<p><code>srand()</code> 返回的值是前一个种子的值。这可以使得很容易来跟踪种子，以便你需要产生一致的随机数序列。
</p>
<p>POSIX 没有指定初始的种子值，因此在不同的 <code>awk</code> 实现中是不同的。
</p></dd>
</dl>

<hr>
<a name="String-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Numeric-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Gory-Details" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ad_0097a_00b8_00b2ae_0093_008da_00bd_009caa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">9.1.3 字串操作函数</h3>

<a name="index-string_002dmanipulation-functions"></a>

<p>本小节我们来讨论一下查找或者更改一个或者一些串的文本。
</p>
<p><code>gawk</code> 可以理解本本语言设置（查看 see section <a href="#Locales">哪里造成差异</a>）并且对字串的处理都是根据<em>字符</em>来的，而不是<em>字节</em>。
这个区别在理解本地语言设置中，一个字符需要多个字节来表示的时候非常重要。所以，像 <code>length()</code> 函数会返回字串中的字符数，而不是用来表示这些字符的字节数。
相似地，<code>index()</code> 是返回字符的索引，而不是字节的索引。
</p>
<blockquote>
<p><b>注意:</b> 有很多的函数会处理字串的索引。对于这此函数，字串的第一个字符的索引为 1。这个与 C 以及其派生的语言不同，在这些语言中，第一个字符的索引位置为 0。你需要记住这个区别，以正确处理索引的计算，尤其是你已经习惯了 C 的情况。
</p></blockquote>

<p>下面的列表中，可选的参数放在方括号中&nbsp;([&nbsp;]).。有几个函数用来处理字串替换，完整的讨论会在 <code>sub()</code> 函数的说明中给出，并且以此为结束，因为列表是按字母顺序排序的。
</p>
<p>那些特定于 <code>gawk</code> 的函数用井号字符（&lsquo;<samp>#</samp>&rsquo;）标识。它们在兼容模式中不可用（查看 <a href="#Options">命令行参数</a>）：
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                More than you want to know about &lsquo;<samp>\</samp>&rsquo; and
                                &lsquo;<samp>&amp;</samp>&rsquo; with <code>sub()</code>, <code>gsub()</code>, and
                                <code>gensub()</code>.
</td></tr>
</table>

<dl compact="compact">
<dt><code>asort(</code><var>source</var> [<code>,</code> <var>dest</var> [<code>,</code> <var>how</var> ] ]<code>) #</code></dt>
<dt><code>asorti(</code><var>source</var> [<code>,</code> <var>dest</var> [<code>,</code> <var>how</var> ] ]<code>) #</code></dt>
<dd><a name="index-asorti_0028_0029-function-_0028gawk_0029"></a>
<a name="index-sort-array"></a>
<a name="index-arrays_002c-elements_002c-retrieving-number-of"></a>
<a name="index-asort_0028_0029-function-_0028gawk_0029"></a>
<a name="index-sort-array-indices"></a>
<p>这两个函数的行为是类似的，因此在一起描述。
</p>
<blockquote>
<p><b>提示:</b> 下面的描述忽略了第三个参数，<var>how</var>，因为需要理解目前我们还没有讨论到的特性。所以，这里讨论有意简化了。（我们后面会提供所有的细节，查看 <a href="#Array-Sorting-Functions">用 <code>gawk</code> 对数组进行值与键的排序</a>，来获取所有的信息。）
</p></blockquote>

<p>两个函数都返回数组 <var>source</var> 中的元素的个数。对于 <code>asort()</code>，<code>gawk</code> 对 <var>source</var> 的值进行排序，并替换经过排序的值的索引为由 1 开始连续整数。如果可选的数组 <var>dest</var> 存在，则 <var>source</var> 的值会复制到 <var>dest</var> 中。<var>dest</var> 则也是经过排序的，而 <var>source</var> 的索引则保持不变。
</p>
<a name="index-gawk_002c-IGNORECASE-variable-in-3"></a>
<p>当进行字串比较时，<code>IGNORECASE</code> 会影响排序（查看 see section <a href="#Array-Sorting-Functions">用 <code>gawk</code> 对数组进行值与键的排序</a>）。
如果 <var>source</var> 数组包含了子数组（查看 see section <a href="#Arrays-of-Arrays">多维数组</a>），它们会在所有的标量值的后面。
子数组<em>不会</em>再进行递归排序。
</p>
<p>例如，<code>a</code> 的内容如下：
</p>
<div class="example">
<pre class="example">a[&quot;last&quot;] = &quot;de&quot;
a[&quot;first&quot;] = &quot;sac&quot;
a[&quot;middle&quot;] = &quot;cul&quot;
</pre></div>

<p>调用 <code>asort()</code>:
</p>
<div class="example">
<pre class="example">asort(a)
</pre></div>

<p><code>a</code> 内容的结果如下：
</p>
<div class="example">
<pre class="example">a[1] = &quot;cul&quot;
a[2] = &quot;de&quot;
a[3] = &quot;sac&quot;
</pre></div>

<p><code>asorti()</code> 函数与 <code>asort()</code> 类型，但是只对<em>索引</em>排序，而不是针对值进行排序。
所以，在前面的例子中，<code>a</code> 用同样的索引与值，调用 &lsquo;<samp>asorti(a)</samp>&rsquo; 则产生如下结果：
</p>
<div class="example">
<pre class="example">a[1] = &quot;first&quot;
a[2] = &quot;last&quot;
a[3] = &quot;middle&quot;
</pre></div>

</dd>
<dt><code>gensub(<var>regexp</var>, <var>replacement</var>, <var>how</var></code> [<code>, <var>target</var></code>]<code>) #</code></dt>
<dd><a name="index-gensub_0028_0029-function-_0028gawk_0029-1"></a>
<a name="index-search-and-replace-in-strings"></a>
<a name="index-substitute-in-string"></a>
<p>搜索匹配正则表达式 <var>regexp</var> 的目标字串，如果 <var>how</var> 是以 &lsquo;<samp>g</samp>&rsquo; 或者 &lsquo;<samp>G</samp>&rsquo; 开如的字串，
则用 <var>replacement</var> 替换所有匹配的 <var>regexp</var>。
否则 <var>how</var> 将会当面成一个指示哪一个要进行替换的数值。如果没有提供 <var>target</var> 参数，则使用 <code>$0</code> 。
函数返回经过修改的字串，原始的字串则<em>不会</em>变化。
</p>
<p><code>gensub()</code> 是一个通用的替换函数。它的目的是提供比标准的 <code>sub()</code> 与 <code>gsub()</code> 函数多一个特性。
</p>
<p><code>gensub()</code> 提供一个额外的特性是 <code>sub()</code> 与 <code>gsub()</code> 所没有的，即：在 <var>replacement</var> 文本中，指定一个 <var>regexp</var> 组件的能力。这个通过在 <var>regexp</var> 中使用括号来标志组件，然后通过在 <var>replacement</var> 中用 &lsquo;<samp>\<var>N</var></samp>&rsquo; 来指定，这里 <var>N</var> 是一个从 0 到 9 的数字。如：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk '</kbd>
&gt; <kbd>BEGIN {</kbd>
&gt;      <kbd>a = &quot;abc def&quot;</kbd>
&gt;      <kbd>b = gensub(/(.+) (.+)/, &quot;\\2 \\1&quot;, &quot;g&quot;, a)</kbd>
&gt;      <kbd>print b</kbd>
&gt; <kbd>}'</kbd>
-| def abc
</pre></div>

<p>用 <code>sub()</code> 函数，你必须指定两个反斜杠来在字串中包含一个。在替换文本中，&lsquo;<samp>\0</samp>&rsquo; 的序列表示整个匹配的文本，如字符 &lsquo;<samp>&amp;</samp>&rsquo; 所表示的一样。
</p>
<p>下面的例子显示了你可以使用第三个参数来控制哪个匹配的正则表达式可以被替换：
</p>
<div class="example">
<pre class="example">$ <kbd>echo a b c a b c |</kbd>
&gt; <kbd>gawk '{ print gensub(/a/, &quot;AA&quot;, 2) }'</kbd>
-| a b c AA b c
</pre></div>

<p>在这个例子中，<code>$0</code> 是默认的 <var>target</var> 字串。<code>gensub()</code> 返回新的串作为它的结果，这个结果直接传递给 <code>print</code> 用来打印。
</p>
<p>如果 <var>how</var> 这个参数是一个不以 &lsquo;<samp>g</samp>&rsquo; 或者 &lsquo;<samp>G</samp>&rsquo; 开头的串，或者是一个小于等于 0 的数值，则只有一个替换会被执行。如果 <var>how</var> 是 0，<code>gawk</code> 会产生一个告警。
</p>
<p>如果 <var>regexp</var> 没有匹配 <var>target</var>，则 <code>gensub()</code> 的返回值就是原来未经更改的 <var>target</var> 的值。
</p>
</dd>
<dt><code>gsub(<var>regexp</var>, <var>replacement</var></code> [<code>, <var>target</var></code>]<code>)</code></dt>
<dd><a name="index-gsub_0028_0029-function-1"></a>
<p>搜索 <var>target</var> 中<em>所有的</em>最左最长的，<em>无重叠</em>的匹配子串，并且用 <var>replacement</var> 进行替换。
<code>gsub()</code> 中的 &lsquo;<samp>g</samp>&rsquo; 表示“global”，其表示替换所有出现的字串。例如：
</p>
<div class="example">
<pre class="example">{ gsub(/Britain/, &quot;United Kingdom&quot;); print }
</pre></div>

<p>会用 &lsquo;<samp>United Kingdom</samp>&rsquo; 替换输入记录所有的 &lsquo;<samp>Britain</samp>&rsquo; 字串。
</p>
<p><code>gsub()</code> 函数返回执行了替换的个数。如果要搜索及变更（<var>target</var>）的变量被省略了，就是使用整个输入记录 <code>$0</code> 。如在 <code>sub()</code> 中，字串 &lsquo;<samp>&amp;</samp>&rsquo; 与 &lsquo;<samp>\</samp>&rsquo; 是特殊字符，并且第三个参数必须是可赋值的。
</p>
</dd>
<dt><code>index(<var>in</var>, <var>find</var>)</code></dt>
<dd><a name="index-index_0028_0029-function"></a>
<a name="index-search-in-string"></a>
<a name="index-find-substring-in-string"></a>
<p>在 <var>in</var> 这个字串中搜索第一次出现的 <var>find</var> 串，并且返回在字串 <var>in</var> 中出现的最开始的位置。考虑下面的例子：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN { print index(&quot;peanut&quot;, &quot;an&quot;) }'</kbd>
-| 3
</pre></div>

<p>如果 <var>find</var> 没有被找到，<code>index()</code> 会返回 0。
If <var>find</var> is not found, <code>index()</code> returns zero.
</p>
<a name="index-dark-corner_002c-regexp-as-second-argument-to-index_0028_0029"></a>
<p>对于 BWK <code>awk</code> 与 <code>gawk</code> ，使用正则表达式常量来作为 <var>find</var> 参数会是一个致命错误。其他的实则允许，他们仅是简单地将正则表达式常量当成与 &lsquo;<samp>$ 0 ~ /regexp/</samp>&rsquo; 一样的表达式。
</p>
</dd>
<dt><code>length(</code>[<var>string</var>]<code>)</code></dt>
<dd><a name="index-length_0028_0029-function"></a>
<a name="index-string-length"></a>
<a name="index-length-of-string"></a>
<p>返回字串 <var>string</var> 的字符数。如果 <var>string</var> 是一个数值，则表示这个数值串的数字位数被返回。
例如 <code>length(&quot;abcde&quot;)</code> 的值为 5。比较 <code>length(15 * 35)</code> 其值则为 3。在这个例子中，
15 * 35 = 525,
而 525 转换成字串 <code>&quot;525&quot;</code>，这里面有三个字符。
</p>
<a name="index-length-of-input-record"></a>
<a name="index-input-record_002c-length-of"></a>
<p>如果没有提供参数，<code>length()</code> 则返回 <code>$0</code> 的长度。
</p>
<a name="index-portability_002c-length_0028_0029-function"></a>
<a name="index-POSIX-awk_002c-functions-and_002c-length_0028_0029"></a>
<blockquote>
<p><b>提示:</b> 在旧版本的 <code>awk</code> 中，<code>length()</code> 函数可以不带括号进行调用。这么做被视为很不好的实践，尽管 2008 版本的 POSIX 标准还是显式地允许它，但那也是为了支持历史实践。为了程序的最大可移植性，在调用时总是使用括号。
</p></blockquote>

<a name="index-dark-corner_002c-length_0028_0029-function"></a>
<p>如果调用 <code>length()</code> 时使用的是一个还没有被使用的变量，<code>gawk</code> 会强制变量为一个标量。其他的 <code>awk</code> 实现会将变量保留为一个无类型的变量。
(d.c.)
如：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { print length(x) ; x[1] = 1 }'</kbd>
-| 0
error--&gt; gawk: fatal: attempt to use scalar `x' as array

$ <kbd>nawk 'BEGIN { print length(x) ; x[1] = 1 }'</kbd>
-| 0
</pre></div>

<p>如果在命令行中指定了 &lsquo;<samp>--lint</samp>&rsquo; 参数，<code>gawk</code> 会对这使用产生一个告警。
</p>
<a name="index-common-extensions_002c-length_0028_0029-applied-to-an-array"></a>
<a name="index-extensions_002c-common_002c-length_0028_0029-applied-to-an-array"></a>
<a name="index-differences-between-gawk-and-awk"></a>
<a name="index-number-of-array-elements"></a>
<a name="index-array_002c-number-of-elements"></a>
<p><code>gawk</code> 与其他的几个 <code>awk</code> 实现，当参数是一个数组时，<code>length()</code> 返回的是数组中的元素个数。 (c.e.)
初看起来，这没什么作用，因为数组的索引并不保证是从 1 到数组中的元素数目。如果在命令行中使用了 &lsquo;<samp>--lint</samp>&rsquo; 选项（查看 <a href="#Options">命令行参数</a>），<code>gawk</code> 会警告说，传递数组参数并不是可移植的。如果指定了 &lsquo;<samp>--posix</samp>&rsquo; 选项，则使用数组作为参数会是一个致命错误（查看 see section <a href="#Arrays"><code>awk</code> 数组</a>）。
</p>
</dd>
<dt><code>match(<var>string</var>, <var>regexp</var></code> [<code>, <var>array</var></code>]<code>)</code></dt>
<dd><a name="index-match_0028_0029-function"></a>
<a name="index-string_002c-regular-expression-match"></a>
<a name="index-match-regexp-in-string"></a>
<p>搜索匹配正则表达式 <var>regexp</var> 的最长最左边的子串，并返回子串开始的字符位置（索引，如果子串是字串 <var>string</var> 的开始，则返回 1 ）。如果没有找到匹配，则返回 0。
</p>
<p><var>regexp</var> 参数即可以是正则表达式常量（<code>/</code>&hellip;<code>/</code>），也可以是一个字串常量（<code>&quot;</code>&hellip;<code>&quot;</code>）。
如果是后者，字串被当成是正则表达式用来进行匹配。查看 <a href="#Computed-Regexps">使用动态正则表达式</a>，可以了解到两种方式之间不同的讨论，以及如何来写出正确的程序的一些提示。
</p>
<p>两个参数的顺序，与大多数的其他用正则表达式处理字串函数的相反，比如 <code>sub()</code> ，<code>gsub()</code>。
记住 <code>match()</code> 函数的参数顺序与 &lsquo;<samp>~</samp>&rsquo; 操作符是一样的：&lsquo;<samp><var>string</var> ~ <var>regexp</var></samp>&rsquo;
</p>
<a name="index-RSTART-variable_002c-match_0028_0029-function-and"></a>
<a name="index-RLENGTH-variable_002c-match_0028_0029-function-and"></a>
<a name="index-match_0028_0029-function_002c-RSTART_002fRLENGTH-variables"></a>
<p><code>match()</code> 函数会设置预定义的变量 <code>RSTART</code> 为索引，同时也设置预定义的变量 <code>RLENGTH</code> 为匹配子串的长度。如果没有找到匹配，<code>RSTART</code> 的值被设置成 0，而 <code>RLENGTH</code> 的值为 -1。
</p>
<p>如：
</p>
<div class="example">
<pre class="example">{
    if ($1 == &quot;FIND&quot;)
        regex = $2
    else {
        where = match($0, regex)
        if (where != 0)
            print &quot;Match of&quot;, regex, &quot;found at&quot;, where, &quot;in&quot;, $0
       }
}
</pre></div>

<p>这个程序查找那些匹配存储在变量 <code>regex</code> 中的正则表达式的行。
这个正则表达式可以被更改。如果行中的第一个单词是 &lsquo;<samp>FIND</samp>&rsquo; ，则 <code>regex</code> 会被改成那一行的第二个单词。
所以，假如有下面的数据：
</p>
<div class="example">
<pre class="example">FIND ru+n
My program runs
but not very quickly
FIND Melvin
JF+KM
This line is property of Reality Engineering Co.
Melvin was here.
</pre></div>

<p>则 <code>awk</code> 会打印：
</p>
<div class="example">
<pre class="example">Match of ru+n found at 12 in My program runs
Match of Melvin found at 1 in Melvin was here.
</pre></div>

<a name="index-differences-in-awk-and-gawk_002c-match_0028_0029-function"></a>
<p>如果提供了 <var>array</var> 参数，它首先会被清除，然后数组 <var>array</var> 的第 0 个元素会被设置为匹配正则表达式 <var>regexp</var> 的整个字串 <var>string</var>。
如果 <var>regexp</var> 包含了括号，数组 <var>array</var> 的整数索引元素会被设置成匹配相应匹配括号子表达式的字串 <var>string</var> 的部分。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>echo foooobazbarrrrr |</kbd>
&gt; <kbd>gawk '{ match($0, /(fo+).+(bar*)/, arr)</kbd>
&gt;         <kbd>print arr[1], arr[2] }'</kbd>
-| foooo barrrrr
</pre></div>

<p>另外，多维下标也可用来提供 start 索引与每个匹配子表达式的长度 length 索引：
</p>
<div class="example">
<pre class="example">$ <kbd>echo foooobazbarrrrr |</kbd>
&gt; <kbd>gawk '{ match($0, /(fo+).+(bar*)/, arr)</kbd>
&gt;           <kbd>print arr[1], arr[2]</kbd>
&gt;           <kbd>print arr[1, &quot;start&quot;], arr[1, &quot;length&quot;]</kbd>
&gt;           <kbd>print arr[2, &quot;start&quot;], arr[2, &quot;length&quot;]</kbd>
&gt; <kbd>}'</kbd>
-| foooo barrrrr
-| 1 5
-| 9 7
</pre></div>

<p>有可能没有为每一个括号子表达式提供 start 以及 index 的下标，因为有可能并不是所有都匹配；
所以，它们应该用 <code>in</code> 操作符来进行测试（查看 <a href="#Reference-to-Elements">指向数组元素</a>）。
</p>
<a name="index-troubleshooting_002c-match_0028_0029-function"></a>
<p><code>match()</code> 的 <var>array</var> 参数是 <code>gawk</code> 扩展。在兼容模式中（查看 <a href="#Options">命令行参数</a>），使用第三个参数是一个致使错误。
</p>
</dd>
<dt><code>patsplit(<var>string</var>, <var>array</var></code> [<code>, <var>fieldpat</var></code> [<code>, <var>seps</var></code> ] ]<code>) #</code></dt>
<dd><a name="index-patsplit_0028_0029-function-_0028gawk_0029"></a>
<a name="index-split-string-into-array"></a>
<p>将 <var>string</var> 用 <var>fieldpat</var> 定义的分隔符分割成片，并存储在 <var>array</var> 中，
并将字串中分隔符存储在 <var>seps</var> 数组中。
第一块片存储在 <code><var>array</var>[1]</code> 中，第二片存储在 <code><var>array</var>[2]</code> 中，依此类推。
第三个参数 <var>fieldpat</var> 是一个正则表达式描述在 <var>string</var> 中的域（就好像 <code>FPAT</code> 是一个描述输入记录域的正则表达式）。它即可以是一个正则表达式常量，也可以是一个字串。
如果省略了 <var>fieldpat</var>，则会使用 <code>FPAT</code> 的值。
<code>patsplit()</code> 返回创建元素的个数。<code><var>seps</var>[<var>i</var>]</code> 是在 <code><var>array</var>[<var>i</var>]</code> 与 <code><var>array</var>[<var>i</var>+1]</code> 之间的分隔符。所有前导的分隔符都存储在 <code><var>seps</var>[0]</code> 中。
</p>
<p><code>patsplit()</code> 函数将字符串分割为片，其方式是与用 <code>FPAT</code> 将输入行分割成域的方式相似（查看 see section <a href="#Splitting-By-Content">以内容定义域</a>）。
</p>
<p>在分割字符串之前，<code>patsplit()</code> 会删除在 <var>array</var> 与 <var>seps</var> 中已经存在的元素。
</p>
</dd>
<dt><code>split(<var>string</var>, <var>array</var></code> [<code>, <var>fieldsep</var></code> [<code>, <var>seps</var></code> ] ]<code>)</code></dt>
<dd><a name="index-split_0028_0029-function"></a>
<p>将 <var>string</var> 用 <var>fieldsep</var> 定义的分隔符分割成片，并存储在 <var>array</var> 中，并将字串中分隔符存储在 <var>seps</var> 中。
第一块片存储在 <code><var>array</var>[1]</code> 中，第二片存储在 <code><var>array</var>[1]</code> 中，依此类推。
第三个参数 <var>fieldsep</var> 的字串值是一个用来描述在何片分割 <var>string</var> 的正则表达式（正如 <code>FS</code> 可以为正则表达式来描述在何处来分割输入记录一样）。
如果 <var>fieldsep</var> 被省略了，则使用 <code>FS</code> 的值。<code>split()</code> 返回被创建的元素个数。<var>seps</var> 是 <code>gawk</code> 扩展，<code><var>seps</var>[<var>i</var>]</code> 是在 <code><var>array</var>[<var>i</var>]</code> 与 <code><var>array</var>[<var>i</var>+1]</code> 之间的分隔符。
如果 <var>fieldsep</var> 是一个空格，则前导的空格会全部存储 <code><var>seps</var>[0]</code> 中，而后缀的空格会存储在 <code><var>seps</var>[<var>n</var>]</code> 中，
其中 <var>n</var> 是 <code>split()</code> 返回的值（即 <var>array</var> 数组中的元素个数）。
</p>
<p><code>split()</code> 函数将字串分割成片的方式与将输入行分割成域的方式类似。比如：
</p>
<div class="example">
<pre class="example">split(&quot;cul-de-sac&quot;, a, &quot;-&quot;, seps)
</pre></div>

<a name="index-strings-splitting_002c-example"></a>
<p>将字串 <code>&quot;cul-de-sac&quot;</code> 用 &lsquo;<samp>-</samp>&rsquo; 分割成三个域。它将数组 <code>a</code> 的内容设置成如下：
</p>
<div class="example">
<pre class="example">a[1] = &quot;cul&quot;
a[2] = &quot;de&quot;
a[3] = &quot;sac&quot;
</pre></div>

<p>同时设置数组 <code>seps</code> 的值为：
</p>
<div class="example">
<pre class="example">seps[1] = &quot;-&quot;
seps[2] = &quot;-&quot;
</pre></div>

<p>调用 <code>split()</code> 的返回值为 3。
</p>
<a name="index-differences-in-awk-and-gawk_002c-split_0028_0029-function"></a>
<p>随着输入的域分割，当 <var>fieldsep</var> 的值为 <code>&quot;&nbsp;&quot;</code> 时，
前缀和后缀的空格都会在赋值给数组 <var>array</var> 中的元素的时候被忽略，但是在 <var>seps</var> 中不会被忽略，<var>array</var> 数组元素是you连续的空格分割。
同时，随着输入记录的分割，如果 <var>fieldsep</var> 是一个空串，在字串中的每一个字符都将分割到数组的元素中。(c.e.)
</p>
<p>但是要注意，<code>RS</code> 的值对 <code>split()</code> 函数的工作没有影响。就算是 &lsquo;<samp>RS = &quot;&quot;</samp>&rsquo; 会导致换行符成为域分割符，这也不会影响 <code>split()</code> 分割字串的方式。
</p>
<a name="index-dark-corner_002c-split_0028_0029-function"></a>
<p>现代的 <code>awk</code> 实现版本，包括 <code>gawk</code>，允许第三个参数为正则表达式常量（<code>/</code>&hellip;<code>/</code>），也可以是一字串。
POSIX 标准允许这样的参数。查看 <a href="#Computed-Regexps">使用动态正则表达式</a>，可了解使用字串常量与正则表达式之间的常量，并获取一些如何正确地写程序的提示。
</p>
<p>在分割字符串前，<code>split()</code> 会删除在数组 <var>array</var> 与 <var>seps</var> 中已经存在的元素。
</p>
<p>如果 <var>string</var> 为空，则数组就不会有元素。（所以这是一个可移植的以一个语句来删除整个数组的方法。查看 <a href="#Delete"><code>delete</code> 语句</a>。）
</p>
<p>如果 <var>string</var> 没有匹配 <var>fieldsep</var>（但不是空），则 <var>array</var> 只会有一个元素。元素的值就是原来的字串 <var>string</var>。
</p>
<p>在 POSIX 模式下（查看 <a href="#Options">命令行参数</a>），第四个参数是不允许的。
</p>
</dd>
<dt><code>sprintf(<var>format</var>, <var>expression1</var>, &hellip;)</code></dt>
<dd><a name="index-sprintf_0028_0029-function-1"></a>
<a name="index-formatting-strings"></a>
<p>返回 <code>printf</code> 采用相同的参数时的输出（但是不输出）的字串。（查看 see section <a href="#Printf">使用 <code>printf</code> 语句美化打印</a>）。例如：
</p>
<div class="example">
<pre class="example">pival = sprintf(&quot;pi = %.2f (approx.)&quot;, 22/7)
</pre></div>

<p>将字串 &lsquo;<samp>pi&nbsp;=&nbsp;3.14&nbsp;(approx.)</samp>&rsquo; 赋值给变量 <code>pival</code>。
</p>
<a name="index-strtonum_0028_0029-function-_0028gawk_0029"></a>
<a name="index-convert-string-to-number"></a>
</dd>
<dt><code>strtonum(<var>str</var>) #</code></dt>
<dd><p>检查 <var>str</var> 并返回它的数值值。如果 <var>str</var> 以 &lsquo;<samp>0</samp>&rsquo; 开头，则 <code>strtonum()</code> 会假设 <var>str</var> 是一个八进制数。
如果 <var>str</var> 是以 &lsquo;<samp>0x</samp>&rsquo; 开头，或者 &lsquo;<samp>0X</samp>&rsquo; 开头，<code>strtonum()</code> 会假设 <var>str</var> 是一个十六进制数。例如：
</p>
<div class="example">
<pre class="example">$ <kbd>echo 0x11 |</kbd>
&gt; <kbd>gawk '{ printf &quot;%d\n&quot;, strtonum($1) }'</kbd>
-| 17
</pre></div>

<p>使用 <code>strtonum()</code> 函数与给字串添加一个零不同，自动强制性地将字串转换为数值只会在十进制数下有效，对于八进制与十六进制都是无效的。 
<a name="DOCF50" href="#FOOT50">(50)</a>
</p>
<p>同时也要注意 <code>strtonum()</code> 会使用当前的本地语言设置中的用于识别数值的十进制位（查看 see section <a href="#Locales">哪里造成差异</a>）。
</p>
</dd>
<dt><code>sub(<var>regexp</var>, <var>replacement</var></code> [<code>, <var>target</var></code>]<code>)</code></dt>
<dd><a name="index-sub_0028_0029-function-1"></a>
<a name="index-replace-in-string"></a>
<p>在被当成字串的 <var>target</var> 中搜索匹配正则表达式 <var>regexp</var> 的最左最长的匹配子串。并用 <var>replacement</var> 来规则匹配的子串。
被修改过的字串成为 <var>target</var> 的新值。返回替换的次数（0 或者 1）。
</p>
<p><var>regexp</var> 参数即可以是一个正则表达式常量（<code>/</code>&hellip;<code>/</code>），也可以是一个字串常量（<code>&quot;</code>&hellip;<code>&quot;</code>）。对于后者，字串会被当面成一个正则表达式来进行匹配。查看 <a href="#Computed-Regexps">使用动态正则表达式</a>，以了解这两种形式之间的差异，以及了解一些如何正确地写这样的程序的提示。
</p>
<p>这个函数非常特别，是因为 <var>target</var> 并不是简单地使用来进行计算出一个值，也不像其他的表达式一样——它必须是一个变量，域或者一个数组元素，因此 <code>sub()</code> 可以将修改的值存在那个地方。如果这个参数被省略了，则默认的值会使用 <code>$0</code>。
<a name="DOCF51" href="#FOOT51">(51)</a>
例如：
</p>
<div class="example">
<pre class="example">str = &quot;water, water, everywhere&quot;
sub(/at/, &quot;ith&quot;, str)
</pre></div>

<p>通过将出现 &lsquo;<samp>at</samp>&rsquo; 的地方替换成 &lsquo;<samp>ith</samp>&rsquo; 来将 <code>str</code> 设置成 &lsquo;<samp>wither,&nbsp;water,&nbsp;everywhere</samp>&rsquo;。
</p>
<p>如果特殊字符 &lsquo;<samp>&amp;</samp>&rsquo; 出现在 <var>replacement</var> 中，它就表示匹配 <var>regexp</var> 的精确子串。（如果 <var>regexp</var> 可以匹配 1 到多个串，则精确的匹配串可能不同。）例如：
</p>
<div class="example">
<pre class="example">{ sub(/candidate/, &quot;&amp; and his wife&quot;); print }
</pre></div>

<p>会将输入的行中出现的第一个 &lsquo;<samp>candidate</samp>&rsquo; 替换成 &lsquo;<samp>candidate and his wife</samp>&rsquo; 。下面是另外一个例子：
</p>
<div class="example">
<pre class="example">$ <kbd>awk 'BEGIN {</kbd>
&gt;         <kbd>str = &quot;daabaaa&quot;</kbd>
&gt;         <kbd>sub(/a+/, &quot;C&amp;C&quot;, str)</kbd>
&gt;         <kbd>print str</kbd>
&gt; <kbd>}'</kbd>
-| dCaaCbaaa
</pre></div>

<p>这里显示了 &lsquo;<samp>&amp;</samp>&rsquo; 可以表示一个非常量的字串，也说明了正则表达式匹配的最左最长规则的含义（查看 see section <a href="#Leftmost-Longest">匹配多少？</a>）。
</p>
<p>这个特殊字符 &lsquo;<samp>&amp;</samp>&rsquo; 的效果可以被关闭，只需要在字串中这个字符前加一个反斜杠即可。通常，为了插入一个反斜杠到字串中，你必须写两个反斜杠。因此在字串常量中要写 &lsquo;<samp>\\&amp;</samp>&rsquo; 来在替换文本中生成一个字面的 &lsquo;<samp>&amp;</samp>&rsquo; 字符。例如，下面的代码展示了如何来行中将第一个 &lsquo;<samp>|</samp>&rsquo; 替换成 &lsquo;<samp>&amp;</samp>&rsquo; ：
</p>
<div class="example">
<pre class="example">{ sub(/\|/, &quot;\\&amp;&quot;); print }
</pre></div>

<a name="index-sub_0028_0029-function_002c-arguments-of"></a>
<a name="index-gsub_0028_0029-function_002c-arguments-of"></a>
<p>如上面所提到的，<code>sub()</code> 的第三个参数必须是一个变量，域或者数组元素。某些版本的 <code>awk</code> 允许第三个参数是一个表达式，这个表达式不是个左传。在这种情况下，<code>sub()</code> 依然会搜索模式并返回 0 或者 1，但是替换的结果会被丢弃（如果有的话），而不会发生替换。这种版本的 <code>awk</code> 接受下面这样的表达式：
</p>
<div class="example">
<pre class="example">sub(/USA/, &quot;United States&quot;, &quot;the USA and Canada&quot;)
</pre></div>

<a name="index-troubleshooting_002c-gsub_0028_0029_002fsub_0028_0029-functions"></a>
<p>为了历史的兼容，<code>gawk</code> 会授受这样的错误代码。但是使用任何不可更改的对象作为第三个参数，会导致致命错误，你的程序也没办法执行下去。
</p>
<p>最后，如果 <var>regexp</var> 不是一个正则表达式常量，则它会被转换为一个字串，然后它的值会被当成正则表达式来进行匹配。
</p>
</dd>
<dt><code>substr(<var>string</var>, <var>start</var></code> [<code>, <var>length</var></code> ]<code>)</code></dt>
<dd><a name="index-substr_0028_0029-function"></a>
<a name="index-substring"></a>
<p>返回字中 <var>string</var> 的从 <var>start</var> 开始的，<var>length</var> 字符长度的子串。字串的第一个字符编号为 1。
<a name="DOCF52" href="#FOOT52">(52)</a>
例如 <code>substr(&quot;washington&quot;, 5, 3)</code> 返回 <code>&quot;ing&quot;</code>。
</p>
<p>如果没有提供 <var>length</var> 参数，<code>substr()</code> 则返回 <var>string</var> 从 <var>start</var> 字符数开始的全部后面的字串。
例如，<code>substr(&quot;washington&quot;, 5)</code> 返回 <code>&quot;ington&quot;</code>。
如果 <var>length</var> 大于 <var>string</var> 后面剩下的字符数，则也会返回整个后缀的字串，这其中包括 <var>start</var> 处的字符。
</p>
<a name="index-Brian-Kernighan_0027s-awk-11"></a>
<p>如果 <var>start</var> 的值小于 1，<code>substr()</code> 会将其当为 1。
（POSIX 没有指定这种情况下如何处理：BWK <code>awk</code> 会如上这么处理，<code>gawk</code> 也这么处理。）
如果 <var>start</var> 大于 <var>string</var> 中的字符数，<code>substr()</code> 返回空串。相似的，如果 <var>length</var> 提供了，但是小于等于 0，也返回空串。
</p>
<a name="index-troubleshooting_002c-substr_0028_0029-function"></a>
<p>由 <code>substr()</code> 返回的串<em>不可以</em>被赋值。所以，试图改变一个字符串的一部分是一个错误，如下面的例子中所示的：
</p>
<div class="example">
<pre class="example">string = &quot;abcdef&quot;
# try to get &quot;abCDEf&quot;, won't work
substr(string, 3, 3) = &quot;CDE&quot;
</pre></div>

<p>将 <code>substr()</code> 的返回作为 <code>sub()</code> 或者 <code>gsub()</code> 的第三个参数，也是错误的：
</p>
<div class="example">
<pre class="example">gsub(/xyz/, &quot;pdq&quot;, substr($0, 5, 20))  # WRONG
</pre></div>

<a name="index-portability_002c-substr_0028_0029-function"></a>
<p>（有一些商业版本的 <code>awk</code> 会把 <code>substr()</code> 的返回作为可赋值的，但是这么做是不可移植的。）
</p>
<p>如果你想替换一个字符串的一部分，将 <code>substr()</code> 与字串连接一起使用，如下面的方式：
</p>
<div class="example">
<pre class="example">string = &quot;abcdef&quot;
&hellip;
string = substr(string, 1, 2) &quot;CDE&quot; substr(string, 6)
</pre></div>

<a name="index-case-sensitivity_002c-converting-case"></a>
<a name="index-strings_002c-converting-letter-case"></a>
</dd>
<dt><code>tolower(<var>string</var>)</code></dt>
<dd><a name="index-tolower_0028_0029-function"></a>
<a name="index-convert-string-to-lower-case"></a>
<p>返回 <var>string</var> 的复本，但是将所有的大写字母用它对应的小写字母进行替换。非字母字符则不变化。例如 <code>tolower(&quot;MiXeD cAsE 123&quot;)</code> 返回 <code>&quot;mixed case 123&quot;</code>。
</p>
</dd>
<dt><code>toupper(<var>string</var>)</code></dt>
<dd><a name="index-toupper_0028_0029-function"></a>
<a name="index-convert-string-to-upper-case"></a>
<p>返回 <var>string</var> 的复本，但是将所有的小写字母用它对应的大写字母进行替换。非字母字符则不变化。例如 <code>toupper(&quot;MiXeD cAsE 123&quot;)</code> 返回 <code>&quot;MIXED CASE 123&quot;</code>。
</p></dd>
</dl>

<a name="index-sidebar_002c-aa_008c_00b9e_0085_008dc_00a9_00baa_00b8_00b2"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>匹配空串</b>
</p>

<a name="index-matching_002c-null-strings"></a>
<a name="index-null-strings_002c-matching"></a>
<a name="index-_002a-_0028asterisk_0029_002c-_002a-operator_002c-null-strings_002c-matching"></a>
<a name="index-asterisk-_0028_002a_0029_002c-_002a-operator_002c-null-strings_002c-matching"></a>

<p>在 <code>awk</code> 中，&lsquo;<samp>*</samp>&rsquo; 操作符可以匹配空串。这对于 <code>sub()</code>，<code>gsub()</code> 与 <code>gensub()</code> 函数尤其重要。如：
</p>
<div class="example">
<pre class="example">$ <kbd>echo abc | awk '{ gsub(/m*/, &quot;X&quot;); print }'</kbd>
-| XaXbXcX
</pre></div>

<p>尽管这有一些意义，但看起来还是让人有点惊讶。
</p></td></tr></table>


<hr>
<a name="Gory-Details"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#String-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#String-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#I_002fO-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="sub_0028_0029a_0080_0081gsub_0028_0029-a_00b8_008e-gensub_0028_0029-aa_0087_00bdae_0095_00b0a_00b8_00adc_009a_0084-_005c-a_00b8_008e-_0026"></a>
<h4 class="subsubsection">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</h4>
<a name="index-escape-processing_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions"></a>
<a name="index-sub_0028_0029-function_002c-escape-processing"></a>
<a name="index-gsub_0028_0029-function_002c-escape-processing"></a>
<a name="index-gensub_0028_0029-function-_0028gawk_0029_002c-escape-processing"></a>
<a name="index-_005c-_0028backslash_0029_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions-and"></a>
<a name="index-backslash-_0028_005c_0029_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions-and"></a>
<a name="index-_0026-_0028ampersand_0029_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions-and"></a>
<a name="index-ampersand-_0028_0026_0029_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions-and"></a>

<blockquote>
<p><b>注意:</b> 本小节据报说是会造成头痛，有可能第一次阅读时想跳过。
</p></blockquote>

<p>当使用 <code>sub()</code>，<code>gsub()</code> 或者 <code>gensub()</code> ，并且试图获取字面的反斜杠与星号，并放在替换文本中，你需要记住，到底有几级<em>转义处理</em>。
</p>
<p>首先，有一个<em>词汇</em>层，就是当 <code>awk</code> 读取你的程序，并建立一个要执行的内部复本的时候。然后一个是运行时层，就是当 <code>awk</code> 实际扫描替换文本串用于确定所产生的结果的时候。
</p>
<a name="index-Brian-Kernighan_0027s-awk-12"></a>
<p>在两个层上，<code>awk</code> 会搜索已经定义好的可以放在反斜杠之后的字符集。在词汇层，它会搜索在 <a href="#Escape-Sequences">转义序列</a> 中列出的转义序列。
所以，对每一个 <code>awk</code> 在运行层处理的 &lsquo;<samp>\</samp>&rsquo; ，你必须在词汇层输入两个反斜杠。当跟在 &lsquo;<samp>\</samp>&rsquo; 之后的字符不是一个有效的转换序列，GWK <code>awk</code> 与 <code>gawk</code> 两者都是简单地移除 &lsquo;<samp>\</samp>&rsquo; 并将下一个字符放在字串中。
因此，如 <code>&quot;a\qb&quot;</code> 会被当成 <code>&quot;aqb&quot;</code>。
</p>
<p>在运行层，不同的函数在处理 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo; 序列时是不同的。这种情况很（蛋疼）地有点复杂。由于历史原因，<code>sub()</code> 与 <code>gsub()</code> 函数都将两字符 &lsquo;<samp>\&amp;</samp>&rsquo; 序列特殊对待，这个序列在产生的文本中被替换为 &lsquo;<samp>&amp;</samp>&rsquo; 。任何在 <var>replacement</var> 中的其他的不在 &lsquo;<samp>&amp;</samp>&rsquo; 之前的 &lsquo;<samp>\</samp>&rsquo; 都原样地传递。这个将在 <a href="#table_002dsub_002descapes">Table 9.1</a> 中解释。
</p>
<div class="float"><a name="table_002dsub_002descapes"></a>

<div class="display">
<pre class="display"> 输入         <code>sub()</code> 所见          <code>sub()</code> 所产生
 &mdash;&mdash;&ndash;         &mdash;&mdash;&mdash;-          &mdash;&mdash;&mdash;&mdash;&mdash;
     <code>\&amp;</code>              <code>&amp;</code>            The matched text
    <code>\\&amp;</code>             <code>\&amp;</code>            字符 &lsquo;<samp>&amp;</samp>&rsquo;
   <code>\\\&amp;</code>             <code>\&amp;</code>            字符 &lsquo;<samp>&amp;</samp>&rsquo;
  <code>\\\\&amp;</code>            <code>\\&amp;</code>            字符 &lsquo;<samp>\&amp;</samp>&rsquo;
 <code>\\\\\&amp;</code>            <code>\\&amp;</code>            字符 &lsquo;<samp>\&amp;</samp>&rsquo;
<code>\\\\\\&amp;</code>           <code>\\\&amp;</code>            字符 &lsquo;<samp>\\&amp;</samp>&rsquo;
    <code>\\q</code>             <code>\q</code>            字符 &lsquo;<samp>\q</samp>&rsquo;
</pre></div>
</div><p><strong>Table 9.1: 由于历史原因 <code>sub()</code> 与 <code>gsub()</code> 处理转义序列情况
</strong>
</p>
<p>上表显示了词汇层的处理，在里面，一个奇数个的反斜杠在运行时，就变成了偶数，这与 <code>sub()</code> 的运行时的处理一样。（为了简单起见，后面的表只显示在词汇层输入偶数的反斜杠的情形。）
</p>
<p>历史方式的问题是，没有办法取得后面跟着匹配字串的字面的 &lsquo;<samp>\</samp>&rsquo; 。
</p>
<p>POSIX 标准的几个版本都尝试来修复这个问题，但是都不成功。细节在此无关。
</p>
<p>在某个时候，<code>gawk</code> 的维护者提交了建议文本，形成一个修订版本的标准，以逆转到与最初存在的实践更加接近的规则上。提交的规则存在特殊情形，以有可能产生在匹配的文本前的 &lsquo;<samp>\</samp>&rsquo;。这个在 <a href="#table_002dsub_002dproposed">Table 9.2</a> 中显示。
</p>
<div class="float"><a name="table_002dsub_002dproposed"></a>

<div class="display">
<pre class="display"> 输入         <code>sub()</code> 所见         <code>sub()</code> 产生
 &mdash;&mdash;&ndash;         &mdash;&mdash;&mdash;-         &mdash;&mdash;&mdash;&mdash;&mdash;
<code>\\\\\\&amp;</code>           <code>\\\&amp;</code>            字符 &lsquo;<samp>\&amp;</samp>&rsquo;
  <code>\\\\&amp;</code>            <code>\\&amp;</code>            字符 &lsquo;<samp>\</samp>&rsquo;，后面跟着匹配文本
    <code>\\&amp;</code>             <code>\&amp;</code>            字符 &lsquo;<samp>&amp;</samp>&rsquo;
    <code>\\q</code>             <code>\q</code>            字符 &lsquo;<samp>\q</samp>&rsquo;
   <code>\\\\</code>             <code>\\</code>            <code>\\</code>
</pre></div>
</div><p><strong>Table 9.2: <code>gawk</code> 针对 <code>sub()</code> 与反斜杠的规则
</strong>
</p>
<p>总的来说，在运行时，现在有三个特殊的字符序列（&lsquo;<samp>\\\&amp;</samp>&rsquo;，&lsquo;<samp>\\&amp;</samp>&rsquo; 和 &lsquo;<samp>\&amp;</samp>&rsquo;），由于历史原因只会存在一个。但是在历史情况下，&lsquo;<samp>\</samp>&rsquo; 并不是这三个序列的一部份也并不特殊，并以字符本身输出。
</p>
<p><code>gawk</code> 3.0 与 3.1 会针对 <code>sub()</code> 与 <code>gsub()</code> 来匹配这些规则。POSIX 标准的修改要比期望的时间长得多。另外，<code>gawk</code> 的维护者的建议在标准化的过程中丢失了。最后的规则看起来更简单。结果除了一个情形外都类似。
</p>
<a name="index-POSIX-awk_002c-functions-and_002c-gsub_0028_0029_002fsub_0028_0029"></a>
<p>POSIX 规则描述说，在替换文本中的 &lsquo;<samp>\&amp;</samp>&rsquo; 产生一个 &lsquo;<samp>&amp;</samp>&rsquo;，&lsquo;<samp>\\</samp>&rsquo; 产生一个字面 &lsquo;<samp>\</samp>&rsquo;，&lsquo;<samp>\</samp>&rsquo; 后面再跟其他的字符都没有特殊含义，&lsquo;<samp>\</samp>&rsquo; 会被直接放到输出中。这些规则在后面的 <a href="#table_002dposix_002dsub">Table 9.3</a>。
</p>
<div class="float"><a name="table_002dposix_002dsub"></a>

<div class="display">
<pre class="display"> 输入         <code>sub()</code> 所见         <code>sub()</code> 生成
 &mdash;&mdash;&ndash;         &mdash;&mdash;&mdash;-         &mdash;&mdash;&mdash;&mdash;&mdash;
<code>\\\\\\&amp;</code>           <code>\\\&amp;</code>            字符 &lsquo;<samp>\&amp;</samp>&rsquo;
  <code>\\\\&amp;</code>            <code>\\&amp;</code>            字符 &lsquo;<samp>\</samp>&rsquo;，后面跟匹配文本
    <code>\\&amp;</code>             <code>\&amp;</code>            字符 &lsquo;<samp>&amp;</samp>&rsquo;
    <code>\\q</code>             <code>\q</code>            字符 &lsquo;<samp>\q</samp>&rsquo;
   <code>\\\\</code>             <code>\\</code>            <code>\</code>
</pre></div>
</div><p><strong>Table 9.3: POSIX 针对 <code>sub()</code> 与 <code>gsub()</code> 的规则
</strong>
</p>
<p>唯一可注意的不同的情形是最后一个：&lsquo;<samp>\\\\</samp>&rsquo; 被看成 &lsquo;<samp>\\</samp>&rsquo; 并产生 &lsquo;<samp>\</samp>&rsquo; ，而不是 &lsquo;<samp>\\</samp>&rsquo; 。
</p>
<p>从 3.1.4 版本开始，如果指定了 &lsquo;<samp>--posix</samp>&rsquo; 选项，<code>gawk</code> 按照 POSIX 的标准来（查看 <a href="#Options">命令行参数</a>）。否则，它还是会使用所建议的方案，因为那是多年来的行为。
</p>
<p>当发布了 4.0.0 版本后，<code>gawk</code> 维护者将 POSIX 规则为默认规则，打破了 10 几年来后向兼容性的价值。
<a name="DOCF53" href="#FOOT53">(53)</a>
无须多说，这个是非常糟糕的主意，当 4.0.1 版本时，<code>gawk</code> 恢复了它的历史行为，当指定了 &lsquo;<samp>--posix</samp>&rsquo; 选项时，则只遵守 POSIX 规则。
</p>
<p><code>gensub()</code> 的规则则相当简单。在运行层，无论什么时候 <code>gawk</code> 看到一个 &lsquo;<samp>\</samp>&rsquo;，如果后面跟着一个数字，则匹配相应括号的子表达式的文件来产生输出。否则，不管 &lsquo;<samp>\</samp>&rsquo; 后面跟着什么字符，它都出现在产生的文本中，而 &lsquo;<samp>\</samp>&rsquo; 则不出现。
如 <a href="#table_002dgensub_002descapes">Table 9.4</a> 所示。
</p>
<div class="float"><a name="table_002dgensub_002descapes"></a>

<div class="display">
<pre class="display">  输入          <code>gensub()</code> 所见         <code>gensub()</code> 产生
  &mdash;&mdash;&ndash;          &mdash;&mdash;&mdash;&mdash;-         &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
      <code>&amp;</code>                    <code>&amp;</code>            匹配文本
    <code>\\&amp;</code>                   <code>\&amp;</code>            字符 &lsquo;<samp>&amp;</samp>&rsquo;
   <code>\\\\</code>                   <code>\\</code>            字符 &lsquo;<samp>\</samp>&rsquo;
  <code>\\\\&amp;</code>                  <code>\\&amp;</code>            字符 &lsquo;<samp>\</samp>&rsquo;，后面跟着匹配文本
<code>\\\\\\&amp;</code>                 <code>\\\&amp;</code>            字符 &lsquo;<samp>\&amp;</samp>&rsquo;
    <code>\\q</code>                   <code>\q</code>            字符 &lsquo;<samp>q</samp>&rsquo;
</pre></div>
</div><p><strong>Table 9.4: <code>gensub()</code> 的转义字符
</strong>
</p>
<p>由于词汇层与运行层处理的复杂性，以及 <code>sub()</code> 与 <code>gsub()</code> 的特殊情形，我们建议使用 <code>gawk</code> 与 <code>gensub()</code> 来执行替换操作。
</p>
<hr>
<a name="I_002fO-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Gory-Details" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Time-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00be_0093aa_0085_00a5e_00be_0093aa_0087_00baaa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">9.1.4 输入输出函数</h3>
<a name="index-input_002foutput-functions"></a>

<p>下面的函数与 I/O 相关。可选择的参数放在方括号中（[ ]）：
</p>
<dl compact="compact">
<dt><code>close(</code><var>filename</var> [<code>,</code> <var>how</var>]<code>)</code></dt>
<dd><a name="index-close_0028_0029-function-1"></a>
<a name="index-files_002c-closing"></a>
<a name="index-close-file-or-coprocess"></a>
<p>关闭用于输入或者输出的文件 <var>filename</var>。另外，参数也可以是一个用来创建并程或者用于重定向输出，或者从管道中输入的 Shell 命令。如果参数是这个，则会关闭相应的并程与管道。查看 <a href="#Close-Files-And-Pipes">关闭输入输出重定向</a>，获取更多信息。
</p>
<p> 当关闭一个并程时，有时先关闭两路管道中的一端然后再关闭另一端非常有用。这通过向 <code>close()</code> 传递第二个参数来完成。这第二个参数（<var>how</var>）要是下面两个串中的一个，
 即 <code>&quot;to&quot;</code> 或者 <code>&quot;from&quot;</code>，以表示关闭管道的哪一端。字串的大小写是无关的。查看 <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>，在里面更详细地讨论了这个特性，并且还举了一个例子。
</p>
<p>注意 <code>close()</code> 的第二个参数是 <code>gawk</code> 扩展，在兼容模式下是不可用的（查看 <a href="#Options">命令行参数</a>）。
</p>
</dd>
<dt><code>fflush(</code>[<var>filename</var>]<code>)</code></dt>
<dd><a name="index-fflush_0028_0029-function"></a>
<a name="index-flush-buffered-output"></a>
<p>将与 <var>filename</var> 相关的缓存输出刷出，<var>filename</var> 要么是一个打开的用于写的文件，或者用于重定向输出的管道，或者并程。
</p>
<a name="index-buffers_002c-flushing"></a>
<a name="index-output_002c-buffering"></a>
<p>很多的工具程序都会<em>缓存</em>它们的输出（即它们会将写到磁盘的文件或者屏幕的信息保存，并等待足够的时间以值得将这些数据输出到输出设备中）。这比起每次准备好一点数据就写要高效得多。但是，有时很有必要强制程序要<em>刷出</em>它的缓存（即将信息写到它的目的地，就是缓存还没有满）。
这就是 <code>fflush()</code> 函数的目的——<code>gawk</code> 也会缓存它的输出，而 <code>fflush()</code> 函数强制 <code>gawk</code> 刷出它的缓存。
</p>
<a name="index-extensions_002c-common_002c-fflush_0028_0029-function"></a>
<a name="index-Brian-Kernighan_0027s-awk-13"></a>
<p>Brian Kernighan 在 1992 年 4 月将 <code>fflush()</code> 加入到他的 <code>awk</code> 中。二十年过去了，它现在成为了一个通过扩展。2012 年 12 月，它被接受包含到 POSIX 标准中。
可以查看<a href="http://austingroupbugs.net/view.php?id=634">Austin Group 网站</a>来了解。
</p>
<p>POSIX 标准化了 <code>fflush()</code> 下面几个方面：如果没有参数，或者参数是空串（<code>&quot;&quot;</code>），则 <code>awk</code> 刷出所有已经打开的文件与管道的缓存。
</p>
<blockquote>
<p><b>提示:</b> 在 4.0.2 之前的版本，如果没有参数，<code>gawk</code> 会只刷出标准输出，而为空串时，才会刷出所有的输出文件与管道。为了与 Brian Kernighan 的 <code>awk</code> 兼容，则对其作了更改，并希望在 POSIX 中对这个特性的标准化可以更加容易（实际上也确实是这样）。
</p>
<p>对于 <code>gawk</code>，你可以使用 &lsquo;<samp>fflush(&quot;/dev/stdout&quot;)</samp>&rsquo; 来只刷出标准输出。
</p></blockquote>

<a name="index-troubleshooting_002c-fflush_0028_0029-function"></a>
<p>如果缓存被成功刷出，则 <code>fflush()</code> 返回 0，否则，它会返回一个非零值。（<code>gawk</code> 返回 -1。）在所有的缓存都刷出的情况下，当只有所有的缓存都成功刷出后才会返回 0。否则会返回 -1，并对有问题的 <var>filename</var> 发送告警。
</p>
<p>如果你刷出的文件或者管道是打开用于读取的（如 <code>getline</code>），或者 <code>fflush()</code> 不是打开的文件，管道或者并程，<code>gawk</code> 也会发出一个告警。这种情况下，<code>fflush()</code> 也返回 -1。
</p>
<a name="index-sidebar_002c-a_00ba_00a4a_00ba_0092aa_00bc_008fa_00b8_008ee_009d_009ea_00ba_00a4a_00ba_0092aa_00bc_008fc_00bc_0093aa_00ad_0098"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>交互式与非交互式缓存</b>
</p>

<a name="index-buffering_002c-interactive-vs_002e-noninteractive"></a>

<p>多说一点，如果你的程序是<em>交互式</em>的（就是与坐在键盘前的用户进行通信），缓存问题有时会非常让人疑惑。
<a name="DOCF54" href="#FOOT54">(54)</a>
</p>
<p>交互式的程序一般都是<em>行缓存</em>它们的输出（即它们一行行地写输出）。非交互式的程序直到缓存满后才会输出，而这可能包含很多行输出。下面是其差异的例子：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print $1 + $2 }'</kbd>
<kbd>1 1</kbd>
-| 2
<kbd>2 3</kbd>
-| 5
<kbd>Ctrl-d</kbd>
</pre></div>

<p>输出的每一行是立即打印的。与下面这个例子的行为进行比较：
</p>
<div class="example">
<pre class="example">$ <kbd>awk '{ print $1 + $2 }' | cat</kbd>
<kbd>1 1</kbd>
<kbd>2 3</kbd>
<kbd>Ctrl-d</kbd>
-| 2
-| 5
</pre></div>

<p>在这里，直到键入 <kbd>Ctrl-d</kbd> 后才有输出打印，因此它将所有的缓存，然后一次性发送到管道输出到 <code>cat</code>。
</p></td></tr></table>

</dd>
<dt><code>system(<var>command</var>)</code></dt>
<dd><a name="index-system_0028_0029-function"></a>
<a name="index-invoke-shell-command"></a>
<a name="index-interacting-with-other-programs"></a>
<p>执行操作系统命令 <var>command</var> 并返回到 <code>awk</code> 程序中。同时返回 <var>command</var> 的退出状态。
</p>
<p>例如，如果下面的代码片段放在你的 <code>awk</code> 程序中：
</p>
<div class="example">
<pre class="example">END {
     system(&quot;date | mail -s 'awk run done' root&quot;)
}
</pre></div>

<p>当 <code>awk</code> 程序完成处理输入，并且开启输入结束处理流程时，会向系统管理员发送邮件。
</p>
<p>注意重定向 <code>print</code> 或者 <code>printf</code> 到管道一般来就就够来完成你的工作。如果你需要运行许多命令，则简单地将它们通过管线打印到 Shell 更高效：
</p>
<div class="example">
<pre class="example">while (<var>more stuff to do</var>)
    print <var>command</var> | &quot;/bin/sh&quot;
close(&quot;/bin/sh&quot;)
</pre></div>

<a name="index-troubleshooting_002c-system_0028_0029-function"></a>
<a name="index-_002d_002dsandbox-option_002c-disabling-system_0028_0029-function"></a>
<p>但是，如果你的 <code>awk</code> 程序是交互式的，<code>system()</code> 用于大型的自包含的程序就非常有用，比如 Shell 或者编辑器。一些操作系统不能实现 <code>system()</code> 函数。<code>system()</code> 在不其不支持的情况下生成一个致命错误。
</p>
<blockquote>
<p><b>注意:</b> 当指定了 &lsquo;<samp>--sandbox</samp>&rsquo; 选项，<code>system()</code> 函数会被禁用（查看 <a href="#Options">命令行参数</a>）。
</p></blockquote>

<p>在 POSIX 系统中，一个命令的退出状态是一个 16 位的数。传递给 C 语言的 <code>exit()</code> 函数的是退出状态值的高 8 位。
低位数表示这个进程是否是被一个信号（第 7 位）杀死的。如果是的话，剩下的位数表示出错的信号数（第 0-6 位）。
</p>
<p>传统上，<code>awk</code> 的 <code>system()</code> 函数简单地返回退出状态值除以 256 的值。
在一般的例子中，就按照这样返回退出状态值。但是在进程被信号杀死的情况下，会产生一个极小的浮点数值。
<a name="DOCF55" href="#FOOT55">(55)</a>
POSIX 声明 <code>awk</code> 的 <code>system()</code> 函数应该返回完整的 16 位数值。
</p>
<p><code>gawk</code> 采取了折中方案。返回值总结在 <a href="#table_002dsystem_002dreturn_002dvalues">Table 9.5</a>。
</p>
<div class="float"><a name="table_002dsystem_002dreturn_002dvalues"></a>

<table>
<thead><tr><th width="40%">场景</th><th width="60%"><code>system()</code> 的返回值</th></tr></thead>
<tr><td width="40%">&lsquo;<samp>--traditional</samp>&rsquo;</td><td width="60%">C <code>system()</code> 的值除以 256</td></tr>
<tr><td width="40%">&lsquo;<samp>--posix</samp>&rsquo;</td><td width="60%">C <code>system()</code> 的值</td></tr>
<tr><td width="40%">一般的退出命令</td><td width="60%">命令的退出状态</td></tr>
<tr><td width="40%">被信号杀死的命令</td><td width="60%">256 + 这种信号的编号</td></tr>
<tr><td width="40%">被带 core dump 的信号杀死的命令</td><td width="60%">512 + 这种信号的编号</td></tr>
<tr><td width="40%">某种错误</td><td width="60%">-1</td></tr>
</table>
</div><p><strong>Table 9.5: <code>system()</code> 的返回值
</strong>
</p></dd>
</dl>

<a name="index-sidebar_002c-e_0080_009ae_00bf_0087-system_0028_0029-ae_009d_00a5ae_008e_00a7aa_0088_00b6e_00be_0093aa_0087_00bac_00bc_0093aa_00ad_0098"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>通过 <code>system()</code> 来控制输出缓存</b>
</p>

<a name="index-buffers_002c-flushing-1"></a>
<a name="index-buffering_002c-input_002foutput"></a>
<a name="index-output_002c-buffering-1"></a>

<p><code>system()</code> 函数提供了显式的控制输出单独文件或者管道缓存的方式。但是，对于许多的旧的 <code>awk</code> 实现却是不可移植的。一个可用的方法就是通过调用 <code>system()</code> 函数，并给其提供一个空串作为其参数来刷出输出缓存：
</p>
<div class="example">
<pre class="example">system(&quot;&quot;)   # flush output
</pre></div>

<p><code>gawk</code> 将这种使用 <code>system()</code> 函数的方式作为一种特殊方式来对待，并且聪明地不用空命令来运行一个 Shell（或者其他的命令解释器）。因此，在 <code>gawk</code> 中，这种范式不仅很有用，同时也非常高效。尽管这个方法也会在其他的 <code>awk</code> 实现中可工作，但是却不是必须要避免开启一个不必要 Shell。（其他的实现可能只刷出与标准输出关键的缓存，而必是所有的缓存输出。）
</p>
<p>如果你考虑一下一个程序员的预期，<code>system()</code> 会刷出所有的挂起的输出看起来就有意思了。下面的程序：
</p>
<div class="example">
<pre class="example">BEGIN {
     print &quot;first print&quot;
     system(&quot;echo system echo&quot;)
     print &quot;second print&quot;
}
</pre></div>

<p>必须打印：
</p>
<div class="example">
<pre class="example">first print
system echo
second print
</pre></div>

<p>而不是：
</p>
<div class="example">
<pre class="example">system echo
first print
second print
</pre></div>

<p>如果 <code>awk</code> 不在调用 <code>system()</code> 前刷出它的缓存，你就可以会看到后面（不希望看到的）输出。
</p></td></tr></table>

<hr>
<a name="Time-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#I_002fO-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Bitwise-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0097_00b6e_0097_00b4aa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">9.1.5 时间函数</h3>
<a name="index-time-functions"></a>

<a name="index-timestamps"></a>
<a name="index-log-files_002c-timestamps-in"></a>
<a name="index-files_002c-log_002c-timestamps-in"></a>
<a name="index-gawk_002c-timestamps"></a>
<a name="index-POSIX-awk_002c-timestamps-and"></a>
<p><code>awk</code> 程序常常用来处理带时间戳信息的日志文件，以提示特定的日志记录是何时被写入的。许多的程序将日志的时间信息记录成 <code>time()</code> 系统调用返回的格式，即是从特定时刻开始的秒数。在 POSIX 兼容的系统上，它是从 1970-01-01 00:00:00 UTC 时间开始以来的秒数，没有包含润秒。
<a name="DOCF56" href="#FOOT56">(56)</a>
所有知名的 POSIX 兼容的系统支持从 0 到
2@sup{31} - 1,
之间的时间戳，这个时间可以表示到 2038-01-19 03:14:07 UTC 的时间。
很多的系统支持更宽的时间戳范围，包括负的时间戳，以表示 epoch 之间的时间。
</p>
<a name="index-date-utility_002c-GNU"></a>
<a name="index-time_002c-retrieving"></a>
<p>为了更容易处理这样的带时间戳的日志文件并且产生有用的报表，<code>gawk</code> 提供了下面的函数来处理时间戳。它们都是 <code>gawk</code> 的扩展，并没有在 POSIX 标准中指定。
<a name="DOCF57" href="#FOOT57">(57)</a>
但是，<code>mawk</code> 的新近的版本（查看 see section <a href="#Other-Versions">其他可自由获取的 <code>awk</code></a>）也支持这些函数。可选的参数被包含在方括号中（[ ]）：
</p>
<dl compact="compact">
<dt><code>mktime(<var>datespec</var>)</code></dt>
<dd><a name="index-mktime_0028_0029-function-_0028gawk_0029"></a>
<a name="index-generate-time-values"></a>
<p>将 <var>datespec</var> 转换为与 <code>systime()</code> 返回的相同格式的时间戳。它与在 ISO C 中同名的函数相似。
<var>datespec</var> 参数是一个 <code>&quot;<var>YYYY</var>&nbsp;<var>MM</var>&nbsp;<var>DD</var>&nbsp;<var>HH</var>&nbsp;<var>MM</var>&nbsp;<var>SS</var>&nbsp;[<var>DST</var>]&quot;</code> 格式的字串。
字串包含 6 个或者 7 个数字，以相应地表示年的全的世纪年，从 1 到 12 的月，1 到 31 的日，一天中从 0 到 23 的小时，0 到 59 分钟，0 到 60 秒，<a name="DOCF58" href="#FOOT58">(58)</a>
以及一个可选的夏令时标志。
</p>
<p>这些数字的值不是必须在所指定的范围内，例如 -1 小时表时午夜前的 1 小时。初始的格林日历的 0 为始，0 年表示 1 年之前，而 -1 年表示在 0 年前。时间也可以假设为本地时间。如果夏令时标志为正，则时间假设为夏令时时间，如果为 0，则时间假设为标准时间，如果为负（默认值），<code>mktime()</code> 会试图确定特定的时间是否是夏令时时间。
</p>
<p>如果 <var>datespec</var> 没有包含足够的元素或者结果的时间超出了范围，<code>mktime()</code> 返回 -1 。
</p>
<a name="index-gawk_002c-PROCINFO-array-in-1"></a>
<a name="index-PROCINFO-array-1"></a>
</dd>
<dt><code>strftime(</code>[<var>format</var> [<code>,</code> <var>timestamp</var> [<code>,</code> <var>utc-flag</var>] ] ]<code>)</code></dt>
<dd><a name="index-strftime_0028_0029-function-_0028gawk_0029"></a>
<a name="index-format-time-string"></a>
<p>根据字串格式 <var>format</var> 的内容，将指定的时间戳 <var>timestamp</var> 进行格式化，并返回结果。这与 ISO C 中同名的函数的功能类似。如果提供了 <var>utc-flag</var> 参数，并且是非 0，或者非空，则值会格式化为 UTC（统一协调时间，之前为 GMT，格林尼治标准时间）。否则，值将被格式化为本地时区时间。<var>timestamp</var> 的格式与 <code>systime()</code> 返回的值的格式一样。
如果没有指定 <var>timestamp</var> 参数，<code>gawk</code> 则使用当天的当时时间作为 <var>timestamp</var>。如果没有格式参数，<code>strftime()</code> 则使用 <code>PROCINFO[&quot;strftime&quot;]</code> 的值作为格式字串（查看 <a href="#Built_002din-Variables">预定义变量</a>）。
默认的字串值为 <code>&quot;%a&nbsp;%b&nbsp;%e&nbsp;%H:%M:%S&nbsp;%Z&nbsp;%Y&quot;</code>。这个格式字串产生的输出与 <code>date</code> 工具产生的输出一样。你可以给 <code>PROCINFO[&quot;strftime&quot;]</code> 赋一个新值，以改变默认格式，查看下面的列表来获取格式指示符。
</p>
</dd>
<dt><code>systime()</code></dt>
<dd><a name="index-systime_0028_0029-function-_0028gawk_0029"></a>
<a name="index-timestamps-1"></a>
<a name="index-current-system-time"></a>
<p>返回从系统 epoch 开始当前时间的秒数。在 POSIX 系统中，这是从 1970-01-01 00:00:00 UTC 开始的秒数，不包含润秒。在其他系统中可能是不同的值。
</p></dd>
</dl>

<p><code>systime()</code> 函数可以让你比较日志文件的时间戳与当前的时间。特别是，很容易确定相应的记录是多久之前记录的。它也可以让你用从 epoch 开始格式的时间来产生日志记录。
</p>
<a name="index-converting_002c-dates-to-timestamps"></a>
<a name="index-dates_002c-converting-to-timestamps"></a>
<a name="index-timestamps_002c-converting-dates-to"></a>
<p><code>mktime()</code> 函数可以让你将文本形式的日期与时间的表示转换为一个时间戳。因此很容易来作日期与时间的前后比较，尤其是当处理的日期与时间数据来自于外部，比如一个日志文件。
</p>
<p><code>strftime()</code> 函数可以让你很容易将一个时间戳转换成一个人可读的信息。这有点像 <code>printf</code> 函数（查看 <a href="#String-Functions">字串操作函数</a>）的特点一样，在这个函数中将非格式化的范围字符一字不变地加入到返回串中。将日期与时间值替换为格式串 <var>format</var> 中所指定的格式规范。
</p>
<a name="index-format-specifiers_002c-strftime_0028_0029-function-_0028gawk_0029"></a>
<p><code>strftime()</code> 使用的是 1999 ISO C 的标准，
<a name="DOCF59" href="#FOOT59">(59)</a>
可以支持下面的日期格式规范：
</p>
<dl compact="compact">
<dt><code>%a</code></dt>
<dd><p>本地语言设置中缩写的星期名。
</p>
</dd>
<dt><code>%A</code></dt>
<dd><p>本地语言设置中的完整的星期名。
</p>
</dd>
<dt><code>%b</code></dt>
<dd><p>本地语言设置中缩写的月份名。
</p>
</dd>
<dt><code>%B</code></dt>
<dd><p>本地语言设置中完整的月份名。
</p>
</dd>
<dt><code>%c</code></dt>
<dd><p>本地语言设置中“恰当的”日期与时间表示。（这在 <code>&quot;C&quot;</code> 语言设置中为 &lsquo;<samp>%A %B %d %T %Y</samp>&rsquo;）
</p>
</dd>
<dt><code>%C</code></dt>
<dd><p>当前年的世纪部分。这是年除以 100，并向下整数进行截取得到的数值。
</p>
</dd>
<dt><code>%d</code></dt>
<dd><p>月中的 10 进制日期（01-31）。
</p>
</dd>
<dt><code>%D</code></dt>
<dd><p>与指定 &lsquo;<samp>%m/%d/%y</samp>&rsquo; 相同。
</p>
</dd>
<dt><code>%e</code></dt>
<dd><p>月中的日期，如果只有一位，则进行空格补全。
</p>
</dd>
<dt><code>%F</code></dt>
<dd><p>与指定 &lsquo;<samp>%Y-%m-%d</samp>&rsquo; 等同。这是 ISO 8601 的格式。
</p>
</dd>
<dt><code>%g</code></dt>
<dd><p>ISO 8601 标准中年与 100 的模的周数值，格式为十进制数（00-99）。例如，2012 年的 1 月 1 日， 是 2011 年的 53 周。因此，年在 ISO 8601 中的周数在 2011 年，就算年已经是 2012 年了。相似的，2012 年 12 月 31 日是 2013 年的第 1 周。所以，年的 ISO 周是 2013 年，就算年还是 2012 年。
</p>
</dd>
<dt><code>%G</code></dt>
<dd><p>ISO 周数的完整年，为十进制数。
</p>
</dd>
<dt><code>%h</code></dt>
<dd><p>与 &lsquo;<samp>%b</samp>&rsquo; 等同。
</p>
</dd>
<dt><code>%H</code></dt>
<dd><p>十进制的小时（24 小时制，00-23）。
</p>
</dd>
<dt><code>%I</code></dt>
<dd><p>十进制的小时（12 小时制，01-12 ）。
</p>
</dd>
<dt><code>%j</code></dt>
<dd><p>一年中的天数的十进制数（001-366）。
</p>
</dd>
<dt><code>%m</code></dt>
<dd><p>月份的十进制数（01-12）。
</p>
</dd>
<dt><code>%M</code></dt>
<dd><p>分钟的十进制数（00-59）。
</p>
</dd>
<dt><code>%n</code></dt>
<dd><p>换行符（ASCII LF）。
</p>
</dd>
<dt><code>%p</code></dt>
<dd><p>与本地语言设置中 AM/PM 的等同，与 12 小时间制关联的表示法。
</p>
</dd>
<dt><code>%r</code></dt>
<dd><p>本地语言设置中 12 小时制的时钟时间。（这在 <code>&quot;C&quot;</code> 语言设置中为 &lsquo;<samp>%I:%M:%S %p</samp>&rsquo;。）
</p>
</dd>
<dt><code>%R</code></dt>
<dd><p>与 &lsquo;<samp>%H:%M</samp>&rsquo; 等同。
</p>
</dd>
<dt><code>%S</code></dt>
<dd><p>十进制的秒数（00-60）。
</p>
</dd>
<dt><code>%t</code></dt>
<dd><p>TAB 字符。
</p>
</dd>
<dt><code>%T</code></dt>
<dd><p>与 &lsquo;<samp>%H:%M:%S</samp>&rsquo; 等同。
</p>
</dd>
<dt><code>%u</code></dt>
<dd><p>十进制的星期数（1-7）。星期一为 1。
</p>
</dd>
<dt><code>%U</code></dt>
<dd><p>一年中的十进制的周数（0-53，第一个星期日作为第一周的第一天）。
</p>
</dd>
<dt><code>%V</code></dt>
<dd><p>一年中的十进制的周数（01-53，第一个星期一作为第一周的第一天）。确定周数的方法由 ISO 8601 中所指定的一样。（即：如果包含 1 月 1 日星期中有在新的一年中有 4 天，或者更多的天数，则就是算成一周，否则前一年就是 53 周，下一周就算成第一周。）
</p>
</dd>
<dt><code>%w</code></dt>
<dd><p>十进制的星期几（0-6）。星期天是 0 天。
</p>
</dd>
<dt><code>%W</code></dt>
<dd><p>一年的周数（00-53，第一个星期一作为第一周的第一天）。
</p>
</dd>
<dt><code>%x</code></dt>
<dd><p>本地语言设置中“恰当的”日期表示。（对于 <code>&quot;C&quot;</code> 的语言设置则为 &lsquo;<samp>%A %B %d %Y</samp>&rsquo; 。）
</p>
</dd>
<dt><code>%X</code></dt>
<dd><p>本地语言设置中“恰当的”时间表示。（对于 <code>&quot;C&quot;</code> 的语言设置则为 &lsquo;<samp>%T</samp>&rsquo; 。）
</p>
</dd>
<dt><code>%y</code></dt>
<dd><p>年与 100 的模的十进制数（00-99）。
</p>
</dd>
<dt><code>%Y</code></dt>
<dd><p>年的十进制全写（如 2015 ）。
</p>
</dd>
<dt><code>%z</code></dt>
<dd><p>时区差，用 &lsquo;<samp>+<var>HHMM</var></samp>&rsquo; 格式表示（即格式需要产生 RFC 822/RFC 1036 的日期头）。
</p>
</dd>
<dt><code>%Z</code></dt>
<dd><p>时区名或者是其缩写，如果时区不能确定则没有字符。
</p>
</dd>
<dt><code>%Ec %EC %Ex %EX %Ey %EY %Od %Oe %OH</code></dt>
<dt><code>%OI %Om %OM %OS %Ou %OU %OV %Ow %OW %Oy</code></dt>
<dd><p>在规范中只使用第二个字符的“替代表示”（&lsquo;<samp>%c</samp>&rsquo;，&lsquo;<samp>%C</samp>&rsquo;，等等）。
<a name="DOCF60" href="#FOOT60">(60)</a>
（这个设施是与 POSIX 的 <code>date</code> 工具兼容的。）
</p>
</dd>
<dt><code>%%</code></dt>
<dd><p>A literal &lsquo;<samp>%</samp>&rsquo;.
</p></dd>
</dl>

<p>如果转换指定符不是上面所列之一，行为就是未定义的。 
<a name="DOCF61" href="#FOOT61">(61)</a>
</p>
<p>对于没有完全与标准兼容的系统，<code>gawk</code> 提供一个来自于 GNU C 库的 <code>strftime()</code> 的一个复本。它支持上面所列的所有格式指定符。如果那个版本用于编译 <code>gawk</code> （查看 see section <a href="#Installation">安装 <code>gawk</code></a>），则下面的额外的格式指定符也可用：
</p>
<dl compact="compact">
<dt><code>%k</code></dt>
<dd><p>24 小时制的十进制小时（0-23）。一个位的数值会用空格进行填补。
</p>
</dd>
<dt><code>%l</code></dt>
<dd><p>12 小时制的十进制小时（1-12）。一个位的数值会用空格进行填补。
</p>

</dd>
<dt><code>%s</code></dt>
<dd><p>十进制的时间戳，从 epoch 开始的秒数。
</p>
</dd>
</dl>

<p>另外，替代的表示可以被识别到，但是只使用它们的常规表示。
</p>
<a name="index-date-utility_002c-POSIX"></a>
<a name="index-POSIX-awk_002c-date-utility-and"></a>
<p>下面的例子是 POSIX <code>date</code> 工具的 <code>awk</code> 实现。正常情况下，<code>date</code> 工具以一种大家都了解的格式打印当前的日期与时间。但是，如果你提供了前面带 &lsquo;<samp>+</samp>&rsquo; 的参数，<code>date</code> 则会复杂非格式指定符到标准输出中，并且按照串中所格式指定符来解释当前的时间。如：
</p>
<div class="example">
<pre class="example">$ <kbd>date '+Today is %A, %B %d, %Y.'</kbd>
-| Today is Monday, September 22, 2014.
</pre></div>

<p>下面是 <code>gawk</code> 版本的 <code>date</code> 工具。它有一个壳为“wrapper”来处理 &lsquo;<samp>-u</samp>&rsquo; 选项，这个选项要求 <code>date</code> 运行时假设时区是 UTC：
</p>
<div class="example">
<pre class="example">#! /bin/sh
#
# date --- approximate the POSIX 'date' command

case $1 in
-u)  TZ=UTC0     # use UTC
     export TZ
     shift ;;
esac

gawk 'BEGIN  {
    format = PROCINFO[&quot;strftime&quot;]
    exitval = 0

    if (ARGC &gt; 2)
        exitval = 1
    else if (ARGC == 2) {
        format = ARGV[1]
        if (format ~ /^\+/)
            format = substr(format, 2)   # remove leading +
    }
    print strftime(format)
    exit exitval
}' &quot;$@&quot;
</pre></div>

<hr>
<a name="Bitwise-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Time-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Type-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_008dae_0093_008da_00bd_009caa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">9.1.6 位操作函数</h3>
<a name="index-bit_002dmanipulation-functions"></a>
<a name="index-bitwise_002c-operations"></a>
<a name="index-AND-bitwise-operation"></a>
<a name="index-OR-bitwise-operation"></a>
<a name="index-XOR-bitwise-operation"></a>
<a name="index-operations_002c-bitwise"></a>
<blockquote>
<p><i>
我可以向你解释，但是没办法帮你理解。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Anonymous</em>
</p>
<p>很多的语言提供了在两个整数之间执行<em>位</em>操作的能力。换句话说，操作在两个在操作数上的连续位对进行操作。三个常用的操作为按位 AND，OR 与 XOR。操作在 <a href="#table_002dbitwise_002dops">Table 9.6</a> 中描述。
</p>
<div class="float"><a name="table_002dbitwise_002dops"></a>

<div class="display">
<pre class="display">                位操作符
          |  AND  |   OR  |  XOR
          |&mdash;+&mdash;+&mdash;+&mdash;+&mdash;+&mdash;
操作数  | 0 | 1 | 0 | 1 | 0 | 1
&mdash;&mdash;&mdash;-+&mdash;+&mdash;+&mdash;+&mdash;+&mdash;+&mdash;
    0     | 0   0 | 0   1 | 0   1
    1     | 0   1 | 1   1 | 1   0
</pre></div>

</div><p><strong>Table 9.6: 位操作
</strong>
</p>
<a name="index-bitwise_002c-complement"></a>
<a name="index-complement_002c-bitwise"></a>
<p>如你所见，AND 操作的结果是只有当两个位<em>都</em>为 1 时才为 1。OR 的操作结果是当两个位<em>有一个</em>为 1 则为 1。
XOR 的操作结果是有一个位 1 则为 1，但不能两个都为 1。下一个参数是<em>“补”</em>（取反），1 的补为 0，0 的补为 1。所以，这个操作“翻转”所给值的所有位。
</p>
<a name="index-bitwise_002c-shift"></a>
<a name="index-left-shift_002c-bitwise"></a>
<a name="index-right-shift_002c-bitwise"></a>
<a name="index-shift_002c-bitwise"></a>
<p>最后，还有两个常用的操作将位从左或者从右进行平移。如，如果你有值串 &lsquo;<samp>10111001</samp>&rsquo;，然后你将它向右平移 3 位，最终得到的值为 &lsquo;<samp>00010111</samp>&rsquo;。
<a name="DOCF62" href="#FOOT62">(62)</a>
如果你又用同样的值 &lsquo;<samp>10111001</samp>&rsquo; 进行左移三位，则得到 &lsquo;<samp>11001000</samp>&rsquo;。下面的列表中描述了 <code>gawk</code> 中内建的实现位操作的函数。可选的参数包含在方括号中（[ ]）：
</p>
<a name="index-gawk_002c-bitwise-operations-in"></a>
<dl compact="compact">
<dd><a name="index-and_0028_0029-function-_0028gawk_0029"></a>
<a name="index-bitwise-AND"></a>
</dd>
<dt><code><code>and(</code><var>v1</var><code>,</code> <var>v2</var> [<code>,</code> &hellip;]<code>)</code></code></dt>
<dd><p>返回参数的 AND 结果。至少有两个参数。
</p>
<a name="index-compl_0028_0029-function-_0028gawk_0029"></a>
<a name="index-bitwise-complement"></a>
</dd>
<dt><code><code>compl(<var>val</var>)</code></code></dt>
<dd><p>返回 <var>val</var> 的位“补”结果。
</p>
<a name="index-lshift_0028_0029-function-_0028gawk_0029"></a>
<a name="index-left-shift"></a>
</dd>
<dt><code><code>lshift(<var>val</var>, <var>count</var>)</code></code></dt>
<dd><p> 返回 <var>val</var> 左移 <var>count</var> 位的值。
</p>
<a name="index-or_0028_0029-function-_0028gawk_0029"></a>
<a name="index-bitwise-OR"></a>
</dd>
<dt><code><code>or(</code><var>v1</var><code>,</code> <var>v2</var> [<code>,</code> &hellip;]<code>)</code></code></dt>
<dd><p>返回参数的 OR 结果。至少有两个参数。
</p>
<a name="index-rshift_0028_0029-function-_0028gawk_0029"></a>
<a name="index-right-shift"></a>
</dd>
<dt><code><code>rshift(<var>val</var>, <var>count</var>)</code></code></dt>
<dd><p>返回 <var>val</var> 右移 <var>count</var> 位的值。
</p>
<a name="index-xor_0028_0029-function-_0028gawk_0029"></a>
<a name="index-bitwise-XOR"></a>
</dd>
<dt><code><code>xor(</code><var>v1</var><code>,</code> <var>v2</var> [<code>,</code> &hellip;]<code>)</code></code></dt>
<dd><p>返回参数的 XOR 结果。至少有两个参数。
</p></dd>
</dl>

<p>对所有这些函数，产生双精度的浮点数会被转换为最宽的 C 的无符号整数，然后再执行位操作。如果结果不能被 C 的 <code>double</code> 精确表示，其前导的非零位会一位位地移除，直到可以被精确表示。结果再转换加 <code>double</code> 类型。（如果你不理解这个转换图，也不要担心。）
</p>
<p>这里是一个用户自定义的函数（查看 <a href="#User_002ddefined">用户自定义函数</a>），其中解释了这些函数的使用：
</p>
<a name="index-bits2str_0028_0029-user_002ddefined-function"></a>
<a name="index-testbits_002eawk-program"></a>
<div class="example">
<pre class="example"># bits2str --- turn a byte into readable ones and zeros

function bits2str(bits,        data, mask)
{
    if (bits == 0)
        return &quot;0&quot;

    mask = 1
    for (; bits != 0; bits = rshift(bits, 1))
        data = (and(bits, mask) ? &quot;1&quot; : &quot;0&quot;) data

    while ((length(data) % 8) != 0)
        data = &quot;0&quot; data

    return data
}
</pre><pre class="example">
BEGIN {
    printf &quot;123 = %s\n&quot;, bits2str(123)
    printf &quot;0123 = %s\n&quot;, bits2str(0123)
    printf &quot;0x99 = %s\n&quot;, bits2str(0x99)
    comp = compl(0x99)
    printf &quot;compl(0x99) = %#x = %s\n&quot;, comp, bits2str(comp)
    shift = lshift(0x99, 2)
    printf &quot;lshift(0x99, 2) = %#x = %s\n&quot;, shift, bits2str(shift)
    shift = rshift(0x99, 2)
    printf &quot;rshift(0x99, 2) = %#x = %s\n&quot;, shift, bits2str(shift)
}
</pre></div>

<p>当执行时，产生如下输出：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f testbits.awk</kbd>
-| 123 = 01111011
-| 0123 = 01010011
-| 0x99 = 10011001
-| compl(0x99) = 0x3fffffffffff66 = 00111111111111111111111111111111111111111111111101100110
-| lshift(0x99, 2) = 0x264 = 0000001001100100
-| rshift(0x99, 2) = 0x26 = 00100110
</pre></div>

<a name="index-converting_002c-strings-to-numbers-1"></a>
<a name="index-strings_002c-converting-1"></a>
<a name="index-numbers_002c-converting-1"></a>
<a name="index-converting_002c-numbers-to-strings-1"></a>
<a name="index-number-as-string-of-bits"></a>
<p><code>bits2str()</code> 函数将一个二进制数转换为字符串。给 <code>mask</code> 初始化为 1 来创建一个这样的二进制数据，其最右边的位被设置为 1。使用这个 <code>mask</code>，函数重复地检查最右边的位。将 <code>mask</code> 与值进行 AND 操作，可以显示出最右边的位是 1 还是 0。如果是 1，就会在字串的前面连接一个 <code>&quot;1&quot;</code>，否则连接一个 <code>&quot;0&quot;</code>。值然后向右称 1 位，直到没有更多的 1 存在。
</p>
<p>如果初始值为 0，它会简单地返回 <code>&quot;0&quot;</code>。否则最后，会将值进行填补以产生 8 位数量的整倍数。在现代的计算机中这是一种典型的处理。
</p>
<p>在 <code>BEGIN</code> 中的主代码规则显示了十进制与八进制数据的同一个值的不同（查看 see section <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>），然后展示了 <code>compl()</code>，<code>lshift()</code>， 与 <code>rshift()</code> 函数的结果。
</p>
<hr>
<a name="Type-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Bitwise-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_008e_00b7aa_008f_0096c_00b1_00bbaa_009e_008ba_00bf_00a1ae_0081_00af"></a>
<h3 class="subsection">9.1.7 获取类型信息</h3>

<p><code>gawk</code> 提供了一个函数来让你可以区分数组与标量变量。这在遍历多维数组的每一个元素的时候是非常有用的（查看 see section <a href="#Arrays-of-Arrays">多维数组</a>）。
</p>
<dl compact="compact">
<dd><a name="index-isarray_0028_0029-function-_0028gawk_0029"></a>
<a name="index-scalar-or-array"></a>
</dd>
<dt><code>isarray(<var>x</var>)</code></dt>
<dd><p>如果 <var>x</var> 是一个数组，则返回 true，否则返回 false。
</p></dd>
</dl>

<p><code>isarray()</code> 主要用在两种环境中。第一种是当遍历多维数组时，你可以测试某个元素是否是数组。第二个场景是在用户自定义函数中（还未讨论到，查看 <a href="#User_002ddefined">用户自定义函数</a>），用来测试参数是否为数组。
</p>
<blockquote>
<p><b>提示:</b> 在全局范围内使用 <code>isarray()</code> 来测试变量并没有含义。因为你就是写程序的人，你当然知道你的变量是不是数组，实际上，由于 <code>gawk</code> 的工具方式，如果你变量的名字在 <code>isarray()</code> 之前还没有用到，<code>gawk</code> 会将其转换成一个标量。
</p></blockquote>

<hr>
<a name="I18N-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Type-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Built_002din" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#User_002ddefined" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ad_0097a_00b8_00b2c_00bf_00bbe_00af_0091aa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">9.1.8 字串翻译函数</h3>
<a name="index-gawk_002c-string_002dtranslation-functions"></a>
<a name="index-functions_002c-string_002dtranslation"></a>
<a name="index-string_002dtranslation-functions"></a>
<a name="index-internationalization"></a>
<a name="index-awk-programs_002c-internationalizing"></a>

<p><code>gawk</code> 提供了一些设施用来国际化 <code>awk</code> 程序。这些包含了下面列表中描述的函数。这些的描述只是目的性的。
查看 <a href="#Internationalization"><code>gawk</code> 的国际化</a>，来查看全部的说明。可选的参数放在方括号中（[ ]）：
</p>
<dl compact="compact">
<dd><a name="index-bindtextdomain_0028_0029-function-_0028gawk_0029"></a>
<a name="index-set-directory-of-message-catalogs"></a>
</dd>
<dt><code>bindtextdomain(<var>directory</var></code> [<code>,</code> <var>domain</var>]<code>)</code></dt>
<dd><p>设置目录，当不会或者不能定位到“标准”的位置时，<code>gawk</code> 会在这个目录里查找信息翻译文件（如在测试期间）。
它返回绑定 <var>domain</var> 的目录。
</p>
<p>默认的 <var>domain</var> 是 <code>TEXTDOMAIN</code> 的值。如果目录是一个空串（<code>&quot;&quot;</code>），则 <code>bindtextdomain()</code> 返回给定 <var>domain</var> 的当前绑定。
</p>
<a name="index-dcgettext_0028_0029-function-_0028gawk_0029"></a>
<a name="index-translate-string"></a>
</dd>
<dt><code>dcgettext(<var>string</var></code> [<code>,</code> <var>domain</var> [<code>,</code> <var>category</var>] ]<code>)</code></dt>
<dd><p>返回在文本域 <var>domain</var> 中，对于本地语言设置 <var>category</var> 的串 <var>string</var> 的翻译串。
默认的 <var>domain</var> 值是当前 <code>TEXTDOMAIN</code> 的值。
<var>category</var> 的默认值是 <code>&quot;LC_MESSAGES&quot;</code>。
</p>
<a name="index-dcngettext_0028_0029-function-_0028gawk_0029"></a>
</dd>
<dt><code>dcngettext(<var>string1</var>, <var>string2</var>, <var>number</var></code> [<code>,</code> <var>domain</var> [<code>,</code> <var>category</var>] ]<code>)</code></dt>
<dd><p>返回在分类 <var>category</var> 的文本域 <var>domain</var> 中，用于进行 <var>string1</var> 与 <var>string2</var> 翻译的数目 <var>number</var> 的复数形式。<var>string1</var> 是某个消息的英语单一变体，<var>string2</var> 同一个消息的英语复数形式。<var>domain</var> 的默认值就是 <code>TEXTDOMAIN</code> 的当前值。<var>category</var> 的默认值是 <code>&quot;LC_MESSAGES&quot;</code>。
</p></dd>
</dl>

<hr>
<a name="User_002ddefined"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Definition-Syntax" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_00a8ae_0088_00b7e_0087_00aaaa_00ae_009aa_00b9_0089aa_0087_00bdae_0095_00b0"></a>
<h2 class="section">9.2 用户自定义函数</h2>

<a name="index-user_002ddefined-functions"></a>
<a name="index-functions_002c-user_002ddefined"></a>
<p>复杂的 <code>awk</code> 程序常常通过定义自己的函数来进行简化。用户自定义函数也可以像内置函数一样调用（查看 see section <a href="#Function-Calls">函数调用</a>），但是定义他们则是你的自由（即告诉 <code>awk</code> 你所要做的事情）。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           How to write definitions and what they mean.
</td></tr>
<tr><td align="left" valign="top"><a href="#Function-Example">9.2.2 函数定义范例</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            An example function definition and what it
                                does.
</td></tr>
<tr><td align="left" valign="top"><a href="#Function-Caveats">9.2.3 调用用户自定义函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Things to watch out for.
</td></tr>
<tr><td align="left" valign="top"><a href="#Return-Statement">9.2.4 <code>return</code> 语句</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Specifying the value a function returns.
</td></tr>
<tr><td align="left" valign="top"><a href="#Dynamic-Typing">9.2.5 函数与其在变量类型上的影响</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              How variable types can change at runtime.
</td></tr>
</table>

<hr>
<a name="Definition-Syntax"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#User_002ddefined" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#User_002ddefined" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Example" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0087_00bdae_0095_00b0aa_00ae_009aa_00b9_0089e_00af_00adae_00b3_0095"></a>
<h3 class="subsection">9.2.1 函数定义语法</h3>

<blockquote>
<p><i>
说 <code>awk</code> 本地变量的定义语法惊人的糟糕是很公正的。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Brian Kernighan</em>
</p>
<a name="index-functions_002c-defining"></a>
<p>函数的定义可以出现在 <code>awk</code> 程序规则之间的任何地方。
所以，<code>awk</code> 程序的一般形式是被扩展为包含一系列的规则<em>与</em>用户自定义函数定义。没有必须将函数定义放在所有使用函数的地方之间。这是因为 <code>awk</code> 读取程序是在开始执行任何部份之前。
</p>
<p>某个函数名为 <var>name</var> 的定义看起来如下：
</p>
<div class="display">
<pre class="display"><code>function</code> <var>name</var><code>(</code>[<var>parameter-list</var>]<code>)</code>
<code>{</code>
     <var>body-of-function</var>
<code>}</code>
</pre></div>

<a name="index-names_002c-functions"></a>
<a name="index-functions_002c-names-of"></a>
<a name="index-namespace-issues_002c-functions"></a>
<p>在这里，<var>name</var> 是要定义函数的名字。有一个有效的函数名就像一个有效的变量名一样：一系列的字母、数字以及下划线，同时不以数字开头的序列。因此，只有 52 个大写跟小写的英文字母可以用于函数名。
在一个单独的 <code>awk</code> 程序中，任何特定的名字只能被作为变量、数组或者函数来使用。
</p>
<p><var>parameter-list</var> 是一个可选的函数参数，以及本地变量名的列表，通过逗号分隔。当函数被调用的时候，参数名用于在调用时传递的参数值。
</p>
<p>函数不可以用两个相同名字的参数，也不可以与函数的名字同名。
</p>
<blockquote>
<p><b>注意:</b> 根据 POSIX 标准，函数参数不可以与特殊的预定义变量同名（查看 see section <a href="#Built_002din-Variables">预定义变量</a>），函数参数也不可以与另一个函数名同名。
</p>
<p>并不是所有的 <code>awk</code> 版本都强制这些限制。<code>gawk</code> 总是强制第一条限制。在指定 &lsquo;<samp>--posix</samp>&rsquo; 选项时（查看 <a href="#Options">命令行参数</a>），它也强制第二个限制。
</p></blockquote>

<p>如果被参考的地方需要一个字串值的时候，本变量表现像一个空串，如果参考到的地方需要一个数值的时候，就表现为 0。这与常规的变量在还没有被赋值时的表现一样。（要更多地理解本地变量，查看 see section <a href="#Dynamic-Typing">函数与其在变量类型上的影响</a>）
</p>
<p><var>body-of-function</var> 由 <code>awk</code> 的语句组成。这是定义的最重要的部分，因此它定义了函数实际要<em>做</em>的事情。参数名存在给了函数体与参数进行对话的方式，本地变量的存在可以使函数体来保存临时值。
</p>
<p>参数名与本地变量名没有语法上的区别。相反，调用函数时提供的参数个数决定了有多少个参数变量。因此，如果给了三个参数值，<var>parameter-list</var> 中的头三个名字就是参数，而剩下的就是本地变量。
</p>
<p>规则是这样的，如果参数的个数与所有的函数的所有调用都不一样，在 <var>parameter-list</var> 中的一些名字有时是参数，而在其他时间则是本地变量。另一个思考这个问题的方式是，被省略的参数的默认值为空串。
</p>
<a name="index-programming-conventions_002c-functions_002c-writing"></a>
<p>通常情况下，当你写一个函数的时候，你知道你要使用的名字数，以基作为参数，而有相应的个数用来作本地变量。将一些额外的空格放在参数与本地变量之间可以很方便地来加以区分，这可以作为如何来使用函数的文档。
</p>
<a name="index-variables_002c-shadowing"></a>
<a name="index-shadowing-of-variable-values"></a>
<p>在函数体的执行过程中，参数与本地变量会被隐藏，或者<em>遮盖</em>掉，程序后面所有使用到的同名的变量。被遮盖掉的变量在函数定义中是不可访问的，因此没有方法在它们的名字被用于参数或者本地变量时进行命名。所以其他的在 <code>awk</code> 程序中使用的变量可以在函数体中被参考，或者设置。参数与本地变量只持续到函数体执行完成。只要函数体一完成，你就再一次可以访问那些在函数执行时被遮盖掉的变量。
</p>
<p>函数体可以包含调用函数的表达式。他们甚至可以调用函数本身，直接地或者通过另一个函数来调用。当发生了这样的事情时，我们称函数是递归的。函数调用其本身的动作称为递归。
</p>
<a name="index-recursive-functions"></a>
<a name="index-functions_002c-recursive"></a>
<p>函数体可以包含调用函数的表达式。他们甚至可以调用函数本身，直接地或者通过另一个函数来调用。当发生了这样的事情时，我们称函数是<em>递归的</em>。函数调用其本身的动作称为<em>递归</em>。
</p>
<p>所有的内建函数返回一个值给它他的调用者。用户自定义函数也可以这么做，只需要使用 <code>return</code> 语句，它在 <a href="#Return-Statement"><code>return</code> 语句</a>，进行详细的描述。本小节中后续的很多例子都使用 <code>return</code> 语句。
</p>
<a name="index-common-extensions_002c-func-keyword"></a>
<a name="index-extensions_002c-common_002c-func-keyword"></a>
<a name="index-POSIX-awk_002c-function-keyword-in"></a>
<p>在很多的 <code>awk</code> 实现中，包括 <code>gawk</code>，关键词 <code>function</code> 可以简写为 <code>func</code>。(c.e.)
但是 POSIX 只指定了使用关键词 <code>function</code>。实际上有一些实践上的隐义。如果 <code>gawk</code> 是 POSIX 兼容模式（查看 <a href="#Options">命令行参数</a>），则下面的语句<em>不会</em>定义一个函数：
</p>
<div class="example">
<pre class="example">func foo() { a = sqrt($1) ; print a }
</pre></div>

<p>相反，它定义了这样的一个规则：对每一个记录，连接变量 &lsquo;<samp>func</samp>&rsquo; 的值与函数 &lsquo;<samp>foo</samp>&rsquo; 的返回值。如果结果字串是非空的，动作就会被执行。这可能不是所想要的。（<code>awk</code> 接收这样的输入为语法有效，因此函数可以在它们在 <code>awk</code> 程序中定义之前被调用。<a name="DOCF63" href="#FOOT63">(63)</a>）
</p>
<a name="index-portability_002c-functions_002c-defining"></a>
<p>为了保证你的 <code>awk</code> 程序是可移植的，在定义函数时，总是使用关键字 <code>function</code>。
</p>
<hr>
<a name="Function-Example"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Definition-Syntax" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#User_002ddefined" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Caveats" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0087_00bdae_0095_00b0aa_00ae_009aa_00b9_0089e_008c_0083a_00be_008b"></a>
<h3 class="subsection">9.2.2 函数定义范例</h3>
<a name="index-function-definition-example"></a>

<p>下面是一个用户自定义函数的例子，函数名字叫 <code>myprint()</code>，该函数取得一个数值，并以指定的格式打印它：
</p>
<div class="example">
<pre class="example">function myprint(num)
{
     printf &quot;%6.3g\n&quot;, num
}
</pre></div>

<p>为了解清楚，下面是一个使用 <code>myprint()</code> 函数的 <code>awk</code> 规则：
</p>
<div class="example">
<pre class="example">$3 &gt; 0     { myprint($3) }
</pre></div>

<p>此程序用我们特定的格式打印所有输入中第三个域是正数的域。因此，当有下面的输入时：
</p>
<div class="example">
<pre class="example"> 1.2   3.4    5.6   7.8
 9.10 11.12 -13.14 15.16
17.18 19.20  21.22 23.24
</pre></div>

<p>用我们的程序格式，则会打印：
</p>
<div class="example">
<pre class="example">   5.6
  21.2
</pre></div>

<p>下面这个函数删除数组中的所有元素（回忆一下额外的空格来标识本地变量列表）：
</p>
<div class="example">
<pre class="example">function delarray(a,    i)
{
    for (i in a)
        delete a[i]
}
</pre></div>

<p>当与数组一起执行时，常常需要删除数组中的所有元素，并开始一个新的元素列表（查看 see section <a href="#Delete"><code>delete</code> 语句</a>）。为了不在每个要清除数组的地方都要重复地写这样的循环，你的程序就只调用 <code>delarray()</code>。（这保证了移植性。&lsquo;<samp>delete <var>array</var></samp>&rsquo; 的使用用来删除整个数组是最新近 才加入到 POSIX 标准中的。<a name="DOCF64" href="#FOOT64">(64)</a>）
</p>
<p>下面是一个递归函数的例子。它取一个字串作为输出参数，并返回逆序字串。递归函数必须有一个测试条件来停止递归。在这种情况下，在输入串为空时就结束递归：
</p>
<a name="index-rev_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function rev(str)
{
    if (str == &quot;&quot;)
        return &quot;&quot;

    return (rev(substr(str, 2)) substr(str, 1, 1))
}
</pre></div>

<p>如果这个函数在一个名字为 &lsquo;<tt>rev.awk</tt>&rsquo; 的文件中，我们可以这么来测试：
</p>
<div class="example">
<pre class="example">$ <kbd>echo &quot;Don't Panic!&quot; |</kbd>
&gt; <kbd>gawk -e '{ print rev($0) }' -f rev.awk</kbd>
-| !cinaP t'noD
</pre></div>

<p>C 的 <code>ctime()</code> 函数输入一个时间戳，并返回一个用常用的形式格式化的字串。下面的例子使用内置函数 <code>strftime()</code>（查看 <a href="#Time-Functions">时间函数</a>）来创建一个 <code>awk</code> 版本的 <code>ctime()</code>。
</p>
<a name="index-ctime_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># ctime.awk
#
# awk version of C ctime(3) function

function ctime(ts,    format)
{
    format = &quot;%a %b %e %H:%M:%S %Z %Y&quot;

    if (ts == 0)
        ts = systime()       # use current time as default
    return strftime(format, ts)
}
</pre></div>

<p>你可能认为 <code>ctime()</code> 可以使用 <code>PROCINFO[&quot;strftime&quot;]</code> 来作为格式串。但那会是个错误，因为 <code>ctime()</code> 假设返回的是标准的格式，而用户级的代码可能已经更改了 <code>PROCINFO[&quot;strftime&quot;]</code>。
</p>
<hr>
<a name="Function-Caveats"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Example" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#User_002ddefined" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Calling-A-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00b0_0083c_0094_00a8c_0094_00a8ae_0088_00b7e_0087_00aaaa_00ae_009aa_00b9_0089aa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">9.2.3 调用用户自定义函数</h3>

<a name="index-functions_002c-user_002ddefined_002c-calling"></a>
<p>调<em>用一个函数</em>会导致那个函数被执行。调用调用是一个表达式，其值就是函数返回的值。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Calling-A-Function">9.2.3.1 如何调用函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Don&rsquo;t use spaces.
</td></tr>
<tr><td align="left" valign="top"><a href="#Variable-Scope">9.2.3.2 控制变量作用域</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Controlling variable scope.
</td></tr>
<tr><td align="left" valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Passing parameters.
</td></tr>
</table>

<hr>
<a name="Calling-A-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Caveats" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Caveats" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Variable-Scope" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a6_0082a_00bd_0095e_00b0_0083c_0094_00a8aa_0087_00bdae_0095_00b0"></a>
<h4 class="subsubsection">9.2.3.1 如何调用函数</h4>

<p>函数调用包含函数名，后面再跟着在括号中的参数。<code>awk</code> 表达式就是用把参数写在函数调用中。每次调用执行时，这些表达式会先求值，然后值为成为实际的参数。例如，下面是一个用三个参数调用 <code>foo()</code> 函数例子（第一个参数是一个字串连接）：
</p>
<div class="example">
<pre class="example">foo(x y, &quot;lose&quot;, 4 * z)
</pre></div>

<blockquote>
<p><b>注意:</b> 在函数名了参数列表的开括号之间的空白（空格与 TABs）是不允许的。如果你不小心写了个空白在里面，<code>awk</code> 可能将你的意思理解成来连接一个变量与括号表达式的值。但是，最后它会注意到你使用了一个函数名，而不是一个变量名，因此会报一个错误。
</p></blockquote>

<hr>
<a name="Variable-Scope"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Calling-A-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Caveats" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Pass-By-Value_002fReference" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008e_00a7aa_0088_00b6aa_008f_0098e_0087_008fa_00bd_009cc_0094_00a8aa_009f_009f"></a>
<h4 class="subsubsection">9.2.3.2 控制变量作用域</h4>

<a name="index-local-variables_002c-in-a-function"></a>
<a name="index-variables_002c-local-to-a-function"></a>
<p>不像其他的很多语言，在 <code>awk</code> 没有办法使一个变量只在 <code>{</code> &hellip; <code>}</code> 块中有作用，但是你可以使一个变量成为一个函数的本地变量。这么做是一个很好的实践，在任何时候在函数中使用一个变量时，都将其置成本地变量。
</p>
<p>为了使一个变量成为函数的本地变量，只需要简单地在实际的参数（查看 see section <a href="#Definition-Syntax">函数定义语法</a>）的后面声明就可以。看下面的例子，变量 <code>i</code> 是一个全局变量，即可以被 <code>foo()</code> 使用，也可以被 <code>bar()</code> 使用：
</p>
<div class="example">
<pre class="example">function bar()
{
    for (i = 0; i &lt; 3; i++)
        print &quot;bar's i=&quot; i
}

function foo(j)
{
    i = j + 1
    print &quot;foo's i=&quot; i
    bar()
    print &quot;foo's i=&quot; i
}

BEGIN {
      i = 10
      print &quot;top's i=&quot; i
      foo(0)
      print &quot;top's i=&quot; i
}
</pre></div>

<p>执行这个脚本，则会产生下面的输出，因为 <code>i</code> 在 <code>foo()</code> 函数与 <code>bar()</code> 函数中以及在最顶层都指向同一个变量实体：
</p>
<div class="example">
<pre class="example">top's i=10
foo's i=1
bar's i=0
bar's i=1
bar's i=2
foo's i=3
top's i=3
</pre></div>

<p>如果你想 <code>i</code> 成为 <code>foo()</code> 与 <code>bar()</code> 的本地变量，近下面这么做（在 <code>i</code> 之前的额外空格是一种编码习惯，以用来表示 <code>i</code> 是一个本地变量，而不是一个参数）：
</p>
<div class="example">
<pre class="example">function bar(    i)
{
    for (i = 0; i &lt; 3; i++)
        print &quot;bar's i=&quot; i
}

function foo(j,    i)
{
    i = j + 1
    print &quot;foo's i=&quot; i
    bar()
    print &quot;foo's i=&quot; i
}

BEGIN {
      i = 10
      print &quot;top's i=&quot; i
      foo(0)
      print &quot;top's i=&quot; i
}
</pre></div>

<p>执行修正过的脚本产生如下输出：
</p>
<div class="example">
<pre class="example">top's i=10
foo's i=1
bar's i=0
bar's i=1
bar's i=2
foo's i=1
top's i=10
</pre></div>

<p>除了标量（字串与数值）外，你也可以有本地数组。通过将某个变量名用作数组，<code>awk</code> 就会将其当为数组，并且是函数的本地数组。另外，递归调用会创建新的数组。考虑下面的例子：
</p>
<div class="example">
<pre class="example">function some_func(p1,      a)
{
    if (p1++ &gt; 3)
        return

    a[p1] = p1

    some_func(p1)

    printf(&quot;At level %d, index %d %s found in a\n&quot;,
         p1, (p1 - 1), (p1 - 1) in a ? &quot;is&quot; : &quot;is not&quot;)
    printf(&quot;At level %d, index %d %s found in a\n&quot;,
         p1, p1, p1 in a ? &quot;is&quot; : &quot;is not&quot;)
    print &quot;&quot;
}

BEGIN {
    some_func(1)
}
</pre></div>

<p>当执行时，程序产生下面的输出：
</p>
<div class="example">
<pre class="example">At level 4, index 3 is not found in a
At level 4, index 4 is found in a

At level 3, index 2 is not found in a
At level 3, index 3 is found in a

At level 2, index 1 is not found in a
At level 2, index 2 is found in a
</pre></div>

<hr>
<a name="Pass-By-Value_002fReference"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Variable-Scope" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Function-Caveats" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Return-Statement" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0087_00bdae_0095_00b0aa_008f_0098e_0087_008fa_00b8_00adc_009a_0084a_00bc_00a0aa_008f_0082a_00b8_008ea_00bc_00a0aa_00bc_0095c_0094_00a8"></a>
<h4 class="subsubsection">9.2.3.3 函数变量中的传参与传引用</h4>

<p>在 <code>awk</code> 中，当你声明一个函数，没有办法显式地声明参数是通过传<em>值</em>还是传<em>引用</em>。
</p>
<p>相反，传递规范是在函数调用时根据下面的规则来动态确定的：如果参数是一个数组变量，则是通过传引用。否则，参数就是通过传值。
</p>
<a name="index-call-by-value"></a>
<p>当调用参数对参数进行传值，意是是说，它给了参数一个<em>复本</em>。调用者使用变量来作用参数的表达式，但是被调用的函数却并不知道这回事——它只知道参数具有什么样的值。例如，如果你写了下面的代码：
</p>
<div class="example">
<pre class="example">foo = &quot;bar&quot;
z = myfunc(foo)
</pre></div>

<p>则你不要将 <code>myfunc()</code> 的参数想象为“<code>foo</code> 变量”。相反，则应该将参数想为字串值 <code>&quot;bar&quot;</code>。
如果函数 <code>myfunc()</code> 改变了它本地变量的值，它对于其他的变量没有任何影响。所以，如果 <code>myfunc()</code> 执行：
</p>
<div class="example">
<pre class="example">function myfunc(str)
{
   print str
   str = &quot;zzz&quot;
   print str
}
</pre></div>

<p>来改变它的参数变量 <code>str</code>，它<em>不会</em>更改调用者 <code>foo</code> 的值。在调用 <code>myfunc()</code> 中 <code>foo</code> 的角色就在它的值（<code>&quot;bar&quot;</code>）被计算完后结束了。如果 <code>str</code> 也在 <code>myfunc()</code> 之外存在，则函数体不能更改外面的值，因为它已经在 <code>myfunc()</code> 执行时被遮盖掉了，不能从那个地方被看到，也不能被改变。
</p>
<a name="index-call-by-reference"></a>
<a name="index-arrays_002c-as-parameters-to-functions"></a>
<a name="index-functions_002c-arrays-as-parameters-to"></a>
<p>但是，当调用函数传递的是一个数组时，就<em>不会</em>执行复制。相反，数组变量本身会被函数进行直接操作。这个在术语上一般叫作<em>引用调用</em>。在函数体内对于数组的更改在函数外部也<em>是</em>可见的。
</p>
<blockquote>
<p><b>提示:</b> 如果你看不到你所做的事情，在函数中改变数组参数会非常危险。如：
</p>
<div class="example">
<pre class="example">function changeit(array, ind, nvalue)
{
     array[ind] = nvalue
}

BEGIN {
    a[1] = 1; a[2] = 2; a[3] = 3
    changeit(a, 2, &quot;two&quot;)
    printf &quot;a[1] = %s, a[2] = %s, a[3] = %s\n&quot;,
            a[1], a[2], a[3]
}
</pre></div>

<p>会打印 &lsquo;<samp>a[1] = 1, a[2] = two, a[3] = 3</samp>&rsquo;，因为 <code>changeit()</code> 会将 <code>&quot;two&quot;</code> 存储到 <code>a</code> 的第二个元素中。
</p></blockquote>

<a name="index-undefined-functions"></a>
<a name="index-functions_002c-undefined"></a>
<p>有一些 <code>awk</code> 实现可以让你调用还没有定义的函数。当程序实际上试图调用时，它只在运行时报告问题。如：
</p>
<div class="example">
<pre class="example">BEGIN {
    if (0)
        foo()
    else
        bar()
}
function bar() { &hellip; }
# note that `foo' is not defined
</pre></div>

<p>因为 &lsquo;<samp>if</samp>&rsquo; 语句决不会为 true，<code>foo()</code> 没有定义也不会是个真正的问题。但是，一般情况下，如果程序调用一个没有定义的函数确实是个问题。
</p>
<a name="index-lint-checking_002c-undefined-functions"></a>
<p>如果指定了 &lsquo;<samp>--lint</samp>&rsquo; 参数（查看 <a href="#Options">命令行参数</a>），<code>gawk</code> 会报告调用用了未定义的函数。
</p>
<a name="index-portability_002c-next-statement-in-user_002ddefined-functions"></a>
<p>如果你在用户自定义函数中使用了 <code>next</code> 语句或者 <code>nextfile</code> 语句（查看 <a href="#Next-Statement"><code>next</code> 语句</a>，以及一些 
 <a href="#Next-Statement"><code>next</code> 语句</a>），
<code>awk</code> 实现会产生一个运行时错误。<code>gawk</code> 则没有这个限制。 
</p>
<hr>
<a name="Return-Statement"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Pass-By-Value_002fReference" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#User_002ddefined" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Typing" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="return-e_00af_00adaa_008f_00a5"></a>
<h3 class="subsection">9.2.4 <code>return</code> 语句</h3>
<a name="index-return-statement_002c-user_002ddefined-functions"></a>

<p>如在之前的几个例子中所见到的，用户自定义的函数体内可以包含一个 <code>return</code> 语句。这个语句将控制返回到 <code>awk</code> 程序调用的地方。也可以用于返回一个值，以在 <code>awk</code> 程序的后面来使用。看来起其形式如下：
</p>
<div class="display">
<pre class="display"><code>return</code> [<var>expression</var>]
</pre></div>

<p><var>expression</var> 的部分是可选的。极有可能是因为疏忽，POSIX 没有定义如果 <var>expression</var> 被省略的情况下该返回什么样的值。从技术上说，这会使返回的值是未定义的，因此也是不可预测的。但是在实践中，所有的 <code>awk</code> 版本都是简单地返回一个空串，在需要数值的上下文则为 0。
</p>
<p><code>return</code> 语句中没有 <var>expression</var> 被假设为每一个函数定义的完成处。所以，如果控制到达了函数体的尾部，函数技术性地返回一个不可预测的值。在实践中，它返回一个空串。<code>awk</code> 在你使用这样的函数返回值是<em>不会</em>产生告警。
</p>
<p>有时，你想写的函数你关注的是它所做的，而不是它所返回的。这样的函数与 C 、C++ 或者 Java 中的 <code>void</code> 函数以及 Ada 中的 <code>procedure</code> 函数对应。所以，不返回任何值是恰当的，只需要简单地记住不要使用这些参数的返回值即可。
</p>
<p>下面的例子是一个返回数组元素中最大的数值的用户自定义函数：
</p>
<div class="example">
<pre class="example">function maxelt(vec,   i, ret)
{
     for (i in vec) {
          if (ret == &quot;&quot; || vec[i] &gt; ret)
               ret = vec[i]
     }
     return ret
}
</pre></div>

<a name="index-programming-conventions_002c-function-parameters"></a>
<p>你用一个参数来调用 <code>maxelt()</code>，这个参数是一个数组名。本地变量 <code>i</code> 以及 <code>ret</code> 都不是用来作参数的，没有什么可以阻止你传递多于一个参数到 <code>maxelt()</code> 中，但那会产生奇怪的结果。在参数列表中，<code>i</code> 之前额外的空格表示 <code>i</code> 与 <code>ret</code> 都是本地变量。你在定义函数时应该使用这些的习惯。
</p>
<p>下面的程序会使用 <code>maxelt()</code> 函数。它装入一个数组，然后调用 <code>maxelt()</code> 然后报告数组中的最大元素：
</p>
<div class="example">
<pre class="example">function maxelt(vec,   i, ret)
{
     for (i in vec) {
          if (ret == &quot;&quot; || vec[i] &gt; ret)
               ret = vec[i]
     }
     return ret
}

# Load all fields of each record into nums.
{
     for(i = 1; i &lt;= NF; i++)
          nums[NR, i] = $i
}

END {
     print maxelt(nums)
}
</pre></div>

<p>如果有下面的输入：
</p>
<div class="example">
<pre class="example"> 1 5 23 8 16
44 3 5 2 8 26
256 291 1396 2962 100
-6 467 998 1101
99385 11 0 225
</pre></div>

<p>则程序报告（可预测的）99,385 是数组中最大的值。
</p>
<hr>
<a name="Dynamic-Typing"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Return-Statement" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#User_002ddefined" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Indirect-Calls" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0087_00bdae_0095_00b0a_00b8_008eaa_0085_00b6aa_009c_00a8aa_008f_0098e_0087_008fc_00b1_00bbaa_009e_008ba_00b8_008ac_009a_0084aa_00bd_00b1aa_0093_008d"></a>
<h3 class="subsection">9.2.5 函数与其在变量类型上的影响</h3>

<p><code>awk</code> 是一种非常随意的语言。<code>awk</code> 有可能办法告诉你一个标识符是一个标量变量还是一个数组，直到运行时才会知道。这是一个用来说明的例子程序：
</p>
<div class="example">
<pre class="example">function foo(a)
{
    a[1] = 1   # parameter is an array
}

BEGIN {
    b = 1
    foo(b)  # invalid: fatal type mismatch

    foo(x)  # x uninitialized, becomes an array dynamically
    x = 1   # now not allowed, runtime error
}
</pre></div>

<p>在这个例子中，第一次调用 <code>foo()</code> 会产生一个致命错误，所以 <code>awk</code> 不会报告第二个错误。如果你将这个调用注释掉，则 <code>awk</code> 会报第二个错误。
</p>
<p>一般来说，这种事不是什么大问题，但是值得注意。
</p>
<hr>
<a name="Indirect-Calls"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Typing" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Functions-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0097_00b4ae_008e_00a5aa_0087_00bdae_0095_00b0e_00b0_0083c_0094_00a8"></a>
<h2 class="section">9.3 间接函数调用</h2>

<a name="index-indirect-function-calls"></a>
<a name="index-function-calls_002c-indirect"></a>
<a name="index-function-pointers"></a>
<a name="index-pointers-to-functions"></a>
<a name="index-differences-in-awk-and-gawk_002c-indirect-function-calls"></a>

<p>这一节描述了一种高级的，特定于 <code>gawk</code> 的扩展。
</p>
<p>经常的，你希望在直接运行时才确定你要调用的函数。例如，你有不同类型的记录，每一个都要有不同的处理方式。
</p>
<p>正常情况下，你不得不用一系列的 <code>if</code>-<code>else</code> 语句来决定要调用哪一个函数。通过使用<em>间接</em>函数调用，你可以指定函数的名字为一个字串，然后来再调用函数。让我们来看下一例子：
</p>
<p>假设你有一个文件，里面有你的选择的课程的测试成绩，并且你希望取得这些成绩的总合与平均值。第一个域是一个课程名。后面的域是函数调用要处理的数组，直到一个域标识 &lsquo;<samp>data:</samp>&rsquo; 为止，在标识后面到记录的末尾，都是一系列的测试成绩。
</p>
<p>这里最开始的文件：
</p>
<div class="example">
<pre class="example">Biology_101 sum average data: 87.0 92.4 78.5 94.9
Chemistry_305 sum average data: 75.2 98.3 94.7 88.2
English_401 sum average data: 100.0 95.6 87.1 93.4
</pre></div>

<p>为了处理数据，你可能开始这么写：
</p>
<div class="example">
<pre class="example">{
    class = $1
    for (i = 2; $i != &quot;data:&quot;; i++) {
        if ($i == &quot;sum&quot;)
            sum()   # processes the whole record
        else if ($i == &quot;average&quot;)
            average()
        &hellip;           # and so on
    }
}
</pre></div>

<p>这样风格的程序也可以，但是看起来有点别扭。通过<em>间接</em>函数调用，你告诉 <code>gawk</code> 使用函数<em>名称</em>变量的<em>值</em>作为函数来调用。
</p>
<a name="index-_0040_002dnotation-for-indirect-function-calls"></a>
<a name="index-indirect-function-calls_002c-_0040_002dnotation"></a>
<a name="index-function-calls_002c-indirect_002c-_0040_002dnotation-for"></a>
<p>语法非常类似于常规的函数调用：一个标识符，后面跟着一个开括号，所有的参数，然后是一个闭括号，加上一个前导的 &lsquo;<samp>@</samp>&rsquo; 符号：
</p>
<div class="example">
<pre class="example">the_func = &quot;sum&quot;
result = @the_func()   # calls the sum() function
</pre></div>

<p>这是处理前所示的数据的完整程序，使用的是间接函数调用：
</p>
<div class="example">
<pre class="example"># indirectcall.awk --- Demonstrate indirect function calls

# average --- return the average of the values in fields $first - $last

function average(first, last,   sum, i)
{
    sum = 0;
    for (i = first; i &lt;= last; i++)
        sum += $i

    return sum / (last - first + 1)
}

# sum --- return the sum of the values in fields $first - $last

function sum(first, last,   ret, i)
{
    ret = 0;
    for (i = first; i &lt;= last; i++)
        ret += $i

    return ret
}
</pre></div>

<p>这两个函数期望是工作于域，因此，参数 <code>first</code> 与 <code>last</code> 表示域处理的开始与结束。否则，它们执行是期望的计算但不正确：
</p>
<div class="example">
<pre class="example"># For each record, print the class name and the requested statistics
{
    class_name = $1
    gsub(/_/, &quot; &quot;, class_name)  # Replace _ with spaces

    # find start
    for (i = 1; i &lt;= NF; i++) {
        if ($i == &quot;data:&quot;) {
            start = i + 1
            break
        }
    }

    printf(&quot;%s:\n&quot;, class_name)
    for (i = 2; $i != &quot;data:&quot;; i++) {
        the_function = $i
        printf(&quot;\t%s: &lt;%s&gt;\n&quot;, $i, @the_function(start, NF) &quot;&quot;)
    }
    print &quot;&quot;
}
</pre></div>

<p>这是处理每个记录的主过程。它打印课程名（将下划线替换成空格）。然后查找实际数据的开始，并将它保存在 <code>start</code> 中。
代码的最后一部分是循环每一个函数名（从 <code>$2</code> 到 &lsquo;<samp>data:</samp>&rsquo; 标识），调用域所表示的名字。间接调用函数将其作为 <code>printf</code> 函数的一个参数。
（<code>printf</code> 的格式串使用 &lsquo;<samp>%s</samp>&rsquo; 作为格式指定符，所以我们可以使用返回字串的函数，当然也包括数值。注意从间接调用返回的结果与空串进行合并，是为将其强制转换为字串值。）
</p>
<p>这是执行程序的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f indirectcall.awk class_data1</kbd>
-| Biology 101:
-|     sum: &lt;352.8&gt;
-|     average: &lt;88.2&gt;
-|
-| Chemistry 305:
-|     sum: &lt;356.4&gt;
-|     average: &lt;89.1&gt;
-|
-| English 401:
-|     sum: &lt;376.1&gt;
-|     average: &lt;94.025&gt;
</pre></div>

<p>可以使用间接函数调用的能力比初看起来要强大得多。C 与 C++ 语言提供了“函数指针”，那也是一个在执行时选择调用函数的机制。这个能力用得最多的是 C <code>qsort()</code> 函数，该函数使用有名的快速排序
（查看 <a href="http://en.wikipedia.org/wiki/Quicksort">Wikipedia 的文档</a> 来了解更多的信息）算法来对数组进行排序。为了使用这个函数，你需要指定一个用于比较的函数指针。这个机制可以使用对任意以及任何方式对数据进行排序。
</p>
<p>我们用 <code>gawk</code> 也可以做同样的事情，如：
</p>
<div class="example">
<pre class="example"># quicksort.awk --- Quicksort algorithm, with user-supplied
#                   comparison function

# quicksort --- C.A.R. Hoare's quicksort algorithm. See Wikipedia
#               or almost any algorithms or computer science text.

function quicksort(data, left, right, less_than,    i, last)
{
    if (left &gt;= right)  # do nothing if array contains fewer
        return          # than two elements

    quicksort_swap(data, left, int((left + right) / 2))
    last = left
    for (i = left + 1; i &lt;= right; i++)
        if (@less_than(data[i], data[left]))
            quicksort_swap(data, ++last, i)
    quicksort_swap(data, left, last)
    quicksort(data, left, last - 1, less_than)
    quicksort(data, last + 1, right, less_than)
}

# quicksort_swap --- helper function for quicksort, should really be inline

function quicksort_swap(data, i, j,      temp)
{
    temp = data[i]
    data[i] = data[j]
    data[j] = temp
}
</pre></div>

<p><code>quicksort()</code> 函数接收 <code>data</code> 数组，以及要进行排序的开始与结束下标（<code>left</code> 与 <code>right</code>），以及执行“less than”比较的函数名。之后实现 quicksort 算法。
</p>
<p>为使用这个排序函数，我们再回到之前的例子。第一件事情就是要写一个比较函数：
</p>
<div class="example">
<pre class="example"># num_lt --- do a numeric less than comparison

function num_lt(left, right)
{
    return ((left + 0) &lt; (right + 0))
}

# num_ge --- do a numeric greater than or equal to comparison

function num_ge(left, right)
{
    return ((left + 0) &gt;= (right + 0))
}
</pre></div>

<p><code>num_ge()</code> 函数在执行降序排序时需要，当执行 “less than” 的测试时，其执行的刚才是相反的（即大于或者等于），这会产生一个降序。
</p>
<p>下面则是排序函数。这是一个参数化了 starting 与 ending 域数值与比较函数的函数。它创建有 data 数组并调用 <code>quicksort()</code> 函数。然后将结果作为一个字串输出：
</p>
<div class="example">
<pre class="example"># do_sort --- sort the data according to `compare'
#             and return it as a string

function do_sort(first, last, compare,      data, i, retval)
{
    delete data
    for (i = 1; first &lt;= last; first++) {
        data[i] = $first
        i++
    }

    quicksort(data, 1, i-1, compare)

    retval = data[1]
    for (i = 2; i in data; i++)
        retval = retval &quot; &quot; data[i]

    return retval
}
</pre></div>

<p>最后，两个排序函数调用 <code>do_sort()</code>，并将两个比较函数名传递进去：
</p>
<div class="example">
<pre class="example"># sort --- sort the data in ascending order and return it as a string

function sort(first, last)
{
    return do_sort(first, last, &quot;num_lt&quot;)
}

# rsort --- sort the data in descending order and return it as a string

function rsort(first, last)
{
    return do_sort(first, last, &quot;num_ge&quot;)
}
</pre></div>

<p>这是数据文件的扩展版本：
</p>
<div class="example">
<pre class="example">Biology_101 sum average sort rsort data: 87.0 92.4 78.5 94.9
Chemistry_305 sum average sort rsort data: 75.2 98.3 94.7 88.2
English_401 sum average sort rsort data: 100.0 95.6 87.1 93.4
</pre></div>

<p>最后，这是增强过的程序的运行结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f quicksort.awk -f indirectcall.awk class_data2</kbd>
-| Biology 101:
-|     sum: &lt;352.8&gt;
-|     average: &lt;88.2&gt;
-|     sort: &lt;78.5 87.0 92.4 94.9&gt;
-|     rsort: &lt;94.9 92.4 87.0 78.5&gt;
-|
-| Chemistry 305:
-|     sum: &lt;356.4&gt;
-|     average: &lt;89.1&gt;
-|     sort: &lt;75.2 88.2 94.7 98.3&gt;
-|     rsort: &lt;98.3 94.7 88.2 75.2&gt;
-|
-| English 401:
-|     sum: &lt;376.1&gt;
-|     average: &lt;94.025&gt;
-|     sort: &lt;87.1 93.4 95.6 100.0&gt;
-|     rsort: &lt;100.0 95.6 93.4 87.1&gt;
</pre></div>

<p>另一个使用间接函数非常有用的地方可以在处理数组的地方找到。这在 <a href="#Walking-Arrays">遍历多维数组</a>，中有描述。
</p>
<p>要记住，在调用间接函数之前，必须在其前面放置一个 &lsquo;<samp>@</samp>&rsquo; 符号。
</p>
<p>从 4.1.2 版本开始，<code>gawk</code> 间接调用也可以用于内置函数以及扩展函数（查看 see section <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>）。他们在使用间接调用内置函数时有一些限制，如下：
</p>
<ul>
<li>
通过间接调用，你不可以传递正则表达式常量到一个内置函数中。
<a name="DOCF65" href="#FOOT65">(65)</a>
这同时也适用于 <code>sub()</code>，<code>gsub()</code>，<code>gensub()</code>，<code>match()</code>，<code>split()</code> 与 <code>patsplit()</code> 函数。

</li><li>
如果调用 <code>sub()</code> 或者 <code>gsub()</code>，你只可以传递两个参数，因为这些函数通常会更改它它们的第三个参数。这表示 <code>$0</code> 会被改变。
</li></ul>

<p><code>gawk</code> 会尽力地使间接函数调用非常高效。如，在下面的例子中：
</p>
<div class="example">
<pre class="example">for (i = 1; i &lt;= n; i++)
    @the_func()
</pre></div>

<p><code>gawk</code> 实际上只查找一次要调用的函数。
</p>
<hr>
<a name="Functions-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Indirect-Calls" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-6"></a>
<h2 class="section">9.4 总结</h2>

<ul>
<li>
<code>awk</code> 提供了内置函数，也可以让你自己定义函数。

</li><li>
POSIX <code>awk</code> 提供了三种内置函数：数值，字串与 I/O。<code>gawk</code> 提供了对数组排序的函数，处理时间的函数，执行位操作的函数，确定变量类型的函数（数组还是标量），与国际化与本地化的函数。<code>gawk</code> 也提供了标准函数的扩展，典型的是针对额外参数的形式。

</li><li>
函数接收 0 个或者更多的参数，并返回一个值。提供参数值的表达式在函数调用前会首先全部求值。求值的顺序是未定义的。返回值可以被忽略。

</li><li>
<code>sub()</code> 与 <code>gsub()</code> 函数对于反斜杠的处理有点复杂。在 <code>gawk</code> 的 <code>gensub()</code> 函数中则更直接一点，但是使用这个函数也需要注意。

</li><li>
用户定义的函数提供了很重要的能力，但是其语法确并不优雅。在函数调用时，在函数名与参数列表的开括号之间不可以有空格。也没有提供本地变量，所以习惯是添加额外的参数，并用空格可视化地将它们与参数列表分开。

</li><li>
用户自定义函数可以调用其他的用户自定义函数（以及内置函数），也可以递归地调用它们自己。函数参数会“隐藏”任何的同名的全局参数。你不可以使用保留的变量（如 <code>ARGC</code> 来作为自定义函数的参数名字。

</li><li>
标量值是通过传值方式传递到用户自定义函数的。数组参数则是通过传引用，函数对于数组的任何改变都会在函数返回之后可见。

</li><li>
使用 <code>return</code> 语言来从用户自定义函数中返回。可选的表达式成为函数的返回值。函数只可以返回标量值。

</li><li>
如果传递到用户自定义函数中的变量从来没有被使用过，那么函数如何来看待这个变量：要么是标题要么是数组。

</li><li>
<code>gawk</code> 使用特殊语法，提供了间接函数调用。通过将某个变量的值设置成函数名，你可以在运行时确定在想说点要调用的函数。这个与 C 跟 C++ 中的函数指针等同。

</li></ul>


<hr>
<a name="c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Functions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Functions-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Library-Names" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="part">第二部分:<br>用 <code>awk</code> 来解决问题</h1>
<hr>


<a name="Library-Functions"></a>
<a name="awk-aa_0087_00bdae_0095_00b0aa_00ba_0093"></a>
<h1 class="chapter">1 <code>awk</code> 函数库</h1>
<a name="index-libraries-of-awk-functions"></a>
<a name="index-functions_002c-library"></a>
<a name="index-functions_002c-user_002ddefined_002c-library-of"></a>

<p>在 <a href="#User_002ddefined">用户自定义函数</a>，描述了如何来写你自己的 <code>awk</code> 函数。写函数是很重要的，因为它可以让你将算法与程序任务封闭在一个单独的地方。同时，它也简化编程，使得程序开发更有可管理性，更可读。
</p>
<a name="index-Kernighan_002c-Brian-5"></a>
<a name="index-Plauger_002c-P_002eJ_002e"></a>
<p>Brian Kernighan 与 P.J. Plauger 在他们 1976 年的书，<cite>Software Tools</cite> 
<a name="DOCF66" href="#FOOT66">(66)</a>
中写到：
</p>
<blockquote>
<p>好的编程不是从一般性来学习，而是通过运用常识与编程实践，看程序如何能够写得清晰，易读，易维护与修改，可被人工程化，高效与可靠。仔细学习与模拟好的编程可以写得更好。
</p></blockquote>

<p>实际上，他们觉得这些思想是如何重要，以致于它们将这个表述放在书的封面上。由于我们强烈地认为这个表述是无此正确的，所在在这章中与 <a href="#Sample-Programs">实用的 <code>awk</code> 程序</a>，提供了大小合适的代码来让你学习，我们希望你能从中学到什么。
</p>
<p>这一章呈现了 <code>awk</code> 中有很有用的函数库。很多后面的例子代码都使用这些函数。这里呈现的函数从简单到复杂进行变化。
</p>
<a name="index-Texinfo-1"></a>
<p>在 <a href="#Extract-Program">从 Texinfo 源文件中提取程序</a>，中提交了一个程序，你可以用来从这些例子库函数中提取源代码，以及从本网页的 Texinfo 源代码中提出程序。（这已经作为 <code>gawk</code> 发行版本的一部份完成了。）
</p>
<p>如果你写了一些有用的，通用目的的 <code>awk</code> 程序，并且想将它们贡献给 <code>awk</code> 社区，查看 <a href="#How-To-Contribute">如何贡献</a>，来获取更多的信息。
</p>
<a name="index-portability_002c-example-programs"></a>
<p>这一章以及 <a href="#Sample-Programs">实用的 <code>awk</code> 程序</a> 中的程序，可以自由地使用 <code>gawk</code> 特有的特性。为不同的 <code>awk</code> 实现重写这些程序也相当地直接：
</p>
<ul>
<li>
区别错误信息并发送到 &lsquo;<tt>/dev/stderr</tt>&rsquo;。如果你的系统中没有 &lsquo;<tt>/dev/stderr</tt>&rsquo;，或者你无法使用 <code>gawk</code>，
则使用 &lsquo;<samp>| &quot;cat 1&gt;&amp;2&quot;</samp>&rsquo; 而不是 &lsquo;<samp>&gt; &quot;/dev/stderr&quot;</samp>&rsquo;。

</li><li>
有很多的程序中使用 <code>nextfile</code>（查看 see section <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>）来跳过任意剩下的输入文件的输入。

</li><li>
<a name="index-case-sensitivity_002c-example-programs"></a>
<a name="index-IGNORECASE-variable_002c-in-example-programs"></a>
最后，某些程序选择忽略输入中的大小写。它们是通过将 <code>IGNORECASE</code> 赋值为 1 来实现的。你可以得到几乎相同的效果，
<a name="DOCF67" href="#FOOT67">(67)</a>
只要将下面的规则加到程序的开始：

<div class="example">
<pre class="example"># ignore case
{ $0 = tolower($0) }
</pre></div>

<p>同时，确定所有的正则表达式以及用在比较中的字串常量全都是小写字母。
</p></li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               How to best name private global variables in
                                library functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#General-Functions">1.2 通用编程</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Functions that are of general use.
</td></tr>
<tr><td align="left" valign="top"><a href="#Data-File-Management">1.3 数据文件管理</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Functions for managing command-line data
                                files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             A function for processing command-line
                                arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Functions for getting user information.
</td></tr>
<tr><td align="left" valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Functions for getting group information.
</td></tr>
<tr><td align="left" valign="top"><a href="#Walking-Arrays">1.7 遍历多维数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              A function to walk arrays of arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Library-Functions-Summary">1.8 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Summary of library functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Library-Exercises">1.9 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Exercises.
</td></tr>
</table>

<hr>
<a name="Library-Names"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0091_00bdaa_0090_008daa_0087_00bdae_0095_00b0aa_00ba_0093c_009a_0084aa_0085_00a8aa_00b1_0080aa_008f_0098e_0087_008f"></a>
<h2 class="section">1.1 命名函数库的全局变量</h2>

<a name="index-names_002c-arrays_002fvariables"></a>
<a name="index-names_002c-functions-1"></a>
<a name="index-namespace-issues"></a>
<a name="index-awk-programs_002c-documenting-1"></a>
<a name="index-documentation_002c-of-awk-programs"></a>
<p>由于 <code>awk</code> 语言的演化方案，变量要么是<em>全局</em>的（可以在整个程序中使用），要么是<em>本地</em>的（只在特定的函数中使用）。没有与 C 中的 <code>static</code> 变量类似的中间状态。
</p>
<a name="index-variables_002c-global_002c-for-library-functions"></a>
<a name="index-private-variables"></a>
<a name="index-variables_002c-private"></a>
<p>库函数常常需要有全局变量来保存在调用函数之间的状态信息——比如，<code>getopt()</code> 的变量 <code>_opti</code>（查看 see section <a href="#Getopt-Function">处理命令行选项</a>）。这样的变量称为<em>私有</em>变量，因为在库中使用它们的函数只有一个。
</p>
<p>当写一个库函数的时候，你应该要尝试选择你自己的私有变量的名字，这样不会与其他的库函数或者用户主程序所使用的变量冲突。如像名字 <code>i</code> 或者 <code>j</code> 就不是好的选择，因此用户程序常常使用这些类似的名字来用任自己的目的。
</p>
<a name="index-programming-conventions_002c-private-variable-names"></a>
<p>在本章中呈现的例子代码中，所有私有变量的名字都以下划线开始（&lsquo;<samp>_</samp>&rsquo;）。用户一般来说不会使用前导的下划线来命名变量，所以这样的惯例立即降低了变量名字偶然与用户程序冲突的机率。
</p>
<a name="index-_005f-_0028underscore_0029_002c-in-names-of-private-variables"></a>
<a name="index-underscore-_0028_005f_0029_002c-in-names-of-private-variables"></a>
<p>另外，有几个库函数还使用相应的前缀，用来指示什么样的函数或者函数集来使用变量——如，在用户数据库例程中的 <code>_pw_byname()</code>（查看 see section <a href="#Passwd-Functions">读取用户数据库</a>）。这样的惯例我们是推荐的，因为这更进一步降低了不小心的变量名字冲突机率。要注意，这样的惯例也可用于变量名与私有函数名。 
<a name="DOCF68" href="#FOOT68">(68)</a>
</p>
<p>在函数命名上还有最后一个提示，如果函数使全局变量可被主程序使用，那么惯例上需要以一个大写字母来开始变量的名字——如 <code>getopt()</code> 的 <code>Opterr</code> 与 <code>Optind</code> 变量（查看 see section <a href="#Getopt-Function">处理命令行选项</a>）。前导的大写字母表示这是一个全局变量，而变量的名字不全是大写字母则是表示变量不是 <code>awk</code> 预定义的变量，比如 <code>FS</code>。
</p>
<a name="index-_002d_002ddump_002dvariables-option_002c-using-for-library-functions"></a>
<p>在库中的函数的<em>所有</em>变量实际上不用于存储状态的变量都声明为本地变量也非常重要。
<a name="DOCF69" href="#FOOT69">(69)</a>
如果不是这么做的，变量有可能偶然在用户程序中使用，从而导致非常难以追踪的 Bug。
</p>
<div class="example">
<pre class="example">function lib_func(x, y,    l1, l2)
{
    &hellip;
    # some_var should be local but by oversight is not
    <var>use variable</var> some_var
    &hellip;
}
</pre></div>

<a name="index-arrays_002c-associative_002c-library-functions-and"></a>
<a name="index-libraries-of-awk-functions_002c-associative-arrays-and"></a>
<a name="index-functions_002c-library_002c-associative-arrays-and"></a>
<a name="index-Tcl"></a>
<p>在 Tcl 社区中也有相同的问题，但是使用不同的惯例，即用单一的关联数组来存储库函数或者“包”所使用的值。这更进一步地降低了实际全局使用的变量的数目。
例如，在 <a href="#Passwd-Functions">读取用户数据库</a> 中描述的函数，已经使用数组元素 <code><span class="nolinebreak">PW_data[&quot;inited&quot;]</span></code>，<code><span class="nolinebreak">PW_data[&quot;total&quot;]</span></code>，<code><span class="nolinebreak">PW_data[&quot;count&quot;]</span></code> 与 <code><span class="nolinebreak">PW_data[&quot;awklib&quot;]</span></code>，而不是使用 <code><span class="nolinebreak">_pw_inited</span></code>，<code><span class="nolinebreak">_pw_awklib</span></code>，<code><span class="nolinebreak">_pw_total</span></code> 与 <code><span class="nolinebreak">_pw_count</span></code>。
</p>
<p>这小节中所呈现的惯例就是：约定俗成。但你不需要按这种方式来写你的程序——我们只是建议你这么做。
</p>
<hr>
<a name="General-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Library-Names" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Strtonum-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0080_009ac_0094_00a8c_00bc_0096c_00a8_008b"></a>
<h2 class="section">1.2 通用编程</h2>

<p>这一小节中呈现了在通用编程中使用到的几个函数。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Strtonum-Function">1.2.1 将数值转换成字串</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           A replacement for the built-in
                                <code>strtonum()</code> function.
</td></tr>
<tr><td align="left" valign="top"><a href="#Assert-Function">1.2.2 断言</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             A function for assertions in <code>awk</code>
                                programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              A function for rounding if <code>sprintf()</code>
                                does not do it correctly.
</td></tr>
<tr><td align="left" valign="top"><a href="#Cliff-Random-Function">1.2.4 Cliff 随机数生成器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       The Cliff Random Number Generator.
</td></tr>
<tr><td align="left" valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Functions for using characters as numbers and
                                vice versa.
</td></tr>
<tr><td align="left" valign="top"><a href="#Join-Function">1.2.6 将数组合并成字串</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               A function to join an array into a string.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getlocaltime-Function">1.2.7 管理时间</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       A function to get formatted times.
</td></tr>
<tr><td align="left" valign="top"><a href="#Readfile-Function">1.2.8 一次读取整个文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           A function to read an entire file at once.
</td></tr>
<tr><td align="left" valign="top"><a href="#Shell-Quoting">1.2.9 将字串用引号引起并传递给 Shell</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               A function to quote strings for the shell.
</td></tr>
</table>

<hr>
<a name="Strtonum-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Assert-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b0_0086ae_0095_00b0aa_0080_00bce_00bd_00acae_008d_00a2ae_0088_0090aa_00ad_0097a_00b8_00b2"></a>
<h3 class="subsection">1.2.1 将数值转换成字串</h3>

<p><code>strtonum()</code> 函数（查看 <a href="#String-Functions">字串操作函数</a>）是一个 <code>gawk</code> 扩展。下面的函数提供了 <code>awk</code> 中另一个版本的实现：
</p>
<div class="example">
<pre class="example"># mystrtonum --- convert string to number

function mystrtonum(str,        ret, n, i, k, c)
{
    if (str ~ /^0[0-7]*$/) {
        # octal
        n = length(str)
        ret = 0
        for (i = 1; i &lt;= n; i++) {
            c = substr(str, i, 1)
            # index() returns 0 if c not in string,
            # includes c == &quot;0&quot;
            k = index(&quot;1234567&quot;, c)

            ret = ret * 8 + k
        }
    } else if (str ~ /^0[xX][[:xdigit:]]+$/) {
        # hexadecimal
        str = substr(str, 3)    # lop off leading 0x
        n = length(str)
        ret = 0
        for (i = 1; i &lt;= n; i++) {
            c = substr(str, i, 1)
            c = tolower(c)
            # index() returns 0 if c not in string,
            # includes c == &quot;0&quot;
            k = index(&quot;123456789abcdef&quot;, c)

            ret = ret * 16 + k
        }
    } else if (str ~ \
  /^[-+]?([0-9]+([.][0-9]*([Ee][0-9]+)?)?|([.][0-9]+([Ee][-+]?[0-9]+)?))$/) {
        # decimal number, possibly floating point
        ret = str + 0
    } else
        ret = &quot;NOT-A-NUMBER&quot;

    return ret
}

# BEGIN {     # gawk test harness
#     a[1] = &quot;25&quot;
#     a[2] = &quot;.31&quot;
#     a[3] = &quot;0123&quot;
#     a[4] = &quot;0xdeadBEEF&quot;
#     a[5] = &quot;123.45&quot;
#     a[6] = &quot;1.e3&quot;
#     a[7] = &quot;1.32&quot;
#     a[8] = &quot;1.32E2&quot;
#
#     for (i = 1; i in a; i++)
#         print a[i], strtonum(a[i]), mystrtonum(a[i])
# }
</pre></div>

<p>函数首先找 C 风格的八进制数（以 8 为底）。如果输出串匹配一个描述八进制的正则表达式，则 <code>mystrtonum()</code> 迭代在串中的每一个字符。它将 <code>k</code> 设置成当前八进制数在 <code>&quot;1234567&quot;</code> 中的索引。返回值要么是与数字相同的值，或者在不存在这个字符时返回 0。那就是真正的 &lsquo;<samp>0</samp>&rsquo;。这是安全的，因为在 <code>if</code> 中的正则表达式保证了只有八进制才会进行转换。
</p>
<p>相同的逻辑也可以应用到转换十六进制的代码中，这些值以 &lsquo;<samp>0x</samp>&rsquo; 或者 &lsquo;<samp>0X</samp>&rsquo; 开头。使用 <code>tolower()</code> 可以简化查找每个十六进制位数字的计算。
</p>
<p>最后，如果字串匹配（相当复杂的）常规十进制或者浮点数的正则表达式，则 &lsquo;<samp>ret = str + 0</samp>&rsquo; 的计算可以让 <code>awk</code> 将这个值转换成一个数。
</p>
<p>被注释掉的是测试程序，所以函数可以用 <code>gawk</code> 来测试，并且结果可以用来与内置的 <code>strtonum()</code> 函数结果来比较。
</p>
<hr>
<a name="Assert-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Strtonum-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Round-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0096_00ade_00a8_0080"></a>
<h3 class="subsection">1.2.2 断言</h3>

<a name="index-assertions"></a>
<a name="index-assert_0028_0029-function-_0028C-library_0029"></a>
<a name="index-libraries-of-awk-functions_002c-assertions"></a>
<a name="index-functions_002c-library_002c-assertions"></a>
<a name="index-awk-programs_002c-lengthy_002c-assertions"></a>
<p>当写一个很大的程序的时候，常常了解一些条件或者某集合的条件为 true 是很有用的。在执行特定计算之前，你要写一条语句你确信条件成立。这样的语句被称为<em>断言</em>。
C 语言提供了 <code>&lt;assert.h&gt;</code> 头文件以及相应的 <code>assert()</code> 宏，这样程序可以用它来作断言。如果断言失败，<code>assert()</code> 宏会打印一些诊断信息以描述条件应该为 true，但实际上不是，然后杀死程序。在 C 语言中，像这样来使用 <code>assert()</code>：
</p>
<div class="example">
<pre class="example">#include &lt;assert.h&gt;

int myfunc(int a, double b)
{
     assert(a &lt;= 5 &amp;&amp; b &gt;= 17.1);
     &hellip;
}
</pre></div>

<p>如果断言失败，程序打印像下面这样的信息：
</p>
<div class="example">
<pre class="example">prog.c:5: assertion failed: a &lt;= 5 &amp;&amp; b &gt;= 17.1
</pre></div>

<a name="index-assert_0028_0029-user_002ddefined-function"></a>
<p>C 语言可以使条件转换为字串，并在打印诊断信息里使用。但在 <code>awk</code> 中却不可能，所以 <code>assert()</code> 函数也需要一个测试条件的字串版本。下面则是字串函数：
</p>
<div class="example">
<pre class="example"># assert --- assert that a condition is true. Otherwise, exit.

function assert(condition, string)
{
    if (! condition) {
        printf(&quot;%s:%d: assertion failed: %s\n&quot;,
            FILENAME, FNR, string) &gt; &quot;/dev/stderr&quot;
        _assert_exit = 1
        exit 1
    }
}

</pre><pre class="example">END {
    if (_assert_exit)
        exit 1
}
</pre></div>

<p><code>assert()</code> 函数测试 <code>condition</code> 参数。如果失败，则打印一个信息到标准输出，并使用 <code>string</code> 参数来描述失败的条件。
然后它将变量 <code>_assert_exit</code> 设置成 1，并执行 <code>exit</code> 语句。<code>exit</code> 语句会跳到 <code>END</code> 规则中来执行。如果 <code>END</code> 规则发现 <code>_assert_exit</code> 为 true，就会立即退出。
</p>
<p>在 <code>END</code> 规则中测试的目的是要保证任意的其他 <code>END</code> 规则不被执行。当断言失败，程序应该立即退出。如果断言通过，则 <code>_assert_exit</code> 则依然是 false，当 <code>END</code> 规则执行时，程序的其他的 <code>END</code> 规则则也会被执行。为了使这一切都正确执行，&lsquo;<tt>assert.awk</tt>&rsquo; 必须成为 <code>awk</code> 读取的第一个源代码文件。函数可以通过下面的方式被使用：
</p>
<div class="example">
<pre class="example">function myfunc(a, b)
{
     assert(a &lt;= 5 &amp;&amp; b &gt;= 17.1, &quot;a &lt;= 5 &amp;&amp; b &gt;= 17.1&quot;)
     &hellip;
}
</pre></div>

<p>如果断言失败，你可以看到如下的信息：
</p>
<div class="example">
<pre class="example">mydata:1357: assertion failed: a &lt;= 5 &amp;&amp; b &gt;= 17.1
</pre></div>

<a name="index-END-pattern_002c-assert_0028_0029-user_002ddefined-function-and"></a>
<p>这个版本的 <code>assert()</code> 有一个小问题。一个 <code>END</code> 规则会自动加到调用 <code>assert()</code> 函数的程序中。正常情况下，如果程序由 <code>BEGIN</code> 规则组成，输入文件与/或者标准输入不会被读取。但是，现在程序有一个 <code>END</code> 规则，<code>awk</code> 会尝试读取输入文件的数据或者标准输入的数据（查看 see section <a href="#Using-BEGIN_002fEND">开始与结束动作</a>），很有可能导致程序挂起，因引它可能会一直等待输入。
</p>
<a name="index-BEGIN-pattern_002c-assert_0028_0029-user_002ddefined-function-and"></a>
<p>有一个很简单的解决方法：确保这这样的 <code>BEGIN</code> 规则总是用一个 <code>exit</code> 语句来结束。
</p>
<hr>
<a name="Round-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Assert-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Cliff-Random-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0aa_0080_00bce_0088_008daa_0085_00a5e_0088_008daa_0087_00ba"></a>
<h3 class="subsection">1.2.3 数值舍入舍出</h3>

<a name="index-rounding-numbers"></a>
<a name="index-numbers_002c-rounding"></a>
<a name="index-libraries-of-awk-functions_002c-rounding-numbers"></a>
<a name="index-functions_002c-library_002c-rounding-numbers"></a>
<a name="index-print-statement_002c-sprintf_0028_0029-function-and"></a>
<a name="index-printf-statement_002c-sprintf_0028_0029-function-and"></a>
<a name="index-sprintf_0028_0029-function_002c-print_002fprintf-statements-and"></a>
<p><code>printf</code> 与 <code>sprintf</code> 的工作方式（查看 see section <a href="#Printf">使用 <code>printf</code> 语句美化打印</a>）执行的舍入舍出常常依赖于系统的 C 函数 <code>sprintf</code> 例程。在很多的机器上，<code>sprintf</code> 舍入舍出是<em>没有偏向的</em>，即是说，它并不总是把 0.5 向上舍入，这与很自然的预期相反。在没有偏向的舍入舍出中。.5 会偶数舍入舍出，而并不总是舍入，所以，1.5 舍入为 2，而 4.5 则舍出为 4。这就是说，如果你使用一个不舍入舍出的格式（比如 <code>&quot;%.0f&quot;</code>），你应该检查你的系统所执行的结果。下面的函数总是执行传输的舍入舍出，如果你的 <code>awk</code> 的 <code>printf</code> 执行的是没有偏向的舍入舍出，则可能很有用。
</p>
<a name="index-round_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># round.awk --- do normal rounding

function round(x,   ival, aval, fraction)
{
   ival = int(x)    # integer part, int() truncates

   # see if fractional part
   if (ival == x)   # no fraction
      return ival   # ensure no decimals

   if (x &lt; 0) {
      aval = -x     # absolute value
      ival = int(aval)
      fraction = aval - ival
      if (fraction &gt;= .5)
         return int(x) - 1   # -2.5 --&gt; -3
      else
         return int(x)       # -2.3 --&gt; -2
   } else {
      fraction = x - ival
      if (fraction &gt;= .5)
         return ival + 1
      else
         return ival
   }
}

# test harness
# { print $0, round($0) }
</pre></div>

<hr>
<a name="Cliff-Random-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Round-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Ordinal-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Cliff-e_009a_008fae_009c_00baae_0095_00b0c_0094_009fae_0088_0090aa_0099_00a8"></a>
<h3 class="subsection">1.2.4 Cliff 随机数生成器</h3>
<a name="index-random-numbers_002c-Cliff"></a>
<a name="index-Cliff-random-numbers"></a>
<a name="index-numbers_002c-Cliff-random"></a>
<a name="index-functions_002c-library_002c-Cliff-random-numbers"></a>

<p><a href="http://mathworld.wolfram.com/CliffRandomNumberGenerator.html">Cliff 随机数产生器</a>是一个非常简单的随机为数生成器，即“通过无结构显示来为随机性传递噪声球测试”。他很容易编程，不到 10 行的 <code>awk</code> 代码就可以完成：
</p>
<a name="index-cliff_005frand_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># cliff_rand.awk --- generate Cliff random numbers

BEGIN { _cliff_seed = 0.1 }

function cliff_rand()
{
    _cliff_seed = (100 * log(_cliff_seed)) % 1
    if (_cliff_seed &lt; 0)
        _cliff_seed = - _cliff_seed
    return _cliff_seed
}
</pre></div>

<p>算法需要一个初始的种子值，为 0.1。每个新值都使用当前的种子的作为输出来进行计算。如果内置 <code>rand()</code> 函数（查看 see section <a href="#Numeric-Functions">数值函数</a>）不够随机，你可以使用这个函数来代替。
</p>
<hr>
<a name="Ordinal-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Cliff-Random-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Join-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8aa_00ad_0097c_00ac_00a6a_00b8_008eae_0095_00b0aa_0080_00bca_00b9_008be_0097_00b4aa_008f_0098ae_008d_00a2"></a>
<h3 class="subsection">1.2.5 在字符与数值之间变换</h3>

<a name="index-libraries-of-awk-functions_002c-character-values-as-numbers"></a>
<a name="index-functions_002c-library_002c-character-values-as-numbers"></a>
<a name="index-characters_002c-values-of-as-numbers"></a>
<a name="index-numbers_002c-as-values-of-characters"></a>
<p>一个商业版本的 <code>awk</code> 实现提供了内置的函数 <code>ord()</code>，输入一个字符，然后返回那个字符在机器的字符集中的数值值。如果传递到 <code>ord()</code> 函数为字串，则会有多个字符，但是只有第一个字符被转换。
</p>
<p>这个函数相反的函数则为 <code>chr()</code>（来自由 Pascal 同名函数），它输入一个数值，然后返回相应的字符。这两个函数在 <code>awk</code> 中都可以很容易实现，因此没有真实的理由要将他们构建进行 <code>awk</code> 解析器：
</p>
<a name="index-ord_0028_0029-user_002ddefined-function"></a>
<a name="index-chr_0028_0029-user_002ddefined-function"></a>
<a name="index-_005ford_005finit_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># ord.awk --- do ord and chr

# Global identifiers:
#    _ord_:        numerical values indexed by characters
#    _ord_init:    function to initialize _ord_

BEGIN    { _ord_init() }

function _ord_init(    low, high, i, t)
{
    low = sprintf(&quot;%c&quot;, 7) # BEL is ascii 7
    if (low == &quot;\a&quot;) {    # regular ascii
        low = 0
        high = 127
    } else if (sprintf(&quot;%c&quot;, 128 + 7) == &quot;\a&quot;) {
        # ascii, mark parity
        low = 128
        high = 255
    } else {        # ebcdic(!)
        low = 0
        high = 255
    }

    for (i = low; i &lt;= high; i++) {
        t = sprintf(&quot;%c&quot;, i)
        _ord_[t] = i
    }
}
</pre></div>

<a name="index-character-sets-_0028machine-character-encodings_0029"></a>
<a name="index-ASCII"></a>
<a name="index-EBCDIC"></a>
<a name="index-Unicode"></a>
<a name="index-mark-parity"></a>
<p>被 <code>_ord_init()</code> 所使用的数值需要一些解释。今天所使用的最重要的字符集就是 ASCII。
<a name="DOCF70" href="#FOOT70">(70)</a>
尽管 8 位的字节可以表示 256 个不同的值（从 0 到 255 ），ASCII 只定义了从 0 到 127 之间的字符。
<a name="DOCF71" href="#FOOT71">(71)</a>
在很久的过去，至少有一个迷你计算机厂商
使用 ASCII，但是带一个校验位，即字节的最高位总是 1。这表示，在这样的系统中，字符的值是从 128 到 255。最后，很多的大型机使用 EBCDIC 字符集。这个集中使用所有的 256 个字符。在一些旧系统中也使用其他的字符集，但是没有必须为此操心了。
</p>
<div class="example">
<pre class="example">function ord(str,    c)
{
    # only first character is of interest
    c = substr(str, 1, 1)
    return _ord_[c]
}

function chr(c)
{
    # force c to be numeric by adding 0
    return sprintf(&quot;%c&quot;, c + 0)
}

#### test code ####
# BEGIN {
#    for (;;) {
#        printf(&quot;enter a character: &quot;)
#        if (getline var &lt;= 0)
#            break
#        printf(&quot;ord(%s) = %d\n&quot;, var, ord(var))
#    }
# }
</pre></div>

<p>这个函数的一个明显改进是将 <code><span class="nolinebreak">_ord_init</span></code> 函数的代码移到了 <code>BEGIN</code> 规则中。这么做的最初目的是为了开发的方便。
</p>
<hr>
<a name="Join-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Ordinal-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getlocaltime-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b0_0086ae_0095_00b0c_00bb_0084aa_0090_0088aa_00b9_00b6ae_0088_0090aa_00ad_0097a_00b8_00b2"></a>
<h3 class="subsection">1.2.6 将数组合并成字串</h3>

<a name="index-libraries-of-awk-functions_002c-merging-arrays-into-strings"></a>
<a name="index-functions_002c-library_002c-merging-arrays-into-strings"></a>
<a name="index-strings_002c-merging-arrays-into"></a>
<a name="index-arrays_002c-merging-into-strings"></a>
<p>当处理字串时，可以将数组的所有字串连接为一个长的字串常常很有用。下面的 <code>join()</code> 函数来做这样的工作。它在后面的几个应用程序中被使用到（查看 see section <a href="#Sample-Programs">实用的 <code>awk</code> 程序</a>）。
</p>
<p>好的函数设计是很重要的，这个函数应该是通用的，但是它也应该有一个合理的默认行为。这个函数合用一个数组以及要合并的开始与结束索引，作为参数。它假设数组的索引是数值的——这是合理的假充，因此数组有可能使用 <code>split()</code> 函数创建的（查看 <a href="#String-Functions">字串操作函数</a>）：
</p>
<a name="index-join_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># join.awk --- join an array into a string

function join(array, start, end, sep,    result, i)
{
    if (sep == &quot;&quot;)
       sep = &quot; &quot;
    else if (sep == SUBSEP) # magic value
       sep = &quot;&quot;
    result = array[start]
    for (i = start + 1; i &lt;= end; i++)
        result = result sep array[i]
    return result
}
</pre></div>

<p>一个可选的参数是用来连接字串的分隔符。如果调用者提供了非空的值，<code>join()</code> 则使用它，如果没有提供，其值则为空值。在这种情况下，<code>join()</code> 使用一个空格来作为默认的字串分隔符。如果值与 <code>SUBSEP</code> 的值相同，则 <code>join()</code> 会在连接的字串中不使用分隔符。<code>SUBSEP</code> 作为一个“魔法”值来指示不要在字串组件之间使用分隔符。 
<a name="DOCF72" href="#FOOT72">(72)</a>
</p>
<hr>
<a name="Getlocaltime-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Join-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Readfile-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00ae_00a1c_0090_0086ae_0097_00b6e_0097_00b4"></a>
<h3 class="subsection">1.2.7 管理时间</h3>

<a name="index-libraries-of-awk-functions_002c-managing_002c-time"></a>
<a name="index-functions_002c-library_002c-managing-time"></a>
<a name="index-timestamps_002c-formatted"></a>
<a name="index-time_002c-managing"></a>
<p>在 <a href="#Time-Functions">时间函数</a>，描述的 <code>systime()</code> 与 <code>strftime()</code> 函数，提供了最小的功能需求来处理人可读形式的时间处理。尽管 <code>strftime()</code> 是扩展的，格式控制不容易记住，或者在读程序时意思不这么明显。
</p>
<p>下面的函数 <code>getlocaltime()</code> 使用用户提供的预定义时间格式信息数组。它返回一个与 <code>date</code> 工具产生一样的的时间格式的字串：
</p>
<a name="index-getlocaltime_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># getlocaltime.awk --- get the time of day in a usable format

# Returns a string in the format of output of date(1)
# Populates the array argument time with individual values:
#    time[&quot;second&quot;]       -- seconds (0 - 59)
#    time[&quot;minute&quot;]       -- minutes (0 - 59)
#    time[&quot;hour&quot;]         -- hours (0 - 23)
#    time[&quot;althour&quot;]      -- hours (0 - 12)
#    time[&quot;monthday&quot;]     -- day of month (1 - 31)
#    time[&quot;month&quot;]        -- month of year (1 - 12)
#    time[&quot;monthname&quot;]    -- name of the month
#    time[&quot;shortmonth&quot;]   -- short name of the month
#    time[&quot;year&quot;]         -- year modulo 100 (0 - 99)
#    time[&quot;fullyear&quot;]     -- full year
#    time[&quot;weekday&quot;]      -- day of week (Sunday = 0)
#    time[&quot;altweekday&quot;]   -- day of week (Monday = 0)
#    time[&quot;dayname&quot;]      -- name of weekday
#    time[&quot;shortdayname&quot;] -- short name of weekday
#    time[&quot;yearday&quot;]      -- day of year (0 - 365)
#    time[&quot;timezone&quot;]     -- abbreviation of timezone name
#    time[&quot;ampm&quot;]         -- AM or PM designation
#    time[&quot;weeknum&quot;]      -- week number, Sunday first day
#    time[&quot;altweeknum&quot;]   -- week number, Monday first day

function getlocaltime(time,    ret, now, i)
{
    # get time once, avoids unnecessary system calls
    now = systime()

    # return date(1)-style output
    ret = strftime(&quot;%a %b %e %H:%M:%S %Z %Y&quot;, now)

    # clear out target array
    delete time

    # fill in values, force numeric values to be
    # numeric by adding 0
    time[&quot;second&quot;]       = strftime(&quot;%S&quot;, now) + 0
    time[&quot;minute&quot;]       = strftime(&quot;%M&quot;, now) + 0
    time[&quot;hour&quot;]         = strftime(&quot;%H&quot;, now) + 0
    time[&quot;althour&quot;]      = strftime(&quot;%I&quot;, now) + 0
    time[&quot;monthday&quot;]     = strftime(&quot;%d&quot;, now) + 0
    time[&quot;month&quot;]        = strftime(&quot;%m&quot;, now) + 0
    time[&quot;monthname&quot;]    = strftime(&quot;%B&quot;, now)
    time[&quot;shortmonth&quot;]   = strftime(&quot;%b&quot;, now)
    time[&quot;year&quot;]         = strftime(&quot;%y&quot;, now) + 0
    time[&quot;fullyear&quot;]     = strftime(&quot;%Y&quot;, now) + 0
    time[&quot;weekday&quot;]      = strftime(&quot;%w&quot;, now) + 0
    time[&quot;altweekday&quot;]   = strftime(&quot;%u&quot;, now) + 0
    time[&quot;dayname&quot;]      = strftime(&quot;%A&quot;, now)
    time[&quot;shortdayname&quot;] = strftime(&quot;%a&quot;, now)
    time[&quot;yearday&quot;]      = strftime(&quot;%j&quot;, now) + 0
    time[&quot;timezone&quot;]     = strftime(&quot;%Z&quot;, now)
    time[&quot;ampm&quot;]         = strftime(&quot;%p&quot;, now)
    time[&quot;weeknum&quot;]      = strftime(&quot;%U&quot;, now) + 0
    time[&quot;altweeknum&quot;]   = strftime(&quot;%W&quot;, now) + 0

    return ret
}
</pre></div>

<p>这些字串下标很容易使用并比 <code>strftime()</code> 所使用的一系列的格式要容易。在 <a href="#Alarm-Program">报警时钟程序</a>，呈现的 <code>alarm</code> 程序，使用了这个函数。<code>getlocaltime()</code> 函数更通用的设计可以允许用户提供一个可选的时间戳值，而不是仅使用当前时间。
</p>
<hr>
<a name="Readfile-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getlocaltime-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Shell-Quoting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_0080ae_00ac_00a1e_00af_00bbaa_008f_0096ae_0095_00b4a_00b8_00aaae_0096_0087a_00bb_00b6"></a>
<h3 class="subsection">1.2.8 一次读取整个文件</h3>

<p>如果将整个文件的内容都放在内存中作为一个字串经常很有用。一个直接的，但是比较幼稚的方法可能如下：
</p>
<div class="example">
<pre class="example">function readfile(file,    tmp, contents)
{
    if ((getline tmp &lt; file) &lt; 0)
        return

    contents = tmp
    while (getline tmp &lt; file) &gt; 0)
        contents = contents RT tmp

    close(file)
    return contents
}
</pre></div>

<p>这个函数一次从文件 <code>file</code> 读取一个记录，然后用文件的内容来构建本地变量 <code>contents</code>。这有用，但是不够高效。
</p>
<p>下面的函数，使用由 Denis Shirokov 提的建议，来一次读取指定名字的文件内容：
</p>
<a name="index-readfile_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># readfile.awk --- read an entire file at once

function readfile(file,     tmp, save_rs)
{
    save_rs = RS
    RS = &quot;^$&quot;
    getline tmp &lt; file
    close(file)
    RS = save_rs

    return tmp
}
</pre></div>

<p>通过将 <code>RS</code> 设置成 &lsquo;<samp>^$</samp>&rsquo;，即一个一定不会匹配文件内容的正则表达式。<code>gawk</code> 从文件中读取内容到 <code>tmp</code> 中，并尝试匹配 <code>RS</code>。每次读后的匹配都失败，但很匹配失败很快，这样 <code>gawk</code> 将 <code>tmp</code> 的内容用文件的内容来进行填充。
（查看 <a href="#Records">输入如何拆分为记录</a>，来获取 <code>RT</code> 与 <code>RS</code> 的信息）
</p>
<p>如果文件 <code>file</code> 为空，则返回值为空串。所以，调用代码可以使用这样的代码：
</p>
<div class="example">
<pre class="example">contents = readfile(&quot;/some/path&quot;)
if (length(contents) == 0)
    # file was empty &hellip;
</pre></div>

<p>这里测试结果看其是否为空还是不为空，一个等同的测试为 &lsquo;<samp>contents == &quot;&quot;</samp>&rsquo;。
</p>
<p>查看 <a href="#Extension-Sample-Readfile">读取整个文件</a>，来查看扩展的函数，它也将整个文件的内容读取到内存中。
</p>
<hr>
<a name="Shell-Quoting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Readfile-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Data-File-Management" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b0_0086aa_00ad_0097a_00b8_00b2c_0094_00a8aa_00bc_0095aa_008f_00b7aa_00bc_0095e_00b5_00b7aa_00b9_00b6a_00bc_00a0e_0080_0092c_00bb_0099-Shell"></a>
<h3 class="subsection">1.2.9 将字串用引号引起并传递给 Shell</h3>


<p>Michael Brennan 提供了下面的编程模式，他经常是这么使用：
</p>
<div class="example">
<pre class="example">#! /bin/sh

awkp='
   &hellip;
   '

<var>input_program</var> | awk &quot;$awkp&quot; | /bin/sh
</pre></div>

<p>比如，他的一个程序名为 <code>flac-edit</code> 就使用这种形式：
</p>
<div class="example">
<pre class="example">$ <kbd>flac-edit -song=&quot;Whoope! That's Great&quot; file.flac</kbd>
</pre></div>

<p>它产生下面的输出，这些输出通过管道输出给 Shell（&lsquo;<tt>/bin/sh</tt>&rsquo;）：
</p>
<div class="example">
<pre class="example">chmod +w file.flac
metaflac --remove-tag=TITLE file.flac
LANG=en_US.88591 metaflac --set-tag=TITLE='Whoope! That'&quot;'&quot;'s Great' file.flac
chmod -w file.flac
</pre></div>

<p>注意 Shell 需要引号。函数 <code>shell_quote()</code> 就是来做这个事情的。<code>SINGLE</code> 是一个一字符的串 <code>&quot;'&quot;</code>，而 <code>QSINGLE</code> 是一个三字符的串 <code>&quot;\&quot;'\&quot;&quot;</code>：
</p>
<div class="example">
<pre class="example"># shell_quote --- quote an argument for passing to the shell

function shell_quote(s,             # parameter
    SINGLE, QSINGLE, i, X, n, ret)  # locals
{
    if (s == &quot;&quot;)
        return &quot;\&quot;\&quot;&quot;

    SINGLE = &quot;\x27&quot;  # single quote
    QSINGLE = &quot;\&quot;\x27\&quot;&quot;
    n = split(s, X, SINGLE)

    ret = SINGLE X[1] SINGLE
    for (i = 2; i &lt;= n; i++)
        ret = ret QSINGLE SINGLE X[i] SINGLE

    return ret
}
</pre></div>

<hr>
<a name="Data-File-Management"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Shell-Quoting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Filetrans-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0ae_008d_00aeae_0096_0087a_00bb_00b6c_00ae_00a1c_0090_0086"></a>
<h2 class="section">1.3 数据文件管理</h2>


<a name="index-files_002c-managing"></a>
<a name="index-libraries-of-awk-functions_002c-managing_002c-data-files"></a>
<a name="index-functions_002c-library_002c-managing-data-files"></a>
<p>本小节呈现的函数用于管理命令行数据文件非常有用。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Filetrans-Function">1.3.1 注意数据文件的边界</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          A function for handling data file transitions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Rewind-Function">1.3.2 重新读取当前文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             A function for rereading the current file.
</td></tr>
<tr><td align="left" valign="top"><a href="#File-Checking">1.3.3 检查可读的数据文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Checking that data files are readable.
</td></tr>
<tr><td align="left" valign="top"><a href="#Empty-Files">1.3.4 检查长度为零的文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Checking for zero-length files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Ignoring-Assigns">1.3.5 将赋值当成是文件名</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Treating assignments as file names.
</td></tr>
</table>

<hr>
<a name="Filetrans-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-File-Management" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-File-Management" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Rewind-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b3_00a8ae_0084_008fae_0095_00b0ae_008d_00aeae_0096_0087a_00bb_00b6c_009a_0084e_00be_00b9c_0095_008c"></a>
<h3 class="subsection">1.3.1 注意数据文件的边界</h3>

<a name="index-files_002c-managing_002c-data-file-boundaries"></a>
<a name="index-files_002c-initialization-and-cleanup"></a>
<p><code>BEGIN</code> 与 <code>END</code> 规则相应地在你的 <code>awk</code> 程序的开始与结束执行一次（查看 see section <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）。我们（<code>gawk</code> 的作者们）遇到过一个用户，错误地认为 <code>BEGIN</code> 规则在每个数据文件的开始都执行，而 <code>END</code> 规则在每个数据文件的结束时执行。
</p>
<p>当被通知说事情不是这样的，用户请求我们加一个新的特定模式到 <code>gawk</code> 中，称为 <code>BEGIN_FILE</code> 与 <code>END_FILE</code>，这些都则具有所期望的行为。他甚至为我们提供这么做的代码。
</p>
<p>给 <code>gawk</code> 加这个特殊模式并不是必需的，<code>awk</code> 自己都就可以很清楚地完成这个事情，如下面的函数程序所解释的一样。它会调用两个用户自己提供的函数 ，<code>beginfile()</code> 与 <code>endfile()</code> 分别在每个数据文件的开始与结束。不但<em>很好地</em>用 9 行代码解决上面的问题，而且还可移植称，这在任何 <code>awk</code> 实现版本都可工作。
</p>
<div class="example">
<pre class="example"># transfile.awk
#
# Give the user a hook for filename transitions
#
# The user must supply functions beginfile() and endfile()
# that each take the name of the file being started or
# finished, respectively.

FILENAME != _oldfilename {
    if (_oldfilename != &quot;&quot;)
        endfile(_oldfilename)
    _oldfilename = FILENAME
    beginfile(FILENAME)
}

END { endfile(FILENAME) }
</pre></div>

<p>这个文件必须在用户的主程序之前装入，因此这里所提供的规则会首先执行。
</p>
<p>这个规则依赖于 <code>awk</code> 的 <code>FILENAME</code> 变量，这个变量在处理每个新的数据文件时自动变化。
当前的数据文件存储在一个私有变量，<code>_oldfilename</code> 中。如果 <code>FILENAME</code> 与 <code>_oldfilename</code> 不相同，则一个新的数据文件正在被处理，则有必须为旧文件调用 <code>endfile()</code>。因为 <code>endfile()</code> 仅在一个文件被处理完后会调用，所以，程序首先要检查确定 <code>_oldfilename</code> 不是一个空串。程序然后将当前文件名赋值给 <code>_oldfilename</code> 然后为当前文件调用 <code>beginfile()</code>。像 <code>awk</code> 的变量一样，因为 <code>_oldfilename</code> 被初始化为空串，这个规则甚至在读取第一个数据文件时也是正确的。
</p>
<p>程序也提供一个 <code>END</code> 规则来处理最后一个文件。因为这个 <code>END</code> 规则在任何其他的由主程序提供 <code>END</code> 规则之前，因此 <code>endfile()</code> 会首先被调用。再一次地， 多个 <code>BEGIN</code> 与 <code>END</code> 规则的值应该被清除。
</p>
<a name="index-beginfile_0028_0029-user_002ddefined-function"></a>
<a name="index-endfile_0028_0029-user_002ddefined-function"></a>
<p>如果同样的数据文件在一个命令中出现了两次，则 <code>endfile()</code> 与 <code>beginfile()</code> 在第一轮结束的时候不会被执行，而在第二轮开始的时候执行。下面的版本解决了这个问题：
</p>
<div class="example">
<pre class="example"># ftrans.awk --- handle datafile transitions
#
# user supplies beginfile() and endfile() functions

FNR == 1 {
    if (_filename_ != &quot;&quot;)
        endfile(_filename_)
    _filename_ = FILENAME
    beginfile(FILENAME)
}

END { endfile(_filename_) }
</pre></div>

<p>在 <a href="#Wc-Program">统计</a>，中展示了这个库函数可以用于以及如何来简化主程序的编写。
</p>
<a name="index-sidebar_002c-e_0082_00a3a_00b9_0088a_00b8_00baa_00bb_0080a_00b9_0088-gawk-e_009c_0080e_00a6_0081-BEGINFILE-a_00b8_008e-ENDFILE_003f"></a>

<table class="cartouche" border="1"><tr><td>
<p align="center"><b>那么为什么 <code>gawk</code> 需要 <code>BEGINFILE</code> 与 <code>ENDFILE</code>?</b>
</p>


<p>你可能很奇怪，如果 <code>beginfile()</code> 与 <code>endfile()</code> 函数可以做相同的事情，为什么 <code>gawk</code> 还要有 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 模式呢？
</p>
<p>问题很好。正常情况下，如果 <code>awk</code> 没法打开一个文件，这会立即导致一个致使错误。在这种情况下，对于用户自己定义的函数来讲，就没有办法来处理这个问题。因为调用函数的机制依赖于正在被打开的文件及其第一条记录。所以，<code>BEGINFILE</code> 的主要原因是给你一个“勾子”来捕获不能被处理的文件。要取得更多的信息，请查看 <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>。
</p></td></tr></table>

<hr>
<a name="Rewind-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Filetrans-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-File-Management" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#File-Checking" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0087_008dae_0096_00b0e_00af_00bbaa_008f_0096aa_00bd_0093aa_0089_008dae_0096_0087a_00bb_00b6"></a>
<h3 class="subsection">1.3.2 重新读取当前文件</h3>

<a name="index-files_002c-reading"></a>
<p>对于内置函数的另一个请求则是加入这样的一个函数使其可以重新读取当前文件。请求的用户不想在循环中使用 <code>getline</code>（查看 see section <a href="#Getline">用 <code>getline</code> 输入数据</a>）。
</p>
<p>但是，只要你还不在 <code>END</code> 规则中，就非常容易安排立即关闭当前文件，然新头开始处理这个文件。由于缺少好名字，我们把它取名为 <code>rewind()</code>：
</p>
<a name="index-rewind_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># rewind.awk --- rewind the current file and start over

function rewind(    i)
{
    # shift remaining arguments up
    for (i = ARGC; i &gt; ARGIND; i--)
        ARGV[i] = ARGV[i-1]

    # make sure gawk knows to keep going
    ARGC++

    # make current file next to get done
    ARGV[ARGIND+1] = FILENAME

    # do it
    nextfile
}
</pre></div>

<p><code>rewind()</code> 函数依赖于 <code>ARGIND</code> 变量（查看 see section <a href="#Auto_002dset">传递信息的内置变量</a>），这个变量是 <code>gawk</code> 特有的。同时也依赖于 <code>nextfile</code> 关键词（查看 see section <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>）。由于这个原因，你不可以在 <code>ENDFILE</code> 规则中调用它。（也没有必要，因此 <code>gawk</code> 只要 <code>ENDFILE</code> 一结束就开始了下一个文件！）
</p>
<p>你需要小心地调用 <code>rewind()</code>。如果你不注意的话，可能会引发无限循环而结束程序。这里是一个使用的例子：
</p>
<div class="example">
<pre class="example">$ <kbd>cat data</kbd>
-| a
-| b
-| c
-| d
-| e

$ cat <kbd>test.awk</kbd>
-| FNR == 3 &amp;&amp; ! rewound {
-| 	rewound = 1
-| 	rewind()
-| }
-| 
-| { print FILENAME, FNR, $0 }

$ <kbd>gawk -f rewind.awk -f test.awk data </kbd>
-| data 1 a
-| data 2 b
-| data 1 a
-| data 2 b
-| data 3 c
-| data 4 d
-| data 5 e
</pre></div>

<hr>
<a name="File-Checking"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Rewind-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-File-Management" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Empty-Files" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a3_0080ae_009f_00a5aa_008f_00afe_00af_00bbc_009a_0084ae_0095_00b0ae_008d_00aeae_0096_0087a_00bb_00b6"></a>
<h3 class="subsection">1.3.3 检查可读的数据文件</h3>

<a name="index-troubleshooting_002c-readable-data-files"></a>
<a name="index-readable-data-files_002c-checking"></a>
<a name="index-files_002c-skipping"></a>
<p>一般情况下，如果你提供 <code>awk</code> 一个数据文件是不可读的，它会以致使错误而结束。有一些时候，你可能想忽略这样的问题并往下走。
<a name="DOCF73" href="#FOOT73">(73)</a>
你可以将下面的程序插入到你的 <code>awk</code> 程序中：
</p>
<a name="index-readable_002eawk-program"></a>
<div class="example">
<pre class="example"># readable.awk --- library file to skip over unreadable files

BEGIN {
    for (i = 1; i &lt; ARGC; i++) {
        if (ARGV[i] ~ /^[a-zA-Z_][a-zA-Z0-9_]*=.*/ \
            || ARGV[i] == &quot;-&quot; || ARGV[i] == &quot;/dev/stdin&quot;)
            continue    # assignment or standard input
        else if ((getline junk &lt; ARGV[i]) &lt; 0) # unreadable
            delete ARGV[i]
        else
            close(ARGV[i])
    }
}
</pre></div>

<a name="index-troubleshooting_002c-getline-function"></a>
<p>这个可以工作，因为 <code>getline</code> 不会导致致使错误。将 <code>delete</code> 从 <code>ARGV</code> 数组中移除元素以跳过这些文件（因此它不再在列表中）。查看 <a href="#ARGC-and-ARGV">使用 <code>ARGC</code> 与 <code>ARGV</code></a>。
</p>
<p>由于 <code>awk</code> 变量名字只允许是英文字母，所以正则表达式检查有意不使用字符类，如 &lsquo;<samp>[:alpha:]</samp>&rsquo; 与 &lsquo;<samp>[:alnum:]</samp>&rsquo; （查看 
see section <a href="#Bracket-Expressions">使用方括号表达式</a>）。
</p>
<hr>
<a name="Empty-Files"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#File-Checking" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-File-Management" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Ignoring-Assigns" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a3_0080ae_009f_00a5e_0095_00bfaa_00ba_00a6a_00b8_00bae_009b_00b6c_009a_0084ae_0096_0087a_00bb_00b6"></a>
<h3 class="subsection">1.3.4 检查长度为零的文件</h3>

<p>所有已知的 <code>awk</code> 实现都默默地跳过长度为零的文件。这是由 <code>awk</code> 隐式规则“读取记录并匹配规则”循环产生的结果。当 <code>awk</code> 尝试读取空文件记录时，它立即会接收到文件结束的指示，然后会关闭文件，并处理命令行中的下一个数据文件，而<em>不会</em>执行任务用户层的 <code>awk</code> 程序代码。
</p>
<p>使用 <code>gawk</code> 的 <code>ARGIND</code> 变量（查看 see section <a href="#Built_002din-Variables">预定义变量</a>），有可能来检测当遇到一个空数据文件时则跳过。
与在 <a href="#Filetrans-Function">注意数据文件的边界</a>，呈现的库文件相似，下面的库文件会调用用户必须提供的函数，名为 <code>zerofile()</code>。传递的参数为文件名，以及其在 <code>ARGV</code> 中的位置：
</p>
<a name="index-zerofile_002eawk-program"></a>
<div class="example">
<pre class="example"># zerofile.awk --- library file to process empty input files

BEGIN { Argind = 0 }

ARGIND &gt; Argind + 1 {
    for (Argind++; Argind &lt; ARGIND; Argind++)
        zerofile(ARGV[Argind], Argind)
}

ARGIND != Argind { Argind = ARGIND }

END {
    if (ARGIND &gt; Argind)
        for (Argind++; Argind &lt;= ARGIND; Argind++)
            zerofile(ARGV[Argind], Argind)
}
</pre></div>

<p>用户层的变量 <code>Argind</code> 允许 <code>awk</code> 程序跟踪它的 <code>ARGV</code> 进度。
无论什么时候程序检测到了 <code>ARGIND</code> 大于 &lsquo;<samp>Argind + 1</samp>&rsquo;，这就表示一到多个的文件名已经被跳过了。然后调用 <code>zerofile()</code> 的动作来处理每一个文件，并递增 Argind 变量。
</p>
<p>&lsquo;<samp>Argind != ARGIND</samp>&rsquo; 中是简单地来使 <code>Argind</code> 在正常情况下更新为最新状态。
</p>
<p>最后 <code>END</code> 规则会捕获在命令行最后的参数中的空文件。注意在 <code>for</code> 循环中使用的测试条件，是 使用 &lsquo;<samp>&lt;=</samp>&rsquo; 操作符而不是 &lsquo;<samp>&lt;</samp>&rsquo;。
</p>
<hr>
<a name="Ignoring-Assigns"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Empty-Files" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-File-Management" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getopt-Function" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b0_0086e_00b5_008baa_0080_00bcaa_00bd_0093ae_0088_0090ae_0098_00afae_0096_0087a_00bb_00b6aa_0090_008d"></a>
<h3 class="subsection">1.3.5 将赋值当成是文件名</h3>

<a name="index-assignments-as-filenames"></a>
<a name="index-filenames_002c-assignments-as"></a>
<p>有时候，你不想 <code>awk</code> 来处理命令行的变量赋值（查看 see section <a href="#Assignment-Options">在命令行中进行变量赋值</a>）。
尤其是你有一个文件中包含 &lsquo;<samp>=</samp>&rsquo; 符号，<code>awk</code> 会将这个文件名当成一个赋值，而不会处理它。
</p>
<p>一些用户曾建议了一个额外的命令行选项来给 <code>gawk</code> 去禁用命令行的赋值。但是，一些库文件中的简单的程序就可以解决：
</p>
<a name="index-noassign_002eawk-program"></a>
<div class="example">
<pre class="example"># noassign.awk --- library file to avoid the need for a
# special option that disables command-line assignments

function disable_assigns(argc, argv,    i)
{
    for (i = 1; i &lt; argc; i++)
        if (argv[i] ~ /^[a-zA-Z_][a-zA-Z0-9_]*=.*/)
            argv[i] = (&quot;./&quot; argv[i])
}

BEGIN {
    if (No_command_assign)
        disable_assigns(ARGC, ARGV)
}
</pre></div>

<p>然后你这么来运行程序：
</p>
<div class="example">
<pre class="example">awk -v No_command_assign=1 -f noassign.awk -f yourprog.awk *
</pre></div>

<p>函数会迭代所有的参数。它会在匹配变量赋值形式的参数前插入 &lsquo;<samp>./</samp>&rsquo;，来将参数转换为文件名。
</p>
<p>通过给 <code>No_command_assign</code> 在调用时赋值为 true，可以让你调用时禁用命令行中的赋值。当没有设置时，它的初始值为 0（即 false），所以命令行参数就不会变化。
</p>
<hr>
<a name="Getopt-Function"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Ignoring-Assigns" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Passwd-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a4_0084c_0090_0086aa_0091_00bda_00bb_00a4e_00a1_008ce_0080_0089e_00a1_00b9"></a>
<h2 class="section">1.4 处理命令行选项</h2>

<a name="index-libraries-of-awk-functions_002c-command_002dline-options"></a>
<a name="index-functions_002c-library_002c-command_002dline-options"></a>
<a name="index-command_002dline-options_002c-processing"></a>
<a name="index-options_002c-command_002dline_002c-processing"></a>
<a name="index-functions_002c-library_002c-C-library"></a>
<a name="index-arguments_002c-processing"></a>
<p>在 POSIX 兼容的系统上的大多数工具都从命令行中取得选项，用此来改变程序的行为方式。<code>awk</code> 是一个这样的例子（查看 <a href="#Options">命令行参数</a>）。
经常地，选项都会有<em>参数</em>（即程序命令行要正确遵守选项的所需要的数据）。例如 <code>awk</code> 的 &lsquo;<samp>-F</samp>&rsquo; 选项，需要一个串来作为域的分隔符。第一个出现在命令行中的 &lsquo;<samp>--</samp>&rsquo; 或者不能 &lsquo;<samp>-</samp>&rsquo; 开头的字串结束选项。
</p>
<a name="index-getopt_0028_0029-function-_0028C-library_0029"></a>
<p>现在的 Unix 系统提供了 C 函数，名字为 <code>getopt()</code> 来处理命令行参数。程序员提供一个字串用来描述单字母的选项。如果选项需要一个参数，则它在字串后后面会跟一个冒号。<code>getopt()</code> 同时也传递命令行参数的数量与值，并在循环中进行调用。<code>getopt()</code> 为选项字母处理命令行参数。每次迭代循环，它就返回一个代表下一个它所发现的选项字母，或者为无效的选项的时候，返回 &lsquo;<samp>?</samp>&rsquo;。当返回 -1 时，表示命令行中没有要处理的选项了。
</p>
<p>当使用 <code>getopt()</code> 时，没有带参数的选项可以被合并在一起。另外，需要带参数选项需要参数与要提供。参数可以直接跟在选项字母后面，或者也可以是一个分离的命令行参数。
</p>
<p>假设有一个假想的程序，接收三个命令行参数，&lsquo;<samp>-a</samp>&rsquo;，&lsquo;<samp>-b</samp>&rsquo; 与 &lsquo;<samp>-c</samp>&rsquo;，而 &lsquo;<samp>-b</samp>&rsquo; 需要一个参数，下面所有的该当都是有效的调用程序的方式：
</p>
<div class="example">
<pre class="example">prog -a -b foo -c data1 data2 data3
prog -ac -bfoo -- data1 data2 data3
prog -acbfoo data1 data2 data3
</pre></div>

<p>注意到，当参数与它的选项进行组合时，参数后面的部分都被当成是选项的参数。在这个例子中，&lsquo;<samp>-abcfoo</samp>&rsquo; 表示所有的 &lsquo;<samp>-a</samp>&rsquo;，&lsquo;<samp>-b</samp>&rsquo; 与 &lsquo;<samp>-c</samp>&rsquo; 选项，并且 &lsquo;<samp>foo</samp>&rsquo; 是 &lsquo;<samp>-b</samp>&rsquo; 选项的参数。
</p>
<p><code>getopt()</code> 提供了 4 个外部的变量，供程序员使用：
</p>
<dl compact="compact">
<dt><code>optind</code></dt>
<dd><p>在参数值数组（<code>argv</code>）中的索引，在这个数组中，可以找到第一个不是选项的命令参数。
</p>
</dd>
<dt><code>optarg</code></dt>
<dd><p>某此选项的参数的字串值。
</p>
</dd>
<dt><code>opterr</code></dt>
<dd><p>通常情况下，<code>getopt()</code> 在找到一个无效的选项的时候会打印一个错误消息。将 <code>opterr</code> 设置为 0 可以禁用这个特性。（应用程序可能想打印自己的错误消息。）
</p>
</dd>
<dt><code>optopt</code></dt>
<dd><p>代表命令行选项的字母。
</p></dd>
</dl>

<p>下面的 C 代码版本展示了 <code>getopt()</code> 如何来处理 <code>awk</code> 命令行参数的可能方式：
</p>
<div class="example">
<pre class="example">int
main(int argc, char *argv[])
{
    &hellip;
    /* print our own message */
    opterr = 0;
    while ((c = getopt(argc, argv, &quot;v:f:F:W:&quot;)) != -1) {
        switch (c) {
        case 'f':    /* file */
            &hellip;
            break;
        case 'F':    /* field separator */
            &hellip;
            break;
        case 'v':    /* variable assignment */
            &hellip;
            break;
        case 'W':    /* extension */
            &hellip;
            break;
        case '?':
        default:
            usage();
            break;
        }
    }
    &hellip;
}
</pre></div>

<p>插一句，<code>gawk</code> 实际上是使用 GNU 的 <code>getopt_long()</code> 函数来处理常规的选项以及 GNU 风格的长选项（查看 <a href="#Options">命令行参数</a>）。
</p>
<p>由 <code>getopt()</code> 提供的抽象非常有用，并且在 <code>awk</code> 程序中也非常方便。下面是一个 <code>awk</code> 版本的 <code>getopt()</code>。
这个函数突出了 <code>awk</code> 中最弱的一个方面，即它在处理单个字符的时候非常差。重复地调用 <code>substr()</code> 在读取单个字符时是必须的（查看 <a href="#String-Functions">字串操作函数</a>）。 
<a name="DOCF74" href="#FOOT74">(74)</a>
</p>
<p>下面一点点地来解释代码：
</p>
<a name="index-getopt_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># getopt.awk --- Do C library getopt(3) function in awk

# External variables:
#    Optind -- index in ARGV of first nonoption argument
#    Optarg -- string value of argument to current option
#    Opterr -- if nonzero, print our own diagnostic
#    Optopt -- current option letter

# Returns:
#    -1     at end of options
#    &quot;?&quot;    for unrecognized option
#    &lt;c&gt;    a character representing the current option

# Private Data:
#    _opti  -- index in multiflag option, e.g., -abc
</pre></div>

<p>函数以注释开始，说明了它所使用的全局变量的一个列表，返回的值是什么，他们又表示什么，以及这个库函数所私有的全局变量。这样的文档对于任何程序来讲都是很重要的，尤其是对于库函数。
</p>
<p><code>getopt()</code> 函数首先检查确实是以选项的串来进行调用的（<code>options</code> 参数）。
如果 <code>options</code> 的长度为 0，则 <code>getopt()</code> 会立即返回 -1 ：
</p>
<a name="index-getopt_0028_0029-user_002ddefined-function-1"></a>
<div class="example">
<pre class="example">function getopt(argc, argv, options,    thisopt, i)
{
    if (length(options) == 0)    # no options given
        return -1

</pre><pre class="example">    if (argv[Optind] == &quot;--&quot;) {  # all done
        Optind++
        _opti = 0
        return -1
</pre><pre class="example">    } else if (argv[Optind] !~ /^-[^:[:space:]]/) {
        _opti = 0
        return -1
    }
</pre></div>

<p>下个要做的事情是要检查选项的结束。&lsquo;<samp>--</samp>&rsquo; 用于结束命令行选项，因为没有任何的命令行参数不是以 &lsquo;<samp>-</samp>&rsquo; 开始。<code>Optind</code> 用来一个个地迭代命令行参数数组，它在调用 <code>getopt()</code> 的过程中一直保留它的值，因为它是一个全局变量。
</p>
<p>在这里使用了正则表达式 <code><span class="nolinebreak">/^-[^:[:space:]/</span></code>，用于检查 &lsquo;<samp>-</samp>&rsquo; 后面跟任意的不是空格与冒号的字符。如果命令行参数不匹配这个模式，则它就不是一个选项，然后结束处理。后续：
</p>
<div class="example">
<pre class="example">    if (_opti == 0)
        _opti = 2
    thisopt = substr(argv[Optind], _opti, 1)
    Optopt = thisopt
    i = index(options, thisopt)
    if (i == 0) {
        if (Opterr)
            printf(&quot;%c -- invalid option\n&quot;, thisopt) &gt; &quot;/dev/stderr&quot;
        if (_opti &gt;= length(argv[Optind])) {
            Optind++
            _opti = 0
        } else
            _opti++
        return &quot;?&quot;
    }
</pre></div>

<p><code>_opti</code> 变量用于跟踪当前命令行参数的位置（<code>argv[Optind]</code>）。如果有多个选项用 &lsquo;<samp>-</samp>&rsquo; 合并在一起（如，&lsquo;<samp>-abx</samp>&rsquo;），则有必要一次返回一个。
</p>
<p>如果 <code>_opti</code> 的等于 0，则被设置为 2，这个值是字串中下一个要查找字符的位置（我们跳过 &lsquo;<samp>-</samp>&rsquo;，而它的位置是 1 ）。变量 <code>thisopt</code> 保存用 <code>substr()</code> 取得的字符。它被保存于 <code>Optopt</code> 以备主程序的使用。
</p>
<p>如果 <code>thisopt</code> 不在选项串 <code>options</code> 中，则它不是一个有效的选项。如果 <code>Opterr</code> 的值为非 0，<code>getopt()</code> 打印一个错误信息到标准错误输出上，这个与 C 版本的 <code>getopt()</code> 的信息类似。
</p>
<p>由于选项是无效的，就有必须跳过它并处理下一个选项字符。如果 <code>_opti</code> 大于或者等于当前命令行参数的个长度，则有必要移动到下一个参数。所以，<code>Optind</code> 被递增，<code>_opti</code> 被设置为 0。否则的话，<code>Optind</code> 不会改变，而只递增 <code>_opti</code>。
</p>
<p>在任何情况下，由于选项是无效的，<code>getopt()</code> 都返回 <code>&quot;?&quot;</code>。主程序可以检查 <code>Optopt</code> 以确定无效的选项到底是什么。继续：
</p>
<div class="example">
<pre class="example">    if (substr(options, i + 1, 1) == &quot;:&quot;) {
        # get option argument
        if (length(substr(argv[Optind], _opti + 1)) &gt; 0)
            Optarg = substr(argv[Optind], _opti + 1)
        else
            Optarg = argv[++Optind]
        _opti = 0
    } else
        Optarg = &quot;&quot;
</pre></div>

<p>如果选项需要一个参数，在选项字串 <code>options</code> 中的选项字母后面会跟着一个冒号。如果在当前的命令参数列表中（<code>argv[Optind]</code>）还有字符，则字串后面的内容会被赋值给 <code>Optarg</code>。否则就使用下一个命令参数（&lsquo;<samp>-xFOO</samp>&rsquo; 对 &lsquo;<samp><span class="nolinebreak">-x</span>&nbsp;FOO</samp>&rsquo;）。
在任一情况下，<code>_opti</code> 都被设置为 0，因为没有更多的字符剩下来检查当前的命令行参数。继续：
</p>
<div class="example">
<pre class="example">    if (_opti == 0 || _opti &gt;= length(argv[Optind])) {
        Optind++
        _opti = 0
    } else
        _opti++
    return thisopt
}
</pre></div>

<p>最后，如果 <code>_opti</code> 为 0 或者大于当前命令行参数的长度，则它表示元素在 argv 中已经处理了，所以，<code>Optind</code> 被递增以指向下一个 <code>argv</code> 中的元素。如果没有一个条件为 true，则只有 <code>_opti</code> 被递增，所以下一个选项字母可以在下次调用 <code>getopt()</code> 时被处理。
</p>
<p><code>BEGIN</code> 规则中将 <code>Opterr</code> 与 <code>Optind</code> 都设置为 1。<code>Opterr</code> 被设置为 1 的原因是 <code>getopt()</code> 的默认行为就是在发现无效选项的时候打印诊断信息。<code>Optind</code> 设置为 1 是因为没有原因要去查看程序名，因为程序名存在 <code>ARGV[0]</code> 中：
</p>
<div class="example">
<pre class="example">BEGIN {
    Opterr = 1    # default is to diagnose
    Optind = 1    # skip ARGV[0]

    # test program
    if (_getopt_test) {
        while ((_go_c = getopt(ARGC, ARGV, &quot;ab:cd&quot;)) != -1)
            printf(&quot;c = &lt;%c&gt;, Optarg = &lt;%s&gt;\n&quot;,
                                       _go_c, Optarg)
        printf(&quot;non-option arguments:\n&quot;)
        for (; Optind &lt; ARGC; Optind++)
            printf(&quot;\tARGV[%d] = &lt;%s&gt;\n&quot;,
                                    Optind, ARGV[Optind])
    }
}
</pre></div>

<p><code>BEGIN</code> 规则的剩下部分就是一个很简单的测试程序。这是两上例子，运行测试程序时的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>awk -f getopt.awk -v _getopt_test=1 -- -a -cbARG bax -x</kbd>
-| c = &lt;a&gt;, Optarg = &lt;&gt;
-| c = &lt;c&gt;, Optarg = &lt;&gt;
-| c = &lt;b&gt;, Optarg = &lt;ARG&gt;
-| non-option arguments:
-|         ARGV[3] = &lt;bax&gt;
-|         ARGV[4] = &lt;-x&gt;

$ <kbd>awk -f getopt.awk -v _getopt_test=1 -- -a -x -- xyz abc</kbd>
-| c = &lt;a&gt;, Optarg = &lt;&gt;
error--&gt; x -- invalid option
-| c = &lt;?&gt;, Optarg = &lt;&gt;
-| non-option arguments:
-|         ARGV[4] = &lt;xyz&gt;
-|         ARGV[5] = &lt;abc&gt;
</pre></div>

<p>在两次运行里，第一个 &lsquo;<samp>--</samp>&rsquo; 会终结 <code>awk</code> 中的参数，所以它不会试图去将 &lsquo;<samp>-a</samp>&rsquo; 等等来当成自己的选项。
</p>
<blockquote>
<p><b>提示:</b> 在 <code>getopt()</code> 完成后，用户层代码必须清除所有的 <code>ARGV</code> 元素，从索引 1 到 <code>Optind</code>，所以，<code>awk</code> 不会试图去把命令行选项当成文件名来处理。
</p></blockquote>

<p>使用 &lsquo;<samp>#!</samp>&rsquo; 并带上 &lsquo;<samp>-E</samp>&rsquo; 选项可以避免将你的程序的选项与 <code>gawk</code> 的选项的冲突，因为 &lsquo;<samp>-E</samp>&rsquo; 选项会导致 <code>gawk</code> 放弃处理后续的选项（查看 see section <a href="#Executable-Scripts">可执行的 <code>awk</code> 程序</a>，以及 
<a href="#Options">命令行参数</a>）。
</p>
<p>在 <a href="#Sample-Programs">实用的 <code>awk</code> 程序</a>，中的几个例子使用 <code>getopt()</code> 来处理它们的参数。
</p>
<hr>
<a name="Passwd-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getopt-Function" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Group-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_00bbaa_008f_0096c_0094_00a8ae_0088_00b7ae_0095_00b0ae_008d_00aeaa_00ba_0093"></a>
<h2 class="section">1.5 读取用户数据库</h2>

<a name="index-libraries-of-awk-functions_002c-user-database_002c-reading"></a>
<a name="index-functions_002c-library_002c-user-database_002c-reading"></a>
<a name="index-user-database_002c-reading"></a>
<a name="index-database_002c-users_002c-reading"></a>
<a name="index-PROCINFO-array-2"></a>
<p><code>PROCINFO</code> 数组（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）提供了访问当前用户直实与有效的用户与组 ID 数值的方式，并且如果可用，用户的补充的组集也可以访问。但是，因为这些都是些数值，它们没有提供非常有用的信息给到普通的用户。必须有什么样的方法来找到与用户与组 ID 数组相关的用户信息。
这一小节就是提供一组函数来从用户数据库中返回信息。查看 <a href="#Group-Functions">读取组数据库</a>，可了解从组数据库中返回信息的一组函数。
</p>
<a name="index-getpwent_0028_0029-function-_0028C-library_0029"></a>
<a name="index-getpwent_0028_0029-user_002ddefined-function"></a>
<a name="index-users_002c-information-about_002c-retrieving"></a>
<a name="index-login-information"></a>
<a name="index-account-information"></a>
<a name="index-password-file"></a>
<a name="index-files_002c-password"></a>
<p>POSIX 标准没有定义用户的信息存在哪。相反，它提供了 <code>&lt;pwd.h&gt;</code> 头文件以及几个 C 语言例程来获取用户的信息。主要的函数有 <code>getpwent()</code>，用来“get password entry”（获取密码项）。密码来自于最初的用户数据库文件，&lsquo;<tt>/etc/passwd</tt>&rsquo;，在里面存储了用户信息以及加密过的密码（与名字有相关）。
</p>
<a name="index-pwcat-program"></a>
<p>尽管 <code>awk</code> 程序可以简单直接地读取 &lsquo;<tt>/etc/passwd</tt>&rsquo; 文件，但是文件并没有包含系统中用户集的完整信息。
<a name="DOCF75" href="#FOOT75">(75)</a>
为了确保你能够产生可读的以及完整的用户数据版本，有必要调用 <code>getpwent()</code> 来写一个小的 C 程序。<code>getpwent()</code> 定义为返回 <code>struct passwd</code> 的指针。每次调用，它都返回下一个项。当没有更多的项时，则返回 <code>NULL</code>，即空指针。
当出现这个结果后，C 程序则要调用 <code>endpwent()</code> 来关闭数据库。下面是 <code>pwcat</code>，一个 C 程序用来“连接”密码数据库：
</p>
<div class="example">
<pre class="example">/*
 * pwcat.c
 *
 * Generate a printable version of the password database.
 */
#include &lt;stdio.h&gt;
#include &lt;pwd.h&gt;

int
main(int argc, char **argv)
{
    struct passwd *p;

    while ((p = getpwent()) != NULL)
        printf(&quot;%s:%s:%ld:%ld:%s:%s:%s\n&quot;,
            p-&gt;pw_name, p-&gt;pw_passwd, (long) p-&gt;pw_uid,
            (long) p-&gt;pw_gid, p-&gt;pw_gecos, p-&gt;pw_dir, p-&gt;pw_shell);

    endpwent();
    return 0;
}
</pre></div>

<p>如果你不理解 C 代码，也没有关系。<code>pwcat</code> 的输出就是以传统的 &lsquo;<tt>/etc/passwd</tt>&rsquo; 的冒号分隔域的格式输出用户数据库。这些域是：
</p>
<dl compact="compact">
<dt>Login name</dt>
<dd><p>用户的登录名。
</p>
</dd>
<dt>Encrypted password</dt>
<dd><p>用户加密过的密码。这在某些系统上可能得不到。
</p>
</dd>
<dt>User-ID</dt>
<dd><p>用户的数值 ID。（在一些系统上，这是一个 C 的 <code>long</code> 类型，而不是 <code>int</code> 型，所以，我们在所有的情况下都转换为 <code>long</code>。）
</p>
</dd>
<dt>Group-ID</dt>
<dd><p>用户的组数值 ID。（内容与刚才所述的 <code>long</code> 与 <code>int</code> 类型的解释类似。）
</p>
</dd>
<dt>Full name</dt>
<dd><p>用户的全名，以及与这个用户相关的其他信息。
</p>
</dd>
<dt>Home directory</dt>
<dd><p>用户的登录目录（或者“home”）（Shell 程序员熟悉的 <code>$HOME</code>）。
</p>
</dd>
<dt>Login shell</dt>
<dd><p>当用户登录时所要运行的程序。一般来说是一个 Shell 程序，如 Bash。
</p></dd>
</dl>

<p><code>pwcat</code> 的输出的几行内容例子如下：
</p>
<a name="index-Jacobs_002c-Andrew"></a>
<a name="index-Robbins_002c-Arnold-2"></a>
<a name="index-Robbins_002c-Miriam-2"></a>
<div class="example">
<pre class="example">$ <kbd>pwcat</kbd>
-| root:x:0:1:Operator:/:/bin/sh
-| nobody:*:65534:65534::/:
-| daemon:*:1:1::/:
-| sys:*:2:2::/:/bin/csh
-| bin:*:3:3::/bin:
-| arnold:xyzzy:2076:10:Arnold Robbins:/home/arnold:/bin/sh
-| miriam:yxaay:112:10:Miriam Robbins:/home/miriam:/bin/sh
-| andy:abcca2:113:10:Andy Jacobs:/home/andy:/bin/sh
&hellip;
</pre></div>

<p>根据之前的一些说明，下面是一组函数用来取得用户的信息的函数。这里有几个函数与 C 中同名的函数对应：
</p>
<a name="index-_005fpw_005finit_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># passwd.awk --- access password file information

BEGIN {
    # tailor this to suit your system
    _pw_awklib = &quot;/usr/local/libexec/awk/&quot;
}

function _pw_init(    oldfs, oldrs, olddol0, pwcat, using_fw, using_fpat)
{
    if (_pw_inited)
        return

    oldfs = FS
    oldrs = RS
    olddol0 = $0
    using_fw = (PROCINFO[&quot;FS&quot;] == &quot;FIELDWIDTHS&quot;)
    using_fpat = (PROCINFO[&quot;FS&quot;] == &quot;FPAT&quot;)
    FS = &quot;:&quot;
    RS = &quot;\n&quot;

    pwcat = _pw_awklib &quot;pwcat&quot;
    while ((pwcat | getline) &gt; 0) {
        _pw_byname[$1] = $0
        _pw_byuid[$3] = $0
        _pw_bycount[++_pw_total] = $0
    }
    close(pwcat)
    _pw_count = 0
    _pw_inited = 1
    FS = oldfs
    if (using_fw)
        FIELDWIDTHS = FIELDWIDTHS
    else if (using_fpat)
        FPAT = FPAT
    RS = oldrs
    $0 = olddol0
}
</pre></div>

<a name="index-BEGIN-pattern_002c-pwcat-program"></a>
<p><code>BEGIN</code> 规则将私有变量设置为 <code>pwcat</code> 所在的目录。因为它用于辅助 <code>awk</code> 的库例程。我们已经将其放在 &lsquo;<tt>/usr/local/libexec/awk</tt>&rsquo; 中，但是，你可能想放到你的系统中的另外一个位置。
</p>
<p>函数 <code>_pw_init()</code> 会将用户信息的三个复本填入到三个相关的数组。数组由用户名进行（<code>_pw_byname</code>)，用户 ID（<code>_pw_byuid</code>)，以及出现的顺序（<code>_pw_bycount</code>）进行索引。变量 <code>_pw_inited</code> 为了高效而设置，因此 <code>_pw_init()</code> 只需要调用一次。
</p>
<a name="index-PROCINFO-array_002c-testing-the-field-splitting"></a>
<a name="index-getline-command_002c-_005fpw_005finit_0028_0029-function"></a>
<p>由于函数使用 <code>getline</code> 来从 <code>pwcat</code> 中读取信息，它首先将 <code>FS</code>，<code>RS</code> 与 <code>$0</code> 的值存起来。使用 <code>using_fw</code> 变量来表示域是否是用 <code>FIELDWIDTHS</code> 来进行分割。这么做是有必要的，因为这些函数也可从用户程序的任何地方进行调用，并且用户有它自己的记录域的分割方式。这样，通过这样的方式使我们可以恢复正确的分割机制。测试只针对 <code>gawk</code>。在某此 <code>awk</code> 实现中，如果使用 <code>FS</code> 或者 <code>FPAT</code>，则这个值为 false。
</p>
<p>检查是否使用 <code>FPAT</code> 的代码利用 <code>using_fpat</code> 变量与 <code>PROCINFO[&quot;FS&quot;]</code> 也是类似的情况。
</p>
<p>函数的主体部分使用循环来读取数据库行，并将它们分割为不同的域，然后将行存储到数组中以备使用。当循环结束时，<code><span class="nolinebreak">_pw_init()</span></code> 通过关闭管线清理，并将 <code><span class="nolinebreak">_pw_inited</span></code> 设置为 1，然后恢复 <code>FS</code> 的值（如果必要的情况下也恢复 <code>FIELDWIDTHS</code> 与 <code>FPAT</code>），<code>RS</code> 的值与 <code>$0</code> 的值。<code><span class="nolinebreak">_pw_count</span></code> 的使用后面再解释。
</p>
<a name="index-getpwnam_0028_0029-function-_0028C-library_0029"></a>
<p><code>getpwnam()</code> 函数取用户名的字串为参数。如果用户在数据库中，则其返回相应的行。否则，通过指向一个不存在的元素的引用会创建一个值为空串的元素。
</p>
<a name="index-getpwnam_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function getpwnam(name)
{
    _pw_init()
    return _pw_byname[name]
}
</pre></div>

<a name="index-getpwuid_0028_0029-function-_0028C-library_0029"></a>
<p>类似地，<code>getpwuid()</code> 函数使用用户的 ID 值作为参数。如果用户数组在数据库中，则返回相应的行，否则返回一个空串：
</p>
<a name="index-getpwuid_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function getpwuid(uid)
{
    _pw_init()
    return _pw_byuid[uid]
}
</pre></div>

<a name="index-getpwent_0028_0029-function-_0028C-library_0029-1"></a>
<p><code>getpwent()</code> 函数简单地遍历数据库，一次一项。它使用 <code>_pw_count</code> 来跟踪 <code>_pw_bycount</code> 数组中的位置：
</p>
<a name="index-getpwent_0028_0029-user_002ddefined-function-1"></a>
<div class="example">
<pre class="example">function getpwent()
{
    _pw_init()
    if (_pw_count &lt; _pw_total)
        return _pw_bycount[++_pw_count]
    return &quot;&quot;
}
</pre></div>

<a name="index-endpwent_0028_0029-function-_0028C-library_0029"></a>
<p><code>endpwent()</code> 函数重新将 <code><span class="nolinebreak">_pw_count</span></code> 设置为 0，所以后续对于 <code>getpwent()</code> 的调用会重头开始：
</p>
<a name="index-endpwent_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function endpwent()
{
    _pw_count = 0
}
</pre></div>

<p>在这一组例程的一致设计决策是每一个例程都调用 <code><span class="nolinebreak">_pw_init()</span></code> 来初始化数组库数组。运行另一个进程来产生用户数组库，以及扫描数据库的负担仅在用户的主程序程序调用其中的某个函数才会产生。如果这个库文件与用户程序一起装载，但是又没有调用其中的任何例程，则不会有任何的运行时负担。（另一个选择是将 <code><span class="nolinebreak">_pw_init()</span></code> 的执行体移到 <code>BEGIN</code> 规则中，在这里部会执行 pwcat。这简化了代码，但是会运行一些从来不会需要的额外过程。）
</p>
<p>再者，调用 <code>_pw_init()</code> 代价也不高，因为 <code>_pw_inited</code> 变量会使程序从数据库中读取数据次数不会出于一次。如果你担心这样的测试会遍历在你的程序中，你也可以将检查 <code>_pw_inited</code> 的代码表从 <code>_pw_init()</code> 移出去，并复制到所有的其他函数中。在实践中，这是没有必要的，因为大多数的 <code>awk</code> 程序都是 I/O 型的，这样改变会弄乱代码。
</p>
<p>在 <a href="#Id-Program">打印用户信息</a>，中的 <code>id</code> 程序会使用到这些函数。
</p>
<hr>
<a name="Group-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Passwd-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Walking-Arrays" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_00bbaa_008f_0096c_00bb_0084ae_0095_00b0ae_008d_00aeaa_00ba_0093"></a>
<h2 class="section">1.6 读取组数据库</h2>

<a name="index-libraries-of-awk-functions_002c-group-database_002c-reading"></a>
<a name="index-functions_002c-library_002c-group-database_002c-reading"></a>
<a name="index-group-database_002c-reading"></a>
<a name="index-database_002c-group_002c-reading"></a>
<a name="index-PROCINFO-array_002c-and-group-membership"></a>
<a name="index-getgrent_0028_0029-function-_0028C-library_0029"></a>
<a name="index-getgrent_0028_0029-user_002ddefined-function"></a>
<a name="index-groups_002c-information-about"></a>
<a name="index-account-information-1"></a>
<a name="index-group-file"></a>
<a name="index-files_002c-group"></a>
<p>在 <a href="#Passwd-Functions">读取用户数据库</a>，中讨论的很多问题也都可以用于组数据库中。尽管传统上以大家都了解的格式与文件（&lsquo;<tt>/etc/group</tt>&rsquo;）存储，但是 POSIX 标准只提供了一组 C 库函数（<code>&lt;grp.h&gt;</code> 与 <code>getgrent()</code>）来访问信息。就算存在这些文件，但是也可能没有完整的信息。因此，与用户数据库一样，也有必要来写一个小的 C 程序来产生组信息。
<code>grcat</code> 则是一个这样的 C 程序用来“cat”组数据库，如下：
</p>
<a name="index-grcat-program"></a>
<div class="example">
<pre class="example">/*
 * grcat.c
 *
 * Generate a printable version of the group database.
 */
#include &lt;stdio.h&gt;
#include &lt;grp.h&gt;

int
main(int argc, char **argv)
{
    struct group *g;
    int i;

    while ((g = getgrent()) != NULL) {
        printf(&quot;%s:%s:%ld:&quot;, g-&gt;gr_name, g-&gt;gr_passwd,
                                     (long) g-&gt;gr_gid);
        for (i = 0; g-&gt;gr_mem[i] != NULL; i++) {
            printf(&quot;%s&quot;, g-&gt;gr_mem[i]);
</pre><pre class="example">            if (g-&gt;gr_mem[i+1] != NULL)
                putchar(',');
        }
</pre><pre class="example">        putchar('\n');
    }
    endgrent();
    return 0;
}
</pre></div>

<p>在组数据库中的一行代表一个组。域则通过冒号来分隔，表示如下信息：
</p>
<dl compact="compact">
<dt>Group Name</dt>
<dd><p>组名。
</p>
</dd>
<dt>Group Password</dt>
<dd><p>组的加密密码。在实践中，这个域不会使用到，通过为空或者设置为 &lsquo;<samp>*</samp>&rsquo;。
</p>
</dd>
<dt>Group ID Number</dt>
<dd><p>组的数值 ID，将名字与数值关联在文件中必须是唯一的。（在一些系统上，它是 C 的 <code>long</code> 类型，而不是 <code>int</code> 类型。所以，我们都将其转换为 <code>long</code>。）
The group&rsquo;s numeric group ID number;
</p>
</dd>
<dt>Group Member List</dt>
<dd><p>一个逗号分隔的用户列表。这些用户是组的成员。现代的 Unix 系统允许用户同时是多个组的成员。如果你的系统可以支持，则在 <code>PROCINFO</code> 中会为这些组 ID 存储元素 <code>&quot;group1&quot;</code> 到 <code>&quot;group<var>N</var>&quot;</code>。（注意，<code>PROCINFO</code> 是一个 <code>gawk</code> 扩展，查看 see section <a href="#Built_002din-Variables">预定义变量</a>）
</p></dd>
</dl>

<p>运行 <code>grcat</code> 时产生的输出可能如下：
</p>
<div class="example">
<pre class="example">$ <kbd>grcat</kbd>
-| wheel:*:0:arnold
-| nogroup:*:65534:
-| daemon:*:1:
-| kmem:*:2:
-| staff:*:10:arnold,miriam,andy
-| other:*:20:
&hellip;
</pre></div>

<p>这些函数用来从组数据库中获取信息。有几个，按照 C 库函数的方式来命名：
</p>
<a name="index-getline-command_002c-_005fgr_005finit_0028_0029-user_002ddefined-function"></a>
<a name="index-_005fgr_005finit_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example"># group.awk --- functions for dealing with the group file

BEGIN {
    # Change to suit your system
    _gr_awklib = &quot;/usr/local/libexec/awk/&quot;
}

function _gr_init(    oldfs, oldrs, olddol0, grcat,
                             using_fw, using_fpat, n, a, i)
{
    if (_gr_inited)
        return

    oldfs = FS
    oldrs = RS
    olddol0 = $0
    using_fw = (PROCINFO[&quot;FS&quot;] == &quot;FIELDWIDTHS&quot;)
    using_fpat = (PROCINFO[&quot;FS&quot;] == &quot;FPAT&quot;)
    FS = &quot;:&quot;
    RS = &quot;\n&quot;

    grcat = _gr_awklib &quot;grcat&quot;
    while ((grcat | getline) &gt; 0) {
        if ($1 in _gr_byname)
            _gr_byname[$1] = _gr_byname[$1] &quot;,&quot; $4
        else
            _gr_byname[$1] = $0
        if ($3 in _gr_bygid)
            _gr_bygid[$3] = _gr_bygid[$3] &quot;,&quot; $4
        else
            _gr_bygid[$3] = $0

        n = split($4, a, &quot;[ \t]*,[ \t]*&quot;)
        for (i = 1; i &lt;= n; i++)
            if (a[i] in _gr_groupsbyuser)
                _gr_groupsbyuser[a[i]] = gr_groupsbyuser[a[i]] &quot; &quot; $1
            else
                _gr_groupsbyuser[a[i]] = $1

        _gr_bycount[++_gr_count] = $0
    }
    close(grcat)
    _gr_count = 0
    _gr_inited++
    FS = oldfs
    if (using_fw)
        FIELDWIDTHS = FIELDWIDTHS
    else if (using_fpat)
        FPAT = FPAT
    RS = oldrs
    $0 = olddol0
}
</pre></div>

<p><code>BEGIN</code> 规则将存储 <code>grcat</code> 所有的目录存储在私有变量中。因此这用于指出 <code>awk</code> 库函数的位置。我们将其放在 &lsquo;<tt>/usr/local/libexec/awk</tt>&rsquo; 中。可能你会选择存在另一个地方。
</p>
<p>这些例程遵循与用户数据库例程一样的框架（查看 see section <a href="#Passwd-Functions">读取用户数据库</a>）。<code><span class="nolinebreak">_gr_inited</span></code> 变量用于保证数据库只被扫描一次。<code><span class="nolinebreak">_gr_init()</span></code> 函数首先存储 <code>FS</code>，<code>RS</code> 以及 <code>$0</code> 值，然后将 <code>FS</code> 与 <code>RS</code> 的值设置成正则扫描组信息的格式。同时也会注意是否是用 <code>FIELDWIDTHS</code> 或者 <code>FPAT</code>，后面以用来恢复恰当的域分割机制。
</p>
<p>组信息存储在几个关联的数组中。数组由组名（<code><span class="nolinebreak">_gr_byname</span></code>)，组ID（<code><span class="nolinebreak">_gr_bygid</span></code>），以及在数据库中的位置（<code><span class="nolinebreak">_gr_bycount</span></code>）来索引。还有一个数组由用户名来索引（<code><span class="nolinebreak">_gr_groupsbyuser</span></code>），这是每个用户所属的组，每一个用空格分割。
</p>
<p>与用户数据库不同，它有可能在一个数据库有多个记录有相同的组名。当这个组有很多的成员的时候这很正常。两个这样的项看起来像：
</p>
<div class="example">
<pre class="example">tvpeople:*:101:johnny,jay,arsenio
tvpeople:*:101:david,conan,tom,joan
</pre></div>

<p>因为这个，<code>_gr_init()</code> 要查看是否有相同的组名与组 ID 值。如果有，用户名只是简单地连接到前面的用户列表中。 
<a name="DOCF76" href="#FOOT76">(76)</a>
</p>
<p>最后，<code>_gr_init()</code> 关闭 <code>grcat</code> 的管线，恢复 <code>FS</code> （如果有必要也恢复 <code>FIELDWIDTHS</code> 或者 <code>FPAT</code>），<code>RS</code> 与 <code>$0</code> 的值，将 <code>_gr_count</code> 的值恢复为 0 （后面会使用到），并使 <code>_gr_inited</code> 为非零。
</p>
<a name="index-getgrnam_0028_0029-function-_0028C-library_0029"></a>
<p><code>getgrnam()</code> 函数取组名为参数，如果存在相应的组，则返回。否则其所依赖的数组，会以空串创建一个元素：
</p>
<a name="index-getgrnam_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function getgrnam(group)
{
    _gr_init()
    return _gr_byname[group]
}
</pre></div>

<a name="index-getgrgid_0028_0029-function-_0028C-library_0029"></a>
<p><code>getgrgid()</code> 函数类似，以数值的组 ID 为参数，来查找与这个 ID 相关的组的信息：
</p>
<a name="index-getgrgid_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function getgrgid(gid)
{
    _gr_init()
    return _gr_bygid[gid]
}
</pre></div>

<a name="index-getgruser_0028_0029-function-_0028C-library_0029"></a>
<p><code>getgruser()</code> 函数没有相应的 C 例程对应。它取用户名为参数，并返回该组中的成员用户的列表：
</p>
<a name="index-getgruser_0028_0029-function_002c-user_002ddefined"></a>
<div class="example">
<pre class="example">function getgruser(user)
{
    _gr_init()
    return _gr_groupsbyuser[user]
}
</pre></div>

<a name="index-getgrent_0028_0029-function-_0028C-library_0029-1"></a>
<p><code>getgrent()</code> 函数迭代数据库，一次一个。它使用 <code>_gr_count</code> 来跟踪在列表中的位置：
</p>
<a name="index-getgrent_0028_0029-user_002ddefined-function-1"></a>
<div class="example">
<pre class="example">function getgrent()
{
    _gr_init()
    if (++_gr_count in _gr_bycount)
        return _gr_bycount[_gr_count]
    return &quot;&quot;
}
</pre></div>

<a name="index-endgrent_0028_0029-function-_0028C-library_0029"></a>
<p><code>endgrent()</code> 函数将 <code>_gr_count</code> 设置为 0，因此 <code>getgrent()</code> 可以重头开始：
</p>
<a name="index-endgrent_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function endgrent()
{
    _gr_count = 0
}
</pre></div>

<p>与用户数据库列表相似，每一个函数都调用 <code>_gr_init()</code> 来初始化数组。这么做，使用 <code>grcat</code> 时导致一些额外的负担（相对于将 <code>_gr_init()</code> 的执行体移到 <code>BEGIN</code> 规则中）。
</p>
<p>大多数的工作都集中于扫描数据库，并且建立多个关联数组。用户自己所调用的函数则相当简单，这依赖于 <code>awk</code> 的关联数组所做的工作。
</p>
<p>在 <a href="#Id-Program">打印用户信息</a>，中的 <code>id</code> 程序会使用到这些函数。
</p>
<hr>
<a name="Walking-Arrays"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Group-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Library-Functions-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0081_008daa_008e_0086aa_00a4_009ac_00bb_00b4ae_0095_00b0c_00bb_0084"></a>
<h2 class="section">1.7 遍历多维数组</h2>

<p>在 <a href="#Arrays-of-Arrays">多维数组</a>，中描述了 <code>gawk</code> 如何来提供多维数组。特别是，数组的任意元素即可以是标量，也可以是另一个数组。<code>isarray()</code> 函数（查看 see section <a href="#Type-Functions">获取类型信息</a>）可以让你将标量与数组区分。下面的函数，<code>walk_array()</code> 递归地遍历数组，打印数组的索引以及值。你可以通过数组与代表这个数组的字串名来调用这个函数：
</p>
<a name="index-walk_005farray_0028_0029-user_002ddefined-function"></a>
<div class="example">
<pre class="example">function walk_array(arr, name,      i)
{
    for (i in arr) {
        if (isarray(arr[i]))
            walk_array(arr[i], (name &quot;[&quot; i &quot;]&quot;))
        else
            printf(&quot;%s[%s] = %s\n&quot;, name, i, arr[i])
    }
}
</pre></div>

<p>函数通过循环迭代数组的每一个元素来工作。如果数组的元素是一个数组，则函数会递归地调用自己，将子数组与表示当前索引的字串传递过去。否则，函数简单地打印元素的名字，索引以及它的值。这里是演示的主程序：
</p>
<div class="example">
<pre class="example">BEGIN {
    a[1] = 1
    a[2][1] = 21
    a[2][2] = 22
    a[3] = 3
    a[4][1][1] = 411
    a[4][2] = 42

    walk_array(a, &quot;a&quot;)
}
</pre></div>

<p>当执行时，产生下面的输出：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f walk_array.awk</kbd>
-| a[1] = 1
-| a[2][1] = 21
-| a[2][2] = 22
-| a[3] = 3
-| a[4][1][1] = 411
-| a[4][2] = 42
</pre></div>

<p>函数仅是简单地打印名字与每个标量的数组元素。但是，也很容易来进行通用化，只要传递一个要遍历数组的函数名就可以做到。修改过后的函数看起来如下：
</p>
<div class="example">
<pre class="example">function process_array(arr, name, process, do_arrays,   i, new_name)
{
    for (i in arr) {
        new_name = (name &quot;[&quot; i &quot;]&quot;)
        if (isarray(arr[i])) {
            if (do_arrays)
                @process(new_name, arr[i])
            process_array(arr[i], new_name, process, do_arrays)
        } else
            @process(new_name, arr[i])
    }
}
</pre></div>

<p>参数如下：
</p>
<dl compact="compact">
<dt><code>arr</code></dt>
<dd><p>相应的数组。
</p>
</dd>
<dt><code>name</code></dt>
<dd><p>数组名（字串）。
</p>
</dd>
<dt><code>process</code></dt>
<dd><p>要调用的函数名。
</p>
</dd>
<dt><code>do_arrays</code></dt>
<dd><p>如果为 true，函数可以处理为子数组的元素。
</p></dd>
</dl>

<p>如果子数组要被处理，则在进一步迭代时进行处理。
</p>
<p>当展开执行时，函数产生与早前的 <code>walk_array()</code> 函数一样的输出结果：
</p>
<div class="example">
<pre class="example">BEGIN {
    a[1] = 1
    a[2][1] = 21
    a[2][2] = 22
    a[3] = 3
    a[4][1][1] = 411
    a[4][2] = 42

    process_array(a, &quot;a&quot;, &quot;do_print&quot;, 0)
}

function do_print(name, element)
{
    printf &quot;%s = %s\n&quot;, name, element
}
</pre></div>

<hr>
<a name="Library-Functions-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Walking-Arrays" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Library-Exercises" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-5"></a>
<h2 class="section">1.8 总结</h2>

<ul>
<li>
阅读程序是学习编程的最好方法。在这章以及下一章中提供的函数以及程序就用于这样的目的。

</li><li>
当写通用目的的库函数时，要用一此些规则来命令任意的全局变量，这样它他不会与用户程序的变量冲突。

</li><li>
这里呈现的函数可以分为下面的类型：

<dl compact="compact">
<dt>一般问题</dt>
<dd><p>数组到字串的转换，测试断言，舍入舍出，随机数产生，将字符转换为数组，连接字串，方便地取得时间间信息，一次读取所有文件。
</p>
</dd>
<dt>管理数据文件</dt>
<dd><p>提示数据文件的边界，重读当前文件，检查文件的可读性，检查 0 长度文件，以及将赋值当成文件名处理。
</p>
</dd>
<dt>处理命令行选项</dt>
<dd><p><code>awk</code> 版本的标准 C 函数 <code>getopt()</code>。
</p>
</dd>
<dt>读取用户与组数据库</dt>
<dd><p>两个与 C 版本的库函数相同的函数集。
</p>
</dd>
<dt>遍历数</dt>
<dd><p>两个函数用来进行任意深度的多维数组的遍历。
</p></dd>
</dl>

</li></ul>

<hr>
<a name="Library-Exercises"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Library-Functions-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bb_0083a_00b9_00a0-4"></a>
<h2 class="section">1.9 练习</h2>

<ol>
<li>
在 <a href="#Empty-Files">检查长度为零的文件</a>，中我们呈现了 &lsquo;<tt>zerofile.awk</tt>&rsquo; 程序，这个程序利用 <code>gawk</code> 的 <code>ARGIND</code> 变量。这个问题是否不依赖 <code>ARGIND</code> 变量就可以解决？如果可以，如何解决？


</li><li>
作为相关的挑战，修改代码来处理这样的情形，在 <code>ARGV</code> 中的插入值是一个变量赋值。


</li></ol>


<hr>
<a name="Sample-Programs"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Library-Exercises" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Running-Examples" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_009ec_0094_00a8c_009a_0084-awk-c_00a8_008baa_00ba_008f"></a>
<h1 class="chapter">2 实用的 <code>awk</code> 程序</h1>
<a name="index-awk-programs_002c-examples-of"></a>

<p>在 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a> 中呈现了读程序的代码来进行程序语言的学习的观点。这一章继续这样的主题，并通过呈现各种各样的 <code>awk</code> 程序以享读者。
这一章有三个小节。
第一小节描述如可来进行这一章中提供的程序。
</p>
<p>第二小节呈现 <code>awk</code> 版本的几个通用的 POSIX 工具。这些程序希望你也已经熟悉了，并且也了解了这些工具的问题。通过用 <code>awk</code> 重新实现这些工具，你可以将焦点集中于 <code>awk</code> 相关的解决程序问题的方面。
</p>
<p>第三小节则是一些有趣的程序集合。这些程序解决了很多数组处理与管理相关的问题。很多的程序都很短，以用于强调 <code>awk</code> 用几行代码即可处理很多事情的能力。
</p>
<p>这当中的很多程序会使用在 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a>，中出现过的库函数。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Running-Examples">2.1 运行例子程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            How to run these examples.
</td></tr>
<tr><td align="left" valign="top"><a href="#Clones">2.2 为快乐与评测重新发明轮子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Clones of common utilities.
</td></tr>
<tr><td align="left" valign="top"><a href="#Miscellaneous-Programs">2.3 <code>awk</code> 程序的大集合</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Some interesting <code>awk</code> programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Programs-Summary">2.4 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Summary of programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Programs-Exercises">2.5 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Exercises.
</td></tr>
</table>

<hr>
<a name="Running-Examples"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00bf_0090e_00a1_008ca_00be_008baa_00ad_0090c_00a8_008baa_00ba_008f"></a>
<h2 class="section">2.1 运行例子程序</h2>

<p>要运行一个程序，典型的情况下你输入下面的代码：
</p>
<div class="example">
<pre class="example">awk -f <var>program</var> -- <var>options</var> <var>files</var>
</pre></div>

<p>在这里，<var>program</var> 是 <code>awk</code> 程序的名字（如 &lsquo;<tt>cut.awk</tt>&rsquo;），选项 <var>options</var> 则是任意程序的命令行选项，以 &lsquo;<samp>-</samp>&rsquo; 开头，而 <var>files</var> 则是实际的数据文件。
</p>
<p>如果你的系统支持 &lsquo;<samp>#!</samp>&rsquo; 可执行解释器机制（查看 see section <a href="#Executable-Scripts">可执行的 <code>awk</code> 程序</a>），你可以直接这么输入：
</p>
<div class="example">
<pre class="example">cut.awk -c1-8 myfiles &gt; results
</pre></div>

<p>如果 <code>awk</code> 不是 <code>gawk</code>，你可能要这么来使用：
</p>
<div class="example">
<pre class="example">cut.awk -- -c1-8 myfiles &gt; results
</pre></div>

<hr>
<a name="Clones"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Running-Examples" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Cut-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_00baaa_00bf_00aba_00b9_0090a_00b8_008ee_00af_0084ae_00b5_008be_0087_008dae_0096_00b0aa_008f_0091ae_0098_008ee_00bd_00aeaa_00ad_0090"></a>
<h2 class="section">2.2 为快乐与评测重新发明轮子</h2>
<a name="index-POSIX_002c-programs_002c-implementing-in-awk"></a>

<p>本小节中呈现了几个用 <code>awk</code> 语言实现的 POSIX 工具。重新用 <code>awk</code> 来发明这些程序，只是好玩，因此算法可以被清晰地表达，而且代码一般来说都非常精简与简单。因为 <code>awk</code> 确实为你做了很多的事情了。
</p>
<p>也要注意到，这些程序没有必要要去替换系统中已经安装的版本。其中也没有程序被完全地实现了最近的 POSIX 标准。但这不是个问题，它们的目的是用于解释 <code>awk</code> 程序语言为“现实世界”的任务的编程方式。
</p>
<p>程序以字母顺序呈现。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 The <code>cut</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               The <code>egrep</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Id-Program">2.2.3 打印用户信息</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  The <code>id</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Split-Program">2.2.4 将大文件分片</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               The <code>split</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Tee-Program">2.2.5 将输出复制到多个文件中</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 The <code>tee</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Uniq-Program">2.2.6 打印去重文本行</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                The <code>uniq</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Wc-Program">2.2.7 统计</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  The <code>wc</code> utility.
</td></tr>
</table>

<hr>
<a name="Cut-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Egrep-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0089_00aaaa_0088_0087aa_009f_009fa_00b8_008eaa_0088_0097"></a>
<h3 class="subsection">2.2.1 剪切域与列</h3>

<a name="index-cut-utility"></a>
<a name="index-cut-utility-1"></a>
<a name="index-fields_002c-cutting"></a>
<a name="index-columns_002c-cutting"></a>
<p><code>cut</code> 这个工具从它的标准输入中选择，或者说“切分”，字符或者域并输出这些字符到它的标准输出中。域默认是通过 TABs 来进行分隔的，但是你可以提供一个命令行参数来改变<em>域界定符</em>（即域分隔符）。<code>cut</code> 的域定义没有 <code>awk</code> 的域那么一般化。
</p>
<p><code>cut</code> 通常的使用方式可能是从命令 <code>who</code> 的输出结果中仅仅抽出已登录用户的登录名。
例如，下面的管线会产生有序的，唯一的登录到系统中的用户列表：
</p>
<div class="example">
<pre class="example">who | cut -c1-8 | sort | uniq
</pre></div>

<p><code>cut</code> 的选项有：
</p>
<dl compact="compact">
<dt><code>-c <var>list</var></code></dt>
<dd><p>使用 <var>list</var> 作为要切分的字符列表。在列表中的项可以用逗号分隔，某个范围的字符可以用横杠来分隔。列表 &lsquo;<samp>1-8,15,22-35</samp>&rsquo; 指定了 1 到 8 的字符，15 以及 22 到 35 之间的字符。
</p>
</dd>
<dt><code>-f <var>list</var></code></dt>
<dd><p>使用 <var>list</var> 作为要切分的域列表。
</p>
</dd>
<dt><code>-d <var>delim</var></code></dt>
<dd><p>使用 <var>delim</var> 作用域分隔符，而不是使用 TAB 字符。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>会抑制打印那些不含有域界定符的行。
</p></dd>
</dl>

<p><code>awk</code> 的 <code>cut</code> 实现使用 <code>getopt()</code> 库函数（查看 see section <a href="#Getopt-Function">处理命令行选项</a>）以及 <code>join()</code> 库函数（查看 see section <a href="#Join-Function">将数组合并成字串</a>）。
</p>
<p>程序以描述选项的注释开始，需要的库函数以及一个 <code>usage()</code> 函数来打印使用信息后退出。<code>usage()</code> 在遇到一个无效的参数时会被调用：
</p>
<a name="index-cut_002eawk-program"></a>
<div class="example">
<pre class="example"># cut.awk --- implement cut in awk

# Options:
#    -f list     Cut fields
#    -d c        Field delimiter character
#    -c list     Cut characters
#
#    -s          Suppress lines without the delimiter
#
# Requires getopt() and join() library functions

</pre><pre class="example">function usage()
{
    print(&quot;usage: cut [-f list] [-d c] [-s] [files...]&quot;) &gt; &quot;/dev/stderr&quot;
    print(&quot;usage: cut [-c list] [files...]&quot;) &gt; &quot;/dev/stderr&quot;
    exit 1
}
</pre></div>

<a name="index-BEGIN-pattern_002c-running-awk-programs-and"></a>
<a name="index-FS-variable_002c-running-awk-programs-and"></a>
<p>接下来就轮到 <code>BEGIN</code> 规则，在里面对命令行进行选项分析。它将 <code>FS</code> 设置为单个的 TAB 字符，因此那是 <code>cut</code> 的默认域分隔符。使用 <code>getopt()</code> 来进行循环命令行中的选项。<code>by_fields</code> 与 <code>by_chars</code> 中只有一个变量被设置为 true，以指示处理是通过域来完成还是通过字符来完成。当以字符来切分时，输出域分隔符被设置为空串：
</p>
<div class="example">
<pre class="example">BEGIN {
    FS = &quot;\t&quot;    # default
    OFS = FS
    while ((c = getopt(ARGC, ARGV, &quot;sf:c:d:&quot;)) != -1) {
        if (c == &quot;f&quot;) {
            by_fields = 1
            fieldlist = Optarg
        } else if (c == &quot;c&quot;) {
            by_chars = 1
            fieldlist = Optarg
            OFS = &quot;&quot;
        } else if (c == &quot;d&quot;) {
            if (length(Optarg) &gt; 1) {
                printf(&quot;cut: using first character of %s&quot; \
                       &quot; for delimiter\n&quot;, Optarg) &gt; &quot;/dev/stderr&quot;
                Optarg = substr(Optarg, 1, 1)
            }
            fs = FS = Optarg
            OFS = FS
            if (FS == &quot; &quot;)    # defeat awk semantics
                FS = &quot;[ ]&quot;
        } else if (c == &quot;s&quot;)
            suppress = 1
        else
            usage()
    }

    # Clear out options
    for (i = 1; i &lt; Optind; i++)
        ARGV[i] = &quot;&quot;
</pre></div>

<a name="index-field-separators_002c-spaces-as"></a>
<p>代码必须小心处理域分界符为空格的情况。使用单独的空格（<code>&quot;&nbsp;&quot;</code>）来作为 <code>FS</code> 的值是不正确的——<code>awk</code> 会用连续的空格、TABs 与/或换行符来进行域分割，但我们是想用单独的空格来进行切分。
为了达到这一效果，我们把原始的空格字符串存在变量 <code>fs</code> 里以备之后使用；在把 <code>FS</code> 设置为 <code>&quot;[ ]&quot;</code> 之后，我们不能直接用它查看是否域分界符在这个字符串中。
</p>
<p>同时也要记住当 <code>getopt()</code> 完成（在 <a href="#Getopt-Function">处理命令行选项</a>，中进行了描述），我们要清除在 <code>ARGV</code> 中 1 到 <code>Optind</code> 中的所有元素，这样 <code>awk</code> 不会将这些命令行参数当成文件名进行处理。
</p>
<p>在处理了命令行选项后，程序要验证选项是否是有用的。只有 &lsquo;<samp>-c</samp>&rsquo; 与 &lsquo;<samp>-f</samp>&rsquo; 之一被使用，而两者都需要一个域列表。然后程序调用 <code>set_fieldlist()</code> 或者 <code>set_charlist()</code> 来将域或者字符表进行拆分：
</p>
<div class="example">
<pre class="example">    if (by_fields &amp;&amp; by_chars)
        usage()

    if (by_fields == 0 &amp;&amp; by_chars == 0)
        by_fields = 1    # default

    if (fieldlist == &quot;&quot;) {
        print &quot;cut: needs list for -c or -f&quot; &gt; &quot;/dev/stderr&quot;
        exit 1
    }

    if (by_fields)
        set_fieldlist()
    else
        set_charlist()
}
</pre></div>

<p><code>set_fieldlist()</code> 将列表以逗号进行分割，并存储到数组中。然后对数组中的每个元素，查看其是否是一个范围，如果是，则将其分开。函数检查范围以确保第一个数值是小于第二个数值的。在列表中每一个数值都会加到 <code>flist</code> 数组中，这个数组只是简单地记录要打印的域。使用的是常规的域分割策略。程序使 <code>awk</code> 处理域分割的工作：
</p>
<div class="example">
<pre class="example">function set_fieldlist(        n, m, i, j, k, f, g)
{
    n = split(fieldlist, f, &quot;,&quot;)
    j = 1    # index in flist
    for (i = 1; i &lt;= n; i++) {
        if (index(f[i], &quot;-&quot;) != 0) { # a range
            m = split(f[i], g, &quot;-&quot;)
</pre><pre class="example">            if (m != 2 || g[1] &gt;= g[2]) {
                printf(&quot;cut: bad field list: %s\n&quot;,
                                  f[i]) &gt; &quot;/dev/stderr&quot;
                exit 1
            }
</pre><pre class="example">            for (k = g[1]; k &lt;= g[2]; k++)
                flist[j++] = k
        } else
            flist[j++] = f[i]
    }
    nfields = j - 1
}
</pre></div>

<p><code>set_charlist()</code> 函数要比 <code>set_fieldlist()</code> 要复杂得多。这里的想法是利用 <code>gawk</code> 的 <code>FIELDWIDTHS</code> 变量（查看 see section <a href="#Constant-Size">读取固定宽度数据</a>），这个变量描述了输入的常量宽度。当使用字符列表时，这正是我们所需要的。
</p>
<p>设置 <code>FIELDWIDTHS</code> 的值要比简单地列表那些要打印的域要简单得多。我们要跟踪要打印的域以及要跳过的中间字符。例如，假设你想要的字符为 1 到 8，15，以及 22 到 35。可需要使用 &lsquo;<samp>-c 1-8,15,22-35</samp>&rsquo;。
<code>FIELDWIDTHS</code> 的值应该是 <code>&quot;8&nbsp;6&nbsp;1&nbsp;6&nbsp;14&quot;</code>。这会产生 5 个域，要打印的域为 <code>$1</code>，<code>$3</code> 与 <code>$5</code>。中间的域则是填充符，是所需要的域之间的字符。<code>flist</code> 列出了要打印的域，<code>t</code> 则是用来跟踪完整的域列表，包括填充域：
</p>
<div class="example">
<pre class="example">function set_charlist(    field, i, j, f, g, n, m, t,
                          filler, last, len)
{
    field = 1   # count total fields
    n = split(fieldlist, f, &quot;,&quot;)
    j = 1       # index in flist
    for (i = 1; i &lt;= n; i++) {
        if (index(f[i], &quot;-&quot;) != 0) { # range
            m = split(f[i], g, &quot;-&quot;)
            if (m != 2 || g[1] &gt;= g[2]) {
                printf(&quot;cut: bad character list: %s\n&quot;,
                               f[i]) &gt; &quot;/dev/stderr&quot;
                exit 1
            }
            len = g[2] - g[1] + 1
            if (g[1] &gt; 1)  # compute length of filler
                filler = g[1] - last - 1
            else
                filler = 0
</pre><pre class="example">            if (filler)
                t[field++] = filler
</pre><pre class="example">            t[field++] = len  # length of field
            last = g[2]
            flist[j++] = field - 1
        } else {
            if (f[i] &gt; 1)
                filler = f[i] - last - 1
            else
                filler = 0
            if (filler)
                t[field++] = filler
            t[field++] = 1
            last = f[i]
            flist[j++] = field - 1
        }
    }
    FIELDWIDTHS = join(t, 1, field - 1)
    nfields = j - 1
}
</pre></div>

<p>下一个则是处理数据的规则。如果指定了 &lsquo;<samp>-s</samp>&rsquo; 选项，则 <code>suppress</code> 为 true。第一个 <code>if</code> 语句确保输入的记录中确实包含域分隔符。如果 <code>cut</code> 正在处理域，而 <code>suppress</code> 为 true，并且域分隔字符不在记录中，则这条记录会被跳过。
</p>
<p>如果记录是有效的，则 <code>gawk</code> 会将记录分割成域，要么使用的是 <code>FS</code> 中的字符，要么是使用固定宽度的方式，以及 <code>FIELDWIDTHS</code> 方式。循环迭代那些要被打印的域列表。如果其包含相应数据，则打印相应的域。如果下一个域也包含数据，则在两个域之间输出分隔符：
</p>
<div class="example">
<pre class="example">{
    if (by_fields &amp;&amp; suppress &amp;&amp; index($0, fs) == 0)
        next

    for (i = 1; i &lt;= nfields; i++) {
        if ($flist[i] != &quot;&quot;) {
            printf &quot;%s&quot;, $flist[i]
            if (i &lt; nfields &amp;&amp; $flist[i+1] != &quot;&quot;)
                printf &quot;%s&quot;, OFS
        }
    }
    print &quot;&quot;
}
</pre></div>

<p>这个版本的 <code>cut</code> 依赖于 <code>gawk</code> 的 <code>FIELDWIDTHS</code> 变量来做基于字符的切分。也可以在其他的 <code>awk</code> 实现中使用 <code>substr()</code>（查看 <a href="#String-Functions">字串操作函数</a>），但是那实现起来也很痛苦。<code>FIELDWIDTHS</code> 变量提供了一种很优雅的解决方法来处理被字符分割的输入行。
</p>

<hr>
<a name="Egrep-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Cut-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Id-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_00a8ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008faa_009c_00a8ae_0096_0087a_00bb_00b6a_00b8_00adae_0090_009cc_00b4_00a2"></a>
<h3 class="subsection">2.2.2 用正则表达式在文件中搜索</h3>

<a name="index-regular-expressions_002c-searching-for"></a>
<a name="index-searching_002c-files-for-regular-expressions"></a>
<a name="index-files_002c-searching-for-regular-expressions"></a>
<a name="index-egrep-utility-1"></a>
<p><code>egrep</code> 工具要来按模式搜索文件内容。它使用的正则表达式几乎与 <code>awk</code> 所使用的一样（查看 see section <a href="#Regexp">正则表达式</a>）。你这么来调用：
</p>
<div class="display">
<pre class="display"><code>egrep</code> [<var>options</var>] <code>'<var>pattern</var>'</code> <var>files</var> &hellip;
</pre></div>

<p><var>pattern</var> 是一个正则表达式。在典型的使用情况下，正则表达式会被引起来，以避免 Shell 将一些特殊字符扩展为文件名的通配符。一般情况下，<code>egrep</code> 打印匹配的行。如果在命令行中提供了多个文件名，则每个输出行前都带上文件名，后面跟着冒号：
</p>
<p><code>egrep</code> 的选项如下：
</p>
<dl compact="compact">
<dt><code>-c</code></dt>
<dd><p>打印匹配 pattern 的行的总数，而不是匹配行本身。
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>静默处理，不产生输出，并且用退出值来表示是否有匹配的行。
</p>
</dd>
<dt><code>-v</code></dt>
<dd><p>对匹配测试取反。<code>egrep</code> 打印那些不匹配模式的行，并且如果匹配<em>没有</em>成功，则以成功退出。
</p>
</dd>
<dt><code>-i</code></dt>
<dd><p>忽略 pattern 与输入数据的大小写。
</p>
</dd>
<dt><code>-l</code></dt>
<dd><p>只打印（列出）匹配的文件名，而不是匹配的行。
</p>
</dd>
<dt><code>-e <var>pattern</var></code></dt>
<dd><p>使用 <var>pattern</var> 为要匹配的正则表达式。&lsquo;<samp>-e</samp>&rsquo; 选项的目的是允许模式可以以 &lsquo;<samp>-</samp>&rsquo; 开始。
</p></dd>
</dl>

<p>这个版本使用 <code>getopt()</code> 库函数（查看 see section <a href="#Getopt-Function">处理命令行选项</a>）以及文件转换库程序（查看 see section <a href="#Filetrans-Function">注意数据文件的边界</a>）。
</p>
<p>程序以描述性的注释开始，然后是 <code>BEGIN</code> 规则调用 <code>getopt()</code> 函数来处理命令行参数。 &lsquo;<samp>-i</samp>&rsquo;（忽略大小写）选项对于 <code>gawk</code> 来说尤其简单，我们只使用预定义的 <code>IGNORECASE</code> 变量就可以实现（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）：
</p>
<a name="index-egrep_002eawk-program"></a>
<div class="example">
<pre class="example"># egrep.awk --- simulate egrep in awk
#
# Options:
#    -c    count of lines
#    -s    silent - use exit value
#    -v    invert test, success if no match
#    -i    ignore case
#    -l    print filenames only
#    -e    argument is pattern
#
# Requires getopt and file transition library functions

BEGIN {
    while ((c = getopt(ARGC, ARGV, &quot;ce:svil&quot;)) != -1) {
        if (c == &quot;c&quot;)
            count_only++
        else if (c == &quot;s&quot;)
            no_print++
        else if (c == &quot;v&quot;)
            invert++
        else if (c == &quot;i&quot;)
            IGNORECASE = 1
        else if (c == &quot;l&quot;)
            filenames_only++
        else if (c == &quot;e&quot;)
            pattern = Optarg
        else
            usage()
    }
</pre></div>

<p>接下来则是处理 <code>egrep</code> 相关的行为。如果没有使用 &lsquo;<samp>-e</samp>&rsquo; 选项提供 pattern 参数，则会使用命令行中的第一个非选项参数。<code>awk</code> 中到 <code>ARGV[Optind]</code> 中的参数会被清空，所以 <code>awk</code> 不会尝试将它们当成文件进行处理。如果没有指定文件，则使用标准的输入，而如果指定的多个文件，我们要确保要看到这种情况，因此文件名要出现在输出的行之前：
</p>
<div class="example">
<pre class="example">    if (pattern == &quot;&quot;)
        pattern = ARGV[Optind++]

    for (i = 1; i &lt; Optind; i++)
        ARGV[i] = &quot;&quot;
    if (Optind &gt;= ARGC) {
        ARGV[1] = &quot;-&quot;
        ARGC = 2
    } else if (ARGC - Optind &gt; 1)
        do_filenames++

#    if (IGNORECASE)
#        pattern = tolower(pattern)
}
</pre></div>

<p>最后两行被注释掉了，因为在 <code>gawk</code> 中不需要。如果你使用其他版本的 <code>awk</code>，则你可能需要将他们反注释回来。
</p>
<p>如果你不是使用的 <code>gawk</code>，下面是要被反注释掉的行。这个规则在指定了 &lsquo;<samp>-i</samp>&rsquo; 参数时，将所有的输入行中的字符转换为小写。
<a name="DOCF77" href="#FOOT77">(77)</a>
它们被注释掉，是因为这些代码在 <code>gawk</code> 中使用。
</p>
<div class="example">
<pre class="example">#{
#    if (IGNORECASE)
#        $0 = tolower($0)
#}
</pre></div>

<p>当每处理一个新文件的时候，<code>beginfile()</code> 函数在 &lsquo;<tt>ftrans.awk</tt>&rsquo; 中被调用。在这种情况下，是非常简单的，所要要做的事情就是初始化变量 <code>fcount</code> 为 0。<code>fcount</code> 用来跟踪当前的文件中有多少行匹配 pattern。名字为 <code>junk</code> 的参数显示 <code>beginfile()</code> 会使用一个参数来调用，但是我们对其值不感兴趣：
</p>
<div class="example">
<pre class="example">function beginfile(junk)
{
    fcount = 0
}
</pre></div>

<p>当每一个文件被处理完后，会调用 <code>endfile()</code>。它只会在用户想知道有多少行匹配时才会影响输出。<code>no_print</code> 需要退出状态时才为会 true。<code>count_only</code> 如果要统计时才会为 true。如果打印与统计被启用，<code>egrep</code> 因此只打印行统计数。输出的格式必须根据要处理的文件进行处理。最后，<code>fcount</code> 被加进 <code>total</code>，因此我们可以知道总共有多少行匹配了 pattern：
</p>
<div class="example">
<pre class="example">function endfile(file)
{
    if (! no_print &amp;&amp; count_only) {
        if (do_filenames)
            print file &quot;:&quot; fcount
        else
            print fcount
    }

    total += fcount
}
</pre></div>

<p><code>BEGINFILE</code> 与 <code>ENDFILE</code> 这两个特殊模式（查看 see section <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>）也可以使用，但是程序必须是用 <code>gawk</code> 来运行的。另外，这个例子写于 <code>gawk</code> 加入 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特性之前。
</p>
<p>下面的规则处理了大部分的匹配行的工作。变量 <code>matches</code> 在行匹配 pattern 时为真。如果用户想要不匹配的行，则 <code>matches</code> 的意义就用 &lsquo;<samp>!</samp>&rsquo; 被反过来使用。<code>fcount</code> 会用 <code>matches</code> 的值一起递增，根据匹配成功与否，其要么是 0，要么是 1。如果行不匹配，则 <code>next</code> 语句会调用，用于处理下一条记录。
</p>
<p>下面执行了很多的测试，但是它们只会在我们不进行行统计时执行。首先，如果用户想要的是退出状态（<code>no_print</code> 为 true），则只需要知道文件中的某<em>一</em>行是否匹配就可以了，然后我们可以用 <code>nextfile</code> 来跳到下一个文件。相似地，如果我们仅需要打印文件名，我们则打印文件名后用 <code>nextfile</code> 语句来跳到下一个文件。最后，我们会打印每一行，如果需要的话，在其前面加入文件名与冒号：
</p>
<a name="index-_0021-_0028exclamation-point_0029_002c-_0021-operator-2"></a>
<a name="index-exclamation-point-_0028_0021_0029_002c-_0021-operator-2"></a>
<div class="example">
<pre class="example">{
    matches = ($0 ~ pattern)
    if (invert)
        matches = ! matches

    fcount += matches    # 1 or 0

    if (! matches)
        next

    if (! count_only) {
        if (no_print)
            nextfile

        if (filenames_only) {
            print FILENAME
            nextfile
        }

        if (do_filenames)
            print FILENAME &quot;:&quot; $0
        else
            print
    }
}
</pre></div>

<p><code>END</code> 规则要处理好正确的返回状态。如果没有匹配，则退出状态为 1，否则为 0 ：
</p>
<div class="example">
<pre class="example">END {
    exit (total == 0)
}
</pre></div>

<p><code>usage()</code> 函数用来在输入无效选项的时候打印使用信息，然后退出：
</p>
<div class="example">
<pre class="example">function usage()
{
    print(&quot;Usage: egrep [-csvil] [-e pat] [files ...]&quot;) &gt; &quot;/dev/stderr&quot;
    print(&quot;\n\tegrep [-csvil] pat [files ...]&quot;) &gt; &quot;/dev/stderr&quot;
    exit 1
}
</pre></div>


<hr>
<a name="Id-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Egrep-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Split-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0089_0093aa_008d_00b0c_0094_00a8ae_0088_00b7a_00bf_00a1ae_0081_00af"></a>
<h3 class="subsection">2.2.3 打印用户信息</h3>

<a name="index-printing_002c-user-information"></a>
<a name="index-users_002c-information-about_002c-printing"></a>
<a name="index-id-utility"></a>
<p><code>id</code> 工具列出用户的真实与有效的用户 ID 值，真实与有效的组 ID 值，如果有的话，包含用户的组集。<code>id</code> 只有在它同于真实的ID 的情况下，才打印有效的用户 ID 与组 ID。如果可能，<code>id</code> 也提供了相应的前户与组名。输出可能如下：
</p>
<div class="example">
<pre class="example">$ <kbd>id</kbd>
-| uid=1000(arnold) gid=1000(arnold) groups=1000(arnold),4(adm),7(lp),27(sudo)
</pre></div>

<a name="index-PROCINFO-array_002c-and-user-and-group-ID-numbers"></a>
<p>这里的信息一部份是由 <code>gawk</code> 的 <code>PROCINFO</code> 数组来提供的（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）。但是，<code>id</code> 工具会提供比单纯的数组更好的输出。
</p>
<p>这里是 <code>id</code> 的一个简单的版本，用 <code>awk</code> 写成。它使用来自于 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a>，的用户数据库函数（查看 see section <a href="#Passwd-Functions">读取用户数据库</a>） 以及组数据库函数（查看 see section <a href="#Group-Functions">读取组数据库</a>）。
</p>
<p>程序相当直接。所有的工作都在 <code>BEGIN</code> 规则中完成。用户以及组 ID 值从 <code>PROCINFO</code> 中取得。代码是可重复的。在用户数据库中的用于真实用户ID 的项被用 &lsquo;<samp>:</samp>&rsquo; 分割成不同的部分。第一项是名字。相应的代码也可以用于有效的用户 ID 与组相关的值：
</p>
<a name="index-id_002eawk-program"></a>
<div class="example">
<pre class="example"># id.awk --- implement id in awk
#
# Requires user and group library functions
# output is:
# uid=12(foo) euid=34(bar) gid=3(baz) \
#             egid=5(blat) groups=9(nine),2(two),1(one)

</pre><pre class="example">BEGIN {
    uid = PROCINFO[&quot;uid&quot;]
    euid = PROCINFO[&quot;euid&quot;]
    gid = PROCINFO[&quot;gid&quot;]
    egid = PROCINFO[&quot;egid&quot;]
</pre><pre class="example">
    printf(&quot;uid=%d&quot;, uid)
    pw = getpwuid(uid)
    pr_first_field(pw)

    if (euid != uid) {
        printf(&quot; euid=%d&quot;, euid)
        pw = getpwuid(euid)
        pr_first_field(pw)
    }

    printf(&quot; gid=%d&quot;, gid)
    pw = getgrgid(gid)
    pr_first_field(pw)

    if (egid != gid) {
        printf(&quot; egid=%d&quot;, egid)
        pw = getgrgid(egid)
        pr_first_field(pw)
    }

    for (i = 1; (&quot;group&quot; i) in PROCINFO; i++) {
        if (i == 1)
            printf(&quot; groups=&quot;)
        group = PROCINFO[&quot;group&quot; i]
        printf(&quot;%d&quot;, group)
        pw = getgrgid(group)
        pr_first_field(pw)
        if ((&quot;group&quot; (i+1)) in PROCINFO)
            printf(&quot;,&quot;)
    }

    print &quot;&quot;
}

function pr_first_field(str,  a)
{
    if (str != &quot;&quot;) {
        split(str, a, &quot;:&quot;)
        printf(&quot;(%s)&quot;, a[1])
    }
}
</pre></div>

<p>在 <code>for</code> 循环中的测试值得注意一下。任意在 <code>PROCINFO</code> 数组中的补充的值都有索引从 <code>&quot;group1&quot;</code> 到某个值 <var>N</var> 的 <code>&quot;group<var>N</var>&quot;</code>（即补充组的总数）。但是，我们事先不知道有多少个这样的组。
</p>
<p>循环从 1 开始，将值是 <code>&quot;group&quot;</code> 进行连接，然后使用 <code>in</code> 操作符来查看相应的值是否在数组中（查看 <a href="#Reference-to-Elements">指向数组元素</a>）。最后，<code>i</code> 会递增越过数组中的最后一个组，然后循环退出。
</p>
<p>循环在<em>没有</em>补充组的情况下也是正确的，这样第一次测试时条件就为 false，这样循环就根本没有执行过。
</p>
<p><code>pr_first_field()</code> 函数简单地隔离一些要重复使用的代码，使得整个程序更短更清晰。特别是将检测空串的代码移进个函数中。
</p>

<hr>
<a name="Split-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Id-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Tee-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b0_0086aa_00a4_00a7ae_0096_0087a_00bb_00b6aa_0088_0086c_0089_0087"></a>
<h3 class="subsection">2.2.4 将大文件分片</h3>


<a name="index-files_002c-splitting"></a>
<a name="index-split-utility"></a>
<p><code>split</code> 工具将大的文本文件分割成更小了几个。用法如下： 
<a name="DOCF78" href="#FOOT78">(78)</a>
</p>
<div class="display">
<pre class="display"><code>split</code> [<code>-<var>count</var></code>] [<var>file</var>] [<var>prefix</var>]
</pre></div>

<p>默认情况下，输出文件命名为 &lsquo;<tt>xaa</tt>&rsquo;，&lsquo;<tt>xab</tt>&rsquo; 等等。每个文件有一千行，最后一个文件例外 。为了每个文件中的行数，在命令行中输入一个数值，前面带一个减号（如 &lsquo;<samp>-500</samp>&rsquo; 使每个文件中有 500 行，而不是 1000 行）。为了改变输出文件的名字为诸如 &lsquo;<tt>myfileaa</tt>&rsquo;，&lsquo;<tt>myfileab</tt>&rsquo; 等等，则提供一个额外的参数来指定文件名的前缀。
</p>
<p>下面是 <code>awk</code> 版本的 split。它使用在 <a href="#Ordinal-Functions">在字符与数值之间变换</a>，中的 <code>ord()</code> 与 <code>chr()</code> 函数。
</p>
<p>程序首先设置它的默认行为，然后测试以确保不会有太多的参数。然后依次查看每个参数。第一个参数可以一个负号，后面跟一个数值。如果果，这看起来就像是一个负数，所以使其为正数，即是行的数值。数据文件名被忽略过去，最后一个参数用于输出文件名的前缀：
</p>
<a name="index-split_002eawk-program"></a>
<div class="example">
<pre class="example"># split.awk --- do split in awk
#
# Requires ord() and chr() library functions
# usage: split [-count] [file] [outname]

BEGIN {
    outfile = &quot;x&quot;    # default
    count = 1000
    if (ARGC &gt; 4)
        usage()

    i = 1
    if (i in ARGV &amp;&amp; ARGV[i] ~ /^-[[:digit:]]+$/) {
        count = -ARGV[i]
        ARGV[i] = &quot;&quot;
        i++
    }
    # test argv in case reading from stdin instead of file
    if (i in ARGV)
        i++    # skip datafile name
    if (i in ARGV) {
        outfile = ARGV[i]
        ARGV[i] = &quot;&quot;
    }

    s1 = s2 = &quot;a&quot;
    out = (outfile s1 s2)
}
</pre></div>

<p>下一个规则做剩下的大部分的事情，<code>tcount</code>（temporary count）跟踪当前已经有多少行输出到了输出文件中。如果其大于 <code>count</code>，则要关闭当前的文件然后开启一个新的文件。<code>s1</code> 与 <code>s2</code> 跟踪当前的文件名前缀。如果他们两个都是 &lsquo;<samp>z</samp>&rsquo;，则表示文件太大了。否则，<code>s1</code> 移动到字母表中的下一个字母，<code>s2</code> 则从 &lsquo;<samp>a</samp>&rsquo; 开始：
</p>
<div class="example">
<pre class="example">{
    if (++tcount &gt; count) {
        close(out)
        if (s2 == &quot;z&quot;) {
            if (s1 == &quot;z&quot;) {
                printf(&quot;split: %s is too large to split\n&quot;,
                       FILENAME) &gt; &quot;/dev/stderr&quot;
                exit 1
            }
            s1 = chr(ord(s1) + 1)
            s2 = &quot;a&quot;
        }
</pre><pre class="example">        else
            s2 = chr(ord(s2) + 1)
</pre><pre class="example">        out = (outfile s1 s2)
        tcount = 1
    }
    print &gt; out
}
</pre></div>

<p><code>usage()</code> 函数简单地打印错误并输出：
</p>
<div class="example">
<pre class="example">function usage()
{
    print(&quot;usage: split [-num] [file] [outname]&quot;) &gt; &quot;/dev/stderr&quot;
    exit 1
}
</pre></div>

<p>这个程序程序有一点滑头，他依赖于 <code>awk</code> 来自动关闭最后一个文件，而不是在 <code>END</code> 规则中来处理。同时，它也假设字母在字符集中是连续的，这在 EBCDIC 的系统中是不成立的。
</p>


<hr>
<a name="Tee-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Split-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Uniq-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b0_0086e_00be_0093aa_0087_00baaa_00a4_008daa_0088_00b6aa_0088_00b0aa_00a4_009aa_00b8_00aaae_0096_0087a_00bb_00b6a_00b8_00ad"></a>
<h3 class="subsection">2.2.5 将输出复制到多个文件中</h3>

<a name="index-files_002c-multiple_002c-duplicating-output-into"></a>
<a name="index-output_002c-duplicating-into-files"></a>
<a name="index-tee-utility"></a>
<p><code>tee</code> 程序是一个“管道适配器”。<code>tee</code> 将他的标准输出到它的标准输出中，并将其复制到命令行中拉丁指定的文件名中。它的用法如下：
</p>
<div class="display">
<pre class="display"><code>tee</code> [&lsquo;<samp>-a</samp>&rsquo;] <var>file</var> &hellip;
</pre></div>

<p>&lsquo;<samp>-a</samp>&rsquo; 选项告诉 <code>tee</code> 将内容附加到命令的文件中，而不是将这些文件行清除再重新开始。
</p>
<p><code>BEGIN</code> 规则首先生成所有命令行参数的复本到名为 <code>copy</code> 的数组中。<code>ARGV[0]</code> 是不需要的，所以它不会被复制。<code>tee</code> 不可以直接使用 <code>ARGV</code> 因为 <code>awk</code> 会尝试将 <code>ARGV</code> 中的文件名当成输入的数据。
</p>
<a name="index-flag-variables-1"></a>
<p>如果第一个参数是 &lsquo;<samp>-a</samp>&rsquo;，然后标志变量 <code>append</code> 被设置为 true，<code>ARGV[1]</code> 与 <code>copy[1]</code> 两个元素都被删除。如果 <code>ARGC</code> 小于 2，则表示没有提供文件名，则 <code>tee</code> 会打印一个使用信息然后退出。最后，<code>awk</code> 被强制从标准输入中读取数据，只要将 <code>ARGV[1]</code> 的值设置为 <code>&quot;-&quot;</code>，同时 <code>ARGC</code> 设置为 2 ：
</p>
<a name="index-tee_002eawk-program"></a>
<div class="example">
<pre class="example"># tee.awk --- tee in awk
#
# Copy standard input to all named output files.
# Append content if -a option is supplied.
#
BEGIN {
    for (i = 1; i &lt; ARGC; i++)
        copy[i] = ARGV[i]

    if (ARGV[1] == &quot;-a&quot;) {
        append = 1
        delete ARGV[1]
        delete copy[1]
        ARGC--
    }
    if (ARGC &lt; 2) {
        print &quot;usage: tee [-a] file ...&quot; &gt; &quot;/dev/stderr&quot;
        exit 1
    }
    ARGV[1] = &quot;-&quot;
    ARGC = 2
}
</pre></div>

<p>下面简单的规则执行所有的工作。由于没有模式，所以它会对每一个输入行都执行。规则的执行体只是简单地打印行到每个命令行上的文件，然后再打印到标准输出中：
</p>
<div class="example">
<pre class="example">{
    # moving the if outside the loop makes it run faster
    if (append)
        for (i in copy)
            print &gt;&gt; copy[i]
    else
        for (i in copy)
            print &gt; copy[i]
    print
}
</pre></div>

<p>也可以这么来写循环：
</p>
<div class="example">
<pre class="example">for (i in copy)
    if (append)
        print &gt;&gt; copy[i]
    else
        print &gt; copy[i]
</pre></div>

<p>这样更精简，但是却没有这么高效。&lsquo;<samp>if</samp>&rsquo; 会对每个记录以及每个输出文件都进行测试。通过复制循环体，&lsquo;<samp>if</samp>&rsquo; 对每个输入记录只执行一次测试。如果有 <var>N</var> 个输入记录，并且有 <var>M</var> 个输出文件，第一种方法只执行 <var>N</var> 个 &lsquo;<samp>if</samp>&rsquo; 语句，而第二种方法会执行 <var>N</var><code>*</code><var>M</var> 个 &lsquo;<samp>if</samp>&rsquo; 语句。
</p>
<p>最后，<code>END</code> 规则通过关闭所有的输出文件来进行清理：
</p>
<div class="example">
<pre class="example">END {
    for (i in copy)
        close(copy[i])
}
</pre></div>

<hr>
<a name="Uniq-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Tee-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Wc-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0089_0093aa_008d_00b0aa_008e_00bbe_0087_008dae_0096_0087ae_009c_00ace_00a1_008c"></a>
<h3 class="subsection">2.2.6 打印去重文本行</h3>


<a name="index-printing_002c-unduplicated-lines-of-text"></a>
<a name="index-text_002c-printing_002c-unduplicated-lines-of"></a>
<a name="index-uniq-utility"></a>
<p><code>uniq</code> 工具从它的标准输入中读取经过排序的行，并且默认地移除重复的行。也就是说，它只打印唯一的行——如此名字所表示的意思。<code>uniq</code> 有很多的选项。其使用方法如下：
</p>
<div class="display">
<pre class="display"><code>uniq</code> [&lsquo;<samp>-udc</samp>&rsquo; [<code>-<var>n</var></code>]] [<code>+<var>n</var></code>] [<var>inputfile</var> [<var>outputfile</var>]]
</pre></div>

<p><code>uniq</code> 的选项如下：
</p>
<dl compact="compact">
<dt><code>-d</code></dt>
<dd><p>只打印重复的（有复本）的行。
</p>
</dd>
<dt><code>-u</code></dt>
<dd><p>只打印不重复的（唯一的）行。
</p>
</dd>
<dt><code>-c</code></dt>
<dd><p>统计行。这个选项会覆盖 &lsquo;<samp>-d</samp>&rsquo; 与 &lsquo;<samp>-u</samp>&rsquo;。重复的与非重复的行都会被统计。
</p>
</dd>
<dt><code>-<var>n</var></code></dt>
<dd><p>在比较行前跳过 <var>n</var> 个域。域的定义与 <code>awk</code> 的默认的类似：被一连续的空格与/或者 TABs 分隔的非空白字符。
</p>
</dd>
<dt><code>+<var>n</var></code></dt>
<dd><p>在比较行前跳过 <var>n</var> 个字符。通过 &lsquo;<samp>-<var>n</var></samp>&rsquo; 指定的任何域会首先被跳过。
</p>
</dd>
<dt><code><var>inputfile</var></code></dt>
<dd><p>数据从在命令行中指定的文件中读取，而不是从标准输入读取。
</p>
</dd>
<dt><code><var>outputfile</var></code></dt>
<dd><p>将产生的输出发送到 <var>outputfile</var> 命名的文件中，而不是到标准输出中。
</p></dd>
</dl>

<p>一般情况下，<code>uniq</code> 的行为就像 &lsquo;<samp>-d</samp>&rsquo; 与 &lsquo;<samp>-u</samp>&rsquo; 两个选项都指定的一样。
</p>
<p><code>uniq</code> 使用 <code>getopt()</code> 库函数（查看 see section <a href="#Getopt-Function">处理命令行选项</a>）以及 <code>join()</code> 库函数（查看 see section <a href="#Join-Function">将数组合并成字串</a>）。
</p>
<p>程序以 <code>usage()</code> 函数开始以及一些写在注释中的简单的选项及其含义的说明。<code>BEGIN</code> 规则处命令行参数与选项。它使用了一个技巧来让 <code>getopt()</code> 处理如 &lsquo;<samp>-25</samp>&rsquo; 这个的选项，将这样的选项当做是字母 &lsquo;<samp>2</samp>&rsquo; 的选项与其参数 &lsquo;<samp>5</samp>&rsquo;。如果实际上提供了两个或者多个数字（<code>Optarg</code> 看起来像一个数值），<code>Optarg</code> 会与选项数字一连接，然后结果与 0 相加来使其转换为数值。如果只有一个数值在选项中，<code>Optarg</code> 就不需要了。在这种情况下，<code>Optind</code> 必须被递减，这样 <code>getopt()</code> 会在下一轮中处理它。这个代码确实玩了一点花招。
</p>
<p>如果没有提供选项，则会使用默认的行为，即打印重复与非重复的行。如果提供了输出文件，将其被赋值给 <code>outputfile</code>。在早期，<code>outputfile</code> 被初始化为标准输出，即 &lsquo;<tt>/dev/stdout</tt>&rsquo;：
</p>
<a name="index-uniq_002eawk-program"></a>
<div class="example">
<pre class="example"># uniq.awk --- do uniq in awk
#
# Requires getopt() and join() library functions
</pre><pre class="example">
function usage()
{
    print(&quot;Usage: uniq [-udc [-n]] [+n] [ in [ out ]]&quot;) &gt; &quot;/dev/stderr&quot;
    exit 1
}

# -c    count lines. overrides -d and -u
# -d    only repeated lines
# -u    only nonrepeated lines
# -n    skip n fields
# +n    skip n characters, skip fields first

BEGIN {
    count = 1
    outputfile = &quot;/dev/stdout&quot;
    opts = &quot;udc0:1:2:3:4:5:6:7:8:9:&quot;
    while ((c = getopt(ARGC, ARGV, opts)) != -1) {
        if (c == &quot;u&quot;)
            non_repeated_only++
        else if (c == &quot;d&quot;)
            repeated_only++
        else if (c == &quot;c&quot;)
            do_count++
        else if (index(&quot;0123456789&quot;, c) != 0) {
            # getopt() requires args to options
            # this messes us up for things like -5
            if (Optarg ~ /^[[:digit:]]+$/)
                fcount = (c Optarg) + 0
            else {
                fcount = c + 0
                Optind--
            }
        } else
            usage()
    }

    if (ARGV[Optind] ~ /^\+[[:digit:]]+$/) {
        charcount = substr(ARGV[Optind], 2) + 0
        Optind++
    }

    for (i = 1; i &lt; Optind; i++)
        ARGV[i] = &quot;&quot;

    if (repeated_only == 0 &amp;&amp; non_repeated_only == 0)
        repeated_only = non_repeated_only = 1

    if (ARGC - Optind == 2) {
        outputfile = ARGV[ARGC - 1]
        ARGV[ARGC - 1] = &quot;&quot;
    }
}
</pre></div>

<p>下面的函数 <code>are_equal()</code> 用来将当前行，<code>$0</code>，与前一行 <code>last</code> 进行比较。它处理要跳过的域与字符。如果没有指定域统计以及字符统计，<code>are_equal()</code> 返回 1，或者 0，这依赖于 <code>last</code> 与 <code>$0</code> 字串的简单的比较结果。
</p>
<p>不然的话，事情会变量更加复杂。如果要跳过域，每一行都会用 <code>split()</code>（查看 <a href="#String-Functions">字串操作函数</a>）拆分成数组，留下来的域然后再用 <code>join()</code> 组合成一行。被组合的行存回 <code>clast</code> 与 <code>cline</code> 中。如果没有域要跳过，<code>clast</code> 与 <code>cline</code> 则被设置成 <code>last</code> 与 <code>$0</code>。最后，如果有字符要跳过，<code>substr()</code> 用于清除 <code>clast</code> 与 <code>cline</code> 中前面 <code>count</code> 个的字符。两个字串然后进行比较，<code>are_equal()</code> 返回比较的结果：
</p>
<div class="example">
<pre class="example">function are_equal(    n, m, clast, cline, alast, aline)
{
    if (fcount == 0 &amp;&amp; charcount == 0)
        return (last == $0)

    if (fcount &gt; 0) {
        n = split(last, alast)
        m = split($0, aline)
        clast = join(alast, fcount+1, n)
        cline = join(aline, fcount+1, m)
    } else {
        clast = last
        cline = $0
    }
    if (charcount) {
        clast = substr(clast, charcount + 1)
        cline = substr(cline, charcount + 1)
    }

    return (clast == cline)
}
</pre></div>

<p>下面的两个规则是程序体。第一个只用在数据的第一行。它将 <code>last</code> 设置为 <code>$0</code>，所以，后续的行才有可以比较的东西。
</p>
<p>第二个规则执行相应的工作。变量 <code>equal</code> 为 1 或者 0，则依赖于 <code>are_equal()</code> 的比较结果。如果 <code>uniq</code> 正在统计重复的行，而行是相同的，则其会递增 <code>count</code> 变量。否则，它打印行然后重新设置 <code>count</code>，因为两行已经不相同了。
</p>
<p>如果 <code>uniq</code> 不在统计中，而比较结果是相同的，<code>count</code> 则会被递增。不会打印输出行，因为要移除重复的行。否则，如果 <code>uniq</code> 正在统计重复的行，并且有看到了多于一行相同行，或者如果 <code>uniq</code> 在统计非重复的行，则只会见到一行，然后该行会被打印输出，而 <code>count</code> 会被重置。
</p>
<p>最后，<code>END</code> 打印输入数据的最后一行的规则也采用相似的逻辑：
</p>
<div class="example">
<pre class="example">NR == 1 {
    last = $0
    next
}

{
    equal = are_equal()

    if (do_count) {    # overrides -d and -u
        if (equal)
            count++
        else {
            printf(&quot;%4d %s\n&quot;, count, last) &gt; outputfile
            last = $0
            count = 1    # reset
        }
        next
    }

    if (equal)
        count++
    else {
        if ((repeated_only &amp;&amp; count &gt; 1) ||
            (non_repeated_only &amp;&amp; count == 1))
                print last &gt; outputfile
        last = $0
        count = 1
    }
}

END {
    if (do_count)
        printf(&quot;%4d %s\n&quot;, count, last) &gt; outputfile
    else if ((repeated_only &amp;&amp; count &gt; 1) ||
            (non_repeated_only &amp;&amp; count == 1))
        print last &gt; outputfile
    close(outputfile)
}
</pre></div>





<hr>
<a name="Wc-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Uniq-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Clones" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bb_009fe_00ae_00a1"></a>
<h3 class="subsection">2.2.7 统计</h3>


<a name="index-counting"></a>
<a name="index-input-files_002c-counting-elements-in"></a>
<a name="index-words_002c-counting"></a>
<a name="index-characters_002c-counting"></a>
<a name="index-lines_002c-counting"></a>
<a name="index-wc-utility"></a>
<p><code>wc</code>（word count）工具用来统计一个或者多个文件中的行，字与字符。它的用法如下：
</p>
<div class="display">
<pre class="display"><code>wc</code> [&lsquo;<samp>-lwc</samp>&rsquo;] [<var>files</var> &hellip;]
</pre></div>

<p>如果在命令行中没有指定文件，<code>wc</code> 则从标准输入中读取。如果有多个文件，则它会打印所有文件的总的统计信息。<code>wc</code> 的选项及其意义如下：
</p>
<dl compact="compact">
<dt><code>-l</code></dt>
<dd><p>只统计行。
</p>
</dd>
<dt><code>-w</code></dt>
<dd><p>只统计单词。一个“单词”是一个连续的非空白字符字符序列，相互之间以空格与/或者 TABs 来分割。幸运的是这也是 <code>awk</code> 对输入数据进行域分割的常规方式。
</p>
</dd>
<dt><code>-c</code></dt>
<dd><p>只统计字符。
</p></dd>
</dl>

<p><code>awk</code> 中的 <code>wc</code> 实现特定优雅，因为 <code>awk</code> 已经为我们做了很多的事情了，<code>awk</code> 将行分割成单词（即域）然后统计它们，也统计行（即记录），它也可以很容易地告诉我们行的长度是多少。
</p>
<p>程序使用到 <code>getopt()</code> 函数（查看 see section <a href="#Getopt-Function">处理命令行选项</a>）以及文件转换函数
（查看 see section <a href="#Filetrans-Function">注意数据文件的边界</a>）。
</p>
<p>这个版本与传统的 <code>wc</code> 版本没有什么特别的不同：它总是按行，单词，字符这样的顺序来打印统计。传统的版本会注意到 &lsquo;<samp>-l</samp>&rsquo;，&lsquo;<samp>-w</samp>&rsquo;，&lsquo;<samp>-c</samp>&rsquo; 选项在命令行中的顺序，并以选项的顺序来打印统计。
</p>
<p><code>BEGIN</code> 规则作参数处理。变量 <code>print_total</code> 在命令行中有多于一个文件的情况下为 true：
</p>
<a name="index-wc_002eawk-program"></a>
<div class="example">
<pre class="example"># wc.awk --- count lines, words, characters

# Options:
#    -l    only count lines
#    -w    only count words
#    -c    only count characters
#
# Default is to count lines, words, characters
#
# Requires getopt() and file transition library functions

BEGIN {
    # let getopt() print a message about
    # invalid options. we ignore them
    while ((c = getopt(ARGC, ARGV, &quot;lwc&quot;)) != -1) {
        if (c == &quot;l&quot;)
            do_lines = 1
        else if (c == &quot;w&quot;)
            do_words = 1
        else if (c == &quot;c&quot;)
            do_chars = 1
    }
    for (i = 1; i &lt; Optind; i++)
        ARGV[i] = &quot;&quot;

    # if no options, do all
    if (! do_lines &amp;&amp; ! do_words &amp;&amp; ! do_chars)
        do_lines = do_words = do_chars = 1

    print_total = (ARGC - i &gt; 1)
}
</pre></div>

<p><code>beginfile()</code> 函数很简单，它仅是把行数，单词数与字符数设置为 0，并将当前的文件名存在 <code>fname</code> 中：
</p>
<div class="example">
<pre class="example">function beginfile(file)
{
    lines = words = chars = 0
    fname = FILENAME
}
</pre></div>

<p><code>endfile()</code> 函数将当前文件的数值加到总的行，单词与字符数上。然后为刚才所读取的文件打印相应的数值。它依赖于 <code>beginfile()</code> 来重置后面的数据文件的数值：
</p>
<div class="example">
<pre class="example">function endfile(file)
{
    tlines += lines
    twords += words
    tchars += chars
    if (do_lines)
        printf &quot;\t%d&quot;, lines
</pre><pre class="example">    if (do_words)
        printf &quot;\t%d&quot;, words
</pre><pre class="example">    if (do_chars)
        printf &quot;\t%d&quot;, chars
    printf &quot;\t%s\n&quot;, fname
}
</pre></div>

<p>有一个对每个行都执行的规则。在里面会对记录的长度加到 <code>chars</code> 上，再加上 1。
<a name="DOCF79" href="#FOOT79">(79)</a>
将记录的长度加 1 是因为换行符用来分割记录（即 <code>RS</code> 的值）但它又不是记录的一部分，因此不包含在长度里。后面，对每一行读取时 <code>lines</code> 会递增，而 <code>words</code> 会递增 <code>NF</code> 的值，而它的值就是本条行中“单词”的个数：
</p>
<div class="example">
<pre class="example"># do per line
{
    chars += length($0) + 1    # get newline
    lines++
    words += NF
}
</pre></div>

<p>最后，<code>END</code> 规则简单地铺所有文件的总合：
</p>
<div class="example">
<pre class="example">END {
    if (print_total) {
        if (do_lines)
            printf &quot;\t%d&quot;, tlines
        if (do_words)
            printf &quot;\t%d&quot;, twords
        if (do_chars)
            printf &quot;\t%d&quot;, tchars
        print &quot;\ttotal&quot;
    }
}
</pre></div>

<hr>
<a name="Miscellaneous-Programs"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Wc-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Dupword-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-c_00a8_008baa_00ba_008fc_009a_0084aa_00a4_00a7e_009b_0086aa_0090_0088"></a>
<h2 class="section">2.3 <code>awk</code> 程序的大集合</h2>

<p>这一小节中是一个不同程序的“大集合”。我们希望你会觉得他们即有趣也很好玩。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Dupword-Program">2.3.1 查找文档中的重复字</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Finding duplicated words in a document.
</td></tr>
<tr><td align="left" valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               An alarm clock.
</td></tr>
<tr><td align="left" valign="top"><a href="#Translate-Program">2.3.3 转换字符</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           A program similar to the <code>tr</code> utility.
</td></tr>
<tr><td align="left" valign="top"><a href="#Labels-Program">2.3.4 打印邮件标题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Printing mailing labels.
</td></tr>
<tr><td align="left" valign="top"><a href="#Word-Sorting">2.3.5 生成字使用统计</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                A program to produce a word usage count.
</td></tr>
<tr><td align="left" valign="top"><a href="#History-Sorting">2.3.6 从未排序的文本中去重</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Eliminating duplicate entries from a history
                                file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extract-Program">2.3.7 从 Texinfo 源文件中提取程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Pulling out programs from Texinfo source
                                files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Simple-Sed">2.3.8 一个简单的流编辑器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  A Simple Stream Editor.
</td></tr>
<tr><td align="left" valign="top"><a href="#Igawk-Program">2.3.9 使用库函数的简单方式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               A wrapper for <code>awk</code> that includes
                                files.
</td></tr>
<tr><td align="left" valign="top"><a href="#Anagram-Program">2.3.10 从字典中查找单词</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Finding anagrams from a dictionary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Signature-Program">2.3.11 来些新鲜的</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           People do amazing things with too much time on
                                their hands.
</td></tr>
</table>

<hr>
<a name="Dupword-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Alarm-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009f_00a5ae_0089_00beae_0096_0087ae_00a1_00a3a_00b8_00adc_009a_0084e_0087_008daa_00a4_008daa_00ad_0097"></a>
<h3 class="subsection">2.3.1 查找文档中的重复字</h3>

<a name="index-words_002c-duplicate_002c-searching-for"></a>
<a name="index-searching_002c-for-words"></a>
<a name="index-documents_002c-searching"></a>
<p>在写大量的单调文章的常见错误就是会偶然输入重复的词。一般情况下你会看到似下面的东西“the the program does the following&hellip;”。当文件是在线的时候，重复的词常常出现在一行的尾部以及另一行的行首，因此很难进行定位。
</p>
<p>&lsquo;<tt>dupword.awk</tt>&rsquo; 这个程序会扫描整个文件，一次一行，并查找同一个字符的的连续出现。它同时也保存一行中的最后一个单词（放在变量 <code>prev</code> 中），用于与下一个单词的第一个单词进行比较。
</p>
<a name="index-Texinfo-2"></a>
<p>头两个语句要确保行全是小写的，所以，像“The”与“the”可以相互进行比较。下一条语句会替换非字母数字与非空格字符为空格，所以标点符号也不会影响比较。用空格替换字符这样格式控制字符不会创建一些没有意义的单词（如 Texinfo 中的 &lsquo;<samp>@code{NF}</samp>&rsquo; 在简单地删除标点的情况下会变成 &lsquo;<samp>codeNF</samp>&rsquo;）。记录然后会被分割为域，产生了一行中的实际单词，并且保证不会有空的域。
</p>
<p>如果在移除了所有的标点后没有域，则当前的记录会被跳过。否则程序会迭代每一个单词，并且其前一个单词进行比较：
</p>
<a name="index-dupword_002eawk-program"></a>
<div class="example">
<pre class="example"># dupword.awk --- find duplicate words in text
{
    $0 = tolower($0)
    gsub(/[^[:alnum:][:blank:]]/, &quot; &quot;);
    $0 = $0         # re-split
    if (NF == 0)
        next
    if ($1 == prev)
        printf(&quot;%s:%d: duplicate %s\n&quot;,
            FILENAME, FNR, $1)
    for (i = 2; i &lt;= NF; i++)
        if ($i == $(i-1))
            printf(&quot;%s:%d: duplicate %s\n&quot;,
                FILENAME, FNR, $i)
    prev = $NF
}
</pre></div>

<hr>
<a name="Alarm-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dupword-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Translate-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008a_00a5e_00ad_00a6ae_0097_00b6e_0092_009fc_00a8_008baa_00ba_008f"></a>
<h3 class="subsection">2.3.2 报警时钟程序</h3>
<a name="index-insomnia_002c-cure-for"></a>
<a name="index-Robbins_002c-Arnold-3"></a>
<blockquote>
<p><i>
没有什么像闹钟一样可以治愈失眠。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Arnold Robbins</em>
</p><a name="index-Quanstrom_002c-Erik"></a>
<blockquote>
<p><i>
睡眠是给 Web 开发者的。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Erik Quanstrom</em>
</p>
<a name="index-time_002c-alarm-clock-example-program"></a>
<a name="index-alarm-clock-example-program"></a>
<p>下面的程序是一个简单的“闹钟”程序。你给它一个时间以及一个可选的消息，在指定的时间上，它会打印消息到标准输出上。另外，你可以给它一个消息重复的资料，以及重复之间的延迟时间。
</p>
<p>这个程序使用 <code>getlocaltime()</code> 函数（查看 <a href="#Getlocaltime-Function">管理时间</a>）。
</p>
<p>在 <code>BEGIN</code> 规则中完成所有的工作。第一部分是参数检查，并设置默认值：delay，count，以及要打印的 message。如果用户提供了一个不带 ASCII BEL 字符的消息（为“alert”字符，<code>\a</code>），然后它会被加到 message 中。（在很多的系统中，打印 ASCII BEL 会产生一个可以听得到的报警块。所以， 当报警消除时，系统会在用户没有看电脑时来唤起其注意。）只是为了做一些改变，这个程序使用 <code>switch</code> 语句（查看 see section <a href="#Switch-Statement"><code>switch</code> 语句</a>），但是处理也可以用一系列的 <code>if</code>-<code>else</code> 语句来完成。下面是程序：
</p>
<a name="index-alarm_002eawk-program"></a>
<div class="example">
<pre class="example"># alarm.awk --- set an alarm
#
# Requires getlocaltime() library function
# usage: alarm time [ &quot;message&quot; [ count [ delay ] ] ]

BEGIN {
    # Initial argument sanity checking
    usage1 = &quot;usage: alarm time ['message' [count [delay]]]&quot;
    usage2 = sprintf(&quot;\t(%s) time ::= hh:mm&quot;, ARGV[1])

    if (ARGC &lt; 2) {
        print usage1 &gt; &quot;/dev/stderr&quot;
        print usage2 &gt; &quot;/dev/stderr&quot;
        exit 1
    }
    switch (ARGC) {
    case 5:
        delay = ARGV[4] + 0
        # fall through
    case 4:
        count = ARGV[3] + 0
        # fall through
    case 3:
        message = ARGV[2]
        break
    default:
        if (ARGV[1] !~ /[[:digit:]]?[[:digit:]]:[[:digit:]]{2}/) {
            print usage1 &gt; &quot;/dev/stderr&quot;
            print usage2 &gt; &quot;/dev/stderr&quot;
            exit 1
        }
        break
    }

    # set defaults for once we reach the desired time
    if (delay == 0)
        delay = 180    # 3 minutes
</pre><pre class="example">    if (count == 0)
        count = 5
</pre><pre class="example">    if (message == &quot;&quot;)
        message = sprintf(&quot;\aIt is now %s!\a&quot;, ARGV[1])
    else if (index(message, &quot;\a&quot;) == 0)
        message = &quot;\a&quot; message &quot;\a&quot;
</pre></div>

<p>代码的下一小节会将报警时间转换为小时分钟，并转换（如果有必要的话）为一个 24 小时制的时间，然后将时间转换为从午夜以来的秒数。后面它会将当前的时候转换为从午夜以来的秒数。两个时间之间的差就是要设置报警要等待的时间：
</p>
<div class="example">
<pre class="example">    # split up alarm time
    split(ARGV[1], atime, &quot;:&quot;)
    hour = atime[1] + 0    # force numeric
    minute = atime[2] + 0  # force numeric

    # get current broken down time
    getlocaltime(now)

    # if time given is 12-hour hours and it's after that
    # hour, e.g., `alarm 5:30' at 9 a.m. means 5:30 p.m.,
    # then add 12 to real hour
    if (hour &lt; 12 &amp;&amp; now[&quot;hour&quot;] &gt; hour)
        hour += 12

    # set target time in seconds since midnight
    target = (hour * 60 * 60) + (minute * 60)

    # get current time in seconds since midnight
    current = (now[&quot;hour&quot;] * 60 * 60) + \
               (now[&quot;minute&quot;] * 60) + now[&quot;second&quot;]

    # how long to sleep for
    naptime = target - current
    if (naptime &lt;= 0) {
        print &quot;alarm: time is in the past!&quot; &gt; &quot;/dev/stderr&quot;
        exit 1
    }
</pre></div>

<a name="index-sleep-utility"></a>
<p>最后，程序使用 <code>system()</code> 函数（查看 see section <a href="#I_002fO-Functions">输入输出函数</a>）来调用 <code>sleep</code> 工具。<code>sleep</code> 工具会暂停给定的秒数。如果其退出时间不是 0，而程序会假设休眠中断并退出。如果 <code>sleep</code> 退出，退出代码为 0，则程序会在循环中打印消息，然后再通过 <code>sleep</code> 来迟延不管多少必要的秒时间：
</p>
<div class="example">
<pre class="example">    # zzzzzz..... go away if interrupted
    if (system(sprintf(&quot;sleep %d&quot;, naptime)) != 0)
        exit 1

    # time to notify!
    command = sprintf(&quot;sleep %d&quot;, delay)
    for (i = 1; i &lt;= count; i++) {
        print message
        # if sleep command interrupted, go away
        if (system(command) != 0)
            break
    }

    exit 0
}
</pre></div>

<hr>
<a name="Translate-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Alarm-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Labels-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00bd_00acae_008d_00a2aa_00ad_0097c_00ac_00a6"></a>
<h3 class="subsection">2.3.3 转换字符</h3>

<a name="index-characters_002c-transliterating"></a>
<a name="index-tr-utility"></a>
<p>系统的 <code>tr</code> 工具用来进行字符的一对一转换。例如，用来将大写字母转换为小写字母以便进行进一步的处理：
</p>
<div class="example">
<pre class="example"><var>generate data</var> | tr 'A-Z' 'a-z' | <var>process data</var> &hellip;
</pre></div>

<p><code>tr</code> 需要两个字符列表。 
<a name="DOCF80" href="#FOOT80">(80)</a>
当处理输入时，在第一个字符列表中的第一个字符会被第二个列表中的第一个字符替换，而第一个字符列表中的第二个字符会被第二个字符列表中的第二个字符替换，以此类推。如果在“from”列表中有比“to”列表中更多的字符，则在“to”中的最后的字符用来替换在“from”列表中的其他字符。
</p>
<p>以前，
有用户建议在 <code>gawk</code> 中加入字符转换函数。
下面的程序可以证明用户层的函数也可以用来实现字符的转换功能。这个程序没有 <code>tr</code> 工具那么完整，但是可以做大部份的事情。
</p>
<p>转换程序 <code>translate</code> 是在 <code>gawk</code> 取得对每个字串中的字符进行分割到数组中的能力很久之前写的。所以，它重复地使用 <code>substr()</code>，<code>index()</code> 与 <code>gsub()</code> 等内置函数（查看 <a href="#String-Functions">字串操作函数</a>）。下面有两个函数，第一个函数 <code>stranslate()</code>，有三个参数：
</p>
<dl compact="compact">
<dt><code>from</code></dt>
<dd><p>要转换的字符列表。
</p>
</dd>
<dt><code>to</code></dt>
<dd><p>要转换成的字符列表。
</p>
</dd>
<dt><code>target</code></dt>
<dd><p>要执行转换的字串。
</p></dd>
</dl>

<p>关联数组使得转换部分非常容易。<code>t_ar</code> 保存“to”的字符，并用“from”的字符作为索引。然后一个简单的循环来循环 <code>from</code> 字符，一次一个字符。对在 <code>from</code> 中的每个字符，如果字符出现在 <code>target</code> 中，则它被替换为 <code>to</code> 中的相应字符。
</p>
<p><code>translate()</code> 函数调用 <code>stranslate()</code>，并将 <code>$0</code> 作为 <code>target</code> 参数。主程序用来自由命令行的值设置两个全局变量，<code>FROM</code> 与 <code>TO</code>，然后将 <code>ARGV</code> 更改为 <code>awk</code> 从标准输入中读取。
</p>
<p>最后，处理规则只是简单地调用 <code>translate()</code> 来处理每一条记录：
</p>
<a name="index-translate_002eawk-program"></a>
<div class="example">
<pre class="example"># translate.awk --- do tr-like stuff
# Bugs: does not handle things like tr A-Z a-z; it has
# to be spelled out. However, if `to' is shorter than `from',
# the last character in `to' is used for the rest of `from'.

function stranslate(from, to, target,     lf, lt, ltarget, t_ar, i, c,
                                                               result)
{
    lf = length(from)
    lt = length(to)
    ltarget = length(target)
    for (i = 1; i &lt;= lt; i++)
        t_ar[substr(from, i, 1)] = substr(to, i, 1)
    if (lt &lt; lf)
        for (; i &lt;= lf; i++)
            t_ar[substr(from, i, 1)] = substr(to, lt, 1)
    for (i = 1; i &lt;= ltarget; i++) {
        c = substr(target, i, 1)
        if (c in t_ar)
            c = t_ar[c]
        result = result c
    }
    return result
}

function translate(from, to)
{
    return $0 = stranslate(from, to, $0)
}

# main program
BEGIN {
</pre><pre class="example">    if (ARGC &lt; 3) {
        print &quot;usage: translate from to&quot; &gt; &quot;/dev/stderr&quot;
        exit
    }
</pre><pre class="example">    FROM = ARGV[1]
    TO = ARGV[2]
    ARGC = 2
    ARGV[1] = &quot;-&quot;
}

{
    translate(FROM, TO)
    print
}
</pre></div>

<p>有可能在用户层的函数中来执行字符转换，但是没有这么高效，我们（即 <code>gawk</code> 的开发者）开始考虑添加一个内置的函数。但是，在完成这个程序之后不久，我们了解到 Brian Kernighan 已经加入了 <code>toupper()</code> 与 <code>tolower()</code> 函数到它的 <code>gawk</code> 中（查看 <a href="#String-Functions">字串操作函数</a>）。这些函数处理处理了大量的所需要的字符转换的主要部分，因此我们只好选择来简单地将这些函数加到 <code>gawk</code>，并保证它们足够独立。
</p>
<p>对这个程序的明显提升就是在 <code>BEGIN</code> 规则中仅设置 <code>t_ar</code> 数组一次。但是，这假设“from”与“to”的列表在程序的生命期内不会改变。
</p>
<p>另一个明显的改进，就是允许使用 <code>tr</code> 工具所使用的范围，如 &lsquo;<samp>a-z</samp>&rsquo;。查看 &lsquo;<tt>cut.awk</tt>&rsquo;（查看 see section <a href="#Cut-Program">剪切域与列</a>）代码来查看其中的灵感。
</p>

<hr>
<a name="Labels-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translate-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Word-Sorting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0089_0093aa_008d_00b0e_0082_00aea_00bb_00b6ae_00a0_0087e_00a2_0098"></a>
<h3 class="subsection">2.3.4 打印邮件标题</h3>

<a name="index-printing_002c-mailing-labels"></a>
<a name="index-mailing-labels_002c-printing"></a>
<p>这里是一个“真实世界” 中的程序。
<a name="DOCF81" href="#FOOT81">(81)</a>
这个脚本读取名字与地址列表，然后产生邮件标签。标签的每一页有 20 个标签在里头，2 行 10 列。地址保证多于 5 行。每一个地方都通过一个空行与下一个地方进行分隔。
</p>
<p>基本的想法是读取 20 个标签的数据。每个标签的每一行都存在 <code>line</code> 数组中。一个单独的规则来处理填充 <code>line</code> 数组，并在读到 20 个标签的时候打印页。
</p>
<p><code>BEGIN</code> 规则简单地将 <code>RS</code> 设置成空串，因此 <code>awk</code> 会将记录以空行分割（查看 see section <a href="#Records">输入如何拆分为记录</a>）。然后将 <code>MAXLINES</code> 设置为 100，因此 100 是在页中的最大行数
（20 * 5 = 100）。
</p>
<p>大多数的工作是在 <code>printpage()</code> 函数中完成的。标签行被顺序地存在 <code>line</code> 数组中。
但是他们要水平地打印出来：<code>line[1]</code> 后面是 <code>line[6]</code>，<code>line[2]</code> 与 <code>line[7]</code> 相邻，等等。用两个循环来完成这个功能。外层的循环通过 <code>i</code> 来控制，用来迭代数据的每 10 行，这是每一行的标签。内循环，通过 <code>j</code> 控制，不用迭代一行中的内容。当 <code>j</code> 从 0 迭代到 4，则 &lsquo;<samp>i+j</samp>&rsquo; 就是行中的第 <code>j</code> 行。 &lsquo;<samp>i+j+5</samp>&rsquo; 则为下一行。输出最终输出可能如下：
</p>
<div class="example">
<pre class="example">line 1          line 6
line 2          line 7
line 3          line 8
line 4          line 9
line 5          line 10
&hellip;
</pre></div>

<p><code>printf</code> 的 &lsquo;<samp>%-41s</samp>&rsquo; 字串表示是左对齐数据，并在固定的宽度域上进行打印。
</p>
<p>作为最后提示，在行 21 与行 61 中会有一个空行输出，来保持输出行是标签是对齐的。这依赖于写程序时所使用的特别的标签类型。你也需要注意，在开头与结尾都有两个空行。
</p>
<p><code>END</code> 规则用来将最后页的标签输出，因为有可能没有多个整 20 个标签存在：
</p>
<a name="index-labels_002eawk-program"></a>
<div class="example">
<pre class="example"># labels.awk --- print mailing labels

# Each label is 5 lines of data that may have blank lines.
# The label sheets have 2 blank lines at the top and 2 at
# the bottom.

BEGIN    { RS = &quot;&quot; ; MAXLINES = 100 }

function printpage(    i, j)
{
    if (Nlines &lt;= 0)
        return

    printf &quot;\n\n&quot;        # header

    for (i = 1; i &lt;= Nlines; i += 10) {
        if (i == 21 || i == 61)
            print &quot;&quot;
        for (j = 0; j &lt; 5; j++) {
            if (i + j &gt; MAXLINES)
                break
            printf &quot;   %-41s %s\n&quot;, line[i+j], line[i+j+5]
        }
        print &quot;&quot;
    }

    printf &quot;\n\n&quot;        # footer

    delete line
}

# main rule
{
    if (Count &gt;= 20) {
        printpage()
        Count = 0
        Nlines = 0
    }
    n = split($0, a, &quot;\n&quot;)
    for (i = 1; i &lt;= n; i++)
        line[++Nlines] = a[i]
    for (; i &lt;= 5; i++)
        line[++Nlines] = &quot;&quot;
    Count++
}

END {
    printpage()
}
</pre></div>

<hr>
<a name="Word-Sorting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Labels-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#History-Sorting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_009fae_0088_0090aa_00ad_0097a_00bd_00bfc_0094_00a8c_00bb_009fe_00ae_00a1"></a>
<h3 class="subsection">2.3.5 生成字使用统计</h3>

<a name="index-words_002c-usage-counts_002c-generating"></a>

<p>当要处理大量的文本的时候，如果了解单词的使用频率是一件很有趣的事情。例如，作者可能会容易使用特定的词，在这种情况下，他或者她可能想找一些同义词来代替那些出现得太频繁的词。这一子小节中开发了一个这样的程序来统计单词以及它出现的频率，并以一种有用的方式输出这些信息。
</p>
<p>乍看之下，像下面这样的程序可以完成这样的功能：
</p>
<div class="example">
<pre class="example"># wordfreq-first-try.awk --- print list of word frequencies

{
    for (i = 1; i &lt;= NF; i++)
        freq[$i]++
}

END {
    for (word in freq)
        printf &quot;%s\t%d\n&quot;, word, freq[word]
}
</pre></div>

<p>程序依赖于 <code>awk</code> 的默认域分割机制来将每一行分割成词并使用关联数组 <code>freq</code> 来存储它们，用单词来作为索引，来统计单词出现的次数，在 <code>END</code> 规则中来打印统计。
</p>
<p>这个程序有几个问题会导致其处理真实文本时有可用程度：
</p>
<ul>
<li>
<code>awk</code> 语言会把大写与小定是有区别的。所以，“bartender”与“Bartender”会当成不一样的词。这不是想要的结果，因为单词在正常的文本中的句首，会进行首字大写，而频率分析器却对首字大写不敏感。

</li><li>
单词的检测使用的是 <code>awk</code> 默认使用空格进行域分割的惯例。在输入中的其他字符（不包含换行符）对于 <code>awk</code> 来说没有特殊的含义。这表示标点符号也会成为单词的一部分。

</li><li>
输出不会有什么有用的顺序。你更有可能对最常出现的单词感兴趣，或者形成一个字母表来表示每个单词的出现频率。
</li></ul>

<a name="index-sort-utility"></a>
<p>第一个问题可以通过 <code>tolower()</code> 来移除大小定来解决。第三个问题可以用 <code>gsub()</code> 移除标点符号来解决。最后，我们通过使用系统的 <code>sort</code> 工具处理 <code>awk</code> 脚本的输出来解决第三个问题。这是一个新版本的程序：
</p>
<a name="index-wordfreq_002eawk-program"></a>
<div class="example">
<pre class="example"># wordfreq.awk --- print list of word frequencies

{
    $0 = tolower($0)    # remove case distinctions
    # remove punctuation
    gsub(/[^[:alnum:]_[:blank:]]/, &quot;&quot;, $0)
    for (i = 1; i &lt;= NF; i++)
        freq[$i]++
}

END {
    for (word in freq)
        printf &quot;%s\t%d\n&quot;, word, freq[word]
}
</pre></div>

<p>正则表达式 <code>/[^[:alnum:]_[:blank:]]/</code> 本可以写在 <code>/[[:punct:]]/</code>，但是下划线也要移除，但我们想保留它。
</p>
<p>假设我们把这个程序保留为名字为 &lsquo;<tt>wordfreq.awk</tt>&rsquo; 的文件，数据在 &lsquo;<tt>file1</tt>&rsquo; 中，则下面的管程：
</p>
<div class="example">
<pre class="example">awk -f wordfreq.awk file1 | sort -k 2nr
</pre></div>

<p>会产生出现在 &lsquo;<tt>file1</tt>&rsquo; 中的单词频率的降序表。
</p>
<p><code>awk</code> 程序适合于处理信息以及数据来产生单词频率表，但是不是有序的。<code>awk</code> 的脚本输出然后通过 <code>sort</code> 工具来排序，然后再打印到屏幕上。
</p>
<p>提交给 <code>sort</code> 工具的选择指定排序使用每个输入行的第二个域（跳过第一个域），排序键被当成数值量来对待（不然 &lsquo;<samp>15</samp>&rsquo; 会排在 &lsquo;<samp>5</samp>&rsquo; 之前），然后排序会以降序（逆序）的方式来执行。
</p>
<p><code>sort</code> 甚至可以在程序中完成，只要把 <code>END</code> 的动作改成如下：
</p>
<div class="example">
<pre class="example">END {
    sort = &quot;sort -k 2nr&quot;
    for (word in freq)
        printf &quot;%s\t%d\n&quot;, word, freq[word] | sort
    close(sort)
}
</pre></div>

<p>这种方式的排序必须使用在那些在命令行一层没有真正的管道的的系统上（或者批处理文件）。查看操作系统上如何使用 <code>sort</code> 程序的文档来获取更多信息。
</p>
<hr>
<a name="History-Sorting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Word-Sorting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extract-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008eae_009c_00aaae_008e_0092aa_00ba_008fc_009a_0084ae_0096_0087ae_009c_00aca_00b8_00adaa_008e_00bbe_0087_008d"></a>
<h3 class="subsection">2.3.6 从未排序的文本中去重</h3>

<a name="index-lines_002c-duplicate_002c-removing"></a>
<p><code>uniq</code> 程序（查看 see section <a href="#Uniq-Program">打印去重文本行</a>）在<em>经过排序</em>的数据中移除重复的行。
</p>
<p>但是，你可能需要移除数据文件中的重复的行，而又想保留行中的顺序。这样处理的一个合适的例子就是 Shell 的 histroy 文件。history 文件保留了你已经输入过的命令的复本，在一行中重复几次相同的命令的情况并不多见。有时候，你可能想移除重复的行来压缩文件。但是还要保留最初命令行的顺序。
</p>
<p>下面这个简单的程序可以完成这个工作。它会使用两个数组。 <code>data</code> 数组由每行的文本来作索引。对每一行，<code>data[$0]</code> 会进行递增。如果某个特定的行之前没有出现过，则 <code>data[$0]</code> 会是 0。在这种情况下，那一行的文本会存在 <code>lines[count]</code> 中。<code>lines</code> 中的元素都是唯一的，而 <code>lines</code> 的索引表示了行出现的顺序。<code>END</code> 规则中介简单地按顺序打印这些行：
</p>
<a name="index-Rakitzis_002c-Byron"></a>
<a name="index-histsort_002eawk-program"></a>
<div class="example">
<pre class="example"># histsort.awk --- compact a shell history file
# Thanks to Byron Rakitzis for the general idea

</pre><pre class="example">{
    if (data[$0]++ == 0)
        lines[++count] = $0
}
</pre><pre class="example">
</pre><pre class="example">END {
    for (i = 1; i &lt;= count; i++)
        print lines[i]
}
</pre></div>

<p>这个程序也提供了用于产生有用信息的一个基础。如，在 <code>END</code> 规则中使用下面的 <code>print</code> 语句表示特定命令使用的频度：
</p>
<div class="example">
<pre class="example">print data[lines[i]], lines[i]
</pre></div>

<p>这么做有效是因为 <code>data[$0]</code> 在行每出现一次都会进行递增。
</p>
<hr>
<a name="Extract-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#History-Sorting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Simple-Sed" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008e-Texinfo-ae_00ba_0090ae_0096_0087a_00bb_00b6a_00b8_00adae_008f_0090aa_008f_0096c_00a8_008baa_00ba_008f"></a>
<h3 class="subsection">2.3.7 从 Texinfo 源文件中提取程序</h3>

<a name="index-Texinfo_002c-extracting-programs-from-source-files"></a>
<a name="index-files_002c-Texinfo_002c-extracting-programs-from"></a>
<p>在本章与前一章（查看 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a>）中，都展示了大量的 <code>awk</code> 程序。
如果你想实践这些程序，如果再次手工输出这些程序则就太繁琐了。这里，我们展示了一个程序可以从 Texinfo 的输入文件中提出部分到一个独立的文件中。
</p>
<a name="index-Texinfo-3"></a>
<p>本网页 是用 <a href="http://www.gnu.org/software/texinfo/">Texinfo</a> 写成的，这是 GNU 项目的文档格式语言。一个单独的 Texinfo 源文件可以用来产生打印的 TeX 文档，也可以产生在线文档。
（Texinfo 在书 <cite>Texinfo&mdash;The GNU Documentation Format</cite> 有完整的文档，也可从自由软件基金会取得，也可以在
<a href="http://www.gnu.org/software/texinfo/manual/texinfo/">网上</a> 取得。）
</p>
<p>对于我们自己的目的，知道 Texinfo 输入文件的三件事情就够了：
</p>
<ul>
<li>
“at” 符号（&lsquo;<samp>@</samp>&rsquo;）在 Texinfo 中是特殊符号，就像是在 C 或者 <code>awk</code> 中的反斜杠一样（&lsquo;<samp>\</samp>&rsquo;）。字面的 &lsquo;<samp>@</samp>&rsquo; 在 Texinfo 源文件中由 &lsquo;<samp>@@</samp>&rsquo; 来表示。

</li><li>
注释同 &lsquo;<samp>@c</samp>&rsquo; 开始，或者由 &lsquo;<samp>@comment</samp>&rsquo; 开始。文件提出程序通过使用在行首开始的特殊的注释。

</li><li>
包含 &lsquo;<samp>@group</samp>&rsquo; 与 &lsquo;<samp>@end group</samp>&rsquo; 命令包含例子文本不可以分页。（不幸的是，TeX 不总是足够来做正确的事情，因此我们还得给它一些帮助。）
</li></ul>

<p>下面的程序 &lsquo;<tt>extract.awk</tt>&rsquo; 从 Texinfo 源文件中读取，并根据特殊注释做两件事情。当看到 &lsquo;<samp>@c&nbsp;system&nbsp;&hellip;</samp>&rsquo; 时，它执行一个命令，并从命令文本中提取控制行并将其传递给 <code>system()</code> 函数
（查看 see section <a href="#I_002fO-Functions">输入输出函数</a>）。当看到 &lsquo;<samp>@c file <var>filename</var></samp>&rsquo; 时，其后续的行将被发送到文件 <var>filename</var> 中，直到看到 &lsquo;<samp>@c endfile</samp>&rsquo; 为止。
在 &lsquo;<tt>extract.awk</tt>&rsquo; 规则中，要么匹配 &lsquo;<samp>@c</samp>&rsquo; 要么匹配 &lsquo;<samp>@comment</samp>&rsquo;，只要将 &lsquo;<samp>omment</samp>&rsquo; 成为可选的部分即可。包含 &lsquo;<samp>@group</samp>&rsquo; 与 &lsquo;<samp>@end group</samp>&rsquo; 的行，只是简单地移除。&lsquo;<tt>extract.awk</tt>&rsquo; 使用到 <code>join()</code> 库函数（查看 see section <a href="#Join-Function">将数组合并成字串</a>）。
</p>
<p>在 <cite>GAWK: Effective AWK Programming</cite> （&lsquo;<tt>gawktexi.in</tt>&rsquo;）的 Texinfo 的源代码中的例子程序都已经包含在 &lsquo;<samp>file</samp>&rsquo; 与 &lsquo;<samp>endfile</samp>&rsquo; 中的行里。
<code>gawk</code> 发行版本使用 &lsquo;<tt>extract.awk</tt>&rsquo; 的一个复本来提取例子程序，并将他们中的多数安装到了标准的 <code>gawk</code> 可查找到目录中。Texinfo 文件看起来这样：
</p>
<div class="example">
<pre class="example">&hellip;
This program has a @code{BEGIN} rule
that prints a nice message:

@example
@c file examples/messages.awk
BEGIN @{ print &quot;Don't panic!&quot; @}
@c endfile
@end example

It also prints some final advice:

@example
@c file examples/messages.awk
END @{ print &quot;Always avoid bored archaeologists!&quot; @}
@c endfile
@end example
&hellip;
</pre></div>

<p>&lsquo;<tt>extract.awk</tt>&rsquo; 将 <code>IGNORECASE</code> 设置为 1，所以大小写混合在指示符中不会有什么影响。
</p>
<p>第一个规则处理 <code>system()</code> 调用，检查要执行的命令（<code>NF</code> 至少为 3 ）并且也检查命令出代码为是否为 0，即表示执行 OK：
</p>
<a name="index-extract_002eawk-program"></a>
<div class="example">
<pre class="example"># extract.awk --- extract files and run programs from Texinfo files

BEGIN    { IGNORECASE = 1 }

/^@c(omment)?[ \t]+system/ {
    if (NF &lt; 3) {
        e = (&quot;extract: &quot; FILENAME &quot;:&quot; FNR)
        e = (e  &quot;: badly formed `system' line&quot;)
        print e &gt; &quot;/dev/stderr&quot;
        next
    }
    $1 = &quot;&quot;
    $2 = &quot;&quot;
    stat = system($0)
    if (stat != 0) {
        e = (&quot;extract: &quot; FILENAME &quot;:&quot; FNR)
        e = (e &quot;: warning: system returned &quot; stat)
        print e &gt; &quot;/dev/stderr&quot;
    }
}
</pre></div>

<p>变量 <code>e</code> 用来使规则很好地匹配页 screen。
</p>
<p>第二个规则将数据移动到文件中。它会检查在指示符中给出的文件名。如果文件名不是当前的文件，然后当前文件就会被关闭。让当前的文件一直打开到处理下一个新文件，这样你可以使用 &lsquo;<samp>&gt;</samp>&rsquo; 来重定向打印内容，打开文件的管理也很简单。
</p>
<p><code>for</code> 循环处理真正的工作。它使用 <code>getline</code> （查看 see section <a href="#Getline">用 <code>getline</code> 输入数据</a>）来读取行。对于一个未期望的文件尾，它会调用 <code><span class="nolinebreak">unexpected_eof()</span></code> 函数。如果行是一个 &lsquo;<samp>endfile</samp>&rsquo; 行，则它就跳出循环。如果行是 &lsquo;<samp>@group</samp>&rsquo; 或者 &lsquo;<samp>@end group</samp>&rsquo; 行，则它会忽略掉，然后继续处理下一行。类似地，例子中的注释也被忽略掉。
</p>
<p>大多数的工作都在下面几行。如果行中没有 &lsquo;<samp>@</samp>&rsquo; 符号，则程序可以直接打印它，否则每一个前导的 &lsquo;<samp>@</samp>&rsquo; 必须被去掉。为了移除 &lsquo;<samp>@</samp>&rsquo; 符号，使用 <code>split()</code> 函数（查看 <a href="#String-Functions">字串操作函数</a>）行被分割成 <code>a</code> 数组的不同元素。
&lsquo;<samp>@</samp>&rsquo; 符号被用于分隔符。<code>a</code> 的每一个空元素表示在原行中的两个连续的 &lsquo;<samp>@</samp>&rsquo; 符号。对每两个空元素（在原文件中的 &lsquo;<samp>@@</samp>&rsquo;），我们需要加一个 &lsquo;<samp>@</samp>&rsquo; 符号进来。
</p>
<p>当数组的处理已经完成，<code>join()</code> 则被以 <code>SUBSEP</code> 的值调用（查看 see section <a href="#Multidimensional">多维数组</a>），用以将分散的块连接成一个单独的行。该行然后被打印到输出文件中：
</p>
<div class="example">
<pre class="example">/^@c(omment)?[ \t]+file/ {
    if (NF != 3) {
        e = (&quot;extract: &quot; FILENAME &quot;:&quot; FNR &quot;: badly formed `file' line&quot;)
        print e &gt; &quot;/dev/stderr&quot;
        next
    }
    if ($3 != curfile) {
        if (curfile != &quot;&quot;)
            close(curfile)
        curfile = $3
    }

    for (;;) {
        if ((getline line) &lt;= 0)
            unexpected_eof()
        if (line ~ /^@c(omment)?[ \t]+endfile/)
            break
        else if (line ~ /^@(end[ \t]+)?group/)
            continue
        else if (line ~ /^@c(omment+)?[ \t]+/)
            continue
        if (index(line, &quot;@&quot;) == 0) {
            print line &gt; curfile
            continue
        }
        n = split(line, a, &quot;@&quot;)
        # if a[1] == &quot;&quot;, means leading @,
        # don't add one back in.
        for (i = 2; i &lt;= n; i++) {
            if (a[i] == &quot;&quot;) { # was an @@
                a[i] = &quot;@&quot;
                if (a[i+1] == &quot;&quot;)
                    i++
            }
        }
        print join(a, 1, n, SUBSEP) &gt; curfile
    }
}
</pre></div>

<p>这里要注意一个重要的事情就是 &lsquo;<samp>&gt;</samp>&rsquo; 重定向符的使用。用 &lsquo;<samp>&gt;</samp>&rsquo; 输出只会打开一次文件，然后会一保持打开，后续的输出操作会附加到文件中（查看 see section <a href="#Redirection">重定向 <code>print</code> 与 <code>printf</code> 的输出</a>）。这使得很容易混合程序文本与针对相同源文件的解释性的文字（正如这里所做的一样）而没有任何问题。文件只在处理一个新的数据文件的时候才会被关闭，或者在输入文件输入结束时关闭。
</p>
<p>最后，<code><span class="nolinebreak">unexpected_eof()</span></code> 函数打印合适的错误信息并退出。<code>END</code> 规则处理最后的清理工作，关闭打开的文件：
</p>
<div class="example">
<pre class="example">function unexpected_eof()
{
    printf(&quot;extract: %s:%d: unexpected EOF or error\n&quot;,
                     FILENAME, FNR) &gt; &quot;/dev/stderr&quot;
    exit 1
}
</pre><pre class="example">
END {
    if (curfile)
        close(curfile)
}
</pre></div>

<hr>
<a name="Simple-Sed"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extract-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Igawk-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_0080a_00b8_00aac_00ae_0080aa_008d_0095c_009a_0084ae_00b5_0081c_00bc_0096e_00be_0091aa_0099_00a8"></a>
<h3 class="subsection">2.3.8 一个简单的流编辑器</h3>

<a name="index-sed-utility-1"></a>
<a name="index-stream-editors-1"></a>
<p><code>sed</code> 是一个流编辑器，它是一个<em>读取数据流</em>，改变它然后传递它的程序。通过它被用来对一个大的文件或者由命令的管程产生的数据流做一些全局性的更改。尽管 <code>sed</code> 在它那边来说是一个很复杂的程序，但是它的通常用法是在管线的中途做一些全局性的替换：
</p>
<div class="example">
<pre class="example"><var>command1</var> &lt; orig.data | sed 's/old/new/g' | <var>command2</var> &gt; result
</pre></div>

<p>如 &lsquo;<samp>s/old/new/g</samp>&rsquo; 告诉 <code>sed</code> 在每一个输入行查找正则表达式 &lsquo;<samp>old</samp>&rsquo;，并全局性地替换它为 &lsquo;<samp>new</samp>&rsquo; （即在一行中所有出现）。这个与 <code>awk</code> 的 <code>gsub()</code> 函数（查看 <a href="#String-Functions">字串操作函数</a>）非常类似。
</p>
<p>下面的程序，&lsquo;<tt>awksed.awk</tt>&rsquo; 接收至少两个命令行参数：一个是要查找的模式，以及替换它的文本。任何其他的参数都当成是要处理的数据文件名。如果没有提供文件名，则使用标准输入：
</p>
<a name="index-Brennan_002c-Michael-4"></a>
<a name="index-awksed_002eawk-program"></a>
<div class="example">
<pre class="example"># awksed.awk --- do s/foo/bar/g using just print
#    Thanks to Michael Brennan for the idea

function usage()
{
    print &quot;usage: awksed pat repl [files...]&quot; &gt; &quot;/dev/stderr&quot;
    exit 1
}

BEGIN {
    # validate arguments
    if (ARGC &lt; 3)
        usage()

    RS = ARGV[1]
    ORS = ARGV[2]

    # don't use arguments as files
    ARGV[1] = ARGV[2] = &quot;&quot;
}

</pre><pre class="example"># look ma, no hands!
{
    if (RT == &quot;&quot;)
        printf &quot;%s&quot;, $0
    else
        print
}
</pre></div>

<p>程序依赖于 <code>gawk</code> 可以将 <code>RS</code> 赋值为正则表达式的能力，以及设置 <code>RT</code> 为实际的结束记录的文本（查看 see section <a href="#Records">输入如何拆分为记录</a>）。
</p>
<p>思路就是让 <code>RS</code> 成为要查找的模式。<code>gawk</code> 会处置设置 <code>$0</code> 为在匹配模式之间的文本。这就是我们想要保留的，不经修改的文本。然后，设置 <code>ORS</code> 为替换的文件。一个简单的 <code>print</code> 语句输出我们想要保留的文本，后面跟着要替换的文本。
</p>
<p>这个方法有一个不完美的地方，即如果最后一条记录不是以匹配 <code>RS</code> 的文本结束该怎么办。使用 <code>print</code> 语句无条件地打印替换文本是不正确的。但是，如果文件不是以匹配 <code>RS</code> 的文本结束，<code>RT</code> 会被设置成空串。在这种情况下，我们可以使用 <code>printf</code> 来打印 <code>$0</code>。（查看 see section <a href="#Printf">使用 <code>printf</code> 语句美化打印</a>）
</p>
<p><code>BEGIN</code> 规则处理环境的设置，检查参数的正确数值，并在出问题时调用 <code>usage()</code> 函数。然后再设置 <code>RS</code> 与 <code>ORS</code> 为从命令行中取得的参数，并调协 <code>ARGV[1]</code> 与 <code>ARGV[2]</code> 为空串，这样它们就不会被当成文件名来处理（查看 see section <a href="#ARGC-and-ARGV">使用 <code>ARGC</code> 与 <code>ARGV</code></a>）。
</p>
<p><code>usage()</code> 函数会打印一个错误信息并退出。最后，一个简单的规则根据 <code>RT</code> 的值来相应地使用 <code>print</code> 与 <code>printf</code> 来打印之前确定好的方案。
</p>
<hr>
<a name="Igawk-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Simple-Sed" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Anagram-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8aa_00ba_0093aa_0087_00bdae_0095_00b0c_009a_0084c_00ae_0080aa_008d_0095ae_0096_00b9aa_00bc_008f"></a>
<h3 class="subsection">2.3.9 使用库函数的简单方式</h3>

<a name="index-libraries-of-awk-functions_002c-example-program-for-using"></a>
<a name="index-functions_002c-library_002c-example-program-for-using"></a>
<p>在 <a href="#Include-Files">在你的程序中包含其他的文件</a> 中我们看到了 <code>gawk</code> 如何来提供内置的文件包含能力。但是，这是 <code>gawk</code> 的扩展。
这一小节提供了让标准的 <code>awk</code> 有文件包含能力的动机，以及如何通过 Shell 与 <code>awk</code> 的编程组合来实现。
</p>
<p>使用在 <code>awk</code> 中的库函数用处非常大。它鼓励代码重用来写一些通用函数。程序看起来会更小更清晰。但是，写 <code>awk</code> 程序时使用库函数非常容易，但是运行他们时却很痛苦，因为需要多个 &lsquo;<samp>-f</samp>&rsquo; 选项。如果 <code>gawk</code> 不可用，则通过 <code>AWKPATH</code> 环境来变量来将 <code>awk</code> 函数放到库目录的能力也一样痛苦（查看 <a href="#Options">命令行参数</a>）。如果能以下面的方式来写程序则就非常好了：
</p>
<div class="example">
<pre class="example"># library functions
@include getopt.awk
@include join.awk
&hellip;

# main program
BEGIN {
    while ((c = getopt(ARGC, ARGV, &quot;a:b:cde&quot;)) != -1)
        &hellip;
    &hellip;
}
</pre></div>

<p>下面的程序 &lsquo;<tt>igawk.sh</tt>&rsquo; 提供了这样的服务。它模拟 <code>gawk</code> 的搜索 <code>AWKPATH</code> 变量的行为，并允许<em>嵌套</em>的包含（即被 <code>@include</code> 包含的文件可以再包含 <code>@include</code> 语句）。<code>igawk</code> 努力使文件只被包含一次，因此嵌套的包含不会偶然包含一个库函数两次。
</p>
<p><code>igawk</code> 应该外在表现得像 <code>gawk</code>。这就是说，它可以接收所有的 <code>gawk</code> 的命令行参数，包含通过 &lsquo;<samp>-f</samp>&rsquo; 指定多个源文件的能力以及能够混用命令行与库源文件的能力。
</p>
<p>程序使用 POSIX Shell（<code>sh</code>）命令语言写成。
<a name="DOCF82" href="#FOOT82">(82)</a>
它工作方式如下：
</p>
<ol>
<li>
当程序展开执行时，循环迭代参数，保存所有不代表 <code>awk</code> 源代码的参数以备用。

</li><li>
对于任何不代表 <code>awk</code> 文件的参数，将参数放到一个可展开的 Shell 变量中。有两种情形：

<ol>
<li>
对于由 &lsquo;<samp>-e</samp>&rsquo; 或者 &lsquo;<samp>--source</samp>&rsquo; 提供的字面文本。这个文本只是直接进行附加。

</li><li>
由 &lsquo;<samp>-f</samp>&rsquo; 参数提供的源文件名。我们使用一个小技巧，并附加 &lsquo;<samp>@include <var>filename</var></samp>&rsquo; 到 Shell 变量的内容中。由于文件包含程序如 <code>gawk</code> 一样的工作方式，这可以在正确的点取得程序中包含的文件的文本。
</li></ol>

</li><li>
在 Shell 变量之上，执行 <code>awk</code> 程序（自然地）来展开 <code>@include</code> 语句。被展开的程序放放在第二个 Shell 变量中。

</li><li>
用 <code>gawk</code> 运行展开的程序以及其他的用户提供的命令参数（例如数据文件名）。
</li></ol>

<p>这个程序扩展地使用 Shell 变量：用于存储命令行参数以及将会展开用户程序的 <code>awk</code> 程序的文本，用于用户的初始程序以及展开的程序。这么做可以移除一些当我们使用临时文件而导致的潜在的问题，但是代价就是使脚本带来一定的复杂性。
</p>
<p>程序的开始部分，如果第一个参数是 &lsquo;<samp>debug</samp>&rsquo;，则打开 Shell 的跟踪。
</p>
<p>下一个部分会循环所有的命令行参数。有几个情况非常有意思：
</p>
<dl compact="compact">
<dt>&lsquo;<samp>--</samp>&rsquo;</dt>
<dd><p>这由于结束 <code>igawk</code> 的参数。其他的任意参数应该被原样地传递到用户的 <code>awk</code> 程序。
</p>
</dd>
<dt>&lsquo;<samp>-W</samp>&rsquo;</dt>
<dd><p>这表示下一个选项是特定于 <code>gawk</code> 的。为了使参数处理更加容易，&lsquo;<samp>-W</samp>&rsquo; 被附加到剩下的参数的前面，然后继续循环。（这是一个 <code>sh</code> 的编程技巧。如果你不熟悉 <code>sh</code> 也不用担心。）
</p>
</dd>
<dt>&lsquo;<samp>-v</samp>&rsquo;, &lsquo;<samp>-F</samp>&rsquo;</dt>
<dd><p>这会被存储并被传递给 <code>gawk</code>。
</p>
</dd>
<dt>&lsquo;<samp>-f</samp>&rsquo;, &lsquo;<samp>--file</samp>&rsquo;, &lsquo;<samp>--file=</samp>&rsquo;, &lsquo;<samp>-Wfile=</samp>&rsquo;</dt>
<dd><p>使用 <code>@include</code> 语句把文件名附加到 Shell 变量程序 <code>program</code>。<code>expr</code> 工具用于移除参数前面的的选项部分（比如 &lsquo;<samp>--file=</samp>&rsquo;）。（典型的 <code>sh</code> 用法应该是使用 <code>echo</code> 以及 <code>sed</code> 工具来做这样的事情。很不幸的是，有一些版本的 <code>echo</code> 会对它的参数列表中的转义序列进行求值，有可能会弄乱程序文本。使用 <code>expr</code> 可以避免这个问题。）
</p>
</dd>
<dt>&lsquo;<samp>--source</samp>&rsquo;, &lsquo;<samp>--source=</samp>&rsquo;, &lsquo;<samp>-Wsource=</samp>&rsquo;</dt>
<dd><p>源代码被附加到程序 <code>program</code> 中。
</p>
</dd>
<dt>&lsquo;<samp>--version</samp>&rsquo;, &lsquo;<samp>-Wversion</samp>&rsquo;</dt>
<dd><p><code>igawk</code> 打印它的版本号，运行 &lsquo;<samp>gawk --version</samp>&rsquo; 来取得 <code>gawk</code> 的版本信息，然后退出。
</p></dd>
</dl>

<p>如果 &lsquo;<samp>-f</samp>&rsquo;，&lsquo;<samp>--file</samp>&rsquo;，&lsquo;<samp>-Wfile</samp>&rsquo;，&lsquo;<samp>--source</samp>&rsquo; 或者 &lsquo;<samp>-Wsource</samp>&rsquo; 参数一个都没有提供，则第一个非选项参数会用作 <code>awk</code> 的程序。如果没有其他的命令行参数，<code>igawk</code> 打印一个错误信息后退出。否则，第一个参数会被附加到程序 <code>program</code>。在任何情况下，在参数被处理后，Shell 变量程序包含最初 <code>awk</code> 程序的完全的文本。
</p>
<p>程序如下：
</p>
<a name="index-igawk_002esh-program"></a>
<div class="example">
<pre class="example">#! /bin/sh
# igawk --- like gawk but do @include processing

if [ &quot;$1&quot; = debug ]
then
    set -x
    shift
fi

# A literal newline, so that program text is formatted correctly
n='
'

# Initialize variables to empty
program=
opts=

while [ $# -ne 0 ] # loop over arguments
do
    case $1 in
    --)     shift
            break ;;

    -W)     shift
            # The ${x?'message here'} construct prints a
            # diagnostic if $x is the null string
            set -- -W&quot;${@?'missing operand'}&quot;
            continue ;;

    -[vF])  opts=&quot;$opts $1 '${2?'missing operand'}'&quot;
            shift ;;

    -[vF]*) opts=&quot;$opts '$1'&quot; ;;

    -f)     program=&quot;$program$n@include ${2?'missing operand'}&quot;
            shift ;;

    -f*)    f=$(expr &quot;$1&quot; : '-f\(.*\)')
            program=&quot;$program$n@include $f&quot; ;;

    -[W-]file=*)
            f=$(expr &quot;$1&quot; : '-.file=\(.*\)')
            program=&quot;$program$n@include $f&quot; ;;

    -[W-]file)
            program=&quot;$program$n@include ${2?'missing operand'}&quot;
            shift ;;

    -[W-]source=*)
            t=$(expr &quot;$1&quot; : '-.source=\(.*\)')
            program=&quot;$program$n$t&quot; ;;

    -[W-]source)
            program=&quot;$program$n${2?'missing operand'}&quot;
            shift ;;

    -[W-]version)
            echo igawk: version 3.0 1&gt;&amp;2
            gawk --version
            exit 0 ;;

    -[W-]*) opts=&quot;$opts '$1'&quot; ;;

    *)      break ;;
    esac
    shift
done

if [ -z &quot;$program&quot; ]
then
     program=${1?'missing program'}
     shift
fi

# At this point, `program' has the program.
</pre></div>

<p>处理 <code>@include</code> 指令的 <code>awk</code> 程序被存储在 Shell 的变量 <code>expand_prog</code> 中。这么做可以使得 Shell 脚本更可读。<code>awk</code> 程序使用 <code>getline</code> （查看 see section <a href="#Getline">用 <code>getline</code> 输入数据</a>）读取用户的程序，一次一行。输入文件名以及 <code>@include</code> 语句使用栈来管理。
每遇到一个 <code>@include</code>，当前的文件名会被推到栈中，在 <code>@include</code> 中的文件名则成为当前文件名。每完成一个文件，则会对栈进行弹出，这样前一个文件会成为当前文件。处理是以最开始的文件作为栈中的第一个文件开始的。
</p>
<p><code>pathto()</code> 函数处理查找文件全路径的事情。它模拟 <code>gawk</code> 的查找 <code>AWKPATH</code>（查看 see section <a href="#AWKPATH-Variable">环境变量 <code>AWKPATH</code></a>） 环境变量的行为。如果文件名中有 &lsquo;<samp>/</samp>&rsquo;，则不会进行路径搜索。
类似地，如果文件名是<code>&quot;-&quot;</code>，则相应的字串则原样不变。否则，文件名被与路径中的每一个上进进行连接，并尝试打开生成的文件名。唯一的测试文件是否可在 <code>awk</code> 中进行读取的方式是继续通过 <code>getline</code> 来尝试读取，这正是 <code>pathto()</code> 所做的。
<a name="DOCF83" href="#FOOT83">(83)</a>
如果文件可读，则关闭它，把返回文件名：
</p>

<div class="example">
<pre class="example">expand_prog='

function pathto(file,    i, t, junk)
{
    if (index(file, &quot;/&quot;) != 0)
        return file

    if (file == &quot;-&quot;)
        return file

    for (i = 1; i &lt;= ndirs; i++) {
        t = (pathlist[i] &quot;/&quot; file)
</pre><pre class="example">        if ((getline junk &lt; t) &gt; 0) {
            # found it
            close(t)
            return t
        }
</pre><pre class="example">    }
    return &quot;&quot;
}
</pre></div>

<p>主程序包含在 <code>BEGIN</code> 规则中。它所做的第一件事情就是设置一个 <code>pathlist</code> 数组给 <code>pathto()</code> 使用。在使用 &lsquo;<samp>:</samp>&rsquo; 分割路径之后，空的元素用 <code>&quot;.&quot;</code> 进行替换，它表示的是当前路径：
</p>
<div class="example">
<pre class="example">BEGIN {
    path = ENVIRON[&quot;AWKPATH&quot;]
    ndirs = split(path, pathlist, &quot;:&quot;)
    for (i = 1; i &lt;= ndirs; i++) {
        if (pathlist[i] == &quot;&quot;)
            pathlist[i] = &quot;.&quot;
    }
</pre></div>

<p>栈使用 <code>ARGV[1]</code> 来进行初始化，它的值为 <code>&quot;/dev/stdin&quot;</code>。后面则是主循环。输入行会一行行连续。不能 <code>@include</code> 开始的行则会原样打印。如果行确实是以 <code>@include</code> 开始的，则文件名会存储在 <code>$2</code> 中。
<code>pathto()</code> 用来产生完整的路径。如果没法产生，程序则打印一个错误信息后继续。
</p>
<p>下一个要做的事情就是检查文件是否已经被包含。已经处理的数组 <code>processed</code> 用已经包含的文件名的全名来进行索引，它会为我们跟踪相应的信息。如果文件再次看到，会打印一个警告信息。否则新的文件名会被推到栈中并继续处理。
</p>
<p>最后，当 <code>getline</code> 遇到了输入的文件尾，文件则被关闭，栈弹出。当 <code>stackptr</code> 小于 0 时，程序完成：
</p>
<div class="example">
<pre class="example">    stackptr = 0
    input[stackptr] = ARGV[1] # ARGV[1] is first file

    for (; stackptr &gt;= 0; stackptr--) {
        while ((getline &lt; input[stackptr]) &gt; 0) {
            if (tolower($1) != &quot;@include&quot;) {
                print
                continue
            }
            fpath = pathto($2)
</pre><pre class="example">            if (fpath == &quot;&quot;) {
                printf(&quot;igawk: %s:%d: cannot find %s\n&quot;,
                    input[stackptr], FNR, $2) &gt; &quot;/dev/stderr&quot;
                continue
            }
</pre><pre class="example">            if (! (fpath in processed)) {
                processed[fpath] = input[stackptr]
                input[++stackptr] = fpath  # push onto stack
            } else
                print $2, &quot;included in&quot;, input[stackptr],
                    &quot;already included in&quot;,
                    processed[fpath] &gt; &quot;/dev/stderr&quot;
        }
        close(input[stackptr])
    }
}'  # close quote ends `expand_prog' variable

processed_program=$(gawk -- &quot;$expand_prog&quot; /dev/stdin &lt;&lt; EOF
$program
EOF
)
</pre></div>

<p>Shell 的 &lsquo;<samp><var>command</var> &lt;&lt; <var>marker</var></samp>&rsquo; 结构称为<em>就地文档</em>。在 Shell 脚本中的到这个标志 <var>marker</var> 的所有内容都被当成是 <var>command</var> 的输入。 Shell 处理就地文档的内容用于变量与命令的替换（也可以是其他的事情，这要看 Shell）。
</p>
<p>Shell 的 &lsquo;<samp>$(&hellip;)</samp>&rsquo; 这样的结构称为<em>命令替换</em>。在括号中的命令的输出会替换命令行。因为结果会在变量赋值中使用，它会被存成一个单独的字串，就算结果包含空格。
</p>
<p>展开的程序被保存在变量 <code>processed_program</code> 中。它通过下面几步来完成：
</p>
<ol>
<li>
与从标准输入读取的 <code>@include</code> 程序一起执行 <code>gawk</code>（即 <code>expand_prog</code> Shell 变量的值）。

</li><li>
标准输入是用户程序的内容，来自于 Shell 变量程序 <code>program</code>。将它的内容通过就地文档的方式灌入 <code>gawk</code> 中。

</li><li>
将这个处理的结果使用命令替换存到 Shell 变量 <code>processed_program</code> 中。
</li></ol>

<p>最后一步使用展开的程序以及用户提供的最初的选项以及命令行参数调用 <code>gawk</code> ：
</p>
<div class="example">
<pre class="example">eval gawk $opts -- '&quot;$processed_program&quot;' '&quot;$@&quot;'
</pre></div>

<p><code>eval</code> 命令是一个 Shell 结果用来重新执行 Shell 的分析过程。这使得内容会被恰当地引起来。
</p>
<p><code>igawk</code> 的这个版本呈现了这个程序的第五个版本。有 4 个关键的简化使得程序运行得更好：
</p>
<ul>
<li>
使用 <code>@include</code> 使得最开始的集合 <code>awk</code> 程序更简单，即使是使用 &lsquo;<samp>-f</samp>&rsquo; 指定的文件名，所有的 <code>@include</code> 处理都可以一次完成。

</li><li>
当测试文件的可访问性，以在主程序中使用时，不会尝试存储在 <code>pathto()</code> 函数中使用 <code>getline</code> 读取的行。这使得事情得到相当的简化。

</li><li>
在 <code>BEGIN</code> 规则中使用 <code>getline</code> 在一个地方就完成所有的工作。没有必要再调用另外一个循环来处理嵌套的 <code>@include</code> 语句。

</li><li>
不将展开的程序存在一个临时文件中，而是将它们放在一个 Shell 变量中可以避免一些潜在的安全问题。但这也有缺点，因为脚本要依赖于 <code>sh</code> 语言的更多特性，使得那些不熟悉 <code>sh</code> 的人很验证于跟踪。
</li></ul>

<p>同时 ，这个程序也说明了将 <code>sh</code> 与 <code>awk</code> 程序混合使用是值得一试的。你可以通过这样来完成很多的事情，不用寻求更加底层的 C 或者 C++ 语言，通常在 Shell 中要比 <code>awk</code> 也更容易来处理特定类型的字串与参数操作。
</p>
<p>最后 <code>igawk</code> 展示了给程序添加新的特性并不总是必要的，它们可以一层层叠加来实现。 
<a name="DOCF84" href="#FOOT84">(84)</a>
</p>

<hr>
<a name="Anagram-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Igawk-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Signature-Program" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008eaa_00ad_0097aa_0085_00b8a_00b8_00adae_009f_00a5ae_0089_00beaa_008d_0095e_00af_008d"></a>
<h3 class="subsection">2.3.10 从字典中查找单词</h3>

<a name="index-anagrams_002c-finding"></a>
<p>一个有趣的编程挑战就是在一个单词列表中查找<em>同字母异序词</em>（词的字母顺序变换后组成的新词，如在很多的 GNU/Linux 系统中的 &lsquo;<tt>/usr/share/dict/words</tt>&rsquo;）。如果两个单词包含相同的字母，则一个单词是另一个单词的字谜（如 “babbling” 与 “blabbing”）。
</p>
<p>Jon Bentley 所著的书 <cite>Programming Pearls</cite>，第二版，第二卷的问题 C，提出了一个优雅的算法。其思想是给单词的字谜一个共同的简单，并通过这些签名来对单词进行排序，然后打印它们。Bentley 博士发现发现用每个单词中出现的字母，并对它们排序来作为单词的签名.
</p>
<p>下面的程序使用多维数组来将有相同签名的单词组织在一起，以及对数组排序来以有序的方式打印单词：
</p>
<a name="index-anagram_002eawk-program"></a>
<div class="example">
<pre class="example"># anagram.awk --- An implementation of the anagram-finding algorithm
#                 from Jon Bentley's &quot;Programming Pearls,&quot; 2nd edition.
#                 Addison Wesley, 2000, ISBN 0-201-65788-0.
#                 Column 2, Problem C, section 2.8, pp 18-20.

/'s$/   { next }        # Skip possessives
</pre></div>

<p>程序以一个头部开始，然后跳过在字典文件中的所有格。下一个规则则是用来建立数组结构。数组的第一维由签名来进行索引，第二维则是单词本身：
</p>
<div class="example">
<pre class="example">{
    key = word2key($1)  # Build signature
    data[key][$1] = $1  # Store word with signature
}
</pre></div>

<p><code>word2key()</code> 用来创建签名，它将单词分成一个个的字符，并对字符进行排序，然后再将它全合并：
</p>
<div class="example">
<pre class="example"># word2key --- split word apart into letters, sort, and join back together

function word2key(word,     a, i, n, result)
{
    n = split(word, a, &quot;&quot;)
    asort(a)

    for (i = 1; i &lt;= n; i++)
        result = result a[i]

    return result
}
</pre></div>

<p>最后，<code>END</code> 规则用来遍历数组，然后打出出字谜列表。它会将输出系统的 <code>sort</code> 工具，因为不这么处理，字谜就会以随机的顺序出现：
</p>
<div class="example">
<pre class="example">END {
    sort = &quot;sort&quot;
    for (key in data) {
        # Sort words with same key
        nwords = asorti(data[key], words)
        if (nwords == 1)
            continue

        # And print. Minor glitch: trailing space at end of each line
        for (j = 1; j &lt;= nwords; j++)
            printf(&quot;%s &quot;, words[j]) | sort
        print &quot;&quot; | sort
    }
    close(sort)
}
</pre></div>

<p>程序运行时，下面是部分输出：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f anagram.awk /usr/share/dict/words | grep '^b'</kbd>
&hellip;
babbled blabbed
babbler blabber brabble
babblers blabbers brabbles
babbling blabbing
babbly blabby
babel bable
babels beslab
babery yabber
&hellip;
</pre></div>


<hr>
<a name="Signature-Program"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Anagram-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Programs-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009d_00a5a_00ba_009bae_0096_00b0e_00b2_009cc_009a_0084"></a>
<h3 class="subsection">2.3.11 来些新鲜的</h3>

<a name="index-signature-program"></a>
<a name="index-Brini_002c-Davide"></a>
<p>下面的程序由 Davide Brini 编写并发布在了<a href="http://backreference.org/2011/02/03/obfuscated-awk/">他的网站</a>上。
它用来作为他在 Usenet 小组 <code>comp.lang.awk</code> 的签名。它提供了下面的版本声明：
</p>
<blockquote>
<p>Copyright &copy; 2008 Davide Brini
</p>
<p>无论是否修改都允许在任何介质上，复制发布本页中公开的代码，而不需要提供正式的版本声明，只要保留本提示即可。
</p></blockquote>

<p>这里它的程序：
</p>
<div class="example">
<pre class="example">awk 'BEGIN{O=&quot;~&quot;~&quot;~&quot;;o=&quot;==&quot;==&quot;==&quot;;o+=+o;x=O&quot;&quot;O;while(X++&lt;=x+o+o)c=c&quot;%c&quot;;
printf c,(x-O)*(x-O),x*(x-o)-o,x*(x-O)+x-O-o,+x*(x-O)-x+o,X*(o*o+O)+x-O,
X*(X-x)-o*o,(x+X)*o*o+o,x*(X-x)-O-O,x-O+(O+o+X+x)*(o+O),X*X-X*(x-O)-x+O,
O+X*(o*(o+O)+O),+x+O+X*o,x*(x-o),(o+X+x)*o*o-(x-O-O),O+(X-x)*(X+O),x-O}'
</pre></div>

<a name="index-Johansen_002c-Chris"></a>
<p>程序做的事情由你来确定。（如果你真的在理解它时绝望了，查看 Chris Johansen 的解释，该解释内嵌在本网页的 Texinfo 源文件中。
</p>

<hr>
<a name="Programs-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Signature-Program" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Programs-Exercises" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-16"></a>
<h2 class="section">2.4 总结</h2>

<ul>
<li>
本章中提供的程序，延续了这样的主旨，就是要学好编程的终极方法就是去阅读程序。

</li><li>
使用 &lsquo;<samp>#!</samp>&rsquo; 来使用 <code>awk</code> 程序可以直接运行而更好使用。否则就得这么来调用程序：&lsquo;<samp>awk -f &hellip;</samp>&rsquo;。

</li><li>
用 <code>awk</code> 重新实现标准的 POSIX 程序是一个令人愉快的练习，<code>awk</code> 的表达的威力你以让你用很少的代码就来写出这样的程序，同时功能完备并且可用。

</li><li>
<code>awk</code> 的一个弱点之一就是在处理单个字符的时候。使用 <code>split()</code> 以及空串来作为分隔符字串的能力可以极大地简化这个工作。

</li><li>
这里的例子表明了来自 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a> 的库函数对于很多的（小）程序的用处。

</li><li>
除了重新发明 POSIX 轮子，其他的程序可以解释很多的有趣的问题，如查找文本中的重复单词，打印邮件标签，或者查找字谜等。

</li></ul>

<hr>
<a name="Programs-Exercises"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Programs-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Programs" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bb_0083a_00b9_00a0-1"></a>
<h2 class="section">2.5 练习</h2>

<ol>
<li>
使用 <code>&quot;&quot;</code> 作为分隔符来调用 <code>split()</code> 来重写 &lsquo;<tt>cut.awk</tt>&rsquo;（查看 see section <a href="#Cut-Program">剪切域与列</a>）。

</li><li>
在 <a href="#Egrep-Program">用正则表达式在文件中搜索</a>，中我们提到过 &lsquo;<samp>egrep -i</samp>&rsquo; 可以使用 <code>tolower()</code> 用于行与模式来模拟 <code>awk</code> 中没有 <code>IGNORECASE</code> 版本的情况。在那个里的一个脚注中，我们也提到这个解决方案有一个 Bug：被转换的行输出后，不是原来的那行。请修复这个问题。

</li><li>
POSIX 版本的 <code>id</code> 通过选项来控制要打印什么样的信息。修改 <code>awk</code> 版本（查看 see section <a href="#Id-Program">打印用户信息</a>）来接收相同的参数并执行相同的结果。

</li><li>
<code>split.awk</code> 程序（查看 see section <a href="#Split-Program">将大文件分片</a>）假设字母在字符集是连续的，但是对于 EBCDIC 的系统上却不是这样的。请修复这个问题。（提示：考虑一种不同的方法来遍历字母表，而不是使用 <code>ord()</code> 与 <code>chr()</code> 函数。）

</li><li>
在 &lsquo;<tt>uniq.awk</tt>&rsquo; 中（查看 see section <a href="#Uniq-Program">打印去重文本行</a>），选择哪一些来打印的逻辑表式一种<em>状态机</em>，即“某个设备可以处于某些稳定的状态依赖于其前面的状态以及它输入的当前值”。
<a name="DOCF85" href="#FOOT85">(85)</a>
Brian Kernighan 则建议“状态机的另一种方式是只将输入读到数组中，然后直接使用索引。这几乎总是能够使用更简单的代码来实现，在你使用这个方式的大多数输入中，是非常快的。”请根据这样的建议来重写上面的逻辑。


</li><li>
为什么 &lsquo;<tt>wc.awk</tt>&rsquo;（查看 see section <a href="#Wc-Program">统计</a>）程序不可以在 <code>endfile()</code> 中使用 <code>FNR</code> 的值？提示：检查 <a href="#Filetrans-Function">注意数据文件的边界</a>，中的代码。


</li><li>
在转换程序 <code>translate</code>（查看 see section <a href="#Translate-Program">转换字符</a>）中使用标准 <code>awk</code> 函数操作单个的字符是很痛苦的。假设 <code>gawk</code> 可以用 <code>&quot;&quot;</code> 作分隔符来将字串分割为单独的字符，你会如何使用这个特定来简化程序？

</li><li>
&lsquo;<tt>extract.awk</tt>&rsquo; 程序（查看 see section <a href="#Extract-Program">从 Texinfo 源文件中提取程序</a>）是在 <code>gawk</code> 有 <code>gensub()</code> 函数之前写的。使用它来简化代码。

</li><li>
用更直接的方式来比较 &lsquo;<tt>awksed.awk</tt>&rsquo; 程序（查看 see section <a href="#Simple-Sed">一个简单的流编辑器</a>）的性能：

<div class="example">
<pre class="example">BEGIN {
    pat = ARGV[1]
    repl = ARGV[2]
    ARGV[1] = ARGV[2] = &quot;&quot;
}

{ gsub(pat, repl); print }
</pre></div>

</li><li>
与真正的 <code>sed</code> 工具比起来，&lsquo;<tt>awksed.awk</tt>&rsquo; 有什么样的优缺点？


</li><li>
在 <a href="#Igawk-Program">使用库函数的简单方式</a> 中我们提到，当在测试文件的可访问性时，不要尝试在 <code>pathto()</code> 函数中将 <code>getline</code> 读取的行进行保存，可以与主程序的一起使用时，极大地简化实现。那么这里面到底有什么问题？

<a name="index-search-paths"></a>
<a name="index-search-paths_002c-for-source-files-1"></a>
<a name="index-source-files_002c-search-path-for"></a>
<a name="index-files_002c-source_002c-search-path-for"></a>
<a name="index-directories_002c-searching"></a>
</li><li>
作为并不总是需要给程序加新功能的想法的一个额外的例子就是，假设有两个文件在搜索路径下的想法：

<dl compact="compact">
<dt>&lsquo;<tt>default.awk</tt>&rsquo;</dt>
<dd><p>这个文件包含默认函数集，如 <code>getopt()</code> 与 <code>assert()</code>。
</p>
</dd>
<dt>&lsquo;<tt>site.awk</tt>&rsquo;</dt>
<dd><p>这个文件包含的库函数特定于某个点或者安装版本，如本地的开发函数。用这样的一个独立文件可以使 &lsquo;<tt>default.awk</tt>&rsquo; 跟随 <code>gawk</code> 版本一同更新，而不需要系统的管理员添加一个本地函数的时候总是要更新它。
</p></dd>
</dl>

<p>某个用户
曾经建议 <code>gawk</code> 要修改成自动地在启动时读取这些文件。但是修改 <code>igawk</code> 来实现这个功能会更加简单。因为 <code>igawk</code> 可以处理嵌套的 <code>@include</code> 指示符，&lsquo;<tt>default.awk</tt>&rsquo; 可以只是简单地包含 <code>@include</code> 语句来引入所需要的库函数。请你做这些修改。
</p>
</li><li>
修改 &lsquo;<tt>anagram.awk</tt>&rsquo;（查看 see section <a href="#Anagram-Program">从字典中查找单词</a>）来避免使用外部的 <code>sort</code> 工具。

</li></ol>

<hr>
<a name="c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Sample-Programs" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Programs-Exercises" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Nondecimal-Data" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="part">第三部分:<br> 用 <code>gawk</code> 超越标准 <code>awk</code></h1>
<hr>


<a name="Advanced-Features"></a>
<a name="gawk-c_009a_0084e_00ab_0098c_00ba_00a7c_0089_00b9ae_0080_00a7"></a>
<h1 class="chapter">1 <code>gawk</code> 的高级特性</h1>
<a name="index-gawk_002c-features_002c-advanced"></a>
<a name="index-advanced-features_002c-gawk"></a>
<a name="index-Langston_002c-Peter"></a>
<a name="index-English_002c-Steve"></a>
<blockquote>
<p><i>
写文档就要像把读它的人当成知道你住在哪的狂暴的精神变态者。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Steve English, as quoted by Peter Langston</em>
</p>
<p>这一章讨论 <code>gawk</code> 中的高级特性。他们只是互不相关的程序大麻袋中的一小点。首先，我们会看一下使 <code>gawk</code> 不识别输入数据，而不仅仅是在 <code>awk</code> 程序中的十进制点的选项。然后，再讨论 <code>gawk</code> 所特有的对数组进行排序的特性。接下来是双路 I/O 问题，在这之前有过简单的讨论，这里将与 TCP/IP 网络一起进行详细的讨论。最后，我们看一下 <code>gawk</code> 如何来进行<em>评测</em> <code>awk</code> 程序，这样可以来对它进行性能上的调优。
</p>
<p>其他的高级特性则在其他的章中进行讨论：
</p>
<ul>
<li>
<a href="#Internationalization"><code>gawk</code> 的国际化</a>，讨论如何来对你的 <code>awk</code> 程序进行国际化，这样它们可以说多国语言。

</li><li>
<a href="#Debugger">调试 <code>awk</code> 程序</a>，描述了 <code>gawk</code> 的内置的命令行调试器来进行 <code>gawk</code> 程序的调试。

</li><li>
<a href="#Arbitrary-Precision-Arithmetic">算术运算与 <code>gawk</code> 中的任意精度算术运算</a>，展示了你如何来使用 <code>gawk</code> 来进行任意精度的算术运算。

</li><li>
<a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>，讨论动态地给 <code>gawk</code> 添加新的内置函数的能力。
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Allowing nondecimal input data.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Sorting">1.2 控制数组排序与遍历</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Facilities for controlling array traversal and
                                sorting arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Two-way communications with another process.
</td></tr>
<tr><td align="left" valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Using <code>gawk</code> for network programming.
</td></tr>
<tr><td align="left" valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Profiling your <code>awk</code> programs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Advanced-Features-Summary">1.6 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Summary of advanced features.
</td></tr>
</table>

<hr>
<a name="Nondecimal-Data"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Sorting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_0081e_00ae_00b8e_009d_009eaa_008d_0081e_00bf_009baa_0088_00b6ae_0095_00b0ae_0095_00b0ae_008d_00aee_00be_0093aa_0085_00a5"></a>
<h2 class="section">1.1 允许非十进制数数据输入</h2>
<a name="index-_002d_002dnon_002ddecimal_002ddata-option-1"></a>
<a name="index-advanced-features_002c-nondecimal-input-data"></a>
<a name="index-input_002c-data_002c-nondecimal"></a>
<a name="index-constants_002c-nondecimal"></a>

<p>如果你用 &lsquo;<samp>--non-decimal-data</samp>&rsquo; 这个选项来运行 <code>gawk</code>，你可以在你的输入数据中使用非十进制数数值：
</p>
<div class="example">
<pre class="example">$ <kbd>echo 0123 123 0x123 |</kbd>
&gt; <kbd>gawk --non-decimal-data '{ printf &quot;%d, %d, %d\n&quot;, $1, $2, $3 }'</kbd>
-| 83, 123, 291
</pre></div>

<p>为了你这个特性可以工作，你需要在写程序时让 <code>gawk</code> 将这些数据当成是数值：
</p>
<div class="example">
<pre class="example">$ <kbd>echo 0123 123 0x123 | gawk '{ print $1, $2, $3 }'</kbd>
-| 0123 123 0x123
</pre></div>

<p><code>print</code> 语句将它的表达式当成是字串。尽管域在需要的时候可以表现成一个数值，但它们依然是字串，所以 <code>print</code> 不会尝试将它们以数值来看待。你需要向域加上一个 0 来强制它被当成数值。比如：
</p>
<div class="example">
<pre class="example">$ <kbd>echo 0123 123 0x123 | gawk --non-decimal-data '</kbd>
&gt; <kbd>{ print $1, $2, $3</kbd>
&gt;   <kbd>print $1 + 0, $2 + 0, $3 + 0 }'</kbd>
-| 0123 123 0x123
-| 83 123 291
</pre></div>

<p>由于有十进制数之前有前导的 0 是很常见的，也由于使用这样的方式可能导致令人惊讶的结果，默认的情况是禁用的。如果你想使用，你必须显式地来指定它。
</p>
<a name="index-programming-conventions_002c-_002d_002dnon_002ddecimal_002ddata-option"></a>
<a name="index-_002d_002dnon_002ddecimal_002ddata-option_002c-strtonum_0028_0029-function-and"></a>
<a name="index-strtonum_0028_0029-function-_0028gawk_0029_002c-_002d_002dnon_002ddecimal_002ddata-option-and"></a>
<blockquote>
<p><b>注意:</b> <em>不推荐使用这个选项。</em>它会导致旧程序非常糟糕地破坏。相反，要使用 <code>strtonum()</code> 函数来转换你的数据（查看 <a href="#String-Functions">字串操作函数</a>）。这也使得你的程序更容易写，也更容易读，结果也不那么令人惊讶。
</p>
<p>这个选项可能在 <code>gawk</code> 的后续版本中消失。
</p></blockquote>

<hr>
<a name="Array-Sorting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Nondecimal-Data" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Controlling-Array-Traversal" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008e_00a7aa_0088_00b6ae_0095_00b0c_00bb_0084ae_008e_0092aa_00ba_008fa_00b8_008ee_0081_008daa_008e_0086"></a>
<h2 class="section">1.2 控制数组排序与遍历</h2>

<p><code>gawk</code> 可以让你在 &lsquo;<samp>for (<var>indx</var> in <var>array</var>)</samp>&rsquo; 的循环迭代数组时控制其顺序。
</p>
<p>另外，有两个内置的函数，<code>asort()</code> 与 <code>asorti()</code> 让你用基于数组的值与索引来对数组进行排序。还有两个函数用来在排序过程中控制元素的顺序的排序方案。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Controlling-Array-Traversal">1.2.1 控制数据遍历</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> How to use PROCINFO[&quot;sorted_in&quot;].
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     How to use <code>asort()</code> and <code>asorti()</code>.
</td></tr>
</table>

<hr>
<a name="Controlling-Array-Traversal"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Sorting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Sorting" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Sorting-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008e_00a7aa_0088_00b6ae_0095_00b0ae_008d_00aee_0081_008daa_008e_0086"></a>
<h3 class="subsection">1.2.1 控制数据遍历</h3>

<p>在默认情况下，在 &lsquo;<samp>for (<var>indx</var> in <var>array</var>)</samp>&rsquo; 循环中来扫描数组的顺序是未定义的，它一般基于 <code>awk</code> 中对于数组的实现。
</p>
<p>通常情况下，做为程序员的你是想来以某种特定的顺序来循环数组中的元素的。<code>gawk</code> 可以让你做到这个。
</p>
<p><a href="#Controlling-Scanning">在 <code>gawk</code> 中使用预定义的数组遍历顺序</a> 中描述了你可以赋值给某个特定预定义的变量 <code>PROCINFO[&quot;sorted_in&quot;]</code> 以来控制 <code>gawk</code> 在 <code>for</code> 循环数组时的顺序。
</p>
<p>另外，<code>PROCINFO[&quot;sorted_in&quot;]</code> 的值可以是一个函数名。 
<a name="DOCF86" href="#FOOT86">(86)</a>
这让你用自己定义的方案来遍历数组。数组的元素的排序由这个函数的返回值来决定。比较函数应该定义成至少有四个参数：
</p>
<div class="example">
<pre class="example">function comp_func(i1, v1, i2, v2)
{
    <var>compare elements 1 and 2 in some fashion</var>
    <var>return &lt; 0; 0; or &gt; 0</var>
}
</pre></div>

<p>这里面 <code>i1</code> 与 <code>i2</code> 是索引，而 <code>v1</code> 与 <code>v2</code> 是两个正在比较的元素的值。如果正在被遍历的数组包含了子数组元素，<code>v1</code> 与 <code>v2</code> 之一或者两者都可能是数组。（查看 <a href="#Arrays-of-Arrays">多维数组</a>，来取得子数组的更多信息）三中可能的返回值如下所述：
</p>
<dl compact="compact">
<dt><code>comp_func(i1, v1, i2, v2) &lt; 0</code></dt>
<dd><p>在循环遍历时，索引 <code>i1</code> 会先于 <code>i2</code>。
</p>
</dd>
<dt><code>comp_func(i1, v1, i2, v2) == 0</code></dt>
<dd><p>索引 <code>i1</code> 与 <code>i2</code> 是相同的，但是其相对顺序是未定义的。
</p>
</dd>
<dt><code>comp_func(i1, v1, i2, v2) &gt; 0</code></dt>
<dd><p>索引 <code>i1</code> 后在 <code>i2</code> 之后。
</p></dd>
</dl>

<p>我们的第一个比较函数可以以索引的数值顺序来扫描数组：
</p>
<div class="example">
<pre class="example">function cmp_num_idx(i1, v1, i2, v2)
{
     # numerical index comparison, ascending order
     return (i1 - i2)
}
</pre></div>

<p>我们的第二个函数基于元素的字串值来遍历数组，而不是基于索引：
</p>
<div class="example">
<pre class="example">function cmp_str_val(i1, v1, i2, v2)
{
    # string value comparison, ascending order
    v1 = v1 &quot;&quot;
    v2 = v2 &quot;&quot;
    if (v1 &lt; v2)
        return -1
    return (v1 != v2)
}
</pre></div>

<p>第三个比较函数使所有的数值，前后没空格的数字字串，会在循环时在前面：
</p>
<div class="example">
<pre class="example">function cmp_num_str_val(i1, v1, i2, v2,   n1, n2)
{
     # numbers before string value comparison, ascending order
     n1 = v1 + 0
     n2 = v2 + 0
     if (n1 == v1)
         return (n2 == v2) ? (n1 - n2) : -1
     else if (n2 == v2)
         return 1
     return (v1 &lt; v2) ? -1 : (v1 != v2)
}
</pre></div>

<p>这是一个说明 <code>gawk</code> 使用前面不同函数时的不同表现时的主程序：
</p>
<div class="example">
<pre class="example">BEGIN {
    data[&quot;one&quot;] = 10
    data[&quot;two&quot;] = 20
    data[10] = &quot;one&quot;
    data[100] = 100
    data[20] = &quot;two&quot;

    f[1] = &quot;cmp_num_idx&quot;
    f[2] = &quot;cmp_str_val&quot;
    f[3] = &quot;cmp_num_str_val&quot;
    for (i = 1; i &lt;= 3; i++) {
        printf(&quot;Sort function: %s\n&quot;, f[i])
        PROCINFO[&quot;sorted_in&quot;] = f[i]
        for (j in data)
            printf(&quot;\tdata[%s] = %s\n&quot;, j, data[j])
        print &quot;&quot;
    }
}
</pre></div>

<p>这是程序执行时的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f compdemo.awk</kbd>
-| Sort function: cmp_num_idx      <i>Sort by numeric index</i>
-|     data[two] = 20
-|     data[one] = 10              <i>Both strings are numerically zero</i>
-|     data[10] = one
-|     data[20] = two
-|     data[100] = 100
-|
-| Sort function: cmp_str_val      <i>Sort by element values as strings</i>
-|     data[one] = 10
-|     data[100] = 100             <i>String 100 is less than string 20</i>
-|     data[two] = 20
-|     data[10] = one
-|     data[20] = two
-|
-| Sort function: cmp_num_str_val  <i>Sort all numeric values before all strings</i>
-|     data[one] = 10
-|     data[two] = 20
-|     data[100] = 100
-|     data[10] = one
-|     data[20] = two
</pre></div>

<p>考虑对 GNU/Linux 系统的密码文件中的项按登录名来排序。下面的程序对特定域位置的比较来进行记录的排序可用于这个目的：
</p>
<div class="example">
<pre class="example"># passwd-sort.awk --- simple program to sort by field position
# field position is specified by the global variable POS

function cmp_field(i1, v1, i2, v2)
{
    # comparison by value, as string, and ascending order
    return v1[POS] &lt; v2[POS] ? -1 : (v1[POS] != v2[POS])
}

{
    for (i = 1; i &lt;= NF; i++)
        a[NR][i] = $i
}

END {
    PROCINFO[&quot;sorted_in&quot;] = &quot;cmp_field&quot;
    if (POS &lt; 1 || POS &gt; NF)
        POS = 1
    for (i in a) {
        for (j = 1; j &lt;= NF; j++)
            printf(&quot;%s%c&quot;, a[i][j], j &lt; NF ? &quot;:&quot; : &quot;&quot;)
        print &quot;&quot;
    }
}
</pre></div>

<p>密码文件中的每一项的第一个域是用户的登录名，域之间通过冒号分隔。每个记录都定义了一个子数组，每个域都是子数组中的一个元素。执行程序会产生如下输出：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -v POS=1 -F: -f sort.awk /etc/passwd</kbd>
-| adm:x:3:4:adm:/var/adm:/sbin/nologin
-| apache:x:48:48:Apache:/var/www:/sbin/nologin
-| avahi:x:70:70:Avahi daemon:/:/sbin/nologin
&hellip;
</pre></div>

<p>当给定一个特定的数组元素对时，比较应该总是返回相同的值。如果返回了不一致的值，则顺序是未定义的。这个行为可以用来给看起来有序的数据引入随机顺序：
</p>
<div class="example">
<pre class="example">function cmp_randomize(i1, v1, i2, v2)
{
    # random order (caution: this may never terminate!)
    return (2 - 4 * rand())
}
</pre></div>

<p>如早前所提到的，如果两个元素比较相同，则两个元素的索引的顺序是任意的。这一般都不是什么问题，但是让两个在一起的元素以任意的顺序出现却是个问题，特别是大比较两者的值的时候。如果其他的元素加入或者从数组中移除，对相同元素间的部分排序在下次数组遍历时会改变。解决这个绑定元素的问题的方法之一是，当比较两元素值相同时，要再比较它们的索引。这么做的话，会使得循环遍历没有那高效，所以，只在必要的时候考虑使用它。下面的比较函数会一定会有确定的顺序，是基于两个元素的索引（字串）肯定不相同这样的事实：
</p>
<div class="example">
<pre class="example">function cmp_numeric(i1, v1, i2, v2)
{
    # numerical value (and index) comparison, descending order
    return (v1 != v2) ? (v2 - v1) : (i2 - i1)
}

function cmp_string(i1, v1, i2, v2)
{
    # string value (and index) comparison, descending order
    v1 = v1 i1
    v2 = v2 i2
    return (v1 &gt; v2) ? -1 : (v1 != v2)
}
</pre></div>


<p>一个定制的比较函数常常可以简单循环遍历，而设计这样的函数的限制只受限于天空的大小。
</p>
<p>当在进行排序时，如果使用的是字串比较，元素值之一或者两者都不会是数值，或者元素的索引会被当成字串来处理，<code>IGNORECASE</code> 的值（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）控制比较是否将对应的大小写字母当成一样的字符来看待。
</p>
<p>还要记住的一点是在子数组的情况下，元素值本身可以是数组，比较函数的结果应该使用 <code>isarray()</code> 函数（查看 see section <a href="#Type-Functions">获取类型信息</a>）来检测，并使用为子数组定义好的顺序。
</p>
<p>所有基于 <code>PROCINFO[&quot;sorted_in&quot;]</code> 的排序在 POSIX 模式下都被禁用，因为 <code>PROCINFO</code> 数组在此种情况下并没有特殊的含义。
</p>
<p>另一个提示就是，在遍历数组时对数组索引的排序已经有报告说会增加 <code>awk</code> 程序执行时 15 % 到 20 % 的负荷。由于这个原因，排序数组的遍历不作为默认行为。
</p>

<hr>
<a name="Array-Sorting-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Controlling-Array-Traversal" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Sorting" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Two_002dway-I_002fO" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_0094_00a8-gawk-aa_00af_00b9ae_0095_00b0c_00bb_0084e_00bf_009be_00a1_008caa_0080_00bca_00b8_008ee_0094_00aec_009a_0084ae_008e_0092aa_00ba_008f"></a>
<h3 class="subsection">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</h3>

<a name="index-arrays_002c-sorting"></a>
<a name="index-asort_0028_0029-function-_0028gawk_0029-1"></a>
<a name="index-asort_0028_0029-function-_0028gawk_0029_002c-arrays_002c-sorting"></a>
<a name="index-asorti_0028_0029-function-_0028gawk_0029-1"></a>
<a name="index-asorti_0028_0029-function-_0028gawk_0029_002c-arrays_002c-sorting"></a>
<a name="index-sort-function_002c-arrays_002c-sorting"></a>
<p>在大多数的 <code>awk</code> 实现中，对数组排序需要写一个 <code>sort()</code> 函数。这对于学习不同的排序算法也是很有教育作用的，但是通过那不是程序的重点。<code>gawk</code> 提供了内置的 <code>asort()</code> 与 <code>asorti()</code> 函数（查看 see section <a href="#String-Functions">字串操作函数</a>）来对数组排序。如：
</p>
<div class="example">
<pre class="example"><var>populate the array</var> data
n = asort(data)
for (i = 1; i &lt;= n; i++)
    <var>do something with</var> data[i]
</pre></div>

<p>在调用 <code>asort()</code> 之后，数组数据 <code>data</code> 已经从 1 到某个数 <var>n</var>，即 <code>data</code> 数组元素中的总数，进行了索引。（这个统计作为 <code>asort()</code> 的返回值。）<code>data[1]</code> &lt;= <code>data[2]</code> &lt;= <code>data[3]</code> 依此类推。
默认的比较是基于元素的类型（查看 see section <a href="#Typing-and-Comparison">变量类型与比较表达式</a>）。所有的数值类型在字串类型之前，然后是所有的子数组。
</p>
<a name="index-side-effects_002c-asort_0028_0029-function"></a>
<p>调用 <code>asort()</code> 函数的一个重要的副作用是<em>数组的原始的索引不可恢复地丢失了</em>。这并不总是所要的结果。<code>asort()</code> 可以授受第二个参数：
</p>
<div class="example">
<pre class="example"><var>populate the array</var> source
n = asort(source, dest)
for (i = 1; i &lt;= n; i++)
    <var>do something with</var> dest[i]
</pre></div>

<p>在这种情况下，<code>gawk</code> 会复制 <code>source</code> 数组到 <code>dest</code> 数组中，然后对 <code>dest</code> 进行排序，并导致其索引的破坏。但是，<code>source</code> 数组则不影响。
</p>
<p>经常情况下，是需要对<em>索引</em>的值进行排序，而不是对元素的值进行排序。为了实现这个功能，则使用 <code>asorti()</code> 函数。这个接口与其行为与 <code>asort()</code> 是一样的，只是使用索引的值来进行排序，并且成为结果数组的值：
</p>
<div class="example">
<pre class="example">{ source[$0] = some_func($0) }

END {
    n = asorti(source, dest)
    for (i = 1; i &lt;= n; i++) {
        <i>Work with sorted indices directly:</i>
        <var>do something with</var> dest[i]
        &hellip;
        <i>Access original array via sorted indices:</i>
        <var>do something with</var> source[dest[i]]
    }
}
</pre></div>

<p>到目前为止都还好。现在开始进入最有趣的部分。<code>asort()</code> 与 <code>asorti()</code> 都接收第三个字串参数来控制数组元素的比较。当我们在 <a href="#String-Functions">字串操作函数</a>，引入 <code>asort()</code> 与 <code>asorti()</code> 时，我们忽略了第三个参数，但是现在是时候来描述这个参数如何来影响这两个函数。
</p>
<p>基本上，第三个参数用来指定数组如何来进行排序。有两个可能。如 <code>PROCINFO[&quot;sorted_in&quot;]</code> 一样，这个参数可以是 <code>gawk</code> 所提供的预定义名字中的一个（查看 see section <a href="#Controlling-Scanning">在 <code>gawk</code> 中使用预定义的数组遍历顺序</a>），或者也可以用户自定义函数的名字（查看 see section <a href="#Controlling-Array-Traversal">控制数据遍历</a>）。
</p>
<p>在后面的情况下，<em>指定的函数可以以任何选择的方式来比较元素</em>，可以只考虑索引，也可以只考虑值，或者两者都考虑。这就相当强大了。
</p>
<p>一旦数组经过排序，<code>asort()</code> 会取得最终顺序的值，并使用他们填入到结果数组中，而 <code>asorti()</code> 取最终顺序的<em>索引</em>并使用它们填充到结果数组中。
</p>
<a name="index-reference-counting_002c-sorting-arrays"></a>
<blockquote>
<p><b>提示:</b> 复制数组的索引与元素在内存中代价并不高。在内部，<code>gawk</code> 会保持数据的<em>参考计数</em>。如当 <code>asort()</code> 复制第一个元素到第二个时，只会有一个元素数据的复本，就算两个数组使用这个值。
</p></blockquote>

<a name="index-gawk_002c-IGNORECASE-variable-in-4"></a>
<a name="index-arrays_002c-sorting_002c-and-IGNORECASE-variable"></a>
<a name="index-IGNORECASE-variable_002c-and-array-sorting-functions"></a>
<p>因为 <code>IGNORECASE</code> 可以影响字串比较，<code>IGNORECASE</code> 的值也会影响 <code>asort()</code> 与 <code>asorti()</code> 的排序。也要注意本地语言设置中的排序则<em>不会</em>有影响，比较只基于字符的值。 
<a name="DOCF87" href="#FOOT87">(87)</a>
</p>
<p>下面的是把 <code>asort()</code> 用于比较函数的例子。比较函数 <code>case_fold_compare()</code> 为了能忽略大小写比较，把两者的值都转换成小写字母。
</p>
<div class="example">
<pre class="example"># case_fold_compare --- compare as strings, ignoring case

function case_fold_compare(i1, v1, i2, v2,    l, r)
{
    l = tolower(v1)
    r = tolower(v2)

    if (l &lt; r)
        return -1
    else if (l == r)
        return 0
    else
        return 1
}
</pre></div>

<p>下面是它的测试程序：
</p>
<div class="example">
<pre class="example"># Test program

BEGIN {
    Letters = &quot;abcdefghijklmnopqrstuvwxyz&quot; \
              &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
    split(Letters, data, &quot;&quot;)

    asort(data, result, &quot;case_fold_compare&quot;)

    j = length(result)
    for (i = 1; i &lt;= j; i++) {
        printf(&quot;%s&quot;, result[i])
        if (i % (j/2) == 0)
            printf(&quot;\n&quot;)
        else
            printf(&quot; &quot;)
    }
}
</pre></div>

<p>当程序运行的时候，我们得到以下输出：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f case_fold_compare.awk</kbd>
-| A a B b c C D d e E F f g G H h i I J j k K l L M m
-| n N O o p P Q q r R S s t T u U V v w W X x y Y z Z
</pre></div>

<hr>
<a name="Two_002dway-I_002fO"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Sorting-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#TCP_002fIP-Networking" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_008eaa_0085_00b6a_00bb_0096e_00bf_009bc_00a8_008be_00bf_009be_00a1_008caa_008f_008caa_0090_0091e_0080_009aa_00bf_00a1"></a>
<h2 class="section">1.3 与其他进程进行双向通信</h2>


<a name="index-advanced-features_002c-processes_002c-communicating-with"></a>
<a name="index-processes_002c-two_002dway-communications-with"></a>
<p>把数据发向另一个单独的程序，处理后再读取结果通常都非常有用。这可以通过临时文件来做到：
</p>
<div class="example">
<pre class="example"># Write the data for processing
tempfile = (&quot;mydata.&quot; PROCINFO[&quot;pid&quot;])
while (<var>not done with data</var>)
    print <var>data</var> | (&quot;subprogram &gt; &quot; tempfile)
close(&quot;subprogram &gt; &quot; tempfile)

# Read the results, remove tempfile when done
while ((getline newdata &lt; tempfile) &gt; 0)
    <var>process</var> newdata <var>appropriately</var>
close(tempfile)
system(&quot;rm &quot; tempfile)
</pre></div>

<p>这可以工作，但是没那么优雅。在其他事情间，它需要程序运行一个不能被其全用户共享的目录中，比如 &lsquo;<tt>/tmp</tt>&rsquo; 就不可以，因为其他的用户有可能碰巧使用相同文件名的临时文件。
<a name="DOCF88" href="#FOOT88">(88)</a> </p>
<a name="index-coprocesses-1"></a>
<a name="index-input_002foutput_002c-two_002dway"></a>
<a name="index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029-3"></a>
<a name="index-vertical-bar-_0028_007c_0029_002c-_007c_0026-operator-_0028I_002fO_0029-2"></a>
<a name="index-csh-utility_002c-_007c_0026-operator_002c-comparison-with"></a>
<p>但是，使用 <code>gawk</code> 可以打开一个<em>双路</em>的管道到另一个进程中。第二个进程被称为<em>并程</em>，因为它与 <code>gawk</code> 一道运行。双路连接使用 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符来建立（从 Korn shell，<code>ksh</code> 借来的）： 
<a name="DOCF89" href="#FOOT89">(89)</a>
</p>
<div class="example">
<pre class="example">do {
    print <var>data</var> |&amp; &quot;subprogram&quot;
    &quot;subprogram&quot; |&amp; getline results
} while (<var>data left to process</var>)
close(&quot;subprogram&quot;)
</pre></div>

<p>第一次使用 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符执行 I/O 操作时，<code>gawk</code> 会创建一个双路管线到进行另一个程序的子进程中。用 <code>print</code> 或者 <code>printf</code> 创建的输出会被写到程序的标准输入中，而程序的标准输出可以被 <code>gawk</code> 的程序使用 <code>getline</code> 来读取。与通过 &lsquo;<samp>|</samp>&rsquo; 创建的程序一样，子程序可以是任何程序，或者程序的管线，可被 Shell 启动。
</p>
<p>要了解的几个注意点是：
</p>
<ul>
<li>
就目前 <code>gawk</code> 中的代码，并程的标准错误会输出到父进程 <code>gawk</code> 的标准错误输出的地方。不可以单独读取子进程的标准错误。

<a name="index-deadlocks"></a>
<a name="index-buffering_002c-input_002foutput-1"></a>
<a name="index-getline-command_002c-deadlock-and"></a>
</li><li>
I/O 缓存可能是个问题。<code>gawk</code> 会自动地刷出所有的输出到并程管道。但是，如果并程没有刷出它的输出，<code>gawk</code> 可能在执行 <code>getline</code> 以读取并程的输出时而挂起。这会导致所谓的<em>死锁</em>问题，在这种情形下，每个进程都在等待对方做些什么事情。
</li></ul>

<a name="index-close_0028_0029-function_002c-two_002dway-pipes-and"></a>
<p>可以只关闭到并程的双路管道的一边，只需要为 <code>close()</code> 函数的提供第二个参数，即 <code>&quot;to&quot;</code> 或者 <code>&quot;from&quot;</code>（查看 see section <a href="#Close-Files-And-Pipes">关闭输入输出重定向</a>）。这些字串通知 <code>gawk</code> 关闭管道的一端，即发送数到并程的一端，或者从其读取的一端。
</p>
<a name="index-sort-utility_002c-coprocesses-and"></a>
<p>当使用 <code>sort</code> 系统工具作为并程的一部分时，上面的行为尤其重要，<code>sort</code> 必须在产生所有的输出之前先读取<em>所有的</em>输入数据。<code>sort</code> 程序直到 <code>gawk</code> 关键管道的写一端后，<code>sort</code> 才会接收到 end-of-file 的指示。
</p>
<p>当你完成了数据输出到 <code>sort</code> 工具，你可以关闭管道的 <code>&quot;to&quot;</code> 端，然后用 <code>getline</code> 从已经排序的数据中读取结果。例如：
</p>
<div class="example">
<pre class="example">BEGIN {
    command = &quot;LC_ALL=C sort&quot;
    n = split(&quot;abcdefghijklmnopqrstuvwxyz&quot;, a, &quot;&quot;)

    for (i = n; i &gt; 0; i--)
        print a[i] |&amp; command
    close(command, &quot;to&quot;)

    while ((command |&amp; getline line) &gt; 0)
        print &quot;got&quot;, line
    close(command)
}
</pre></div>

<p>这个程序将字母表的字母以逆序方式写入，一次一行，写到 <code>sort</code> 的双路管道中。之后关闭管道的写端，因此 <code>sort</code> 会接收到 end-of-file 指示。这会导致 <code>sort</code> 来排序数据，然后将排序后的数据写回到 <code>gawk</code> 程序。只要所有的数据被读取完毕，<code>gawk</code> 会结束并程，然后退出。
</p>
<p>另外一个提示是，在 <code>sort</code> 命令的 &lsquo;<samp>LC_ALL=C</samp>&rsquo; 赋值用来保证传统的 Unix（ASCII）排序。在这里并不是严格需要，但是知道如何来做也是很好的。
</p>
<p>当关闭一个双路管道的 <code>&quot;from&quot;</code> 端的时候要小心；在这个例子中 <code>gawk</code> 等待子进程退出，这可能会引起你的程序挂起。
（因此，这个特性在实际中不如能关闭 <code>&quot;to&quot;</code> 端那么有用。）
</p>
<blockquote>
<p><b>注意:</b> 写一个双路管道的已关闭的 <code>&quot;to&quot;</code> 端是一个致命错误。读一个双路管道已关闭的 <code>&quot;from&quot;</code> 端也是一个致命错误。
</p></blockquote>

<a name="index-gawk_002c-PROCINFO-array-in-2"></a>
<a name="index-PROCINFO-array_002c-and-communications-via-ptys"></a>
<p>如果系统支持，你也可以使用 pseudo-ttys(ptys) 用来代替管道来做双路通信。这是通过基于单命令来完成的，只要设置 <code>PROCINFO</code> 数组的特殊元素的值来实现（查看 see section <a href="#Auto_002dset">传递信息的内置变量</a>），如：
</p>
<div class="example">
<pre class="example">command = &quot;sort -nr&quot;           # command, save in convenience variable
PROCINFO[command, &quot;pty&quot;] = 1   # update PROCINFO
print &hellip; |&amp; command           # start two-way pipe
&hellip;
</pre></div>

<p>如果你的系统没有 ptys，或者系统中所有的 ptys 都在使用，<code>gawk</code> 会自动地返回使用常规的管道。
</p>
<p>使用 ptys 可以避免缓存死锁的问题，只是损失一些性能。
这是因为 tty driver 是一行一行缓存数据和发送数据的。在用 <code>stdbuf</code>（<a href="http://www.gnu.org/software/coreutils/coreutils.html">GNU Coreutils package</a>的一部分）的系统中，你可以使用那个程序来代替 ptys。
</p>
<p>也要注意 ptys 不是完全透明的。某些二进制控制代码，例如用 <kbd>Ctrl-d</kbd> 表示 end-of-file，是由 tty driver 解释的，不能传输。
</p>
<blockquote>
<p><b>注意:</b> 最后，并程导致了 <code>gawk</code> 和并程中运行的程序中间产生死锁的可能性。
如果你在得到任何返回数据之前发送“太多”数据给并程，这会发送死锁；每个写数据的进程会阻塞，
没有一个能读他们已经写入的数据。死锁没有什么变通办法；你需要小心地编程，并且了解并程的表现。
</p></blockquote>

<hr>
<a name="TCP_002fIP-Networking"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Two_002dway-I_002fO" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Profiling" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0088_00a9c_0094_00a8-gawk-e_00bf_009be_00a1_008cc_00bd_0091c_00bb_009ce_0080_009aa_00bf_00a1"></a>
<h2 class="section">1.4 利用 <code>gawk</code> 进行网络通信</h2>
<a name="index-advanced-features_002c-network-programming"></a>
<a name="index-networks_002c-programming"></a>
<a name="index-TCP_002fIP"></a>
<a name="index-_002finet_002f_2026-special-files-_0028gawk_0029"></a>
<a name="index-files_002c-_002finet_002f_2026-_0028gawk_0029"></a>
<a name="index-_002finet4_002f_2026-special-files-_0028gawk_0029"></a>
<a name="index-files_002c-_002finet4_002f_2026-_0028gawk_0029"></a>
<a name="index-_002finet6_002f_2026-special-files-_0028gawk_0029"></a>
<a name="index-files_002c-_002finet6_002f_2026-_0028gawk_0029"></a>
<a name="index-EMRED"></a>
<blockquote>
<p><code>EMRED</code>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>A host is a host from coast to coast,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and nobody talks to a host that&rsquo;s close,<br>
&nbsp;&nbsp;&nbsp;&nbsp;unless the host that isn&rsquo;t close<br>
&nbsp;&nbsp;&nbsp;&nbsp;is busy, hung, or dead.</i>
</p></blockquote>
<p align="center">&mdash; <em>Mike O'Brien (aka Mr.@: Protocol)</em>
</p>

<p>除了可以在同一个系统中打开一个双路到并程的管线（查看 see section <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>），也可以通过 IP 网络连接来与在另一个系统上的另一个进程之间进行双路连接。
</p>
<p>你可以把这个当成是一个<em>非常长</em>的到并程的双路管线。<code>gawk</code> 确定你使用 TCP/IP 网络的方式是通过识别以 &lsquo;<samp>/inet/</samp>&rsquo;，&lsquo;<samp>/inet4/</samp>&rsquo;， 或者 &lsquo;<samp>/inet6/</samp>&rsquo; 开头的特别文件名。
</p>
<p>特殊文件名的完整语法为 &lsquo;<tt>/<var>net-type</var>/<var>protocol</var>/<var>local-port</var>/<var>remote-host</var>/<var>remote-port</var></tt>&rsquo;。这些组件为：
</p>
<dl compact="compact">
<dt><var>net-type</var></dt>
<dd><p>指定要建立的互联网连接的类型。使用 &lsquo;<samp>/inet4/</samp>&rsquo; 来强制使用 IPv4，&lsquo;<samp>/inet6/</samp>&rsquo; 来强制为 IPv6。普通文本 &lsquo;<samp>/inet/</samp>&rsquo; （过去是唯一的选项）用于系统默认方式，大多数可能是 IPv4。
</p>
</dd>
<dt><var>protocol</var></dt>
<dd><p>在 IP 之上使用的协议。必须是 &lsquo;<samp>tcp</samp>&rsquo;，&lsquo;<samp>udp</samp>&rsquo; 之一，相应对应为 TCP 或者 UDP IP 连接。TCP 用于大多数程序。
</p>
</dd>
<dt><var>local-port</var></dt>
<dd><a name="index-getaddrinfo_0028_0029-function-_0028C-library_0029"></a>
<p>本地 TCP 或者 UDP 端口。如果你想让系统选择端口，则指定 &lsquo;<samp>0</samp>&rsquo; 为其端口号。如果你在写 TCP 或者 UDP 客户端则你应该这么来处理。你也可以使用知名的服务名，如 &lsquo;<samp>smtp</samp>&rsquo; 或者 &lsquo;<samp>http</samp>&rsquo;，这样 <code>gawk</code> 在使用 C 的 <code>getaddinfo()</code> 函数时会尝试确定预定义的端口。
</p>
</dd>
<dt><var>remote-host</var></dt>
<dd><p>你要连接的主机的 IP 地址，或者是完整的 Internet 域名。
</p>
</dd>
<dt><var>remote-port</var></dt>
<dd><p>连接远程主机 <var>remote-host</var> 的 TCP 或者 UDP 端口。再次地，你如果不关心端口可以使用 &lsquo;<samp>0</samp>&rsquo;，或者知名的服务名。
</p></dd>
</dl>

<a name="index-gawk_002c-ERRNO-variable-in-4"></a>
<a name="index-ERRNO-variable-1"></a>
<blockquote>
<p><b>提示:</b> 无法打开双路的 socket 会导致一个致命错误返回到调用的代码。<code>ERRNO</code> 的值指示了错误信息（查看 see section <a href="#Auto_002dset">传递信息的内置变量</a>）。
</p></blockquote>

<p>考虑下面非常简单的例子：
</p>
<div class="example">
<pre class="example">BEGIN {
    Service = &quot;/inet/tcp/0/localhost/daytime&quot;
    Service |&amp; getline
    print $0
    close(Service)
}
</pre></div>

<p>这个程序从本地系统的 TCP <code>daytime</code> 服务器中读取当前的日期及时间。然后打印结果后关闭连接。
</p>
<p>由于这个主题是扩展内容，用 <code>gawk</code> 进行 TCP/IP 编程为独立的文档。
Because this topic is extensive, the use of <code>gawk</code> for
TCP/IP programming is documented separately.
查看 <a href="http://www.gnu.org/software/gawk/manual/gawkinet/"><cite>TCP/IP Internetworking with <code>gawk</code></cite></a>。它是 <code>gawk</code> 发布版本的一部分，
其中有完整的介绍与讨论，同时有更多的例子。
</p>
<blockquote>
<p><b>提示:</b> <code>gawk</code> 只能打开直接的 sockets。现在没有办法去获取 SSL 的服务；这包括任何 URL 以 &lsquo;<samp>https://</samp>&rsquo; 开头的网站服务。
</p></blockquote>


<hr>
<a name="Profiling"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#TCP_002fIP-Networking" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Advanced-Features-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b5_008be_00af_0084a_00bd_00a0c_009a_0084-awk-c_00a8_008baa_00ba_008f"></a>
<h2 class="section">1.5 测评你的 <code>awk</code> 程序</h2>
<a name="index-awk-programs_002c-profiling"></a>
<a name="index-profiling-awk-programs"></a>
<a name="index-awkprof_002eout-file"></a>
<a name="index-files_002c-awkprof_002eout"></a>

<p>你可以生成你的 <code>awk</code> 程序执行的跟踪信息。这只要传递 &lsquo;<samp>--profile</samp>&rsquo; 参数到 <code>gawk</code> 就可以。当 <code>gawk</code> 完成后，它会创建一个名为 &lsquo;<tt>awkprof.out</tt>&rsquo; 的测评文件。由于程序被测评，这样它要比正常的执行慢 45%。
</p>
<a name="index-_002d_002dprofile-option-1"></a>
<p>如下面的例子所示，&lsquo;<samp>--profile</samp>&rsquo; 选项可以指定 <code>gawk</code> 将测评信息写入的文件的名字：
</p>
<div class="example">
<pre class="example">gawk --profile=myprog.prof -f myprog.awk data1 data2
</pre></div>

<p>在前面的例子中，<code>gawk</code> 将测评数据放在 &lsquo;<tt>myprog.prof</tt>&rsquo; 文件，而不是 &lsquo;<tt>awkprof.out</tt>&rsquo; 文件。
</p>
<p>这是一个简单的 <code>awk</code> 程序的执行信息，包含输入数据，以及用 &lsquo;<samp>--profile</samp>&rsquo; 执行 <code>gawk</code> 时的结果。首先，下面是 <code>awk</code> 程序：
</p>
<div class="example">
<pre class="example">BEGIN { print &quot;First BEGIN rule&quot; }

END { print &quot;First END rule&quot; }

/foo/ {
    print &quot;matched /foo/, gosh&quot;
    for (i = 1; i &lt;= 3; i++)
        sing()
}

{
    if (/foo/)
        print &quot;if is true&quot;
    else
        print &quot;else is true&quot;
}

BEGIN { print &quot;Second BEGIN rule&quot; }

END { print &quot;Second END rule&quot; }

function sing(    dummy)
{
    print &quot;I gotta be me!&quot;
}
</pre></div>

<p>Following is the input data:
</p>
<div class="example">
<pre class="example">foo
bar
baz
foo
junk
</pre></div>

<p>下面是使用 <code>gawk</code> 测评器执行程序与数据时的产生的数据文件 &lsquo;<tt>awkprof.out</tt>&rsquo;（这个例子也说明了 <code>awk</code> 程序员有时很早就起来工作了）：
</p>
<a name="index-BEGIN-pattern_002c-and-profiling"></a>
<a name="index-END-pattern_002c-and-profiling"></a>
<div class="example">
<pre class="example">    # gawk profile, created Mon Sep 29 05:16:21 2014

    # BEGIN rule(s)

    BEGIN {
 1          print &quot;First BEGIN rule&quot;
    }

    BEGIN {
 1          print &quot;Second BEGIN rule&quot;
    }

    # Rule(s)

 5  /foo/ { # 2
 2          print &quot;matched /foo/, gosh&quot;
 6          for (i = 1; i &lt;= 3; i++) {
 6                  sing()
            }
    }

 5  {
 5          if (/foo/) { # 2
 2                  print &quot;if is true&quot;
 3          } else {
 3                  print &quot;else is true&quot;
            }
    }

    # END rule(s)

    END {
 1          print &quot;First END rule&quot;
    }

    END {
 1          print &quot;Second END rule&quot;
    }


    # Functions, listed alphabetically

 6  function sing(dummy)
    {
 6          print &quot;I gotta be me!&quot;
    }
</pre></div>

<p>这个例子说明了测评输出的一些基本特性。它们是：
</p>
<ul>
<li>
程序以 <code>BEGIN</code> 规则，模式-动作规则，<code>BEGINFILE</code> 规则，<code>ENDFILE</code> 规则，<code>END</code> 规则这样的顺序来打印输出。并以字母顺序列表。多个 <code>BEGIN</code> 与 <code>END</code> 规则会有单独的标识，<code>BEGINFILE</code> 与 <code>ENDFILE</code> 也一样。

<a name="index-patterns_002c-counts_002c-in-a-profile"></a>
</li><li>
模式-动作规则有两个统计，第一个是规则的左边，显示的是规则的模式被<em>测试</em>的次数。第二个分是规则的右边在开花号中在注释里面，显示的是规则被<em>执行</em>的次数。两个数值的差异显示的是规则模式被测试为 false 的次数。

</li><li>
相似的，对于 <code>if</code>-<code>else</code> 语句的统计显示了条件被测试的次数。在开花括号的右边的 <code>if</code> 的语句体处的统计显示的是条件测试为真的次数。<code>else</code> 的统计显示的是测试失败的次数。

<a name="index-loops_002c-count-for-header_002c-in-a-profile"></a>
</li><li>
对于循环头的统计（如 <code>for</code> 或者 <code>while</code>）显示的是循环测试执行的次数。（由于这个原因，你不可只看在规则中的第一条语句的统计来确定规则被执行的次数。如果第一条语句是一个循环，则统计会误导你。）

<a name="index-functions_002c-user_002ddefined_002c-counts_002c-in-a-profile"></a>
<a name="index-user_002ddefined_002c-functions_002c-counts_002c-in-a-profile"></a>
</li><li>
对于用户自定义的函数，在 <code>function</code> 关键词后面的统计显示的是函数被调用的次数。在函数体语句语句后面的统计，则是语句被执行的次数。

<a name="index-_007b_007d-_0028braces_0029"></a>
<a name="index-braces-_0028_007b_007d_0029"></a>
</li><li>
输出布局使用的是 “K&amp;R” 带 TABs 的风格。花括号会到处使用，就算是 <code>if</code>，<code>else</code>，或者循环体只有一个语句。

<a name="index-_0028_0029-_0028parentheses_0029_002c-in-a-profile"></a>
<a name="index-parentheses-_0028_0029_002c-in-a-profile"></a>
</li><li>
括号则只在需要的时候使用，它由程序的结构 以及前面规则来提示。例如，&lsquo;<samp>(3 + 5) * 4</samp>&rsquo; 表示 3 加 5，然后乘上 4 的结果。但是 &lsquo;<samp>3 + 5 * 4</samp>&rsquo; 没有括号，则表示 &lsquo;<samp>3 + (5 * 4)</samp>&rsquo;。


</li><li>
括号只用在 <code>print</code> 与 <code>printf</code> 参数周围，并且只当 <code>print</code> 与 <code>printf</code> 的语句后面跟着重定向符。相似的，如果重定向的目标不是标量，则它会被括起来。

</li><li>
<code>gawk</code> 提供 <code>BEGIN</code> 与 <code>END</code> 规则，<code>BEGINFILE</code> 与 <code>ENDFILE</code> 规则，模式-动作规则与函数的前导注释。

</li></ul>

<p>你的程序的测评版本可能不会完全像你所写的那样。这是因为 <code>gawk</code> 用“简洁打印”其程序的内部表示来生成的测评。这么做的好处是 <code>gawk</code> 可以产生标准的表示。不好的地方是会丢失程序的代码。同时，像这样的代码：
</p>
<div class="example">
<pre class="example">/foo/
</pre></div>

<p>会生成：
</p>
<div class="example">
<pre class="example">/foo/   {
    print $0
}
</pre></div>

<p>虽然正确，但可能并不是所期望的。
</p>
<a name="index-profiling-awk-programs_002c-dynamically"></a>
<a name="index-gawk-program_002c-dynamic-profiling"></a>
<a name="index-dynamic-profiling"></a>
<p>当程序执行完成后会生成测评外，<code>gawk</code> 也可以在运行的时候生成。如果你的 <code>awk</code> 程序会进入一个无限循环，而你又想看执行了什么的时候，这会非常有用。为了使用这个特性，请在后台模式来执行带 &lsquo;<samp>--profile</samp>&rsquo; 选项的 <code>gawk</code> ：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk --profile -f myprog &amp;</kbd>
[1] 13992
</pre></div>

<a name="index-kill-command_002c-dynamic-profiling"></a>
<a name="index-USR1-signal_002c-for-dynamic-profiling"></a>
<a name="index-SIGUSR1-signal_002c-for-dynamic-profiling"></a>
<a name="index-signals_002c-USR1_002fSIGUSR1_002c-for-profiling"></a>
<p>shell 会打印一个任务号以及进程 ID 号，在这里是 13992。使用 <code>kill</code> 命令来发送 <code>USR1</code> 信号到 <code>gawk</code> ：
</p>
<div class="example">
<pre class="example">$ <kbd>kill -USR1 13992</kbd>
</pre></div>

<p>如通常情况，测评的程序版本被写入到 &lsquo;<tt>awkprof.out</tt>&rsquo; 文件中，或者写入到在 &lsquo;<samp>--profile</samp>&rsquo; 选项中指定的文件中。
</p>
<p>作为常规的测评，如稍早显示的，测评中包含任何活动的函数的跟踪信息：
</p>
<div class="example">
<pre class="example"># Function Call Stack:

#   3. baz
#   2. bar
#   1. foo
# -- main --
</pre></div>

<p>你可以发送多次 <code>USR1</code> 信号。每发一次，测评与函数调用路径会被附加到测评文件中。
</p>
<a name="index-HUP-signal_002c-for-dynamic-profiling"></a>
<a name="index-SIGHUP-signal_002c-for-dynamic-profiling"></a>
<a name="index-signals_002c-HUP_002fSIGHUP_002c-for-profiling"></a>
<p>如果你使用的是 <code>HUP</code> 信号，而不是 <code>USR1</code> 信号，<code>gawk</code> 会产生测评与函数调用路径信息后退出。
</p>
<a name="index-INT-signal-_0028MS_002dWindows_0029"></a>
<a name="index-SIGINT-signal-_0028MS_002dWindows_0029"></a>
<a name="index-signals_002c-INT_002fSIGINT-_0028MS_002dWindows_0029"></a>
<a name="index-QUIT-signal-_0028MS_002dWindows_0029"></a>
<a name="index-SIGQUIT-signal-_0028MS_002dWindows_0029"></a>
<a name="index-signals_002c-QUIT_002fSIGQUIT-_0028MS_002dWindows_0029"></a>
<p>当 <code>gawk</code> 在 MS-Windows 系统上运行时，它使用 <code>INT</code> 与 <code>QUIT</code> 信息来产生测评，在使用 <code>INT</code> 信号时，<code>gawk</code> 会退出。这里因为这些系统不支持 <code>kill</code> 命令，所以只能通过键盘产生的信号来发送给程序。<code>INT</code> 信号通过 <kbd>Ctrl-c</kbd> 或者 <kbd>Ctrl-BREAK</kbd> 键来产生，而 <code>QUIT</code> 信息则由 <kbd>Ctrl-\</kbd> 键来产生。
</p>
<p>最后，<code>gawk</code> 也接收其他的选项，&lsquo;<samp>--pretty-print</samp>&rsquo;。当这么调用时，<code>gawk</code> 会“简洁打印”程序到 &lsquo;<tt>awkprof.out</tt>&rsquo; 中，不带执行统计的方式。
</p>
<blockquote>
<p><b>提示:</b> &lsquo;<samp>--pretty-print</samp>&rsquo; 会执行你的程序。这会在下一个主要版本中改变。
</p></blockquote>

<hr>
<a name="Advanced-Features-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Profiling" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-9"></a>
<h2 class="section">1.6 总结</h2>

<ul>
<li>
&lsquo;<samp>--non-decimal-data</samp>&rsquo; 选项可以使 <code>gawk</code> 将八进制或者十六进制式的输入数据当成是八进制与十六进制数据对待。这个选项要小心使用，或者不要使用，而是要使用 <code>strtonum()</code>。也要注意这个选项在未来的 <code>gawk</code> 版本可能会消失。

</li><li>
你可以完全控制在 &lsquo;<samp>for (<var>indx</var> in <var>array</var>)</samp>&rsquo; 中进行数组遍历的排序方式，这通过将预定义的 <code>PROCINFO[&quot;sorted_in&quot;]</code> 变量设置为用户自定义的函数名，而这个函数则通过对索引与值的比较来进行元素的比较。

</li><li>
类似地，你也可提供一个用户自定义的比较函数的名字来作为 <code>asort()</code> 或者 <code>asorti()</code> 函数的第三个参数来控制函数如何来对数组进行排序。或者你也可以提供一个预定义控制字串来设置 <code>PROCINFO[&quot;sorted_in&quot;]</code> 的值。

</li><li>
你可以使用 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符来创建一个双路的到并程的管道。你通过 <code>getline</code> 来从并程中读取，并通过 <code>print</code> 或者 <code>printf</code> 来写入。使用 <code>close()</code> 来完全地关闭并程，或者可选地关闭双路通过中的一端。

</li><li>
通过使用特殊文件名以及 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符，你可以使用 TCP/IP（或者 UDP/IP）来与互联网上的主机进行连接。<code>gawk</code> 支持 IPv4，也支持IPv6。

</li><li>
你可以生成程序的语句测评统计。这个可以让你来确定你程序的哪部分占用了较多的时间，以让你来方便地对你的程序进行调优。当进行测评进行时，你可以向程序发送 <code>USR1</code> 信号，这可以使 <code>gawk</code> 输出测评信息以及函数调用栈。

</li><li>
你也可以只“简洁打印”（pretty-<code>print</code>）你的程序。当前，它会运行你的程序，但是在后面的主要发行版本中会改变。

</li></ul>


<hr>
<a name="Internationalization"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Advanced-Features-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-and-L10N" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-c_009a_0084aa_009b_00bde_0099_0085aa_008c_0096"></a>
<h1 class="chapter">2 <code>gawk</code> 的国际化</h1>

<p>很久前，计算机的制造者们所写的程序只能使用英语。后来，硬件与软件的生产商位注意到，如果他们的系统也可以在非英语国家的语言中工作，则它他就可以卖更多的系统。结果就是，国际化与本地化程序以及软件会成为一个通用的实践。
</p>
<a name="index-internationalization_002c-localization-1"></a>
<a name="index-gawk_002c-internationalization-and_002c-See-internationalization"></a>
<a name="index-internationalization_002c-localization_002c-gawk-and"></a>
<p>很多年以来，提供国际化与本地化能力的程序失业地限制在用 C 或者 C++ 写的程序中。这一章会描述 <code>gawk</code> 底层使用的用来进行国际化的库，包含 <code>gawk</code> 如何来在 <code>awk</code> 程序代码级上实现国际化特性。在 <code>awk</code> 代码级实现国际化可以给软件开发者额外的灵活性——它们不再被迫使用 C 或者 C++ 来编写要实现国际化的软件。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#I18N-and-L10N">2.1 国际化与本地化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Internationalization and Localization.
</td></tr>
<tr><td align="left" valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          How GNU <code>gettext</code> works.
</td></tr>
<tr><td align="left" valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Features for the programmer.
</td></tr>
<tr><td align="left" valign="top"><a href="#Translator-i18n">2.4 翻译 <code>awk</code> 程序</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Features for the translator.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                A simple i18n example.
</td></tr>
<tr><td align="left" valign="top"><a href="#Gawk-I18N">2.6 <code>gawk</code> 可以说你的语言</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   <code>gawk</code> is also internationalized.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-Summary">2.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Summary of I18N stuff.
</td></tr>
</table>

<hr>
<a name="I18N-and-L10N"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Explaining-gettext" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009b_00bde_0099_0085aa_008c_0096a_00b8_008eae_009c_00acaa_009c_00b0aa_008c_0096"></a>
<h2 class="section">2.1 国际化与本地化</h2>

<a name="index-internationalization-1"></a>
<a name="index-localization_002c-See-internationalization_002c-localization"></a>
<a name="index-localization"></a>
<p><em>国际化</em>表示只写（编辑）一次程序，就可以不再需要对代码进行变更就可以在多种语言下使用。<em>本地化</em>则表示给国际化的程序提供相应的数据来在某个特定的语言中工作。最典型的是，这些术语指的是在打印错误信息，在读取反馈时使用的语言的特性，以及数值与倾向值如何来进行读取与打印的方式。
</p>
<hr>
<a name="Explaining-gettext"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-and-L10N" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Programmer-i18n" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="GNU-c_009a_0084-gettext"></a>
<h2 class="section">2.2 GNU 的 <code>gettext</code></h2>

<a name="index-internationalizing-a-program"></a>
<a name="index-gettext-library"></a>
<p><code>gawk</code> 使用 GNU 的 <code>gettext</code> 来提供国际化特性。GNU <code>gettext</code> 工具关注信息：程序中打印的字串，无论是通过 <code>printf</code> 还是通过 <code>sprintf()</code>。 
<a name="DOCF90" href="#FOOT90">(90)</a>
</p>
<a name="index-portability_002c-gettext-library-and"></a>
<p>当使用 GNU <code>gettext</code> 时，每个程序都有它的<em>文本域</em>。这是一个唯一的名字，如 &lsquo;<samp>kpilot</samp>&rsquo; 或者 &lsquo;<samp>gawk</samp>&rsquo;，用来标识程序。一个完整的程序有多个组件——用 C 或者 C++ 写的程序，以及使用 <code>sh</code> 或者 <code>awk</code> 写的脚本。所有的这些组件都使用相同的文本域。
</p>
<p>为了使讨论更加具体，假设我们写一个程序名为 <code>guide</code>。按顺序，国际化包含下面的步骤：
</p>
<ol>
<li>
程序员检查所有的 <code>guide</code> 组件的代码，并且标注出要进行翻译的字串。例如 <code>&quot;`-F': option required&quot;</code> 是一个很好的要进行翻译的候选者。而选项名的字串表则不是（如，<code>gawk</code> 的 &lsquo;<samp>--profile</samp>&rsquo; 选项要保留原样，而不管是什么样的语言）。

<a name="index-textdomain_0028_0029-function-_0028C-library_0029"></a>
</li><li>
通过调用 <code>textdomain()</code> 函数，程序员向 <code>gettext</code> 库指定（<code>&quot;guide&quot;</code>）的应用文本域。

<a name="index-_002epot-files"></a>
<a name="index-files_002c-_002epot"></a>
<a name="index-portable-object-template-files"></a>
<a name="index-files_002c-portable-object-template"></a>
</li><li>
从源代码中提取的消息放到一个移植的对象模板文件（&lsquo;<tt>guide.pot</tt>&rsquo;），在这个文件里列出了所有的字串以及对应的翻译串。翻译开始是空的。原始信息（一般是英语）会作为翻译查找的键。

<a name="index-_002epo-files"></a>
<a name="index-files_002c-_002epo"></a>
<a name="index-portable-object-files"></a>
<a name="index-files_002c-portable-object"></a>
</li><li>
对于翻译的每中语言，&lsquo;<tt>guide.pot</tt>&rsquo; 都被复制到一个可移植的对象文件（<code>.po</code>）并建立起翻译然后与程序一起打包。例如，有可能有 &lsquo;<tt>fr.po</tt>&rsquo; 用来做为法语翻译。

<a name="index-_002egmo-files"></a>
<a name="index-files_002c-_002egmo"></a>
<a name="index-message-object-files"></a>
<a name="index-files_002c-message-object"></a>
</li><li>
每种语言的 &lsquo;<tt>.po</tt>&rsquo; 文件都被转换为二进制消息对象（&lsquo;<tt>.gmo</tt>&rsquo;）文件。消息对象文件包含原始消息与它们的翻译的二进制格式，这样可以在运行时快速查找。

</li><li>
当 <code>guide</code> 被构建并被安装，二进制的翻译文件也被安装到标准位置。

<a name="index-bindtextdomain_0028_0029-function-_0028C-library_0029"></a>
</li><li>
对于测试与开发，可以告知 <code>gettext</code> 使用不是标准目录下的 &lsquo;<tt>.gmo</tt>&rsquo; 文件，这通过调用 <code>bindtextdomain()</code> 函数来实现。

<a name="index-_002egmo-files_002c-specifying-directory-of"></a>
<a name="index-files_002c-_002egmo_002c-specifying-directory-of"></a>
<a name="index-message-object-files_002c-specifying-directory-of"></a>
<a name="index-files_002c-message-object_002c-specifying-directory-of"></a>
</li><li>
在运行时，<code>guide</code> 会通过调用 <code>gettext()</code> 来查找每一个字串。返回的串为字串的翻译串，如果没可得的话，就是原串。

</li><li>
如果必要，也可以从另一个不属于这个程序的不同的文本域中来访问消息，而不需要在程序的默认文本域之间来回切换。
</li></ol>

<a name="index-gettext_0028_0029-function-_0028C-library_0029"></a>
<p>在 C（或者C++）中，标志动态翻译查找的字串是通过将字串通过 <code>gettext()</code> 来完成的：
</p>
<div class="example">
<pre class="example">printf(&quot;%s&quot;, gettext(&quot;Don't Panic!\n&quot;));
</pre></div>

<p>工具可以从源代码中将所有用 <code>gettext()</code> 包含的字串提取出来。
</p>
<a name="index-_005f-_0028underscore_0029_002c-C-macro"></a>
<a name="index-underscore-_0028_005f_0029_002c-C-macro"></a>
<p>GNU <code>gettext</code> 的开发者，意识到一次次地输入 &lsquo;<samp>gettext(&hellip;)</samp>&rsquo; 既痛苦，看起来也丑，因此使用宏 &lsquo;<samp>_</samp>&rsquo;（下划线）来使得事情简化：
</p>
<div class="example">
<pre class="example">/* In the standard header file: */
#define _(str) gettext(str)

/* In the program text: */
printf(&quot;%s&quot;, _(&quot;Don't Panic!\n&quot;));
</pre></div>

<a name="index-internationalization_002c-localization_002c-locale-categories"></a>
<a name="index-gettext-library_002c-locale-categories"></a>
<a name="index-locale-categories"></a>
<p>这产生的输入负担只是每个字串三个额外的字符 ，而且也更容易阅读。
</p>
<p>对于不同本地语言的信息有不同的本地语言<em>分类</em>。<code>gettext</code> 可识别的定义好的本地语言分类有：
</p>
<dl compact="compact">
<dd><a name="index-LC_005fMESSAGES-locale-category"></a>
</dd>
<dt><code>LC_MESSAGES</code></dt>
<dd><p>文本消息。这是 <code>gettext</code> 操作的默认分类，但是如果需要的话，可以显式地指定不同的类型。（几乎没有必要指定不同的分类。）
</p>
<a name="index-sorting-characters-in-different-languages"></a>
<a name="index-LC_005fCOLLATE-locale-category"></a>
</dd>
<dt><code>LC_COLLATE</code></dt>
<dd><p>文本协同信息（如，不同的字符与/或者字符组在一个给定的语言中如何排序）。
</p>
<a name="index-LC_005fCTYPE-locale-category"></a>
</dd>
<dt><code>LC_CTYPE</code></dt>
<dd><p>字符类型信息（字母表，数字，大小写等等）以及字符编码。
这个信息通过正则表达式的 POSIX 字符类来访问，比如 <code>/[[:alnum:]]/</code>（查看 see section <a href="#Bracket-Expressions">使用方括号表达式</a>）。
</p>
<a name="index-monetary-information_002c-localization"></a>
<a name="index-currency-symbols_002c-localization"></a>
<a name="index-LC_005fMONETARY-locale-category"></a>
</dd>
<dt><code>LC_MONETARY</code></dt>
<dd><p>货币信息，如货币符号以及符号是在数值前还是在数值后。
</p>
<a name="index-LC_005fNUMERIC-locale-category"></a>
</dd>
<dt><code>LC_NUMERIC</code></dt>
<dd><p>数值信息。例如用于十进制小数点以及百分位分隔符。 
<a name="DOCF91" href="#FOOT91">(91)</a>
</p>
<a name="index-time_002c-localization-and"></a>
<a name="index-dates_002c-information-related-to_002c-localization"></a>
<a name="index-LC_005fTIME-locale-category"></a>
</dd>
<dt><code>LC_TIME</code></dt>
<dd><p>时间与日期相关，如 12 或者 24 小时制，月分在日期中是打印在天的前面还是后面。本地月分的缩写等等。
</p>
<a name="index-LC_005fALL-locale-category"></a>
</dd>
<dt><code>LC_ALL</code></dt>
<dd><p>上述所有的。（在 <code>gettext</code> 的内容中不是特别有用。）
</p></dd>
</dl>

<blockquote>
<p><b>提示:</b> <a name="index-LANGUAGE-environment-variable"></a>
如 <a href="#Locales">哪里造成差异</a> 所述，和本地语言分类同名的环境变量会影响 <code>gawk</code> 的行为（和其他工具的行为）。
</p>
<p>通常，这些变量也会影响 <code>gettext</code> 库如何找到翻译。然而，<code>LANGUAGE</code> 环境变量会使 <code>LC_<var>xxx</var></code> 环境变量无效。许多 GNU/Linux 系统可能在你不知道的情况下定义这个变量，导致 <code>gawk</code> 不能找到正确的翻译。如果这发生在你身上，检查是否 <code>LANGUAGE</code> 被定义了。如果是的话，用 shell 的 <code>unset</code> 命令去删除它。
</p></blockquote>

<p>为了测试 <code>gawk</code> 本身的翻译，你可以设置 <code>GAWK_LOCALE_DIR</code> 环境变量。查看 <code>bindtextdomain()</code> 文档的函数，也可以看 <a href="#Other-Environment-Variables">其他的环境变量</a>。
</p>
<hr>
<a name="Programmer-i18n"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Explaining-gettext" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-i18n" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-c_00a8_008baa_00ba_008fc_009a_0084aa_009b_00bde_0099_0085aa_008c_0096"></a>
<h2 class="section">2.3 <code>awk</code> 程序的国际化</h2>
<a name="index-awk-programs_002c-internationalizing-1"></a>

<p><code>gawk</code> 使用下面的变量来用于国际化：
</p>
<dl compact="compact">
<dd><a name="index-TEXTDOMAIN-variable-1"></a>
</dd>
<dt><code>TEXTDOMAIN</code></dt>
<dd><p>这个变量表示应用的文本域。为了与 GNU <code>gettext</code> 的兼容性。其默认值是 <code>&quot;messages&quot;</code>。
</p>
<a name="index-internationalization_002c-localization_002c-marked-strings"></a>
<a name="index-strings_002c-for-localization"></a>
</dd>
<dt><code>_&quot;your message here&quot;</code></dt>
<dd><p>用前导的下划线标志的字串常量是在运行时用于翻译的候选串。字串常量前没有下划线的不会被翻译。
</p></dd>
</dl>

<p><code>gawk</code> 提供了下面的函数用来作国际化：
</p>
<dl compact="compact">
<dd><a name="index-dcgettext_0028_0029-function-_0028gawk_0029-1"></a>
</dd>
<dt><code><code>dcgettext(<var>string</var></code> [<code>,</code> <var>domain</var> [<code>,</code> <var>category</var>]]<code>)</code></code></dt>
<dd><p>在本地语言分类 <var>category</var> 中的 <var>domain</var> 文本域中返回 <var>string</var> 串的翻译。默认的<var>domain</var> 的值是 <code>TEXTDOMAIN</code> 变量的当前值。默认的 <var>category</var> 的值必须是已经 <code>&quot;LC_MESSAGES&quot;</code>。
</p>
<p>如果你为 <var>category</var> 提供了一个值，则它必须是已知的本地语言分类字串名，这个在
If you supply a value for <var>category</var>, it must be a string equal to
one of the known locale categories described in
前面的小节提过。
你必需要提供文本域。如果你使用当前域则使用 <code>TEXTDOMAIN</code>。
</p>
<blockquote>
<p><b>注意:</b> <code>awk</code> 版本的 <code>dcgettext()</code> 函数的参数的顺序有意地与 C 版本的中的顺序不一致。<code>awk</code> 版本的顺序的选择是为了简化以及允许合理的 <code>awk</code> 风格默认参数。
</p></blockquote>

<a name="index-dcngettext_0028_0029-function-_0028gawk_0029-1"></a>
</dd>
<dt><code><code>dcngettext(<var>string1</var>, <var>string2</var>, <var>number</var></code> [<code>,</code> <var>domain</var> [<code>,</code> <var>category</var>]]<code>)</code></code></dt>
<dd><p>返回 <var>string1</var> 与 <var>string2</var> 在本地语言分类 <var>category</var> 中，文本域 <var>domain</var> 中的翻译的数量 <var>number</var> 复数形式。<var>string1</var> 是消息的英语的单数形式变体，<var>string2</var> 是相同消息的英语复数形式。<var>domain</var> 的默认值是 <code>TEXTDOMAIN</code> 的当前值。<var>category</var> 的默认值是 <code>&quot;LC_MESSAGES&quot;</code>。
</p>
<p>对于 <code>dcgettext()</code> 函数的参数的顺序说明，也适应于这个函数。
</p>
<a name="index-_002egmo-files_002c-specifying-directory-of-1"></a>
<a name="index-files_002c-_002egmo_002c-specifying-directory-of-1"></a>
<a name="index-message-object-files_002c-specifying-directory-of-1"></a>
<a name="index-files_002c-message-object_002c-specifying-directory-of-1"></a>
<a name="index-bindtextdomain_0028_0029-function-_0028gawk_0029-1"></a>
</dd>
<dt><code><code>bindtextdomain(<var>directory</var></code> [<code>,</code> <var>domain</var> ]<code>)</code></code></dt>
<dd><p>改变 <code>gettext</code> 查找 &lsquo;<tt>.gmo</tt>&rsquo; 文件的目录，以防万一它们不在，或者不能放在标准位置的情况下（如，在测试期间）。返回文本域 <var>domain</var> 绑定的目录。
</p>
<p>默认的域 <var>domain</var> 是 <code>TEXTDOMAIN</code> 的值。如果目录是空串（<code>&quot;&quot;</code>），<code>bindtextdomain()</code> 则返回给定文件域 <var>domain</var> 的当前绑定目录。
</p></dd>
</dl>

<p>为了在你的 <code>awk</code> 程序中使用这样的工具，请按照下面的步骤来执行：
</p>
<ol>
<li><a name="index-BEGIN-pattern_002c-TEXTDOMAIN-variable-and"></a>
<a name="index-TEXTDOMAIN-variable_002c-BEGIN-pattern-and"></a>
</li><li>
将 <code>TEXTDOMAIN</code> 变量设置为程序的文本域。最好是在 <code>BEGIN</code> 规则中完成（查看 see section <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>），或者可以通过命令行选项 &lsquo;<samp>-v</samp>&rsquo; 来完成（查看 <a href="#Options">命令行参数</a>）：

<div class="example">
<pre class="example">BEGIN {
    TEXTDOMAIN = &quot;guide&quot;
    &hellip;
}
</pre></div>

<a name="index-_005f-_0028underscore_0029_002c-translatable-string"></a>
<a name="index-underscore-_0028_005f_0029_002c-translatable-string"></a>
</li><li>
将所有有可翻译的字串用前置下划线来进行标识（&lsquo;<samp>_</samp>&rsquo;）。它<em>必须</em>与字串的开引号相连。如：

<div class="example">
<pre class="example">print _&quot;hello, world&quot;
x = _&quot;you goofed&quot;
printf(_&quot;Number of users is %d\n&quot;, nusers)
</pre></div>

</li><li>
如果你动态地创建字串，你也可以通过 <code>dcgettext()</code> 内置函数来翻译它们： 
<a name="DOCF92" href="#FOOT92">(92)</a>

<div class="example">
<pre class="example">if (groggy)
    message = dcgettext(&quot;%d customers disturbing me\n&quot;, &quot;adminprog&quot;)
else
    message = dcgettext(&quot;enjoying %d customers\n&quot;, &quot;adminprog&quot;)
printf(message, ncustomers)
</pre></div>

<p>在这里，调用 <code>dcgettext()</code> 提供了一个不同的文本域（<code>&quot;adminprog&quot;</code>），在这里来查找消息，但是使用的是默认的 <code>&quot;LC_MESSAGES&quot;</code> 分类。
</p>
<p>前面的例子只在 <code>ncustomers</code> 大于 1 的情况下会工作。这个例子用 <code>dcngettext()</code> 可以更好地完成：
</p>
<div class="example">
<pre class="example">if (groggy)
    message = dcngettext(&quot;%d customer disturbing me\n&quot;,
                         &quot;%d customers disturbing me\n&quot;, &quot;adminprog&quot;)
else
    message = dcngettext(&quot;enjoying %d customer\n&quot;,
                         &quot;enjoying %d customers\n&quot;, &quot;adminprog&quot;)
printf(message, ncustomers)
</pre></div>


<a name="index-LC_005fMESSAGES-locale-category_002c-bindtextdomain_0028_0029-function-_0028gawk_0029"></a>
</li><li>
在开发过程中，你可能想将 &lsquo;<tt>.gmo</tt>&rsquo; 文件放在一个私有的用于测试的目录。这可以通过 <code>bindtextdomain()</code> 内置函数来设置：

<div class="example">
<pre class="example">BEGIN {
   TEXTDOMAIN = &quot;guide&quot;   # our text domain
   if (Testing) {
       # where to find our files
       bindtextdomain(&quot;testdir&quot;)
       # joe is in charge of adminprog
       bindtextdomain(&quot;../joe/testdir&quot;, &quot;adminprog&quot;)
   }
   &hellip;
}
</pre></div>

</li></ol>

<p>查看 <a href="#I18N-Example">简单的国际化例子</a>，来获取如何来一步步地创建并使用来自 <code>awk</code> 的翻译字串的例子。
</p>
<hr>
<a name="Translator-i18n"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Programmer-i18n" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#String-Extraction" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bf_00bbe_00af_0091-awk-c_00a8_008baa_00ba_008f"></a>
<h2 class="section">2.4 翻译 <code>awk</code> 程序</h2>

<a name="index-_002epo-files-1"></a>
<a name="index-files_002c-_002epo-1"></a>
<a name="index-portable-object-files-1"></a>
<a name="index-files_002c-portable-object-1"></a>
<p>只要程序中的可翻译字串已经被标志，它们就可以被提取用来创建初始的 &lsquo;<tt>.pot</tt>&rsquo; 文件。作为翻译的一部分，重排 <code>printf</code> 要输出的参数通常都很有帮助。
</p>
<p><code>gawk</code> 的 &lsquo;<samp>--gen-pot</samp>&rsquo; 命令行参数提出消息并在后面进行讨论。之后，也会涉及 <code>printf</code> 在运行时重排 <code>printf</code> 参数的能力。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Extracting marked strings.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printf-Ordering">2.4.2 重排 <code>printf</code> 参数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Rearranging <code>printf</code> arguments.
</td></tr>
<tr><td align="left" valign="top"><a href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            <code>awk</code>-level portability issues.
</td></tr>
</table>

<hr>
<a name="String-Extraction"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-i18n" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-i18n" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Printf-Ordering" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008f_0090aa_008f_0096aa_00b7_00b2ae_00a0_0087aa_00bf_0097aa_00ad_0097a_00b8_00b2"></a>
<h3 class="subsection">2.4.1 提取已标志字串</h3>
<a name="index-strings_002c-extracting"></a>
<a name="index-marked-strings_002c-extracting"></a>
<a name="index-_002d_002dgen_002dpot-option-1"></a>
<a name="index-command_002dline-options_002c-string-extraction"></a>
<a name="index-string-extraction-_0028internationalization_0029"></a>
<a name="index-marked-string-extraction-_0028internationalization_0029"></a>
<a name="index-extraction_002c-of-marked-strings-_0028internationalization_0029"></a>

<a name="index-_002d_002dgen_002dpot-option-2"></a>
<p>一旦你的 <code>awk</code> 程序可以工作，而所有的字串都已经被标志，也设置了（可能也绑定了）文本域，就是该生成翻译的时候。首先，使用 &lsquo;<samp>--gen-pot</samp>&rsquo; 命令行选项来造成初始的 &lsquo;<tt>.pot</tt>&rsquo; 文件：
</p>
<div class="example">
<pre class="example">gawk --gen-pot -f guide.awk &gt; guide.pot
</pre></div>

<a name="index-xgettext-utility"></a>
<p>当以 &lsquo;<samp>--gen-pot</samp>&rsquo; 运行时，<code>gawk</code> 不会执行你的程序。相反，它会按通常的方式分析它，然后打印所有的已经标志的字串到标准输出上，并且是以 GNU 的 <code>gettext</code> 的可移植对象文件的格式输出。同时在输出中也包含出现在 <code>dcgettext()</code> 函数的第一个参数中的字串常量，或者是 <code>dcn<code>gettext</code>()</code> 函数中的第一、二个参数。
<a name="DOCF93" href="#FOOT93">(93)</a>
你应该你你的 <code>awk</code> 程序一起发布你的 &lsquo;<tt>.pot</tt>&rsquo; 文件，翻译者最终也会使用它来为你提供翻译，你也可以将其发布。查看 <a href="#I18N-Example">简单的国际化例子</a>，来获取完整的为 <code>guide</code> 创建及测试翻译的步骤。
</p>
<hr>
<a name="Printf-Ordering"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#String-Extraction" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-i18n" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-Portability" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0087_008dae_008e_0092-printf-aa_008f_0082ae_0095_00b0"></a>
<h3 class="subsection">2.4.2 重排 <code>printf</code> 参数</h3>

<a name="index-printf-statement_002c-positional-specifiers-1"></a>
<a name="index-positional-specifiers_002c-printf-statement-1"></a>
<p>用于 <code>printf</code> 与 <code>sprintf()</code> 函数的格式字串（查看 see section <a href="#Printf">使用 <code>printf</code> 语句美化打印</a>）导致了一种特殊的翻译问题。考虑下面的代码： 
<a name="DOCF94" href="#FOOT94">(94)</a>
</p>
<div class="example">
<pre class="example">printf(_&quot;String `%s' has %d characters\n&quot;,
          string, length(string)))
</pre></div>

<p>可能德语翻译成这样：
</p>
<div class="example">
<pre class="example">&quot;%d Zeichen lang ist die Zeichenkette `%s'\n&quot;
</pre></div>

<p>问题应该是很明显的：格式的指定与最初的是不同的！就算 <code>gettext()</code> 可以在运行时返回翻译后的字串，但是却没有办法改变调用 <code>printf</code> 参数的顺序。
</p>
<p>为了解决这个问题，<code>printf</code> 格式指定符可以有另外一个可选的元素，即<em>位置指定符</em>。例如：
</p>
<div class="example">
<pre class="example">&quot;%2$d Zeichen lang ist die Zeichenkette `%1$s'\n&quot;
</pre></div>

<p>在这里，位置指定符由一个整数构成，用来表示要使用哪个参数，以及一年 &lsquo;<samp>$</samp>&rsquo; 符号。位置是由 1 开始的，<em>不</em>包含格式串自己。所以，在下面的例子中，&lsquo;<samp>string</samp>&rsquo; 是第一个参数，&lsquo;<samp>length(string)</samp>&rsquo; 则是第二个参数：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN {</kbd>
&gt;     <kbd>string = &quot;Don\47t Panic&quot;</kbd>
&gt;     <kbd>printf &quot;%2$d characters live in \&quot;%1$s\&quot;\n&quot;,</kbd>
&gt;                         <kbd>string, length(string)</kbd>
&gt; <kbd>}'</kbd>
-| 11 characters live in &quot;Don't Panic&quot;
</pre></div>

<p>如果提供了位置指定符，这在格式规则中要第一个出现，即在标志，域宽以及/或者精度之前。
</p>
<p>位置指定符可以与动态域宽以及精度一起使用：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN {</kbd>
&gt;    <kbd>printf(&quot;%*.*s\n&quot;, 10, 20, &quot;hello&quot;)</kbd>
&gt;    <kbd>printf(&quot;%3$*2$.*1$s\n&quot;, 20, 10, &quot;hello&quot;)</kbd>
&gt; <kbd>}'</kbd>
-|      hello
-|      hello
</pre></div>

<blockquote>
<p><b>提示:</b> 当与位置指定符一起使用 &lsquo;<samp>*</samp>&rsquo; 时，&lsquo;<samp>*</samp>&rsquo; 要先出现，然后是整数位置，然后才是 &lsquo;<samp>$</samp>&rsquo; 符。这有一点反直觉。
</p></blockquote>

<a name="index-printf-statement_002c-positional-specifiers_002c-mixing-with-regular-formats"></a>
<a name="index-positional-specifiers_002c-printf-statement_002c-mixing-with-regular-formats"></a>
<a name="index-format-specifiers_002c-mixing-regular-with-positional-specifiers"></a>
<p><code>gawk</code> 不允许你在同样的字串中混用常规的格式指定符与位置指定符：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { printf &quot;%d %3$s\n&quot;, 1, 2, &quot;hi&quot; }'</kbd>
error--&gt; gawk: cmd. line:1: fatal: must use `count$' on all formats or none
</pre></div>

<blockquote>
<p><b>提示:</b> 有一个病态的列子中，<code>gawk</code> 无法识别。在这样的例子中，输出可能不是你所想要的。既使 <code>gawk</code> 没有检测到它们， 混用它们依然是个坏主意。
</p></blockquote>

<p>尽管位置指定符可以直接用在 <code>awk</code> 程序中，但它们的主要目的是用来帮助产生正确的格式串的翻译，从开始编写的语言到其他不同的语言。
</p>
<hr>
<a name="I18N-Portability"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printf-Ordering" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Translator-i18n" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-Example" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-c_009a_0084c_00a7_00bbae_00a4_008dae_0080_00a7e_0097_00aee_00a2_0098"></a>
<h3 class="subsection">2.4.3 <code>awk</code> 的移植性问题</h3>

<a name="index-portability_002c-internationalization-and"></a>
<a name="index-internationalization_002c-localization_002c-portability-and"></a>
<p><code>gawk</code> 的国际化特性有意选择对 <code>awk</code> 的可移植性影响最可能小，使它们可以用于其他的 <code>awk</code> 版本。考虑下面的程序：
</p>
<div class="example">
<pre class="example">BEGIN {
    TEXTDOMAIN = &quot;guide&quot;
    if (Test_Guide)   # set with -v
        bindtextdomain(&quot;/test/guide/messages&quot;)
    print _&quot;don't panic!&quot;
}
</pre></div>

<p>如上的代码，在其他的版本的 <code>awk</code> 中没办法工作。但是，实际它已经差不多可移植了，只需要一点点改动：
</p>
<ul>
<li><a name="index-TEXTDOMAIN-variable_002c-portability-and"></a>
</li><li>
对 <code>TEXTDOMAIN</code> 的赋值没有效果，因为 <code>TEXTDOMAIN</code> 在其他的 <code>awk</code> 实现中没有特殊含义。

</li><li>
非 GNU 版本的 <code>awk</code> 将已经标志的变量当成是变量名为 <code>_</code> 与其他的字串的连接。 
<a name="DOCF95" href="#FOOT95">(95)</a>
典型的情况，变量 <code>_</code> 将空串（<code>&quot;&quot;</code>）当成它的值，这样最初的常量字串不变。

</li><li>
通过定义“哑”函数来代替 <code>dcgettext()</code>、<code>dcngettext()</code> 与 <code>bindtextdomain()</code>，这样 <code>awk</code> 程序可以运行起来，但是只输出所有的初始语言的消息。

<a name="index-bindtextdomain_0028_0029-function-_0028gawk_0029_002c-portability-and"></a>
<a name="index-dcgettext_0028_0029-function-_0028gawk_0029_002c-portability-and"></a>
<a name="index-dcngettext_0028_0029-function-_0028gawk_0029_002c-portability-and"></a>
<div class="example">
<pre class="example">function bindtextdomain(dir, domain)
{
    return dir
}

function dcgettext(string, domain, category)
{
    return string
}

function dcngettext(string1, string2, number, domain, category)
{
    return (number == 1 ? string1 : string2)
}
</pre></div>

</li><li>
在 <code>printf</code> 与 <code>sprintf()</code> 中的位置指定符是<em>不可</em>移植的。为了在 C 层次上支持 <code>gettext()</code>，很多的系统的 C 版本的 <code>sprintf</code> 也支持位置指定符。但是只要提供了足够的参数的调用时才会有用。很多的 <code>awk</code> 版本将 <code>printf</code> 的格式与参数不变地传递给下层的 C 版本的 <code>sprintf()</code>，但是一次只传递一个格式与参数。大家可以猜测试如果使用了位置指定符的时候会发生什么。
但是，由于位置指定符主要是用来做<em>翻译</em>格式的字串，而且因为非 GNU 的 <code>awk</code> 不会返回翻译后的字中，所以这在实践中不会成为一个问题。
</li></ul>

<hr>
<a name="I18N-Example"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-Portability" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Gawk-I18N" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00ae_0080aa_008d_0095c_009a_0084aa_009b_00bde_0099_0085aa_008c_0096a_00be_008baa_00ad_0090"></a>
<h2 class="section">2.5 简单的国际化例子</h2>

<p>现在，让我们看看如何一步步地进行国际化与本地化一个例子 <code>awk</code> 程序，使用 &lsquo;<tt>guide.awk</tt>&rsquo; 作为我们的源代码：
</p>
<div class="example">
<pre class="example">BEGIN {
    TEXTDOMAIN = &quot;guide&quot;
    bindtextdomain(&quot;.&quot;)  # for testing
    print _&quot;Don't Panic&quot;
    print _&quot;The Answer Is&quot;, 42
    print &quot;Pardon me, Zaphod who?&quot;
}
</pre></div>

<p>执行 &lsquo;<samp>gawk --gen-pot</samp>&rsquo; 来创建 &lsquo;<tt>.pot</tt>&rsquo; 文件：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk --gen-pot -f guide.awk &gt; guide.pot</kbd>
</pre></div>

<p>这里会产生：
</p>
<div class="example">
<pre class="example">#: guide.awk:4
msgid &quot;Don't Panic&quot;
msgstr &quot;&quot;

#: guide.awk:5
msgid &quot;The Answer Is&quot;
msgstr &quot;&quot;

</pre></div>

<p>这是最初的可移植对象模块文件，会被保存并在每个它要进行翻译的语言中进行重用。<code>msgid</code> 是最初的字串，而 <code>msgstr</code> 是翻译。
</p>
<blockquote>
<p><b>提示:</b> 字串没有用下划线进行标志的，不会出现在 &lsquo;<tt>guide.pot</tt>&rsquo; 文件中。
</p></blockquote>

<p>下一步，则要进行消息的翻译。这里的翻译是一个假想的英语方言，称为 “Mellow”： 
<a name="DOCF96" href="#FOOT96">(96)</a>
</p>
<div class="example">
<pre class="example">$ <kbd>cp guide.pot guide-mellow.po</kbd>
<var>Add translations to</var> guide-mellow.po &hellip;
</pre></div>

<p>下面是翻译：
</p>
<div class="example">
<pre class="example">#: guide.awk:4
msgid &quot;Don't Panic&quot;
msgstr &quot;Hey man, relax!&quot;

#: guide.awk:5
msgid &quot;The Answer Is&quot;
msgstr &quot;Like, the scoop is&quot;

</pre></div>

<a name="index-Linux-1"></a>
<a name="index-GNU_002fLinux-1"></a>
<p>下一步是创建一个目录来存储二进制消息对象文件，然后创建 &lsquo;<tt>guide.mo</tt>&rsquo; 文件。我们假装我们的文件准备在 <code>en_US.UTF-8</code> 语言设置中使用，因为我们必须使用一个 C 的<code>gettext</code> 例程知道的语言设置。这里显示的目录布局表示的是 GNU/Linux 系统上的 GNU <code>gettext</code>。其他版本的 <code>gettext</code> 可以使用不同的布局：
</p>
<div class="example">
<pre class="example">$ <kbd>mkdir en_US.UTF-8 en_US.UTF-8/LC_MESSAGES</kbd>
</pre></div>

<a name="index-_002epo-files_002c-converting-to-_002emo"></a>
<a name="index-files_002c-_002epo_002c-converting-to-_002emo"></a>
<a name="index-_002emo-files_002c-converting-from-_002epo"></a>
<a name="index-files_002c-_002emo_002c-converting-from-_002epo"></a>
<a name="index-portable-object-files_002c-converting-to-message-object-files"></a>
<a name="index-files_002c-portable-object_002c-converting-to-message-object-files"></a>
<a name="index-message-object-files_002c-converting-from-portable-object-files"></a>
<a name="index-files_002c-message-object_002c-converting-from-portable-object-files"></a>
<a name="index-msgfmt-utility"></a>
<p><code>msgfmt</code> 工具将人可读的 &lsquo;<tt>.mo</tt>&rsquo; 文件转换成机器可读的 &lsquo;<tt>.mo</tt>&rsquo; 文件。默认情况下，<code>msgfmt</code> 创建一个叫做 &lsquo;<tt>messages</tt>&rsquo; 文件。这个文件必须被重新命名，并被放在合适的位置（使用 &lsquo;<samp>-o</samp>&rsquo; 选项），因此 <code>gawk</code> 可以找到它：
</p>
<div class="example">
<pre class="example">$ <kbd>msgfmt guide-mellow.po -o en_US.UTF-8/LC_MESSAGES/guide.mo</kbd>
</pre></div>

<p>最后，我们运行程序来测试：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f guide.awk</kbd>
-| Hey man, relax!
-| Like, the scoop is 42
-| Pardon me, Zaphod who?
</pre></div>

<p>如果 <code>dcgettext()</code>，<code>dcngettext()</code> 与 <code>bindtextdomain()</code> （查看 see section <a href="#I18N-Portability"><code>awk</code> 的移植性问题</a>）这三个函数在文件 &lsquo;<tt>libintl.awk</tt>&rsquo; 文件中，然后我们可以这样的运行 &lsquo;<tt>guide.awk</tt>&rsquo;：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk --posix -f guide.awk -f libintl.awk</kbd>
-| Don't Panic
-| The Answer Is 42
-| Pardon me, Zaphod who?
</pre></div>

<hr>
<a name="Gawk-I18N"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-Example" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-aa_008f_00afa_00bb_00a5e_00af_00b4a_00bd_00a0c_009a_0084e_00af_00ade_00a8_0080"></a>
<h2 class="section">2.6 <code>gawk</code> 可以说你的语言</h2>

<p><code>gawk</code> 本身已经使用 GNU <code>gettext</code> 包来做了国际化。（GNU <code>gettext</code> 在 
<a href="http://www.gnu.org/software/gettext/manual/"><cite>GNU <code>gettext</code> 工具</cite></a>
里有完整的描述）
在写这个的时候，GNU <code>gettext</code> 的最新版本是 <a href="ftp://ftp.gnu.org/gnu/gettext/gettext-0.19.4.tar.gz">版本 0.19.4</a>。
</p>
<p>如果 <code>gawk</code> 的消息翻译存在，<code>gawk</code> 产生的信息，警告，命令错误会使用本地语言。
</p>
<hr>
<a name="I18N-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Gawk-I18N" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internationalization" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-1"></a>
<h2 class="section">2.7 总结</h2>

<ul>
<li>
国际化表示写的程序可以使用多种语言而不需要对源代码进行改变。本地化则表示给已经国际化的语言提供必要的数据来使其他特定的语言中工作。

</li><li>
<code>gawk</code> 使用 GNU <code>gettext</code> 来让你对 <code>awk</code> 程序进行国际化与本地化。一个程序的文本域标识了用于组合消息与其他数据的程序。

</li><li>
你将程序中的字串用下划线来进行标识以用于翻译。一旦完成了这个，字串会被提取到一个 &lsquo;<tt>.pot</tt>&rsquo; 文件中。这个文件为每种语言的复制一个 &lsquo;<tt>.po</tt>&rsquo; 文件，然后 &lsquo;<tt>.po</tt>&rsquo; 文件会编译成 &lsquo;<tt>.gmo</tt>&rsquo; 文件来在运行时使用。

</li><li>
你可以在 <code>sprintf</code> 与 <code>printf</code> 中使用位置指定符，使可以在格式化串与输出中输出中重新对参数值进行排序。这对于控制字串的翻译很有用。

</li><li>
国际化特别被设计成在标准的 <code>awk</code> 中也可以很好处理。

</li><li>
<code>gawk</code> 本身已经国际化，并发布了多种语言消息。

</li></ul>


<hr>
<a name="Debugger"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Internationalization" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#I18N-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00b0_0083e_00af_0095-awk-c_00a8_008baa_00ba_008f"></a>
<h1 class="chapter">3 调试 <code>awk</code> 程序</h1>
<a name="index-debugging-awk-programs"></a>


<p>如果程序在第一次运动就表现完美那就好了，但是在现实生活中，这对于任意复杂度的程序来说都很少见。所以，大多数的程序语言都有相应的工具用来进行“调试”程序，而 <code>awk</code> 也不例外。
</p>
<p><code>gawk</code> 的调试器有意地参照 <a href="http://www.gnu.org/software/gdb/">GNU 调试器（GDB）</a> 的命令行调试器。如果你熟悉 GDB，学习如何来使用 <code>gawk</code> 调试你的程序就很简单。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Debugging">3.1 <code>gawk</code> 调试器介绍</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Introduction to <code>gawk</code> debugger.
</td></tr>
<tr><td align="left" valign="top"><a href="#Sample-Debugging-Session">3.2 <code>gawk</code> 调试例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Sample debugging session.
</td></tr>
<tr><td align="left" valign="top"><a href="#List-of-Debugger-Commands">3.3 主要的调试器命令</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Main debugger commands.
</td></tr>
<tr><td align="left" valign="top"><a href="#Readline-Support">3.4 支持</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Readline support.
</td></tr>
<tr><td align="left" valign="top"><a href="#Limitations">3.5 限制</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Limitations and future plans.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugging-Summary">3.6 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Debugging summary.
</td></tr>
</table>

<hr>
<a name="Debugging"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging-Concepts" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-e_00b0_0083e_00af_0095aa_0099_00a8a_00bb_008bc_00bb_008d"></a>
<h2 class="section">3.1 <code>gawk</code> 调试器介绍</h2>

<p>本小节一般性地介绍一下调试器以及开始讨论 <code>gawk</code> 的调试。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Debugging-Concepts">3.1.1 通用的调试技术</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Debugging in General.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugging-Terms">3.1.2 调试概念</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Additional Debugging Concepts.
</td></tr>
<tr><td align="left" valign="top"><a href="#Awk-Debugging">3.1.3 <code>awk</code> 调试</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Awk Debugging.
</td></tr>
</table>

<hr>
<a name="Debugging-Concepts"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging-Terms" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0080_009ac_0094_00a8c_009a_0084e_00b0_0083e_00af_0095ae_008a_0080ae_009c_00af"></a>
<h3 class="subsection">3.1.1 通用的调试技术</h3>

<p>（如果你使用过其他语言的调试器，你可以跳过到 <a href="#Awk-Debugging"><code>awk</code> 调试</a>。）
</p>
<p>当然，调试程序没办法帮你移除 Bug，因此它并不知道你或者你的用户如何将其当成是个 Bug，还是一个特性。（有时候，人类自己对于这个问题也挣扎了很久。）在这个情况下，你从这样的工具想得到什么呢？答案依赖于正在被调试的语言，但是一般来说，你至少可以得如下的结果：
</p>
<ul>
<li>
有能力查看程序指令一条条地执行，这样你这样的程序员就有机会考虑在秒级，分钟级，或者小时级的时间上发生了什么，而不是纳秒级的时间上。在这个时间上代码总会是执行的。

</li><li>
有机会不仅是被动地发现你的程序的操作，而且能够控制它，并且尝试不同的执行路径，而不需要改动你的源代码。

</li><li>
有机会在任何的执行时间点看到数据的值，并且在执行时候改变它的值，以测试后续其如何来影响程序。（这一般都包括查看内部数据结构的能力，包含你在代码中定义的变量。）

</li><li>
有能力取得程序状态的额外 信息，甚至是内部结构。
</li></ul>

<p>所有这样的工作都提供大量的帮助来使用你自己的技能来理解你的程序的目标，以此来发现哪里出了错（或者，通过这样可以更好地理解你或者别人写的功能程序）。
</p>
<hr>
<a name="Debugging-Terms"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging-Concepts" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Awk-Debugging" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00b0_0083e_00af_0095ae_00a6_0082aa_00bf_00b5"></a>
<h3 class="subsection">3.1.2 调试概念</h3>

<p>在深入细节之前，我们需要介绍关于调试器的几个重要概念。下面的列表定义了本章中后面使用到术语：
</p>
<dl compact="compact">
<dd><a name="index-stack-frame"></a>
</dd>
<dt><em>Stack frame</em></dt>
<dd><p>程序一般在它们的执行过程中调用函数。一个函数调用另一个函数，或者函数调试自己（递归）。你可以查看函数调用的链（主程序调用 A，而 A 调用 B，B 再试用 C），作为执行函数栈：当前运行的函数在栈的最顶端，当它完成时（返回），下一个则成会活动函数。这样的一个栈术语上叫做<em>调用栈</em>。
</p>
<p>在调用栈上的每一个函数，系统都会保留一个数据区来包含函数的参数，本地变量以及返回值，以及其他的“登记”信息，以用来管理调用栈。这个数据区被称为<em>栈帧</em>。
</p>
<p><code>gawk</code> 也使用这样的模型，可以让你访问到调用栈以及每个栈帧。你可以看到调用栈，以及从栈中的哪个函数调用。用来打印调用栈的命令打印每个栈帖的信息（后面有详细内容）。
</p>
</dd>
<dt><em>Breakpoint</em></dt>
<dd><a name="index-breakpoint"></a>
<p>在调试期间，你常常希望程序执行到一个特定的点，然后继续从那里一次执行一条语句。要这么做的方式是在程序中设置一个<em>断点</em>。一个断点是程序执行时会暂停（停止）的位置，因此你可以取得程序执行控制权。你可以添加或者移除多个断点。
</p>
</dd>
<dt><em>Watchpoint</em></dt>
<dd><a name="index-watchpoint"></a>
<p>一个查看点与断点类型。不同的是断点是面向代码的，当代码执行到达后，会停止执行。一个查看点，则指定的程序当某个<em>值</em>改变时会停止。这会相当有用，因为有时变量接收了一个错误的值，而只查看代码很难跟踪。通过使用查看点，你可以在变量被赋值时而停下来，这样通常可以很快地查找到错误的代码。
</p></dd>
</dl>

<hr>
<a name="Awk-Debugging"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging-Terms" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Debugging-Session" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="awk-e_00b0_0083e_00af_0095"></a>
<h3 class="subsection">3.1.3 <code>awk</code> 调试</h3>

<p>调试 <code>awk</code> 程序有一些方面与调试其他语言写成的程序有一些不同。
</p>
<p>首先，<code>awk</code> 程序通常是从一个或者多个文件中一行行地读取数据，然后使用特定的规则操作这些行，这样，根据这些规则来查看程序的程序的执行是非常有用的。正如我们见到的，每一个 <code>awk</code> 规则都像一个函数一样，它们有自己特定的指令块。
</p>
<p>另外，由于 <code>awk</code> 设计上是一个很简练的语言，这样很容易看走眼，而不知道每一个行的 <code>awk</code> 程序代码里面到底发生了什么。使用更高层的 <code>awk</code> 命令，调试器使得我们有机会来查看单个的原始命令。
</p>
<hr>
<a name="Sample-Debugging-Session"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Awk-Debugging" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger-Invocation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-e_00b0_0083e_00af_0095a_00be_008baa_00ad_0090"></a>
<h2 class="section">3.2 <code>gawk</code> 调试例子</h2>
<a name="index-sample-debugging-session"></a>

<p>为了解释 <code>gawk</code> 调用的使用，让我们来看一个例子的调试过程。我们利用早前提到的 POSIX uniq 命令的 <code>awk</code> 实现（查看 see section <a href="#Uniq-Program">打印去重文本行</a>）来作为我们的例子。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Debugger-Invocation">3.2.1 如何开启调试器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         How to Start the Debugger.
</td></tr>
<tr><td align="left" valign="top"><a href="#Finding-The-Bug">3.2.2 查找 Bug</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Finding the Bug.
</td></tr>
</table>

<hr>
<a name="Debugger-Invocation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Debugging-Session" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Debugging-Session" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Finding-The-Bug" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a6_0082a_00bd_0095aa_00bc_0080aa_0090_00afe_00b0_0083e_00af_0095aa_0099_00a8"></a>
<h3 class="subsection">3.2.1 如何开启调试器</h3>
<a name="index-starting-the-debugger"></a>
<a name="index-debugger_002c-how-to-start"></a>

<p>开始调试器几乎就跟正常运行 <code>gawk</code> 一样，只是你需要传递一个额外的选项 &lsquo;<samp>--debug</samp>&rsquo;，或者其对应的短选项 &lsquo;<samp>-D</samp>&rsquo;。包含程序的文件，或者任何受支持的在命令行上的代码，都作为一个或者多个 &lsquo;<samp>-f</samp>&rsquo; 选项的参数。（<code>gawk</code> 没有为命令行程序设计调试，只支持包含在文件的程序）在我们的例子中，我们这样来调用调试器：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -D -f getopt.awk -f join.awk -f uniq.awk -1 inputfile</kbd>
</pre></div>

<p>&lsquo;<tt>getopt.awk</tt>&rsquo; 与 &lsquo;<tt>uniq.awk</tt>&rsquo; 两个程序都在 <code>$AWKPATH</code> 目录中。
（GDB 或者类似调试器有经验的用户都应该注意到了这个语法与你之前所使用的语法有一些轻微的差异。在 <code>gawk</code> 调试器里，你将在命令行上传递给运行程序的参数给了调试器，而不是作为在调试指示符下 <code>run</code> 命令的一部分。&lsquo;<samp>-1</samp>&rsquo; 是 &lsquo;<tt>uniq.awk</tt>&rsquo; 的选项。
</p>
<p>不像 <code>gawk</code> 通常所做的那样，立即对输入文件 &lsquo;<tt>inputfile</tt>&rsquo; 执行程序，调试器仅仅载入所有的程序源代码，在内部编译它们，然后给出提示符：
</p>
<div class="example">
<pre class="example">gawk&gt;
</pre></div>

<p>从这里，你们可以发送命令到调试器。在这一点上，还没有代码被执行。
</p>
<hr>
<a name="Finding-The-Bug"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger-Invocation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Sample-Debugging-Session" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#List-of-Debugger-Commands" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009f_00a5ae_0089_00be-Bug"></a>
<h3 class="subsection">3.2.2 查找 Bug</h3>

<p>假充我们在使用（一个有错误的版本）&lsquo;<tt>uniq.awk</tt>&rsquo; 中的 “域跨越”模式时有问题，看起来，当要跳过第一个域时，它没有捕获到本来相同的行，如：
</p>
<div class="example">
<pre class="example">awk is a wonderful program!
gawk is a wonderful program!
</pre></div>

<p>这有可能会发生，如果我们将在记录中的域想成是一个以 0 开始（C 风格）编号的，所以本来应该写成下面的行：
</p>
<div class="example">
<pre class="example">clast = join(alast, fcount+1, n)
cline = join(aline, fcount+1, m)
</pre></div>

<p>我们写成了：
</p>
<div class="example">
<pre class="example">clast = join(alast, fcount, n)
cline = join(aline, fcount, m)
</pre></div>

<p>我们第一件要做的事常常是要检查出这样的问题是在程序中设置一个断点，这样我们可以查看它们如何工作，并捕获到发生的错误。在 &lsquo;<tt>uniq.awk</tt>&rsquo; 中合理的断点是在函数 <code>are_equal()</code> 的开始处，在这个函数中，会将当前行与前一个行进行比较。要设置断点，使用 <code>b</code>（breakpoint）命令：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>b are_equal</kbd>
-| Breakpoint 1 set at file `awklib/eg/prog/uniq.awk', line 63
</pre></div>

<p>调试器告诉我们断点所在的文件以及行号。现在，我们输入 &lsquo;<samp>r</samp>&rsquo; 或者 &lsquo;<samp>run</samp>&rsquo;，然后程序会执行，直到其第一次命令断点：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>r</kbd>
-| Starting program:
-| Stopping in Rule ...
-| Breakpoint 1, are_equal(n, m, clast, cline, alast, aline)
         at `awklib/eg/prog/uniq.awk':63
-| 63          if (fcount == 0 &amp;&amp; charcount == 0)
gawk&gt;
</pre></div>

<p>现在，我们可以查看程序中哪里出了问题。首先，让我们看一下我们是怎么来到现在的位置。在提示符下，我们输入 &lsquo;<samp>bt</samp>&rsquo;（“backtrace”的缩写），则调试器会返回当前栈帧的列表：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>bt</kbd>
-| #0  are_equal(n, m, clast, cline, alast, aline)
         at `awklib/eg/prog/uniq.awk':68
-| #1  in main() at `awklib/eg/prog/uniq.awk':88
</pre></div>

<p>这告诉我们 <code>are_equal()</code> 是在主程序 &lsquo;<tt>uniq.awk</tt>&rsquo; 第 88 行调用的。（这没什么大惊小怪的，因此这是在程序中唯一调用 <code>are_equal()</code> 的地方，但是在更复杂的程序中，了解谁调用了函数，以及相应的参数是查找到程序问题的关键。）
</p>
<p>现在，我们已经在 <code>are_equal()</code> 中了，我们开始来查看某些变量的值。假设我们输入 &lsquo;<samp>p n</samp>&rsquo;（p 是 “print”的缩写）。我们期望看到 <code>are_equal()</code> 参数 <code>n</code> 的值。实际是，调试器返回：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p n</kbd>
-| n = untyped variable
</pre></div>

<p>在这个例子中，<code>n</code> 是一个未初始化的本地变量，因为函数调用时没有提供绘画它参数（查看 see section <a href="#Function-Calls">函数调用</a>）。
</p>
<p>要显示的更有用的变量应该是当前记录：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p $0</kbd>
-| $0 = &quot;gawk is a wonderful program!&quot;
</pre></div>

<p>在一开始，这个可能会有一点疑惑，因为这是我们的测试输入的第二行，我们来看看 <code>NR</code>：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p NR</kbd>
-| NR = 2
</pre></div>

<p>因此，我们看到 <code>are_equal()</code> 只会从文件的第二个记录开始调用。当然，这是因为我们包含了这样的一个规则 &lsquo;<samp><code>NR</code> == 1</samp>&rsquo; ：
</p>
<div class="example">
<pre class="example">NR == 1 {
    last = $0
    next
}
</pre></div>

<p>好了，让我们查看当前正在执行的规则：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p last</kbd>
-| last = &quot;awk is a wonderful program!&quot;
</pre></div>

<p>目前我们所做的一切都只是说明程序正如计划的那样执行，直至 <code>are_equal()</code> 为止，包含函数调用，因此问题一定出在函数内部。为了进一步调查，我们必须“一步步”地执行 <code>are_equal()</code> 的代码行。我们敲入 &lsquo;<samp>n</samp>&rsquo;（表示“next”）：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>n</kbd>
-| 66          if (fcount &gt; 0) {
</pre></div>

<p>这告诉我们，<code>gawk</code> 现在已经准备执行第 66 行，确定这是否需要给行特殊的“域跨越”处理，正如命令行选项 &lsquo;<samp>-1</samp>&rsquo; 所示的那样。（请注意，我们是从我们之前所在的位置，第 63 行，跳到目前所在的位置，因为在 63 行的条件是 &lsquo;<samp>if (fcount == 0 &amp;&amp; charcount == 0)</samp>&rsquo;，而其值为 false。）
</p>
<p>继续执行一步，我们现在到了将当前与最后记录进行分割的地方：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>n</kbd>
-| 67              n = split(last, alast)
gawk&gt; <kbd>n</kbd>
-| 68              m = split($0, aline)
</pre></div>

<p>在这一点上，我们很好奇地去查看记录被分割成了什么，我们试着去查看：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p n m alast aline</kbd>
-| n = 5
-| m = untyped variable
-| alast = array, 5 elements
-| aline = untyped variable
</pre></div>

<p>（<code>p</code> 命令可以有多于一个参数，与 <code>awk</code> 的 <code>printf</code> 语句类似。）
</p>
<p>但是，这里有一点失望。我们找到的是在里面有 5 个元素的 <code>alast</code>，<code>m</code> 与 <code>aline</code> 没有值，因为我们在行 68，但是还没有执行。这个信息已经够用了（我们现在知道没有单词被无意间丢掉了），但是如果我们想知道数组里有什么怎么办？
</p>
<p>第一个选择是使用下标：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p alast[0]</kbd>
-| &quot;0&quot; not in array `alast'
</pre></div>

<p>Oops!
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p alast[1]</kbd>
-| alast[&quot;1&quot;] = &quot;awk&quot;
</pre></div>

<p>如果有 100 个成员的数组，这就太慢了，所以，<code>gawk</code> 提供了一个快捷方式（对于其他语言的旧情怀就不提了）：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p @alast</kbd>
-| alast[&quot;1&quot;] = &quot;awk&quot;
-| alast[&quot;2&quot;] = &quot;is&quot;
-| alast[&quot;3&quot;] = &quot;a&quot;
-| alast[&quot;4&quot;] = &quot;wonderful&quot;
-| alast[&quot;5&quot;] = &quot;program!&quot;
</pre></div>

<p>目前看起来，一切 OK，让我们再执行一两步：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>n</kbd>
-| 69              clast = join(alast, fcount, n)
gawk&gt; <kbd>n</kbd>
-| 70              cline = join(aline, fcount, m)
</pre></div>

<p>好了，我们已经到达了错误的地方（抱歉破坏了悬念）。在我们的大脑中是从第二个域开始来生成一个假记录来进行比较。而如果第一个记录编号为 0，这就会工作。让我们看看我们得到什么：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>p cline clast</kbd>
-| cline = &quot;gawk is a wonderful program!&quot;
-| clast = &quot;awk is a wonderful program!&quot;
</pre></div>

<p>嘿，看起来是不是很熟悉！他们就是原来的值，没有改变。思考片刻（人的大脑依然是最好的调试工具），我们知道我们少加了 1！
</p>
<p>我们退出调试器：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>q</kbd>
-| The program is running. Exit anyway (y/n)? <kbd>y</kbd>
</pre></div>

<p>然后进入编辑器编辑：
</p>
<div class="example">
<pre class="example">clast = join(alast, fcount+1, n)
cline = join(aline, fcount+1, m)
</pre></div>

<p>然后问题解决！
</p>
<hr>
<a name="List-of-Debugger-Commands"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Finding-The-Bug" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Breakpoint-Control" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_00bbe_00a6_0081c_009a_0084e_00b0_0083e_00af_0095aa_0099_00a8aa_0091_00bda_00bb_00a4"></a>
<h2 class="section">3.3 主要的调试器命令</h2>

<p><code>gawk</code> 调试器命令可以被分为下面的几类：
</p>
<ul>
<li>
断点控制

</li><li>
执行控制

</li><li>
查看与更改数据

</li><li>
使用栈

</li><li>
获取信息

</li><li>
其他
</li></ul>

<p>每个个类型都在下面的节中进行讨论。在下面的描述中，命令，可能被缩写显示在第二个描述行。调试器命令名如果没有二义，则也可以被丢弃后面一部分。调试器有内置的自动重复前一个命令的能力，只需要输入回车键 <kbd>Enter</kbd>。这可用于命令列表，<code>next</code>，<code>nexti</code>，<code>step</code>，<code>stepi</code>，以及 <code>continue</code> 等不带参数的命令。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Control of Breakpoints.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Control of Execution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   Viewing and Changing Data.
</td></tr>
<tr><td align="left" valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Dealing with the Stack.
</td></tr>
<tr><td align="left" valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Obtaining Information about the Program and
                                the Debugger State.
</td></tr>
<tr><td align="left" valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Miscellaneous Commands.
</td></tr>
</table>

<hr>
<a name="Breakpoint-Control"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#List-of-Debugger-Commands" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#List-of-Debugger-Commands" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger-Execution-Control" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008e_00a7aa_0088_00b6ae_0096_00adc_0082_00b9"></a>
<h3 class="subsection">3.3.1 控制断点</h3>

<p>如早前看见，你要开启一个调试过程时，要考虑的第一件事情是设置好断点，因为程序会像没有调试器一样运行下去。用于控制断点的命令有：
</p>
<dl compact="compact">
<dd><a name="index-debugger-commands_002c-b-_0028break_0029"></a>
<a name="index-debugger-commands_002c-break"></a>
<a name="index-break-debugger-command"></a>
<a name="index-b-debugger-command-_0028alias-for-break_0029"></a>
<a name="index-set-breakpoint"></a>
<a name="index-breakpoint_002c-setting"></a>
</dd>
<dt><code>break</code> [[<var>filename</var><code>:</code>]<var>n</var> | <var>function</var>] [<code>&quot;<var>expression</var>&quot;</code>]</dt>
<dt><code>b</code> [[<var>filename</var><code>:</code>]<var>n</var> | <var>function</var>] [<code>&quot;<var>expression</var>&quot;</code>]</dt>
<dd><p>如果不带任何参数，则在所选择的栈中的下一个要执行的指令处设置一个断点。参数可以是如下格式：
</p>
<dl compact="compact">
<dt><var>n</var></dt>
<dd><p>在当前的源文件中的 <var>n</var> 行设置一个断点。
</p>
</dd>
<dt><var>filename</var><code>:</code><var>n</var></dt>
<dd><p>在源文件 <var>filename</var> 的 <var>n</var> 行设置一个断点。
</p>
</dd>
<dt><var>function</var></dt>
<dd><p>在函数 <var>function</var>（第一条指令）入口处设置一个断点。
</p></dd>
</dl>

<p>每一个断点被赋给了一个数值，可以用 <code>delete</code> 命令来从断点列表中删除。
</p>
<p>对于断点，你还可以提供一个条件。这是一个 <code>awk</code> 的表达式（包在双引号中），这样调试器当到到断点时可以对其求值。如果条件为 true，则调试器停止执行，然后提示等待命令输入。否则，它会继续执行程序。
</p>
<a name="index-debugger-commands_002c-clear"></a>
<a name="index-clear-debugger-command"></a>
<a name="index-delete-breakpoint-at-location"></a>
<a name="index-breakpoint-at-location_002c-how-to-delete"></a>
</dd>
<dt><code>clear</code> [[<var>filename</var><code>:</code>]<var>n</var> | <var>function</var>]</dt>
<dd><p>如果没有参数，则在当前的栈中删除下一条要执行命令的所有断点。如果程序在断点上停止了，这会删除那个断点，这样程序在那个位置不会再停下来。参数可以有下面的形式：
</p>
<dl compact="compact">
<dt><var>n</var></dt>
<dd><p>在当前源文件中删除在 <var>n</var> 行上设置的断点。
</p>
</dd>
<dt><var>filename</var><code>:</code><var>n</var></dt>
<dd><p>删除源文件 <var>filename</var> 行 <var>n</var> 中的断点。
</p>
</dd>
<dt><var>function</var></dt>
<dd><p>删除源函数 <var>function</var> 的断点。
</p></dd>
</dl>

<a name="index-debugger-commands_002c-condition"></a>
<a name="index-condition-debugger-command"></a>
<a name="index-breakpoint-condition"></a>
</dd>
<dt><code>condition</code> <var>n</var> <code>&quot;<var>expression</var>&quot;</code></dt>
<dd><p>给已经存在的断点或者查看点 <var>n</var> 加一个额外的条件。条件是一个 <code>awk</code> 表达式，<em>用双引号括起来，</em>当断点或者查看点到达时，会对其进行求值。如果条件为 true，则调试器会停止执行然后提示命令输入。否则，调试器会继续执行程序。如果条件表达式没有被指定，则已经存在的条件会被删除（即，断点或者查看点会被设置成无条件的）。
</p>
<a name="index-debugger-commands_002c-d-_0028delete_0029"></a>
<a name="index-debugger-commands_002c-delete"></a>
<a name="index-delete-debugger-command"></a>
<a name="index-d-debugger-command-_0028alias-for-delete_0029"></a>
<a name="index-delete-breakpoint-by-number"></a>
<a name="index-breakpoint_002c-delete-by-number"></a>
</dd>
<dt><code>delete</code> [<var>n1 n2</var> &hellip;] [<var>n</var>&ndash;<var>m</var>]</dt>
<dt><code>d</code> [<var>n1 n2</var> &hellip;] [<var>n</var>&ndash;<var>m</var>]</dt>
<dd><p>删除指定的断点，或者断点范围。如果没有指定参数，则删除所有的断点。
</p>
<a name="index-debugger-commands_002c-disable"></a>
<a name="index-disable-debugger-command"></a>
<a name="index-disable-breakpoint"></a>
<a name="index-breakpoint_002c-how-to-disable-or-enable"></a>
</dd>
<dt><code>disable</code> [<var>n1 n2</var> &hellip; | <var>n</var>&ndash;<var>m</var>]</dt>
<dd><p>禁用指定的断点或者断点范围。如果没有带参数，则禁用所有的断点。
</p>
<a name="index-debugger-commands_002c-e-_0028enable_0029"></a>
<a name="index-debugger-commands_002c-enable"></a>
<a name="index-enable-debugger-command"></a>
<a name="index-e-debugger-command-_0028alias-for-enable_0029"></a>
<a name="index-enable-breakpoint"></a>
</dd>
<dt><code>enable</code> [<code>del</code> | <code>once</code>] [<var>n1 n2</var> &hellip;] [<var>n</var>&ndash;<var>m</var>]</dt>
<dt><code>e</code> [<code>del</code> | <code>once</code>] [<var>n1 n2</var> &hellip;] [<var>n</var>&ndash;<var>m</var>]</dt>
<dd><p>启用指定的断点或者范围内的断点。如果没有参数，则启用所有的断点。你也可以选择性地定义如何来恢复断点：
</p>
<dl compact="compact">
<dt><code>del</code></dt>
<dd><p>临时启用断点，然后程序在此停止时删除每个断点。
</p>
</dd>
<dt><code>once</code></dt>
<dd><p>临时启用断点，然后程序在此停止时禁用每个断点。
</p></dd>
</dl>

<a name="index-debugger-commands_002c-ignore"></a>
<a name="index-ignore-debugger-command"></a>
<a name="index-ignore-breakpoint"></a>
</dd>
<dt><code>ignore</code> <var>n</var> <var>count</var></dt>
<dd><p>忽略断点 <var>n</var> 后面命中的 <var>count</var> 次。
</p>
<a name="index-debugger-commands_002c-t-_0028tbreak_0029"></a>
<a name="index-debugger-commands_002c-tbreak"></a>
<a name="index-tbreak-debugger-command"></a>
<a name="index-t-debugger-command-_0028alias-for-tbreak_0029"></a>
<a name="index-temporary-breakpoint"></a>
</dd>
<dt><code>tbreak</code> [[<var>filename</var><code>:</code>]<var>n</var> | <var>function</var>]</dt>
<dt><code>t</code> [[<var>filename</var><code>:</code>]<var>n</var> | <var>function</var>]</dt>
<dd><p>设置临时断点（只启用一次）。参数与 <code>break</code> 一样。
</p></dd>
</dl>

<hr>
<a name="Debugger-Execution-Control"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Breakpoint-Control" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#List-of-Debugger-Commands" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Viewing-And-Changing-Data" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008e_00a7aa_0088_00b6ae_0089_00a7e_00a1_008c"></a>
<h3 class="subsection">3.3.2 控制执行</h3>

<p>现在，你的断点已经准备好了，你可以开始运行程序，然后观察它的行为。有多个命令用来控制程序的执行，之前我们已经看过：
</p>
<dl compact="compact">
<dd><a name="index-debugger-commands_002c-commands"></a>
<a name="index-commands-debugger-command"></a>
<a name="index-debugger-commands_002c-silent"></a>
<a name="index-silent-debugger-command"></a>
<a name="index-debugger-commands_002c-end"></a>
<a name="index-end-debugger-command"></a>
<a name="index-breakpoint-commands"></a>
<a name="index-commands-to-execute-at-breakpoint"></a>
</dd>
<dt><code>commands</code> [<var>n</var>]</dt>
<dt><code>silent</code></dt>
<dt>&hellip;</dt>
<dt><code>end</code></dt>
<dd><p>设置一个命令列表，当在断点或者查看点处停止时会被执行。<var>n</var> 是断点或者查看点编号。如果没有编号，则会使用最后一个。后面的命令，从下一行开始，然后在 <code>end</code> 命令处结束。如果命令 <code>silent</code> 在列表中，则通常的在断点停止处的消息以及源代码就会被打印。在列表中的所有命令如果继续执行代码（如 <code>continue</code>）会结束列表（一个隐式的 <code>end</code>），后面的命令会被忽略掉。如：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>commands</kbd>
&gt; <kbd>silent</kbd>
&gt; <kbd>printf &quot;A silent breakpoint; i = %d\n&quot;, i</kbd>
&gt; <kbd>info locals</kbd>
&gt; <kbd>set i = 10</kbd>
&gt; <kbd>continue</kbd>
&gt; <kbd>end</kbd>
gawk&gt;
</pre></div>

<a name="index-debugger-commands_002c-c-_0028continue_0029"></a>
<a name="index-debugger-commands_002c-continue"></a>
<a name="index-continue-program_002c-in-debugger"></a>
</dd>
<dt><code>continue</code> [<var>count</var>]</dt>
<dt><code>c</code> [<var>count</var>]</dt>
<dd><p>继续执行程序。如果从断点处继续，而指定了 <var>count</var>，则忽略所在处的断点后面的 <var>count</var> 次命中。直到所选择的帧结束。并打印返回值。
</p>
<a name="index-debugger-commands_002c-finish"></a>
<a name="index-finish-debugger-command"></a>
</dd>
<dt><code>finish</code></dt>
<dd><p>执行代码直到所选择的帧返回，并打印返回值。
</p>
<a name="index-debugger-commands_002c-n-_0028next_0029"></a>
<a name="index-debugger-commands_002c-next"></a>
<a name="index-next-debugger-command"></a>
<a name="index-n-debugger-command-_0028alias-for-next_0029"></a>
<a name="index-single_002dstep-execution_002c-in-the-debugger"></a>
</dd>
<dt><code>next</code> [<var>count</var>]</dt>
<dt><code>n</code> [<var>count</var>]</dt>
<dd><p>继续执行下一行源代码，函数调用一次划过。参数 <var>count</var> 控制重复多少次，与 <code>step</code> 一样。
</p>
<a name="index-debugger-commands_002c-ni-_0028nexti_0029"></a>
<a name="index-debugger-commands_002c-nexti"></a>
<a name="index-nexti-debugger-command"></a>
<a name="index-ni-debugger-command-_0028alias-for-nexti_0029"></a>
</dd>
<dt><code>nexti</code> [<var>count</var>]</dt>
<dt><code>ni</code> [<var>count</var>]</dt>
<dd><p>执行 1 个或者 <var>count</var> 个指令，并越过函数调用。
</p>
<a name="index-debugger-commands_002c-return"></a>
<a name="index-return-debugger-command"></a>
</dd>
<dt><code>return</code> [<var>value</var>]</dt>
<dd><p>取消函数调用。如果 <var>value</var>（一个字串或者数值）被指定了，则它会作为函数的返回值。如果是在不是最内层（当前的执行函数，即帧 0 ）的帧中使用，会取消所有最内层的帧，包括所在的帧，该帧的调用者会成为最内层帧。
</p>
<a name="index-debugger-commands_002c-r-_0028run_0029"></a>
<a name="index-debugger-commands_002c-run"></a>
<a name="index-run-debugger-command"></a>
<a name="index-r-debugger-command-_0028alias-for-run_0029"></a>
</dd>
<dt><code>run</code></dt>
<dt><code>r</code></dt>
<dd><p>开始/重新开始程序的执行。当重新开始时，调试器会保留当前的断点，查看点以及命令历史，自动显示变量，以及调试器选项。
</p>
<a name="index-debugger-commands_002c-s-_0028step_0029"></a>
<a name="index-debugger-commands_002c-step"></a>
<a name="index-step-debugger-command"></a>
<a name="index-s-debugger-command-_0028alias-for-step_0029"></a>
</dd>
<dt><code>step</code> [<var>count</var>]</dt>
<dt><code>s</code> [<var>count</var>]</dt>
<dd><p>继续执行直到控制流到到当前帧的源代码行的不同位置，并进入该行调用的函数中。如果参数 <var>count</var> 被指定了，则表示在停止前单独执行多少次，除非它遇到了断点或者查看点。
</p>
<a name="index-debugger-commands_002c-si-_0028stepi_0029"></a>
<a name="index-debugger-commands_002c-stepi"></a>
<a name="index-stepi-debugger-command"></a>
<a name="index-si-debugger-command-_0028alias-for-stepi_0029"></a>
</dd>
<dt><code>stepi</code> [<var>count</var>]</dt>
<dt><code>si</code> [<var>count</var>]</dt>
<dd><p>执行 1 个（或者 <var>count</var>）个指令，并进入函数调用中。（为了说明“指令”的含义，查看在 <a href="#Miscellaneous-Debugger-Commands">其他命令</a> 中 <code>dump</code> 下的输出。）
</p>
<a name="index-debugger-commands_002c-u-_0028until_0029"></a>
<a name="index-debugger-commands_002c-until"></a>
<a name="index-until-debugger-command"></a>
<a name="index-u-debugger-command-_0028alias-for-until_0029"></a>
</dd>
<dt><code>until</code> [[<var>filename</var><code>:</code>]<var>n</var> | <var>function</var>]</dt>
<dt><code>u</code> [[<var>filename</var><code>:</code>]<var>n</var> | <var>function</var>]</dt>
<dd><p>如果没有任何参数，执行到当前帧当前行的下一行。如果有参数，则持续执行到指定的位置，或者直到当前帧返回。
</p></dd>
</dl>

<hr>
<a name="Viewing-And-Changing-Data"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger-Execution-Control" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#List-of-Debugger-Commands" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Execution-Stack" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009f_00a5c_009c_008ba_00b8_008eae_009b_00b4ae_0094_00b9ae_0095_00b0ae_008d_00ae"></a>
<h3 class="subsection">3.3.3 查看与更改数据</h3>

<p><code>gawk</code> 中用于查看及更改变量的命令有：
</p>
<dl compact="compact">
<dd><a name="index-debugger-commands_002c-display"></a>
<a name="index-display-debugger-command"></a>
</dd>
<dt><code>display</code> [<var>var</var> | <code>$</code><var>n</var>]</dt>
<dd><p>将变量 <var>var</var> 或者域 <code>$<var>n</var></code> 添加到显示列表中。变量的值或者域的值在程序每次停止都会被显示。每个加入到列表中的列表都通过一个唯一的数字来区别：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>display x</kbd>
-| 10: x = 1
</pre></div>

<p>这显示了被赋值的项，变量名以及其及当前的值。如果显示变量指向了函数的参数，它会在执行到没有这个变量名的上下文时默默地将它从显示列表中删除。如果没有参数，<code>display</code> 会显示列表中的项的当前值。
</p>
<a name="index-debugger-commands_002c-eval"></a>
<a name="index-eval-debugger-command"></a>
<a name="index-evaluate-expressions_002c-in-debugger"></a>
</dd>
<dt><code>eval &quot;<var>awk statements</var>&quot;</code></dt>
<dd><p>对 <var>awk statements</var> 在执行程序中的上下文中进行求值。你可以做任何的 <code>awk</code> 程序可以做的事情：赋值绘画变量，调用函数等等。
</p>
</dd>
<dt><code>eval</code> <var>param</var>, &hellip;</dt>
<dt><var>awk statements</var></dt>
<dt><code>end</code></dt>
<dd><p><code>eval</code> 这个形式的求值类似，但是可以让你定义存在 <var>awk statements</var> 上下文中“本地变量”，而不是使用由程序定义的变量或者函数参数。
</p>
<a name="index-debugger-commands_002c-p-_0028print_0029"></a>
<a name="index-debugger-commands_002c-print"></a>
<a name="index-print-debugger-command"></a>
<a name="index-p-debugger-command-_0028alias-for-print_0029"></a>
<a name="index-print-variables_002c-in-debugger"></a>
</dd>
<dt><code>print</code> <var>var1</var>[<code>,</code> <var>var2</var> &hellip;]</dt>
<dt><code>p</code> <var>var1</var>[<code>,</code> <var>var2</var> &hellip;]</dt>
<dd><p>打印 <code>gawk</code> 变量或者域的值。域必须是通过常量来参考：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>print $3</kbd>
</pre></div>

<p>这打印输入记录中的第三个域（如果指定的域不存在，它会打印 &lsquo;<samp>Null field</samp>&rsquo;）。变量可以是数组元素，下标是常量字串。为了打印数组内容，在名字的前面加一个 &lsquo;<samp>@</samp>&rsquo; 符号：
</p>
<div class="example">
<pre class="example">gawk&gt; <kbd>print @a</kbd>
</pre></div>

<p>这会打印索引以及所有在数组 <code>a</code> 中相应元素的值。
</p>
<a name="index-debugger-commands_002c-printf"></a>
<a name="index-printf-debugger-command"></a>
</dd>
<dt><code>printf</code> <var>format</var> [<code>,</code> <var>arg</var> &hellip;]</dt>
<dd><p>打印格式式的文本。格式 <var>format</var> 包含转义序列，如 &lsquo;<samp>\n</samp>&rsquo;（查看 see section <a href="#Escape-Sequences">转义序列</a>）。如果不指定，不会打印换行符。
</p>
<a name="index-debugger-commands_002c-set"></a>
<a name="index-set-debugger-command"></a>
<a name="index-assign-values-to-variables_002c-in-debugger"></a>
</dd>
<dt><code>set</code> <var>var</var><code>=</code><var>value</var></dt>
<dd><p>将一个常量（数值或者字串）值赋值绘画一个 <code>awk</code> 变量或者域。字串值必须用双引号包起来（<code>&quot;</code>&hellip;<code>&quot;</code>）。
</p>
<p>你也可以设置 <code>awk</code> 的特殊变量，像 <code>FS</code>，<code>NF</code>，<code>NR</code> 等等。
</p>
<a name="index-debugger-commands_002c-w-_0028watch_0029"></a>
<a name="index-debugger-commands_002c-watch"></a>
<a name="index-watch-debugger-command"></a>
<a name="index-w-debugger-command-_0028alias-for-watch_0029"></a>
<a name="index-set-watchpoint"></a>
</dd>
<dt><code>watch</code> <var>var</var> | <code>$</code><var>n</var> [<code>&quot;<var>expression</var>&quot;</code>]</dt>
<dt><code>w</code> <var>var</var> | <code>$</code><var>n</var> [<code>&quot;<var>expression</var>&quot;</code>]</dt>
<dd><p>将变量 <var>var</var> 或者域 <code>$<var>n</var></code> 加到查看列表中。调试器会在变量或者域的值被改变时停下来。每个一个查看列表项都赋予了一个数值，这样可以用中 <code>unwatch</code> 命令中来它从查看列表中删除。
</p>
<p>你可以绘画查看点附加一个条件。这是一个 <code>awk</code> 表达式（包在双引号中），这样当查看点被命中时，调试器会对其进行求值。如果条件为 true，则调试器会停止执行，然后提示命令输入。否则，<code>gawk</code> 会继续执行命令。
</p>
<a name="index-debugger-commands_002c-undisplay"></a>
<a name="index-undisplay-debugger-command"></a>
<a name="index-stop-automatic-display_002c-in-debugger"></a>
</dd>
<dt><code>undisplay</code> [<var>n</var>]</dt>
<dd><p>删除编号为 <var>n</var> 的自动显示列表项（如果没有提供参数，则删除所有的项）。
</p>
<a name="index-debugger-commands_002c-unwatch"></a>
<a name="index-unwatch-debugger-command"></a>
<a name="index-delete-watchpoint"></a>
</dd>
<dt><code>unwatch</code> [<var>n</var>]</dt>
<dd><p>删除编号为 <var>n</var> 的查看列表中的项（如果没有提供参数，则删除所有的项）。
</p>
</dd>
</dl>

<hr>
<a name="Execution-Stack"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Viewing-And-Changing-Data" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#List-of-Debugger-Commands" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger-Info" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00a8_008baa_00ba_008fae_00a0_0088"></a>
<h3 class="subsection">3.3.4 程序栈</h3>

<p>无论何时你运行一个包含任意函数调用的程序，<code>gawk</code> 都会保持一个所有函数调用的栈，一直向上到正在执行的程序处。你可以查看你你如何到达目前所在到位置，也可以按照栈的路径来移动以来查看在你所在的被调用的函数中事件的状态。下面的命令来实现这样的功能：
</p>
<dl compact="compact">
<dd><a name="index-debugger-commands_002c-bt-_0028backtrace_0029"></a>
<a name="index-debugger-commands_002c-backtrace"></a>
<a name="index-debugger-commands_002c-where-_0028backtrace_0029"></a>
<a name="index-backtrace-debugger-command"></a>
<a name="index-bt-debugger-command-_0028alias-for-backtrace_0029"></a>
<a name="index-where-debugger-command"></a>
<a name="index-where-debugger-command-_0028alias-for-backtrace_0029"></a>
<a name="index-call-stack_002c-display-in-debugger"></a>
<a name="index-traceback_002c-display-in-debugger"></a>
</dd>
<dt><code>backtrace</code> [<var>count</var>]</dt>
<dt><code>bt</code> [<var>count</var>]</dt>
<dt><code>where</code> [<var>count</var>]</dt>
<dd><p>打印所有函数调用（栈帧）的路径，或者在 <var>count</var> &gt; 0 时最内层 <var>count</var> 个栈帧。如果 <var>count</var> &lt; 0，则打印最外层的 <var>count</var> 个栈帧。路径显示每一个函数的名字以及参数，还有文件名与行号。<code>backtrace</code> 别名 <code>where</code> 用于向长期使用 GDB 的用户提供栈路径，他们可能会使用这个命令。
</p>
<a name="index-debugger-commands_002c-down"></a>
<a name="index-down-debugger-command"></a>
</dd>
<dt><code>down</code> [<var>count</var>]</dt>
<dd><p>向下最内层的帧移动 <var>count</var>（默认为 1）个帧。然后选择并打印这个帧。
</p>
<a name="index-debugger-commands_002c-f-_0028frame_0029"></a>
<a name="index-debugger-commands_002c-frame"></a>
<a name="index-frame-debugger-command"></a>
<a name="index-f-debugger-command-_0028alias-for-frame_0029"></a>
</dd>
<dt><code>frame</code> [<var>n</var>]</dt>
<dt><code>f</code> [<var>n</var>]</dt>
<dd><p>选择并打印栈帧 <var>n</var>。帧 0 是当前正在被执行的，或者<em>最内层</em>帧（函数调用），帧 1 是调用最内层的帧。最高层的帧是主程序。被打印的信息包括帧号，函数以及参数名，源文件与行号。
</p>
<a name="index-debugger-commands_002c-up"></a>
<a name="index-up-debugger-command"></a>
</dd>
<dt><code>up</code> [<var>count</var>]</dt>
<dd><p>向上最外层移动 <var>count</var>（默认为 1）帧。然后选择并打印相应的帧。
</p></dd>
</dl>

<hr>
<a name="Debugger-Info"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Execution-Stack" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#List-of-Debugger-Commands" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Debugger-Commands" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_008e_00b7aa_008f_0096c_00a8_008baa_00ba_008fa_00b8_008ee_00b0_0083e_00af_0095aa_0099_00a8c_008a_00b6ae_0080_0081a_00bf_00a1ae_0081_00af"></a>
<h3 class="subsection">3.3.5 获取程序与调试器状态信息</h3>

<p>除了查看变量的值外，也常常需要来获取其他关于程序状态的信息，以及调试环境本身的信息。<code>gawk</code> 调试器有一个命令来提供这样的信息，非常恰当地叫做 <code>info</code>。<code>info</code> 与多个参数中的一个使用，可以告诉你想要的准备的信息：
</p>
<dl compact="compact">
<dd><a name="index-debugger-commands_002c-i-_0028info_0029"></a>
<a name="index-debugger-commands_002c-info"></a>
<a name="index-info-debugger-command"></a>
<a name="index-i-debugger-command-_0028alias-for-info_0029"></a>
</dd>
<dt><code>info</code> <var>what</var></dt>
<dt><code>i</code> <var>what</var></dt>
<dd><p><var>what</var> 应该是下在其中之一的值：
</p>
<dl compact="compact">
<dt><code>args</code></dt>
<dd><a name="index-show-function-arguments_002c-in-debugger"></a>
<p>列出所选择的帧的参数。
</p>
</dd>
<dt><code>break</code></dt>
<dd><a name="index-show-breakpoints"></a>
<p>列出当前的所有断点。
</p>
</dd>
<dt><code>display</code></dt>
<dd><a name="index-automatic-displays_002c-in-debugger"></a>
<p>列出自动显示的所有项。
</p>
</dd>
<dt><code>frame</code></dt>
<dd><a name="index-describe-call-stack-frame_002c-in-debugger"></a>
<p>被选择的帧的描述。
</p>
</dd>
<dt><code>functions</code></dt>
<dd><a name="index-list-function-definitions_002c-in-debugger"></a>
<p>列出所有的函数定义，包括源文件名以及行号。
</p>
</dd>
<dt><code>locals</code></dt>
<dd><a name="index-show-local-variables_002c-in-debugger"></a>
<p>列出被选择帧的本地变量列表。
</p>
</dd>
<dt><code>source</code></dt>
<dd><a name="index-show-name-of-current-source-file_002c-in-debugger"></a>
<p>打印当前源文件的名字。每次程序停止时，当前的源文件是包含当前指令的文件。当调用第一次开始时，当前的源文件是通过 &lsquo;<samp>-f</samp>&rsquo; 指定的文件。&lsquo;<samp>list <var>filename</var>:<var>lineno</var></samp>&rsquo; 命令可以在任何时候用来改变当前源文件。
</p>
</dd>
<dt><code>sources</code></dt>
<dd><a name="index-show-all-source-files_002c-in-debugger"></a>
<p>列出所有的程序源。
</p>
</dd>
<dt><code>variables</code></dt>
<dd><a name="index-list-all-global-variables_002c-in-debugger"></a>
<p>列出所有的全局变量。
</p>
</dd>
<dt><code>watch</code></dt>
<dd><a name="index-show-watchpoints"></a>
<p>列出所有的在查看列表中的项。
</p></dd>
</dl>
</dd>
</dl>

<p>其他的命令可以让你控制调试器，使其有保存调试器的状态以及从文件中运行调试器的能力，
</p>
<dl compact="compact">
<dd><a name="index-debugger-commands_002c-o-_0028option_0029"></a>
<a name="index-debugger-commands_002c-option"></a>
<a name="index-option-debugger-command"></a>
<a name="index-o-debugger-command-_0028alias-for-option_0029"></a>
<a name="index-display-debugger-options"></a>
<a name="index-debugger-options"></a>
</dd>
<dt><code>option</code> [<var>name</var>[<code>=</code><var>value</var>]]</dt>
<dt><code>o</code> [<var>name</var>[<code>=</code><var>value</var>]]</dt>
<dd><p>如果没有参数，显示所有可用的调试器选项以及它们的当前值。&lsquo;<samp>option <var>name</var></samp>&rsquo; 显示指定名字选项的当前值。&lsquo;<samp>option <var>name</var>=<var>value</var></samp>&rsquo; 将一个新值赋给指定的选项。可用的选项有：
</p>
<dl compact="compact">
<dt><code>history_size</code></dt>
<dd><a name="index-debugger-history-size"></a>
<p>设置保存在历史文件 &lsquo;<tt>./.gawk_history</tt>&rsquo; 文件中的最大行数。默认值是 100。
</p>
</dd>
<dt><code>listsize</code></dt>
<dd><a name="index-debugger-default-list-amount"></a>
<p>指定列表 <code>list</code> 打印的行数。默认是 15。
</p>
</dd>
<dt><code>outfile</code></dt>
<dd><a name="index-redirect-gawk-output_002c-in-debugger"></a>
<p>将 <code>gawk</code> 的输出发送到文件，调试器输出依然发送到标准输出上。空串（<code>&quot;&quot;</code>）会重新将设置输出到标准输出上。
</p>
</dd>
<dt><code>prompt</code></dt>
<dd><a name="index-debugger-prompt"></a>
<p>改变调试器的提示。默认是 &lsquo;<samp>gawk&gt;&nbsp;</samp>&rsquo;。
</p>
</dd>
<dt><code>save_history</code> [<code>on</code> | <code>off</code>]</dt>
<dd><a name="index-debugger-history-file"></a>
<p>保存命令历史到文件 &lsquo;<tt>./.gawk_history</tt>&rsquo;。默认是 <code>on</code>。
</p>
</dd>
<dt><code>save_options</code> [<code>on</code> | <code>off</code>]</dt>
<dd><a name="index-save-debugger-options"></a>
<p>在退出时，保存当前的选项到文件 &lsquo;<tt>./.gawkrc</tt>&rsquo;。默认是 <code>on</code>。选项会在启动下一个会话过程时读取回来。
</p>
</dd>
<dt><code>trace</code> [<code>on</code> | <code>off</code>]</dt>
<dd><a name="index-instruction-tracing_002c-in-debugger"></a>
<p>打开或者关闭命令跟踪。默认是 <code>off</code>。
</p></dd>
</dl>

</dd>
<dt><code>save</code> <var>filename</var></dt>
<dd><p>将来自于当前会话的命令保存到所给的文件名中，所以他们可以使用 <code>source</code> 命令进行重放。
</p>
</dd>
<dt><code>source</code> <var>filename</var></dt>
<dd><a name="index-debugger_002c-read-commands-from-a-file"></a>
<p>从文件中执行命令，任何命令的错误不会导致后续命令的结束。注释（以 &lsquo;<samp>#</samp>&rsquo; 开头的行）可以存在命令文件中。空行会被忽略，它们<em>不会</em>重复最后的命令。在文件中，你不可以有多于一个的 <code>run</code> 命令来重新启动程序。同时，命令列表可以包含其他的源 <code>source</code> 的命令，但是，<code>gawk</code> 调试器不会对同一个文件执行多次 source，以避免无限递归。
</p>
<p>为了使用或者代替 <code>source</code> 命令，你可以使用 &lsquo;<samp>-D <var>file</var></samp>&rsquo; 或者 &lsquo;<samp>--debug=<var>file</var></samp>&rsquo; 命令行参数从一个文件中来非交互式地执行命令（查看 <a href="#Options">命令行参数</a>）。
</p></dd>
</dl>

<hr>
<a name="Miscellaneous-Debugger-Commands"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger-Info" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#List-of-Debugger-Commands" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Readline-Support" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_00b6a_00bb_0096aa_0091_00bda_00bb_00a4"></a>
<h3 class="subsection">3.3.6 其他命令</h3>

<p>有一些命令不太好归入到之前的那几种分类，他们是：
</p>
<dl compact="compact">
<dd><a name="index-debugger-commands_002c-dump"></a>
<a name="index-dump-debugger-command"></a>
</dd>
<dt><code>dump</code> [<var>filename</var>]</dt>
<dd><p>Dump 程序的字节码到标准输出中，或者名字为 <var>filename</var> 的文件中。这会打印指令的内部表示，<code>gawk</code> 通过执行这些指令来实现程序中的命令。这会非常有启发性，如下面的 Davide Brini 的含人无法捉摸的代码的部分 dump 内容（查看 see section <a href="#Signature-Program">来些新鲜的</a>）：
</p>
<div class="smallexample">
<pre class="smallexample">gawk&gt; <kbd>dump</kbd>
-|        # BEGIN
-|
-| [  1:0xfcd340] Op_rule           : [in_rule = BEGIN] [source_file = brini.awk]
-| [  1:0xfcc240] Op_push_i         : &quot;~&quot; [MALLOC|STRING|STRCUR]
-| [  1:0xfcc2a0] Op_push_i         : &quot;~&quot; [MALLOC|STRING|STRCUR]
-| [  1:0xfcc280] Op_match          :
-| [  1:0xfcc1e0] Op_store_var      : O
-| [  1:0xfcc2e0] Op_push_i         : &quot;==&quot; [MALLOC|STRING|STRCUR]
-| [  1:0xfcc340] Op_push_i         : &quot;==&quot; [MALLOC|STRING|STRCUR]
-| [  1:0xfcc320] Op_equal          :
-| [  1:0xfcc200] Op_store_var      : o
-| [  1:0xfcc380] Op_push           : o
-| [  1:0xfcc360] Op_plus_i         : 0 [MALLOC|NUMCUR|NUMBER]
-| [  1:0xfcc220] Op_push_lhs       : o [do_reference = true]
-| [  1:0xfcc300] Op_assign_plus    :
-| [   :0xfcc2c0] Op_pop            :
-| [  1:0xfcc400] Op_push           : O
-| [  1:0xfcc420] Op_push_i         : &quot;&quot; [MALLOC|STRING|STRCUR]
-| [   :0xfcc4a0] Op_no_op          :
-| [  1:0xfcc480] Op_push           : O
-| [   :0xfcc4c0] Op_concat         : [expr_count = 3] [concat_flag = 0]
-| [  1:0xfcc3c0] Op_store_var      : x
-| [  1:0xfcc440] Op_push_lhs       : X [do_reference = true]
-| [  1:0xfcc3a0] Op_postincrement  :
-| [  1:0xfcc4e0] Op_push           : x
-| [  1:0xfcc540] Op_push           : o
-| [  1:0xfcc500] Op_plus           :
-| [  1:0xfcc580] Op_push           : o
-| [  1:0xfcc560] Op_plus           :
-| [  1:0xfcc460] Op_leq            :
-| [   :0xfcc5c0] Op_jmp_false      : [target_jmp = 0xfcc5e0]
-| [  1:0xfcc600] Op_push_i         : &quot;%c&quot; [MALLOC|STRING|STRCUR]
-| [   :0xfcc660] Op_no_op          :
-| [  1:0xfcc520] Op_assign_concat  : c
-| [   :0xfcc620] Op_jmp            : [target_jmp = 0xfcc440]
-|
&hellip;
-|
-| [     2:0xfcc5a0] Op_K_printf         : [expr_count = 17] [redir_type = &quot;&quot;]
-| [      :0xfcc140] Op_no_op            :
-| [      :0xfcc1c0] Op_atexit           :
-| [      :0xfcc640] Op_stop             :
-| [      :0xfcc180] Op_no_op            :
-| [      :0xfcd150] Op_after_beginfile  :
-| [      :0xfcc160] Op_no_op            :
-| [      :0xfcc1a0] Op_after_endfile    :
gawk&gt;
</pre></div>

<a name="index-exit-debugger-command"></a>
<a name="index-exit-the-debugger"></a>
</dd>
<dt><code>exit</code></dt>
<dd><p>退出调试器。查看之后列出的 &lsquo;<samp>quit</samp>&rsquo;。
</p>
<a name="index-debugger-commands_002c-h-_0028help_0029"></a>
<a name="index-debugger-commands_002c-help"></a>
<a name="index-help-debugger-command"></a>
<a name="index-h-debugger-command-_0028alias-for-help_0029"></a>
</dd>
<dt><code>help</code></dt>
<dt><code>h</code></dt>
<dd><p>打印所有的 <code>gawk</code> 调试器命令列表，以及它全的简短使用说明。&lsquo;<samp>help <var>command</var></samp>&rsquo; 打印命令 <var>command</var> 的信息。
</p>
<a name="index-debugger-commands_002c-l-_0028list_0029"></a>
<a name="index-debugger-commands_002c-list"></a>
<a name="index-list-debugger-command"></a>
<a name="index-l-debugger-command-_0028alias-for-list_0029"></a>
</dd>
<dt><code>list</code> [<code>-</code> | <code>+</code> | <var>n</var> | <var>filename</var><code>:</code><var>n</var> | <var>n</var>&ndash;<var>m</var> | <var>function</var>]</dt>
<dt><code>l</code> [<code>-</code> | <code>+</code> | <var>n</var> | <var>filename</var><code>:</code><var>n</var> | <var>n</var>&ndash;<var>m</var> | <var>function</var>]</dt>
<dd><p>打印从当源代码或者名为 <var>filename</var> 文件的指定行数（默认为 15）。下面是 <code>list</code> 的可能的参数：
</p>
<dl compact="compact">
<dt><code>-</code> (Minus)</dt>
<dd><p>打印最后打印前的行。
</p>
</dd>
<dt><code>+</code></dt>
<dd><p>打印最后打印行的后面的行。<code>list</code> 如果不带参数则与这个执行结果相同。
</p>
</dd>
<dt><var>n</var></dt>
<dd><p>打印行号 <var>n</var> 为中心周围的行。
</p>
</dd>
<dt><var>n</var>&ndash;<var>m</var></dt>
<dd><p>打印从 <var>n</var> 到 <var>m</var> 的行。
</p>
</dd>
<dt><var>filename</var><code>:</code><var>n</var></dt>
<dd><p>打印在源文件 <var>filename</var> 行 <var>n</var> 为中心的行。这个命令会改变当前的源文件。
</p>
</dd>
<dt><var>function</var></dt>
<dd><p>打印函数 <var>function</var> 开始行为中心的行。这个命令有可能改变当前的源文件。
</p></dd>
</dl>

<a name="index-debugger-commands_002c-q-_0028quit_0029"></a>
<a name="index-debugger-commands_002c-quit"></a>
<a name="index-quit-debugger-command"></a>
<a name="index-q-debugger-command-_0028alias-for-quit_0029"></a>
<a name="index-exit-the-debugger-1"></a>
</dd>
<dt><code>quit</code></dt>
<dt><code>q</code></dt>
<dd><p>退出调试器。调试程序非常有意思，但是在生活中有时你还有其他的责任要尽，而有时我们找到了 Bug，则会再找下一个。如我们早前看到的，如果你正在执行一个程序，调试器会在你输入 &lsquo;<samp>q</samp>&rsquo; 或者 &lsquo;<samp>quit</samp>&rsquo; 时给你警告，以确信你真的想退出。
</p>
<a name="index-debugger-commands_002c-trace"></a>
<a name="index-trace-debugger-command"></a>
</dd>
<dt><code>trace</code> [<code>on</code> | <code>off</code>]</dt>
<dd><p>打开或者关闭连续打印将要执行的指令，以及这些指令所实现的 <code>awk</code> 代码。默认是 <code>off</code>。
</p>
<p>在这此指令中的大多数“opcodes”都相当地能够自我说明，使用 <code>stepi</code> 与 <code>nexti</code> 的时候，<code>trace</code> 打开的时候会使得它们变成熟悉的朋友。（译注：就是会在接下来的显示中会显示很多字节码，看久了，就成为熟悉的朋友了。这是作者的幽默。）
</p>
</dd>
</dl>

<hr>
<a name="Readline-Support"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Miscellaneous-Debugger-Commands" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Limitations" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0094_00afae_008c_0081"></a>
<h2 class="section">3.4 支持</h2>
<a name="index-command-completion_002c-in-debugger"></a>
<a name="index-history-expansion_002c-in-debugger"></a>

<p>如果 <code>gawk</code> 使用 <a href="http://cnswww.cns.cwru.edu/php/chet/readline/readline.html">GNU Readline 库</a> 来编译的，则你可以使用这个库的命令完成与历史扩展特性这个优点。下面的完成类型可以使用：
</p>
<dl compact="compact">
<dt>Command completion</dt>
<dd><p>命令名字。
</p>
</dd>
<dt>Source 文件名 completion</dt>
<dd><p>源文件名。相关的命令是 <code>break</code>，<code>clear</code>，<code>list</code>，<code>tbreak</code> 与 <code>until</code>。
</p>
</dd>
<dt>Argument completion</dt>
<dd><p>命令的非数值参数。相关的命令是 <code>enable</code> 与 <code>info</code>。
</p>
</dd>
<dt>Variable name completion</dt>
<dd><p>全局变量句以及正在执行程序的当前上下文的函数参数。相关的命令是 <code>display</code>，<code>print</code>，<code>set</code> 与 <code>watch</code>。
</p>
</dd>
</dl>

<hr>
<a name="Limitations"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Readline-Support" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging-Summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0099_0090aa_0088_00b6"></a>
<h2 class="section">3.5 限制</h2>

<p>我们希望你发现 <code>gawk</code> 的调试器很有用并且享受使用它，但是对于任何的程序，特别是在发布的早期，依然还有有一些限制的。要注意以下几点：
</p>
<ul>
<li>
在这个时候，调试器不会在你输入一些它不喜欢的东西之后，不会给你错误给出详细的解释。相反，它只是反馈说 &lsquo;<samp>syntax error</samp>&rsquo;。当你确实找到了你的错误所在，所以你确实感觉自己会是一个真正的大牛。

</li><li>
如果你一直 dump 出 <a href="#Miscellaneous-Debugger-Commands">其他命令</a> 中的 opcodes（或者是你已经熟悉了 <code>gawk</code> 的内部细节），你会意识到 <code>gawk</code> 的很多的内部数据操作，与其他的翻译器一样是在栈中完成的。<code>Op_push</code>，<code>Op_pop</code> 以及像“bread and butter”占 <code>gawk</code> 代码中的大多数。

<p>不幸的是，到现在为止，<code>gawk</code> 调试器不允许你检查栈的内容。也就是，表达式的中间结果是在栈中进行求值的，但是却不可以打印。而且，只有在程序的程序中定义的变量才可以打印。当然，要解决这个问题就是在调试阶段使用更加显式的变量，然后再转回到更加隐讳，也许是更加优化的代码。
</p>
</li><li>
没有办法查看编译的正则表达式的内部过程以查看它是否正确。作为 <code>awk</code> 程序员，你只希望理解 <code>/[^[:alnum:][:blank:]]/</code> 的意义就可以了。

</li><li>
<code>gawk</code> 调试器设计是用在通过命令行运行的程序上的（以及其所有的参数），如 <a href="#Debugger-Invocation">如何开启调试器</a> 中所描述的。没有办法（目前）来附加或者“插入”到一个运行中的程序。这对主要是用于短程序且快速执行的语言上看起来是合理的。

</li><li>
<code>gawk</code> 调试器只接收通过 &lsquo;<samp>-f</samp>&rsquo; 选项提供的源代码。
</li></ul>


<hr>
<a name="Debugging-Summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Limitations" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugger" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-11"></a>
<h2 class="section">3.6 总结</h2>

<ul>
<li>
程序很少第一次就可以正确工作。查看 Bug 的过程称为调试，帮你找到 Bug 的程序称为调试器。 <code>gawk</code> 有内置的调试器，并且与 GNU 调试器 GDB 工作起来很类似。

</li><li>
调试器可以让你一次一个语句执行程序，以检查与改变变量与数组的值，以及许多其他的事情来让你理解你的程序实际所做的（相对于它应该所做的）。

</li><li>
与其他的调试器类似，<code>gawk</code> 调试器也是按照栈帧的方式工作的，并且可以你让设置断点（在代码中停止的点）与查看点（当值被改变时停止）。

</li><li>
调试器命令相当完备，提供了断点，执行，查看，改变数据等控制命令，还有处理栈，获取信息以及其他任务的命令。

</li><li>
如果 GNU Readline 库在 <code>gawk</code> 编译时是可用的，它可以被调试器用于命令行历史与编辑。

</li></ul>

<hr>
<a name="Arbitrary-Precision-Arithmetic"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Debugger" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Debugging-Summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Computer-Arithmetic" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00ae_0097ae_009c_00afe_00bf_0090c_00ae_0097a_00b8_008e-gawk-a_00b8_00adc_009a_0084a_00bb_00bbae_0084_008fc_00b2_00beaa_00ba_00a6c_00ae_0097ae_009c_00afe_00bf_0090c_00ae_0097"></a>
<h1 class="chapter">4 算术运算与 <code>gawk</code> 中的任意精度算术运算</h1>
<a name="index-arbitrary-precision"></a>
<a name="index-multiple-precision"></a>
<a name="index-infinite-precision"></a>
<a name="index-floating_002dpoint_002c-numbers_002c-arbitrary-precision"></a>

<p>本章介绍一些与计算如何进行算术运行相关的基本概念，并定义一些重要的术语。然后继续描述浮点数算术运算，<code>awk</code> 正是用其来做其所有的计算。后面还会有任意精度浮点数算术运行的讨论，这是个只在 <code>gawk</code> 中可用的特性。后续会再讨论任意精度的整数，及对讨论的某些点做一些小结，在这些点上 <code>gawk</code> 与 POSIX 标准不太一致。
</p>
<blockquote>
<p><b>提示:</b> <code>gawk</code> 的很多的用户都可以完全地跳过本章。但是如果你想用 <code>gawk</code> 做一些科学计算，这章就非常合适。
</p></blockquote>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Computer-Arithmetic">4.1 计算机算术计算说明</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           A quick intro to computer math.
</td></tr>
<tr><td align="left" valign="top"><a href="#Math-Definitions">4.2 要了解的其他知识</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Defining terms used.
</td></tr>
<tr><td align="left" valign="top"><a href="#MPFR-features">4.3 <code>gawk</code> 的任意精度计算</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 The MPFR features in <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#FP-Math-Caution">4.4 浮点算法：买者自慎！</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Things to know.
</td></tr>
<tr><td align="left" valign="top"><a href="#Arbitrary-Precision-Integers">4.5 <code>gawk</code> 中的任意精度整数计算</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Arbitrary Precision Integer Arithmetic with
                                  <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#POSIX-Floating-Point-Problems">4.6 标准与既存实践</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Standards Versus Existing Practice.
</td></tr>
<tr><td align="left" valign="top"><a href="#Floating-point-summary">4.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Summary of floating point discussion.
</td></tr>
</table>

<hr>
<a name="Computer-Arithmetic"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Math-Definitions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00ae_00a1c_00ae_0097ae_009c_00bac_00ae_0097ae_009c_00afe_00ae_00a1c_00ae_0097e_00af_00b4ae_0098_008e"></a>
<h2 class="section">4.1 计算机算术计算说明</h2>

<p>到目前为止，我们已经处理过数字或者字串。但是，最终计算机都是以<em>二进制数字</em>，或者说<em>二进制位</em>表示一切。十进制数可以用 10 个值来表示： 0 到 9。二进制数可以用两个值来表示，0 与 1。通过使用二进制数，计算（以及计算软件）可以表示并操作数值与字符数据。一般来说，更多的位可以用来表示特定的事，以及可以表示的更大的范围的可能数值。
</p>
<p>现代计算机支持至少两种，通常是更多的方式来进行算术计算。每种算术计算都可以使用不同的表示（位的组织方式）来代表数值。我们感兴趣的算术类型如下：
</p>
<dl compact="compact">
<dt>十进制算术运算</dt>
<dd><p>此类型的算术运行你已经在初级学校中就已经学过了，它们使用笔与纸（或者是计算器）来运算。理论上，在十进制小数点的一边或者两边都可以用任意数值位，而结果总是精确的。
</p>
<p>一些现代的系统可以用硬件执行十进制算术运算，但是通常需要特殊的软件库来访问这些指令。也有库用完全用软件来执行十进制算术运算。
</p>
<p>尽管有一些用户希望 <code>gawk</code> 可以执行十进制运算， 
<a name="DOCF97" href="#FOOT97">(97)</a>
但是 <code>gawk</code> 不支持这样的能力。
</p>
</dd>
<dt>整数算法运算</dt>
<dd><p>在学校里，整数值被指为“全部”是数值——也就是，数值中没有小数部分，如 1，42 或者 -17。整数的好处是它们完全代表值。缺点就是它们的范围是有限的。
</p>
<a name="index-unsigned-integers"></a>
<a name="index-integers_002c-unsigned"></a>
<p>在计算机中，整数值会分成两类：<em>有符号</em>与<em>无符号</em>的。有符号的值可以为正也可以为负，而无符号数值总是大于等于 0。
</p>
<p>在计算机系统中，整数算术运算是精确的，但是值的可能范围是有限的。整数算术运算一般要比浮点数算术运算要快。
</p>
</dd>
<dt>浮点数算术运算</dt>
<dd><p>浮点数值的表示，我们在学校中叫做“实”数（即这些值有小数部分，如 3.1415927 ）。浮点数值的优点是它可以表示比整数所能表示的数值大得多的范围。缺陷就是这此数值无法精确表示。
</p>
<p>现代系统支持硬件实现的浮点运算，但是值是有限的。也有软件库可以使用任意精度的浮点数计算。
</p>
<p>POSIX <code>awk</code> 使用<em>双精度浮点数值</em>，这比<em>单精度浮点数</em>可以保存更大范围的数值。<code>gawk</code> 有工具用来执行任意精度的浮点数算术运算，我们后面会进行详细地描述。
</p></dd>
</dl>

<p>计算机处理整数与浮点数表示的不同范围的数值。整数值通常要么是 32 位的，或者是 64 位的值。单精度浮点数占用 32 位，而双精度浮点数占用 64 位数。浮点值总是有符号的。可能的值范围如 <a href="#table_002dnumeric_002dranges">Table 4.1</a> 所示：
</p>
<div class="float"><a name="table_002dnumeric_002dranges"></a>

<table>
<thead><tr><th width="34%">数值表示</th><th width="33%">最小值</th><th width="33%">最大值</th></tr></thead>
<tr><td width="34%">32-bit 有符号整数</td><td width="33%">-2,147,483,648</td><td width="33%">2,147,483,647</td></tr>
<tr><td width="34%">32-bit 无符号整数</td><td width="33%">0</td><td width="33%">4,294,967,295</td></tr>
<tr><td width="34%">64-bit 有符号整数</td><td width="33%">-9,223,372,036,854,775,808</td><td width="33%">9,223,372,036,854,775,807</td></tr>
<tr><td width="34%">64-bit 无符号整数</td><td width="33%">0</td><td width="33%">18,446,744,073,709,551,615</td></tr>
<tr><td width="34%">单精度浮点数（大约值）</td><td width="33%">1.175494@sup{-38}</td><td width="33%">3.402823@sup{38}</td></tr>
<tr><td width="34%">双数度浮点数（大约值）</td><td width="33%">2.225074@sup{-308}</td><td width="33%">1.797693@sup{308}</td></tr>
</table>
</div><p><strong>Table 4.1: 不同的数值表示的值范围
</strong>
</p>
<hr>
<a name="Math-Definitions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Computer-Arithmetic" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#MPFR-features" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00a6_0081a_00ba_0086e_00a7_00a3c_009a_0084aa_0085_00b6a_00bb_0096c_009f_00a5e_00af_0086"></a>
<h2 class="section">4.2 要了解的其他知识</h2>

<p>这一章的剩下部分使用大量数值术语。下面是一些非正式定义，这样可以通过这些材料了解，有助于你的工作。
</p>
<dl compact="compact">
<dt><em>精确度</em></dt>
<dd><p>浮点数计算的精确度是指其与真实值（纸笔来表示的）的接近程序。
</p>
</dd>
<dt><em>错误</em></dt>
<dd><p>计算所以“应该是”的结果与实际的结果之间的差异。应该是尽管最小化这样的错误。
</p>
</dd>
<dt><em>幂</em></dt>
<dd><p>值的数量级，在浮点数值的一些数值位是用来存储幂的。
</p>
</dd>
<dt><em>Inf（无穷）</em></dt>
<dd><p>代表无穷的特殊值。与其他的数或者无穷数之间的操作产生无穷。
</p>
</dd>
<dt><em>非数值</em></dt>
<dd><p>“不是一个数字。”
<a name="DOCF98" href="#FOOT98">(98)</a>
尝试计算时，无法得到实数结果的一个特殊值。在这样的情况下，程序要么会收到一个浮点数异常，或者取得一个 <code>NaN</code> 的结果。IEEE 754 标准建议系统应该返回 <code>NaN</code>。有一些例子如下：
</p>
<dl compact="compact">
<dt><code>sqrt(-1)</code></dt>
<dd><p>这只有在复数的范围内才是有意义的，但是在实数范围内，结果则是 <code>NaN</code>。
</p>
</dd>
<dt><code>log(-8)</code></dt>
<dd><p>-8 不在 <code>log()</code> 的域内，所以结果为 <code>NaN</code>。
</p></dd>
</dl>

</dd>
<dt><em>正规化</em></dt>
<dd><p>系数及其实际存储方式（后面会有说明）。值会被调整使得第一位为 1，因此开始的一位是假想存在，实际并没有存储起来。这可以提供多一位的精度。
</p>
</dd>
<dt><em>精度</em></dt>
<dd><p>用于表示浮点数值的位数。位数越多，则可以表示更多的数值。二进制与十进制数度都是大概的，可根据如下的公式：
</p>
<div class="display">
<pre class="display"><var>prec</var> = 3.322 * <var>dps</var>
</pre></div>

<p>在这里，<em>prec</em> 表示二进制数度（以位来衡量），<em>dps</em>（十进制位的缩写）是十进制位。
</p>
</dd>
<dt><em>舍入舍出模式</em></dt>
<dd><p>如果需要，数值是如何来进行舍入舍出的。后面会提供更多的细节。
</p>
</dd>
<dt><em>系数</em></dt>
<dd><p>浮点数由系数与 10 的幂指数相乘组成。比如，在 <code>1.2345e67</code>，则系数为 <code>1.2345</code>。
</p>
</dd>
<dt><em>Stability</em></dt>
<dd><p><a href="http://en.wikipedia.org/wiki/Numerical_stability">关于稳定性的维基百科文档</a> 中说“一个计算可证地不会扩大近似错误称为在数值上是稳定的。” 
</p></dd>
</dl>

<p>查看 <a href="http://en.wikipedia.org/wiki/Accuracy_and_precision">维基百科关于精确性与精度的文章</a> 来获取类似术语的更多信息。
</p>
<p>在现代的系统上，浮点数硬件使用 IEEE 754 标准定义的表示以及操作。IEEE 754 的类型的三个标准是 32 位单精度，64 位双精度以及 128 位四精度。这个标准也指定了扩展精度的格式以允许更大精度以及更大的指数范围。（<code>awk</code> 只使用 64 位双精度格式。）
</p>
<p><a href="#table_002dieee_002dformats">Table 4.2</a> 列出了基本的 IEEE 754 二进制格式的精度以及指数域值。
</p>
<div class="float"><a name="table_002dieee_002dformats"></a>

<table>
<thead><tr><th width="20%">名字</th><th width="20%">部位数</th><th width="20%">精度</th><th width="20%">最小指数</th><th width="20%">最大指数</th></tr></thead>
<tr><td width="20%">单精度</td><td width="20%">32</td><td width="20%">24</td><td width="20%">-126</td><td width="20%">+127</td></tr>
<tr><td width="20%">双精度</td><td width="20%">64</td><td width="20%">53</td><td width="20%">-1022</td><td width="20%">+1023</td></tr>
<tr><td width="20%">四精度</td><td width="20%">128</td><td width="20%">113</td><td width="20%">-16382</td><td width="20%">+16383</td></tr>
</table>
</div><p><strong>Table 4.2: 基本的 IEEE 格式的值
</strong>
</p>
<blockquote>
<p><b>提示:</b> 精度数值包含了隐含的最开始的一位，因此比所给的系数要多一位。
</p></blockquote>

<hr>
<a name="MPFR-features"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Math-Definitions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#FP-Math-Caution" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-c_009a_0084a_00bb_00bbae_0084_008fc_00b2_00beaa_00ba_00a6e_00ae_00a1c_00ae_0097"></a>
<h2 class="section">4.3 <code>gawk</code> 的任意精度计算</h2>

<p>默认的情况下，<code>gawk</code> 使用由其所运行的系统的硬件来提供双精度浮点数值。但是，如果它编译的时候没有指定，并且 &lsquo;<samp>-M</samp>&rsquo; 命令行选项被提供了，<code>gawk</code> 则使用 <a href="http://www.mpfr.org">GNU MPFR</a> 以及 <a href="http://gmplib.org">GNU MP</a>（GMP）库来执行任意精度的数值算术运算。你可以这样来查看是否支持 MPFR：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk --version</kbd>
-| GNU Awk 4.1.2, API: 1.1 (GNU MPFR 3.1.0-p3, GNU MP 5.0.2)
-| Copyright (C) 1989, 1991-2015 Free Software Foundation.
&hellip;
</pre></div>

<p>（你可能看到与这里显示的不同的版本数。也没有问题，重要的是看 GNU MPFR 与 GNU MP 是否显示在输出中。）
</p>
<p>另外，在 <code>PROCINFO</code> 数组中的一些元素可以来提供 MPFR 与 GMP 库一些信息（查看 see section <a href="#Auto_002dset">传递信息的内置变量</a>）。
</p>
<p>MPFR 库提供了在精度与舍入舍出模式的精确控制，并给出正确的舍入舍出，可重现的，平台无关的结果。使用 &lsquo;<samp>-M</samp>&rsquo; 命令行参数，所有的浮点算术操作符以及数值函数都可以产生任意想要的由 MPFR 所提供的精度。
</p>
<p>有两个预定义的变量，<code>PREC</code> 与 <code>ROUNDMODE</code> 提供了工作精度与舍入舍出模式的控制。精度与舍入舍出模式的设置对于之后的操作是全局的。查看 <a href="#Setting-precision">设置精度</a>，以及 <a href="#Setting-the-rounding-mode">设置舍入转出模式</a>，来获取更多的信息。
</p>
<hr>
<a name="FP-Math-Caution"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#MPFR-features" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Inexactness-of-computations" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b5_00aec_0082_00b9c_00ae_0097ae_00b3_0095i_00bc_009aa_00b9_00b0e_0080_0085e_0087_00aaae_0085_008ei_00bc_0081"></a>
<h2 class="section">4.4 浮点算法：买者自慎！</h2>

<blockquote>
<p><i>数学课太难了。</i>
</p></blockquote>
<p align="center">&mdash; <em>Teen Talk Barbie, July 1992</em>
</p>
<p>这一小节提供了一个更高层上视图，来审视在执行非常多的浮点数计算时所产生问题。 
<a name="DOCF99" href="#FOOT99">(99)</a>
这些讨论同样也适用于硬件与任意精度浮点数算术运算。
</p>
<blockquote>
<p><b>注意:</b> 这里的内容有意地写得非常概括。如果你需要做一些严格的计算算术运行，你首先要进行一些研究，而不仅仅依赖我们所告诉你的。
</p></blockquote>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Inexactness-of-computations">4.4.1 浮点计算是不精确的</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Floating point math is not exact.
</td></tr>
<tr><td align="left" valign="top"><a href="#Getting-Accuracy">4.4.2 获取你需要的精度</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Getting more accuracy takes some work.
</td></tr>
<tr><td align="left" valign="top"><a href="#Try-To-Round">4.4.3 增加几位精度然后再舍入转出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Add digits and round.
</td></tr>
<tr><td align="left" valign="top"><a href="#Setting-precision">4.4.4 设置精度</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           How to set the precision.
</td></tr>
<tr><td align="left" valign="top"><a href="#Setting-the-rounding-mode">4.4.5 设置舍入转出模式</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   How to set the rounding mode.
</td></tr>
</table>

<hr>
<a name="Inexactness-of-computations"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#FP-Math-Caution" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#FP-Math-Caution" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Inexact-representation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b5_00aec_0082_00b9e_00ae_00a1c_00ae_0097ae_0098_00afa_00b8_008dc_00b2_00bec_00a1_00aec_009a_0084"></a>
<h3 class="subsection">4.4.1 浮点计算是不精确的</h3>

<p>二进制浮点数表示以及算术运行是不精确的。像 0.1 这样简单的值没不能精确地由二进制的浮点数来表示，浮点数有有限的精度数表示在计算等级上，或者中间的存储精度的一点点改变都会以改变结果。在任意精度浮点数算术运算时，为了使问题更糟糕， 你可以在开始计算之前设置精度，但是你没有办法保证在最终结果上的十进制的最高有效位的数值。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Inexact-representation">4.4.1.1 很多的数不能完全表示</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Numbers are not exactly represented.
</td></tr>
<tr><td align="left" valign="top"><a href="#Comparing-FP-Values">4.4.1.2 值比较时要小心</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         How to compare floating point values.
</td></tr>
<tr><td align="left" valign="top"><a href="#Errors-accumulate">4.4.1.3 错误累积</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Errors get bigger as they go.
</td></tr>
</table>

<hr>
<a name="Inexact-representation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Inexactness-of-computations" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Inexactness-of-computations" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Comparing-FP-Values" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00be_0088aa_00a4_009ac_009a_0084ae_0095_00b0a_00b8_008de_0083_00bdaa_00ae_008caa_0085_00a8e_00a1_00a8c_00a4_00ba"></a>
<h4 class="subsubsection">4.4.1.1 很多的数不能完全表示</h4>

<p>所以，在开始写任何代码之间，你要考虑一下你到底想要的是什么，以及到底会发生什么。考虑下面的两个例子中的两个数：
</p>
<div class="example">
<pre class="example">x = 0.875             # 1/2 + 1/4 + 1/8
y = 0.425
</pre></div>

<p>不像数字 <code>y</code>，在 <code>x</code> 中存储的数字可以精确地用二进制来表示，因为它可以写成有限个分数的和，而它他的分母都是 2 的幂次方。当 <code>gawk</code> 从程序源代码中读取浮点数时，它会自动地对于字进行舍入舍出，而不管你的机器支持的是什么样的精度。如果你尝试你用输出格式串 <code>&quot;%.17g&quot;</code> 打印某个变量的内容时，它不会产生与你所赋给它的一样的值：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { x = 0.875; y = 0.425</kbd>
&gt; <kbd>              printf(&quot;%0.17g, %0.17g\n&quot;, x, y) }'</kbd>
-| 0.875, 0.42499999999999999
</pre></div>

<p>通常的错误是很小的，你可能都注意不到。如果你确实需要，你可以指定输出中所需要的精度。
通常像 <code>&quot;%.15g&quot;</code> 一样的格式。在上一个例子中，这会产生与输入一样的值。
</p>
<hr>
<a name="Comparing-FP-Values"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Inexact-representation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Inexactness-of-computations" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Errors-accumulate" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0080_00bcae_00af_0094e_00be_0083ae_0097_00b6e_00a6_0081aa_00b0_008faa_00bf_0083"></a>
<h4 class="subsubsection">4.4.1.2 值比较时要小心</h4>

<p>由于底层的表示与实际的值有一些偏离，所以比较浮点数来查看两者是否完全相等是一个不好的主意。下面是一个例子，它不会如你所预期的那样执行：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN { print (0.1 + 12.2 == 12.3) }'</kbd>
-| 0
</pre></div>

<p>比较浮点数的值以查看它们是否是在一个很小的范围内的差异才是正确想法（称为 <em>delta（差异）</em> 或者<em>容忍度</em>）。你需要确定差异是多小对你来说是重要的。这样的处理代码如下：
</p>
<div class="example">
<pre class="example">delta = 0.00001                 # for example
difference = abs(a) - abs(b)    # subtract the two values
if (difference &lt; delta)
    # all ok
else
    # not ok
</pre></div>

<p>（我们假设你有一个简单的绝对值函数，名字为 <code>abs()</code>，定义在你的程序的代码的某处。）
</p>
<hr>
<a name="Errors-accumulate"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Comparing-FP-Values" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Inexactness-of-computations" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getting-Accuracy" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0094_0099e_00af_00afc_00b4_00afc_00a7_00af"></a>
<h4 class="subsubsection">4.4.1.3 错误累积</h4>

<p>在单个浮点数计算中损失的精度，通常不需要担心。但是，如果你计算的值是一系列的浮点数操作的结果，则错误可以累积并且可以极大地影响计算本身。下面尝试用它一系列的表示来计算 <i>pi</i> 的值：
</p>
<div class="example">
<pre class="example">BEGIN {
    x = 1.0 / sqrt(3.0)
    n = 6
    for (i = 1; i &lt; 30; i++) {
        n = n * 2.0
        x = (sqrt(x * x + 1) - 1) / x
        printf(&quot;%.15f\n&quot;, n * x)
    }
}
</pre></div>

<p>当执行的时候，错误会传递到后面的计算中，导致在进行除 0 操作时，循环过早地结束：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f pi.awk</kbd>
-| 3.215390309173475
-| 3.159659942097510
-| 3.146086215131467
-| 3.142714599645573
&hellip;
-| 3.224515243534819
-| 2.791117213058638
-| 0.000000000000000
error--&gt; gawk: pi.awk:6: fatal: division by zero attempted
</pre></div>

<p>下面是另外一个例子，说明内部表示的不精确导致一个非期望的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN {</kbd>
&gt;   <kbd>for (d = 1.1; d &lt;= 1.5; d += 0.1)    # loop five times (?)</kbd>
&gt;       <kbd>i++</kbd>
&gt;   <kbd>print i</kbd>
&gt; <kbd>}'</kbd>
-| 4
</pre></div>

<hr>
<a name="Getting-Accuracy"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Errors-accumulate" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#FP-Math-Caution" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Try-To-Round" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_008e_00b7aa_008f_0096a_00bd_00a0e_009c_0080e_00a6_0081c_009a_0084c_00b2_00beaa_00ba_00a6"></a>
<h3 class="subsection">4.4.2 获取你需要的精度</h3>

<p>任意精度的算术运算可以得到精确的结果么？这个没有很好的答案。代数的标准规则常常无法用在浮点数的算术运算中。在这些事情中，分配与关联规则都无法完整地应用，操作的等级对于你的计算非常重要。舍入舍出错误，累积精度损失，以及内部运行经常都是麻烦事。
</p>
<p>当 <code>gawk</code> 使用机器的双精度来测试表达式 &lsquo;<samp>0.1 + 12.2</samp>&rsquo; 与 &lsquo;<samp>12.3</samp>&rsquo; 的相等性时，得到的结果是不相等。（查看 <a href="#Comparing-FP-Values">值比较时要小心</a>.。）你可以通过提供精度来得到你想要的结果，在这个例子中则是要提到 56 位：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -M -v PREC=56 'BEGIN { print (0.1 + 12.2 == 12.3) }'</kbd>
-| 1
</pre></div>

<p>如果添加多一个位不错，那么添加多一位是不是更好？下面是当你使用更大的 <code>PREC</code> 时所产生的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -M -v PREC=201 'BEGIN { print (0.1 + 12.2 == 12.3) }'</kbd>
-| 0
</pre></div>

<p>这既不是 <code>gawk</code> 的 bug 也不是 MPFR 库的 bug。大家很容易忘记有限的位数用来存储一个值，通常都在进行了相应的舍入舍出后都是一个相似值。对于测试相等性，只有在所两个操作数中<em>所有</em>等都相同时才会成功。因为在以特定的精度与有效的舍入舍出模式进行浮点数运行后这并不一定要必须的，直接进行相等性的比较是不会成功的。相反，比较两个数以查看它们是否相互之间是在所希望的差异区间内才是正解。
</p>
<p>在应用中，15 或者更少的十进制位就够了。硬件的双精度算术运算是合适的，并且也很快速。但是你要记住，每一个浮点数操作都会导致一个新的舍入舍出错误，进而导致悲剧性的结果，这正如早先的尝试计算 <i>pi</i> 的值所说明的一样。在这个情况里，额外的精度可以极大地提供计算的稳定性与精确度。
</p>
<p>另外，你需要了解，在浮点数算术运算中，重复加并不一定等于乘。这个例子在 <a href="#Errors-accumulate">错误累积</a>：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk 'BEGIN {</kbd>
&gt;   <kbd>for (d = 1.1; d &lt;= 1.5; d += 0.1)    # loop five times (?)</kbd>
&gt;       <kbd>i++</kbd>
&gt;   <kbd>print i</kbd>
&gt; <kbd>}'</kbd>
-| 4
</pre></div>

<p>通过选择任意大数值的 <code>PREC</code>，你可能会，也可能不会成功地取得正确的结果。在这种情况下，立即重组问题通常才是正确的方法。
</p>
<hr>
<a name="Try-To-Round"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getting-Accuracy" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#FP-Math-Caution" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Setting-precision" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a2_009eaa_008a_00a0aa_0087_00a0a_00bd_008dc_00b2_00beaa_00ba_00a6c_0084_00b6aa_0090_008eaa_0086_008de_0088_008daa_0085_00a5e_00bd_00acaa_0087_00ba"></a>
<h3 class="subsection">4.4.3 增加几位精度然后再舍入转出</h3>

<p>除了任意精度的浮点数算术运算，你所需要的常常是调整你的逻辑，或者是计算的不同等级。早先的例子中，<i>pi</i> 计算的稳定性与精度可以通过下面的代数变形可以得到提高：
</p>
<div class="example">
<pre class="example">(sqrt(x * x + 1) - 1) / x &equiv; x / (sqrt(x * x + 1) + 1)
</pre></div>

<p>通过这样的变化，在 30 个迭代后，程序汇集到 <i>pi</i> 的结果为：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -f pi2.awk</kbd>
-| 3.215390309173473
-| 3.159659942097501
-| 3.146086215131436
-| 3.142714599645370
-| 3.141873049979825
&hellip;
-| 3.141592653589797
-| 3.141592653589797
</pre></div>

<hr>
<a name="Setting-precision"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Try-To-Round" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#FP-Math-Caution" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Setting-the-rounding-mode" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00ae_00bec_00bd_00aec_00b2_00beaa_00ba_00a6"></a>
<h3 class="subsection">4.4.4 设置精度</h3>

<p><code>gawk</code> 使用全局性的工作精度 ，它不会为单个的数值跟踪精度与精确度。执行算术运算或者调用内置函数来对结果进行舍入舍出都以当的精度为准。默认的工作精度是 53 位，你可以通过修改变量 <code>PREC</code> 来改变。你也可以设置为预定义的大小写有关的值串，如 <a href="#table_002dpredefined_002dprecision_002dstrings">Table 4.3</a> 所列，这些用来对 IEEE 754 二进制标准进行模拟。
</p>
<div class="float"><a name="table_002dpredefined_002dprecision_002dstrings"></a>

<table>
<thead><tr><th><code>PREC</code></th><th>IEEE 754 二进制格式</th></tr></thead>
<tr><td><code>&quot;half&quot;</code></td><td>16 位半精度</td></tr>
<tr><td><code>&quot;single&quot;</code></td><td>基本的 32 位单精度</td></tr>
<tr><td><code>&quot;double&quot;</code></td><td>基本的 64 位双精度</td></tr>
<tr><td><code>&quot;quad&quot;</code></td><td>基本的 128 位四精度</td></tr>
<tr><td><code>&quot;oct&quot;</code></td><td>256 位八精度</td></tr>
</table>
</div><p><strong>Table 4.3: <code>PREC</code> 的预定义精度串
</strong>
</p>
<p>下面的例子说明了改变算术操作符的精度的效果：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -M -v PREC=100 'BEGIN { x = 1.0e-400; print x + 0</kbd>
&gt;   <kbd>PREC = &quot;double&quot;; print x + 0 }'</kbd>
-| 1e-400
-| 0
</pre></div>

<blockquote>
<p><b>注意:</b> 要小心浮点数常量！当从程序源代码中读取浮点数常量时，<code>gawk</code> 会使用默认的精度（即 C <code>double</code>），除非通过命令行赋值来改变 <code>PREC</code> 的值，将其内部存为 MPFR 数值。在程序源代码通过使用 <code>PREC</code> 来改变精度<em>不会</em>影响常量的精度。
</p>
<p>如果需要在比默认的精度还要高的精度上表示一个浮点数，但又不能使用命令行对 <code>PREC</code> 进行赋值，你要么将常数指定会字串，要么只要可能，使其成为有理数， 下面的例子说明了不同的方式下打印浮点数常量时的不同：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -M 'BEGIN { PREC = 113; printf(&quot;%0.25f\n&quot;, 0.1) }'</kbd>
-| 0.1000000000000000055511151
$ <kbd>gawk -M -v PREC=113 'BEGIN { printf(&quot;%0.25f\n&quot;, 0.1) }'</kbd>
-| 0.1000000000000000000000000
$ <kbd>gawk -M 'BEGIN { PREC = 113; printf(&quot;%0.25f\n&quot;, &quot;0.1&quot;) }'</kbd>
-| 0.1000000000000000000000000
$ <kbd>gawk -M 'BEGIN { PREC = 113; printf(&quot;%0.25f\n&quot;, 1/10) }'</kbd>
-| 0.1000000000000000000000000
</pre></div>
</blockquote>

<hr>
<a name="Setting-the-rounding-mode"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Setting-precision" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#FP-Math-Caution" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Integers" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00ae_00bec_00bd_00aee_0088_008daa_0085_00a5e_00bd_00acaa_0087_00baae_00a8_00a1aa_00bc_008f"></a>
<h3 class="subsection">4.4.5 设置舍入转出模式</h3>

<p><code>ROUNDMODE</code> 变量提供了在程序层控制舍入舍出模式的方法。<code>ROUNDMODE</code> 与 IEEE 的舍入舍出的比较显示在 <a href="#table_002dgawk_002drounding_002dmodes">Table 4.4</a> 中。
</p>
<div class="float"><a name="table_002dgawk_002drounding_002dmodes"></a>

<table>
<thead><tr><th width="45%">舍入舍出模式</th><th width="30%">IEEE 名</th><th width="25%"><code>ROUNDMODE</code></th></tr></thead>
<tr><td width="45%">向偶数舍入舍出到最近</td><td width="30%"><code>roundTiesToEven</code></td><td width="25%"><code>&quot;N&quot;</code> or <code>&quot;n&quot;</code></td></tr>
<tr><td width="45%">向正无穷舍入舍出</td><td width="30%"><code>roundTowardPositive</code></td><td width="25%"><code>&quot;U&quot;</code> or <code>&quot;u&quot;</code></td></tr>
<tr><td width="45%">向负无穷舍入舍出</td><td width="30%"><code>roundTowardNegative</code></td><td width="25%"><code>&quot;D&quot;</code> or <code>&quot;d&quot;</code></td></tr>
<tr><td width="45%">向零舍入舍出</td><td width="30%"><code>roundTowardZero</code></td><td width="25%"><code>&quot;Z&quot;</code> or <code>&quot;z&quot;</code></td></tr>
<tr><td width="45%">背身零舍入舍出到最近</td><td width="30%"><code>roundTiesToAway</code></td><td width="25%"><code>&quot;A&quot;</code> or <code>&quot;a&quot;</code></td></tr>
</table>
</div><p><strong>Table 4.4: <code>gawk</code> 的舍入舍出模式
</strong>
</p>
<p><code>ROUNDMODE</code> 的默认值为 <code>&quot;N&quot;</code>，这选择的是 IEEE 754 的舍入舍出模式为 roundTiesToEven。在 <a href="#table_002dgawk_002drounding_002dmodes">Table 4.4</a> 中，值 <code>&quot;A&quot;</code> 选择的是 <code>roundTiesToAway</code>。这只有顺你的 MPFR 库支持时才可用，否则设置 <code>ROUNDMODE</code> 为 <code>&quot;A&quot;</code> 是没有效果的。
</p>
<p>默认的模式 <code>roundTiesToEven</code> 是使用得最多的，但是最不直观。这个方法对大多数的值的处理都是很明显的，就是将它们向上或者向下到最近的数。例如，将 1.132 舍入舍出为两位数，会产生 1.13，而对 1.157 舍入舍出产生 1.16。
</p>
<p>但是，其值刚好是一半的时候，对其进行舍入舍出时，事情处理方式就不会像你在学校时所学的一样工作。在这种情况下，数字被舍入舍出到最近的偶数位。所以，对 0.125 舍入舍出为两位数，则会产生 0.12，但是对数值 0.6875 舍入舍出到三位则会向上舍入为 0.688。你可能在使用 <code>printf</code> 来格式化浮点数时已经遇到过这样的舍入舍出模式。例如：
</p>
<div class="example">
<pre class="example">BEGIN {
    x = -4.5
    for (i = 1; i &lt; 10; i++) {
        x += 1.0
        printf(&quot;%4.1f =&gt; %2.0f\n&quot;, x, x)
    }
}
</pre></div>

<p>在作者的系统上，会产生下面的输出： 
<a name="DOCF100" href="#FOOT100">(100)</a>
</p>
<div class="example">
<pre class="example">-3.5 =&gt; -4
-2.5 =&gt; -2
-1.5 =&gt; -2
-0.5 =&gt; 0
 0.5 =&gt; 0
 1.5 =&gt; 2
 2.5 =&gt; 2
 3.5 =&gt; 4
 4.5 =&gt; 4
</pre></div>

<p><code>roundTiesToEven</code> 背后的理论是，对确定的半值舍入舍出或多或少向上或者向下是均等地分布的。这样可以使得舍入输出导致的损失可以自己补偿。这对于 IEEE 754 的计算函数与操作符是默认的舍入舍出模式。
</p>
<p>其他的舍入舍出模式很少使用。向正无穷舍入舍出（<code>roundTowardPositive</code>）以及向负无穷舍入舍出（<code>roundTowardNegative</code>）常常用于实现间隔算术，在这样的计算中，你调整舍入舍出模式来计算输出范围的上下边沿。<code>roundTowardZero</code> 模式可用于将浮点数转换了整数。<code>roundTiesToAway</code> 这个舍入输出模式将结果舍入舍出到最近的数，如果出现的绑定的情况，则选择一个较大幅度的值。
</p>
<p>有一些数值分析师会告诉你，你的舍入舍出风格的选择会极大地影响最后的输出，并且建议你直到最后输出时才确定舍入舍出模式。相反地，你常常可以避免舍入舍出错误，需要的只是在一开始将初始精度设置比最终所需要的大得多的精度，这样累积的舍入舍出错误不会影响结果。如果你怀疑你计算的结果对于舍入舍出错误是很敏感的，需要你改变舍入舍出模式来看现输出中明显的差异来进行确认。
</p>
<hr>
<a name="Arbitrary-Precision-Integers"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Setting-the-rounding-mode" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#POSIX-Floating-Point-Problems" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-a_00b8_00adc_009a_0084a_00bb_00bbae_0084_008fc_00b2_00beaa_00ba_00a6ae_0095_00b4ae_0095_00b0e_00ae_00a1c_00ae_0097"></a>
<h2 class="section">4.5 <code>gawk</code> 中的任意精度整数计算</h2>
<a name="index-integers_002c-arbitrary-precision"></a>
<a name="index-arbitrary-precision-integers"></a>

<p>当指定了 &lsquo;<samp>-M</samp>&rsquo; 选项，<code>gawk</code> 会使用 GMP 任意精度整数的执行所有的整数算术。在源代码中或者数据文件中任意的看起来像整数值都存成任意精度的整数。整数的大小只受限于可用的内存。例如，下面会计算
5@sup{4@sup{3@sup{2}}}
，这个结果已经超过了一般的双精度浮点值的限制：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -M 'BEGIN {</kbd>
&gt;   <kbd>x = 5^4^3^2</kbd>
&gt;   <kbd>print &quot;number of digits =&quot;, length(x)</kbd>
&gt;   <kbd>print substr(x, 1, 20), &quot;...&quot;, substr(x, length(x) - 19, 20)</kbd>
&gt; <kbd>}'</kbd>
-| number of digits = 183231
-| 62060698786608744707 ... 92256259918212890625
</pre></div>

<p>如果你使用任意精度的浮点值来计算相同的值，为了正确的输出所需要的精度（使用公式 
If instead you were to compute the same value using arbitrary-precision
floating-point values, the precision needed for correct output (using
the formula
&lsquo;<samp>prec = 3.322 * dps</samp>&rsquo;）
则会是 3.322 x 183231，
或者说是 608693。
</p>
<p>来自于一个整数与一个浮点数值的算术操作的结果，是一个与当前工作数度相同的一个浮点数。下面的程序用迭代来计算 Sylvester 序列
<a name="DOCF101" href="#FOOT101">(101)</a>
的第八个项：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -M 'BEGIN {</kbd>
&gt;   <kbd>s = 2.0</kbd>
&gt;   <kbd>for (i = 1; i &lt;= 7; i++)</kbd>
&gt;       <kbd>s = s * (s - 1) + 1</kbd>
&gt;   <kbd>print s</kbd>
&gt; <kbd>}'</kbd>
-| 113423713055421845118910464
</pre></div>

<p>输出不同于实际的数值，即 113，423，713，055，421，844，361，000，443，这里因为默认的精度为 53 位，不足以精确地表示清点结果。你要么提供高精（在这个例子中，100 位是够了的），或者将浮点数常数 &lsquo;<samp>2.0</samp>&rsquo; 替换为一个整数，以全部使用整数算术运行来计算正确有的输出。
</p>
<p>有时候，<code>gawk</code> 必须隐式地将任意精度的整数转换为任意粒度的浮点数。这主要是因为，当一个操作或者函数需要时，MPFR 库并不总是提供相关的接口来处理任意精度的整数，或者混合模式的数字。在这样的例子中，精度会被设置成要精度转换时的最小的值，而工作精度则不用于这个目的。如果这不是你想要的，你可以用个小诡计并将整数先转换为浮点数，如：
</p>
<div class="example">
<pre class="example">gawk -M 'BEGIN { n = 13; print (n + 0.0) % 2.0 }'
</pre></div>

<p>你可以通过指定数值为浮点数来避免这样的问题：
</p>
<div class="example">
<pre class="example">gawk -M 'BEGIN { n = 13.0; print n % 2.0 }'
</pre></div>

<p>注意，对于这个特殊的例子，最好是使用下面的方式：
</p>
<div class="example">
<pre class="example">gawk -M 'BEGIN { n = 13; print n % 2 }'
</pre></div>

<hr>
<a name="POSIX-Floating-Point-Problems"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Integers" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Floating-point-summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a0_0087aa_0087_0086a_00b8_008eae_0097_00a2aa_00ad_0098aa_00ae_009ee_00b7_00b5"></a>
<h2 class="section">4.6 标准与既存实践</h2>

<p>历史上，<code>awk</code> 会在需要的时候，将所有的看起业是非数值的字串转换为数值 0。而且，语言的最开始的定义与最初的 POSIX 标准规定，<code>awk</code> 只理解十进制（基数为 10），而不是八进制（以 8 为基数）以及十六进制数（以 16 为基数）。
</p>
<p>2001 的语言的变化与 2004 年的 POSIX 标准都可以解释为，<code>awk</code> 会可支持额外的特性，这些特性是：
</p>
<ul>
<li>
以十六进制形成指定的浮点数的解析（如，<code>0xDEADBEEF</code>）。（提示：是数据值，而<em>不是</em>源代码常量。）

</li><li>
支持 IEEE 754 特殊的浮点数值“not a number”（NaN），正无穷（“inf”）与负无穷（“-inf”）。特别是，这些值的格式由 ISO 1999 的 C 标准指定，它们不区别大小写，可允许依赖于实现的在 &lsquo;<samp>nan</samp>&rsquo; 后的额外字符，也允许 &lsquo;<samp>inf</samp>&rsquo; 或者 &lsquo;<samp>infinity</samp>&rsquo;。
</li></ul>

<p>第一个问题是这两个相比于历史实践都有明确的改变：
</p>
<ul>
<li>
<code>gawk</code> 的维护者感觉，支持十六进制的浮点数，相当的丑，从来没有被最初的实现者接受为语言的一部分。

</li><li>
完全允许字母串有一个有效的数值也与历史实践有着严重的分离。
</li></ul>

<p>第二个问题是 <code>gawk</code> 的维护者觉得，对于标准的这种解释，需要大量的“语言立法”来达到第一个目标，这甚至也不被标准的开发者预料到。也就是说，“我们看到了你怎么来的，但是我们不认为那就是你想要去的地方。”
</p>
<p>由于发现了这样的问题，作为提供一个与早期标准版本兼容的尝试，在 2008 年的 POSIX 标准添加了一个显式的话来允许，但是不是必须，<code>awk</code> 支持十六进制的浮点数值以及针对 “not a number”下无穷的特殊值。
</p>
<p>尽管 <code>gawk</code> 的维护者仍然觉得提供这样的特性是不被建议的，但是，在支持 IEEE 浮点数的系统上，提供<em>某些</em>途径来支持 NaN 与无穷值却是合理的。<code>gawk</code> 的解决方案如下：
</p>
<ul>
<li>
如果有 &lsquo;<samp>--posix</samp>&rsquo; 命令行选项，则 <code>gawk</code> 会松手不管。字串值会被直接传递绘画系统的库函数 <code>strtod()</code> 函数，如果成功地返回了数值值，那么它就会被当做数值使用。 
<a name="DOCF102" href="#FOOT102">(102)</a>
根据定义，结果在不同的系统上是不可移植的。而且也有一些小的令人惊奇的行为：

<div class="example">
<pre class="example">$ <kbd>echo nanny | gawk --posix '{ print $1 + 0 }'</kbd>
-| nan
$ <kbd>echo 0xDeadBeef | gawk --posix '{ print $1 + 0 }'</kbd>
-| 3735928559
</pre></div>

</li><li>
如果没有 &lsquo;<samp>--posix</samp>&rsquo; 选项，<code>gawk</code> 会将后面的字串值 &lsquo;<samp>+inf</samp>&rsquo;，&lsquo;<samp>-inf</samp>&rsquo;，&lsquo;<samp>+nan</samp>&rsquo; 与 &lsquo;<samp>-nan</samp>&rsquo; 作特别的解释，并产生相应的特殊的数值。前导的符号会被当成发送绘画 <code>gawk</code> （以及用户）的信号说，这确实是个数值。十六进制浮点数是不受支持的（除非你也使用了 &lsquo;<samp>--non-decimal-data</samp>&rsquo; 选项，但我们<em>不</em>建议）。例如：

<div class="example">
<pre class="example">$ <kbd>echo nanny | gawk '{ print $1 + 0 }'</kbd>
-| 0
$ <kbd>echo +nan | gawk '{ print $1 + 0 }'</kbd>
-| nan
$ <kbd>echo 0xDeadBeef | gawk '{ print $1 + 0 }'</kbd>
-| 0
</pre></div>

<p><code>gawk</code> 对这四个值不区分大小写。因此 &lsquo;<samp>+nan</samp>&rsquo; 与 &lsquo;<samp>+NaN</samp>&rsquo; 是一样的。
</p></li></ul>

<hr>
<a name="Floating-point-summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#POSIX-Floating-Point-Problems" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-13"></a>
<h2 class="section">4.7 总结</h2>

<ul>
<li>
大多数的计算机算术运算是通过整数或者浮点数来完成的。标准的 <code>awk</code> 使用双精度浮点数数值。

</li><li>
在 1990 年代早期，Barbie 不正确地说过，“数学真难！”虽然数学不难，但是浮点数运算并不像“纸笔”数学一样，而必须仔细处理：

<ul class="no-bullet">
<li>-
并不是所有的数都可以被精确表示。

</li><li>-
值的比较应该使用差别，而不是直接使用 &lsquo;<samp>==</samp>&rsquo; 与 &lsquo;<samp>!=</samp>&rsquo;。

</li><li>-
错误会累积。

</li><li>-
操作并不总是关联与分布的。
</li></ul>

</li><li>
提供精度有用，但并不总是成能药。

</li><li>
提升精度然后舍入舍出到一个需要的数值位以产生合理的结果。

</li><li>
使用 &lsquo;<samp>-M</samp>&rsquo;（或者 &lsquo;<samp>--bignum</samp>&rsquo;）来使用 MPFR 算术。使用 <code>PREC</code> 来设置精度位，以及设置 <code>ROUNDMODE</code> 来设置 IEEE 754 的舍入舍出模式。

</li><li>
通过 &lsquo;<samp>-M</samp>&rsquo;，<code>gawk</code> 会使用 GMP 库执行任意精度的整数算术运算。这比 MPFR 执行相同的计算会更快，在空间上更高效。

</li><li>
<code>gawk</code> 在处理浮点数上有几个方面与 POSIX 标准不同。有必要注意。

</li><li>
总体上看，没有必要过度地怀疑浮点数运算的结果。要记住的教训是浮点数运算要比纸笔上进行运算要更复杂。为了充分利用浮点数运算的优势，你需要知道它的限制来使用它们来工作。对于大多数的浮点算术运算，如果你简单地舍入舍出来显示你的结果到正确的十进制有效位，你都可以得到想要的结果。

</li><li>
作为一般建议，避免以隐式的比实际更高精度来表示一个数据。

</li></ul>

<hr>
<a name="Dynamic-Extensions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Arbitrary-Precision-Arithmetic" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Floating-point-summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Intro" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bc_0096aa_0086_0099-gawk-ae_0089_00a9aa_00b1_0095"></a>
<h1 class="chapter">5 编写 <code>gawk</code> 扩展</h1>
<a name="index-dynamically-loaded-extensions"></a>

<p>使用动态装载的库，可以用 C 或者 C++ 为 <code>gawk</code> 编写新的功能。这样的工具在支持 C 的 <code>dlopen()</code> 与 <code>dlsym()</code> 函数的系统上是可用的。本章会描述如何用 C 与 C++ 的代码来创建扩展。
</p>
<p>如果你不了解 C 编程，你可以跳过这一章，你可以查看随 <code>gawk</code> 一起发布的扩展文件（查看 see section <a href="#Extension-Samples"><code>gawk</code> 发行版本中的例子扩展</a>），也可了解 <code>gawkextlib</code> 项目的信息（查看 see section <a href="#gawkextlib"><code>gawkextlib</code> 项目</a>）。例子扩展会与 <code>gawk</code> 一起进行构建并安装。
</p>
<blockquote>
<p><b>提示:</b> 当使用 &lsquo;<samp>--sandbox</samp>&rsquo; 选项时，扩展会被禁用（查看 <a href="#Options">命令行参数</a>）。
</p></blockquote>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Extension-Intro">5.1 介绍</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             What is an extension.
</td></tr>
<tr><td align="left" valign="top"><a href="#Plugin-License">5.2 扩展许可</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              A note about licensing.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Mechanism-Outline">5.3 在高层级中是它是如何工作的</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> An outline of how it works.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Description">5.4 API 描述</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   A full description of the API.
</td></tr>
<tr><td align="left" valign="top"><a href="#Finding-Extensions">5.5 <code>gawk</code> 如何找到扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          How <code>gawk</code> finds compiled extensions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Example">5.6 例子：一些文件函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Example C code for an extension.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Samples">5.7 <code>gawk</code> 发行版本中的例子扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           The sample extensions that ship with
                                <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#gawkextlib">5.8 <code>gawkextlib</code> 项目</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  The <code>gawkextlib</code> project.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-summary">5.9 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Extension summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Exercises">5.10 练习</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Exercises.
</td></tr>
</table>

<hr>
<a name="Extension-Intro"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Plugin-License" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008bc_00bb_008d-1"></a>
<h2 class="section">5.1 介绍</h2>

<a name="index-plug_002din"></a>
<p><em>扩展</em>（有时也称为<em>插件</em>）是一块外部编译的代码，<code>gawk</code> 可以在运行时装载来提供额外的功能，它们建立在本网页中所描述的内建能力之上。
</p>
<p>扩展非常有用，因此它们可以让你（这毫无疑问）来扩展 <code>gawk</code> 的功能。例如，它们可以提供访问系统调用的能力（比如 <code>chdir()</code> 来更改目录）以及其他的可用的 C 库例程。如大多数的软件“天空才是限制”，如果你想到某些事情，你可以通过 C 或者 C++ 代码来实现，你就可以写一个扩展来实现他。
</p>
<p>扩展通过 C 或者 C++ 写成，并利用为此目的而向 <code>gawk</code> 开发者提供的<em>应用程序接口</em>（API）来实现。本章中的其他部分解释 API 工具以及如何来使用它们，并提供了一个小的扩展例子。另外，例子扩展程序也包含在了 <code>gawk</code> 的发布版本中，并对 <code>gawkextlib</code> 进行描述。
查看 <a href="#Extension-Design">扩展 API 设计</a>，来获取扩展机制的目标与设计的更多讨论。
</p>
<hr>
<a name="Plugin-License"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Intro" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Mechanism-Outline" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0089_00a9aa_00b1_0095e_00ae_00b8aa_008f_00af"></a>
<h2 class="section">5.2 扩展许可</h2>

<p>每个动态的扩展必须在与 GNU GPL（查看 see section <a href="#Copying">GNU General Public License</a>）兼容的许可下发布。
</p>
<p>为了让扩展告知 <code>gawk</code> 它是有适当的许可的，扩展必须定义一个全局符号 <code>plugin_is_GPL_compatible</code>。如果这个符号不存在，在扩展被装载时，<code>gawk</code> 会发送一个致命错误，并退出。
</p>
<p>符号的声明类型为 <code>int</code>。它没有必要一定要在某个段中。代码仅仅是断言符号在全局范围内存在即可。像下面这样就足够了：
</p>
<div class="example">
<pre class="example">int plugin_is_GPL_compatible;
</pre></div>

<hr>
<a name="Extension-Mechanism-Outline"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Plugin-License" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8e_00ab_0098aa_00b1_0082c_00ba_00a7a_00b8_00adae_0098_00afaa_00ae_0083ae_0098_00afaa_00a6_0082a_00bd_0095aa_00b7_00a5a_00bd_009cc_009a_0084"></a>
<h2 class="section">5.3 在高层级中是它是如何工作的</h2>

<p><code>gawk</code> 与扩展之间的通信是双向的。首先，当扩展被装载，<code>gawk</code> 会向它传递一个结构体 <code>struct</code> 的指针，结构体中都是函数指针。
如 <a href="#figure_002dload_002dextension">Figure 5.1</a> 所示：
</p>
<div class="float"><a name="figure_002dload_002dextension"></a>

<img src="api-figure1.png" alt="Loading the extension">
</div><p><strong>Figure 5.1: 装载扩展
</strong>
</p>

<p>扩展通过这些指针函数来调用 <code>gawk</code> 中的函数，并且是在运行时调用，而无须（在连接时）访问 <code>gawk</code> 的符号。这些函数指针中的一个是用来“注册”新功能的函数。
如 <a href="#figure_002dregister_002dnew_002dfunction">Figure 5.2</a> 所示：
</p>
<div class="float"><a name="figure_002dregister_002dnew_002dfunction"></a>

<img src="api-figure2.png" alt="Registering a new Function">
</div><p><strong>Figure 5.2: 注册新函数
</strong>
</p>

<p>在另一个方向，扩展注册它的新函数是向 <code>gawk</code> 传递函数的指针，这个函数提供了新的特性（比如 <code>do_chdir()</code>）。<code>gawk</code> 将这个函数指针与一个名字关联，然后使用定义好的调用规范来调用它。
如在 <a href="#figure_002dcall_002dnew_002dfunction">Figure 5.3</a> 所示：
</p>
<div class="float"><a name="figure_002dcall_002dnew_002dfunction"></a>

<img src="api-figure3.png" alt="Calling the new function">
</div><p><strong>Figure 5.3: 调用新函数
</strong>
</p>

<p>接下来 <code>do_<var>xxx</var>()</code> 函数使用 API 结构体 <code>struct</code> 中的函数指针来实现它的功能，如更新变量或者数组，打印信息，设置 <code>ERRNO</code> 等等。
</p>
<p>方便的宏可以使用通过函数指针调用看起来像常规的函数调用一样，这样扩展代码非常好读，也很好理解。
</p>
<p>尽管这听起来有一些复杂，而结果是扩展的代码编写与阅读都非常直接。你可以查看样例扩展 &lsquo;<tt>filefuncs.c</tt>&rsquo;（查看 see section <a href="#Extension-Example">例子：一些文件函数</a>）以及 &lsquo;<tt>testext.c</tt>&rsquo; 代码来测试 APIs。
</p>
<p>一些其他的杂项：
</p>
<ul>
<li>
API 提供了访问 <code>gawk</code> 的 <code>do_<var>xxx</var></code> 值的方式，以此来反应命令行参数，如 <code>do_lint</code>，<code>do_profiling</code> 等等（查看 see section <a href="#Extension-API-Variables">API 变量</a>）。而下面提供相关信息：扩展不可以改变它们在 <code>gawk</code> 中的值。另外，尝试绘给它们赋值会产生一个编译时错误。

</li><li>
API 也提供了主次版本号，这样扩展可以来检查装载扩展的 <code>gawk</code> 的版本是否支持其被编译时的所需要的功能。（版本不匹配“不应该”发生，但是我们所有人都知道<em>事情</em>怎么发生的。）查看 <a href="#Extension-Versioning">API Version Constants and Variables</a>，来获取相关细节。
</li></ul>

<hr>
<a name="Extension-API-Description"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Mechanism-Outline" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Functions-Introduction" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="API-ae_008f_008fe_00bf_00b0"></a>
<h2 class="section">5.4 API 描述</h2>
<a name="index-extension-API"></a>

<p>C 或者 C++ 所写的扩展必须包含头文件 &lsquo;<tt>gawkapi.h</tt>&rsquo;，在这个文件中声明函数，并且定义了与 <code>gawk</code> 进行通信的数组类型。这（相当大的）小节，详细地描述了这些 API。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Extension-API-Functions-Introduction">5.4.1 介绍</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Introduction to the API functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#General-Data-Types">5.4.2 通用目的的数据类型</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   The data types.
</td></tr>
<tr><td align="left" valign="top"><a href="#Memory-Allocation-Functions">5.4.3 内存分配函数与相应的简化宏</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Functions for allocating memory.
</td></tr>
<tr><td align="left" valign="top"><a href="#Constructor-Functions">5.4.4 构造函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Functions for creating values.
</td></tr>
<tr><td align="left" valign="top"><a href="#Registration-Functions">5.4.5 注册函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Functions to register things with
                                         <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Printing-Messages">5.4.6 打印信息</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Functions for printing messages.
</td></tr>
<tr><td align="left" valign="top"><a href="#Updating-ERRNO">5.4.7 更新 <code>ERRNO</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Functions for updating <code>ERRNO</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Requesting-Values">5.4.8 请求值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    How to get a value.
</td></tr>
<tr><td align="left" valign="top"><a href="#Accessing-Parameters">5.4.9 访问与更新参数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Functions for accessing parameters.
</td></tr>
<tr><td align="left" valign="top"><a href="#Symbol-Table-Access">5.4.10 符号表访问</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Functions for accessing global
                                         variables.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Manipulation">5.4.11 数组操作</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Functions for working with arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Variables">5.4.12 API 变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Variables provided by the API.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Boilerplate">5.4.13 样板代码</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Boilerplate code for using the API.
</td></tr>
</table>

<hr>
<a name="Extension-API-Functions-Introduction"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#General-Data-Types" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bb_008bc_00bb_008d"></a>
<h3 class="subsection">5.4.1 介绍</h3>

<p>访问 <code>gawk</code> 的工具是通过调用传递到你的扩展的函数指针来完成的。
</p>
<p>API 函数指针提供了下面类型的操作：
</p>
<ul>
<li>
分配，重新分配以及释放内存。

</li><li>
注册函数，有如下：

<ul class="no-bullet">
<li>-
扩展函数
</li><li>-
退出回调函数
</li><li>-
版本字串
</li><li>-
输入分析器
</li><li>-
输出包装器
</li><li>-
双路处理器
</li></ul>

<p>所有的这些都会在本章中的剩余部进行详细的讨论。
</p>
</li><li>
打印致命错误，告警以及“lint”警告信息。

</li><li>
更新 <code>ERRNO</code>，或者重置它。

</li><li>
访问参数，包括将未定义的参数转换为数组。

</li><li>
符号表访问：返回全局变量，合建或者更改全局变量。

</li><li>
创建，释放缓存值，这提供了一种高效访问多个变量的方式，可能极大地提供性能。

</li><li>
数组操作：

<ul class="no-bullet">
<li>-
检索，添加，删除以及修改元素。

</li><li>-
获取数组中的元素个数。

</li><li>-
创建新数组。

</li><li>-
清除数组。

</li><li>-
扁平化数组，使用以使用简单的 C 风格的循环来迭代所有的索引以及元素。
</li></ul>
</li></ul>

<p>使用 API 的一些点：
</p>
<ul>
<li>
下面的类型，宏，以及/或者函数可以在 &lsquo;<tt>gawkapi.h</tt>&rsquo; 文件参考。为了正确使用，你必须在包含 &lsquo;<tt>gawkapi.h</tt>&rsquo; <em>前</em>包含相应的标准头文件。

<table>
<thead><tr><th>C entity</th><th>Header file</th></tr></thead>
<tr><td><code>EOF</code></td><td><code>&lt;stdio.h&gt;</code></td></tr>
<tr><td>Values for <code>errno</code></td><td><code>&lt;errno.h&gt;</code></td></tr>
<tr><td><code>FILE</code></td><td><code>&lt;stdio.h&gt;</code></td></tr>
<tr><td><code>NULL</code></td><td><code>&lt;stddef.h&gt;</code></td></tr>
<tr><td><code>memcpy()</code></td><td><code>&lt;string.h&gt;</code></td></tr>
<tr><td><code>memset()</code></td><td><code>&lt;string.h&gt;</code></td></tr>
<tr><td><code>size_t</code></td><td><code>&lt;sys/types.h&gt;</code></td></tr>
<tr><td><code>struct stat</code></td><td><code>&lt;sys/stat.h&gt;</code></td></tr>
</table>

<p>由于考虑到可移植性，特别是那些没有完全与标准兼容的系统，你需要以正确的方式包含正确的文件。为了保证 &lsquo;<tt>gawkapi.h</tt>&rsquo; 的简单清楚，这个要求是很必要的，这样不会成为可移植性的大杂烩，而这会在部分的 <code>gawk</code> 源代码中看到。
</p>
</li><li>
&lsquo;<tt>gawkapi.h</tt>&rsquo; 文件可以被包含多次，而不会产生不好的结果。只是这么做是个很不好的编程实践。

</li><li>
尽管 API 只使用 ISO C 90 的特性，但是有一个例外，即“构造”函数使用 <code>inline</code> 关键词。如果你的编译器不支持这个关键词，你要么在命令行中加入 &lsquo;<samp>-Dinline=''</samp>&rsquo;，或者使用 GNU 的 Autotools 并在你的扩展中包含一个 &lsquo;<tt>config.h</tt>&rsquo; 文件。

</li><li>
所有的在 <code>gawk</code> 填充的指针指向的内存，都由 <code>gawk</code> 管理，应该被你的扩展看成是只读的。从扩展中传递到 <code>gawk</code> 中的<em>所有</em>字串内存，<em>必须</em>使用 <code>gawk_malloc()</code>，<code>gawk_calloc()</code> 或者 <code>gawk_realloc()</code> 调用获取，并从那以后，由 <code>gawk</code> 进行管理。

</li><li>
API 定义了几个简单的结构体 <code>struct</code> 用来影射 <code>awk</code> 看到的值。值可以是 <code>double</code> 类型，或者字串，或者是数组（如多维数组，或者创建新数组时）。字串值通过指针与长度来管理，因此内嵌的 <small>NUL</small> 字符也可以使用。

<blockquote>
<p><b>提示:</b> 从目的上讲，字串使用当前的多字节编码来维护（如 <code>LC_<var>xxx</var></code> 环境变量定义的）而不是使用宽字符。这个与 <code>gawk</code> 内部存储字串是匹配的，字符也可能是这么从文件读取或者输出到文件的。
</p></blockquote>

</li><li>
当收到一个值（如参数或者全局变量，或者数组元素），扩展需要请示一个特定的类型（数值，字串，标量，值的Cookie，数组，或者“未定义”）。当请求为“未定义”时，返回的值是会有真正的底层类型的。

<p>但是，如果请求的类型与实际的类型不匹配，读取函数会返回“false”，并在 type 类型里填上值实际的类型，这样扩展可以打印错误的信息（比如 “scalar passed where array expected”（需要数组时传递的是标量类型））。
</p>
</li></ul>

<p>你可以使用函数指针来调用 API 函数，但是接口没有这么简单。为了使扩展代码看起来像常规的代码，&lsquo;<tt>gawkapi.h</tt>&rsquo; 头文件中定义了几个宏，你可以在你的代码中使用。这一小节会在你使用函数时来呈现这些宏。
</p>
<hr>
<a name="General-Data-Types"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Functions-Introduction" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Memory-Allocation-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0080_009ac_0094_00a8c_009b_00aec_009a_0084c_009a_0084ae_0095_00b0ae_008d_00aec_00b1_00bbaa_009e_008b"></a>
<h3 class="subsection">5.4.2 通用目的的数据类型</h3>

<a name="index-Robbins_002c-Arnold-4"></a>
<a name="index-Ramey_002c-Chet-1"></a>
<blockquote>
<p><i>
我是真的喜欢/讨厌与联合之间的关系。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Arnold Robbins</em>
</p>
<blockquote>
<p><i>
这是在关于联合的事情：编译器会对事进行周密安排，这样可以协调对它的爱与恨。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Chet Ramey</em>
</p>
<p>扩展的 API 定义了很多简单的类型以及结构来用于通用目的。另外，很多特有的数据结构会在后面的小节中进行介绍，包含使用他们的函数。
</p>
<p>通用目的类型和结构如下：
</p>
<dl compact="compact">
<dt><code>typedef void *awk_ext_id_t;</code></dt>
<dd><p>这个类型的值是在扩展被载入的时候从 <code>gawk</code> 中返回的。这个值必须被作为每个 API 的函数的第一个参数回传给 <code>gawk</code>。
</p>
</dd>
<dt><code>#define awk_const &hellip;</code></dt>
<dd><p>这个宏会在编译扩展时展开成为 &lsquo;<samp>const</samp>&rsquo;，但在编译 <code>gawk</code> 本身时，则为空。这使得 API 数组结构中的特定域从扩展中是不可写的，而允许 <code>gawk</code> 在需要的时候使用它们。
</p>
</dd>
<dt><code>typedef enum awk_bool {</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_false = 0,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_true</code></dt>
<dt><code>} awk_bool_t;</code></dt>
<dd><p>简单的布尔类型。
</p>
</dd>
<dt><code>typedef struct awk_string {</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;char *str;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* data */</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;size_t len;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* length thereof, in chars */</code></dt>
<dt><code>} awk_string_t;</code></dt>
<dd><p>这表示一个可变的字串。如果有值的话，<code>gawk</code> 持有指向它的内存。否则，它会自己持有其指向的内存。<em>这些内存必须来自于 <code>gawk_malloc()</code>，<code>gawk_calloc()</code>，或者 <code>gawk_realloc()</code> 函数。</em>
</p>
<p>如早前所提，字串使用当前的多字节编码来保存。
</p>
</dd>
<dt><code>typedef enum {</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;AWK_UNDEFINED,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;AWK_NUMBER,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;AWK_STRING,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;AWK_ARRAY,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;AWK_SCALAR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* opaque access to a variable */</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;AWK_VALUE_COOKIE&nbsp;&nbsp;&nbsp;&nbsp;/* for updating a previously created value */</code></dt>
<dt><code>} awk_valtype_t;</code></dt>
<dd><p>这个 <code>enum</code> 指示了数据的类型。它会在后面的结构体 <code>struct</code> 中使用。
</p>
</dd>
<dt><code>typedef struct awk_value {</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_valtype_t   val_type;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;union {</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_string_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_array_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_scalar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scl;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_value_cookie_t&nbsp;vc;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;} u;</code></dt>
<dt><code>} awk_value_t;</code></dt>
<dd><p>一个“<code>awk</code> 值”。<code>val_type</code> 成员指示了联合体 <code>union</code> 存有的值的类型，每个成员都是特定的类型。
</p>
</dd>
<dt><code>#define str_value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.s</code></dt>
<dt><code>#define num_value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.d</code></dt>
<dt><code>#define array_cookie&nbsp;&nbsp;&nbsp;u.a</code></dt>
<dt><code>#define scalar_cookie&nbsp;&nbsp;u.scl</code></dt>
<dt><code>#define value_cookie&nbsp;&nbsp;&nbsp;u.vc</code></dt>
<dd><p>使用这些宏来访问 <code>awk_value_t</code> 的域会使用代码更阅读。
</p>
</dd>
<dt><code>typedef void *awk_scalar_t;</code></dt>
<dd><p>标量可以被表示成一个透明类型。这些值从 <code>gawk</code> 中获取，然后再回传给 <code>gawk</code>。这在本列表下面的会以有更一般的讨论。更多的细节请参考 <a href="#Symbol-table-by-cookie">通过 Cookie 访问与更新变量</a>。
</p>
</dd>
<dt><code>typedef void *awk_value_cookie_t;</code></dt>
<dd><p>一个“值 cookie”表示一个缓存值的透明类型。这会下列表的后面进行更一般的讨论，而更多的细节请参考 <a href="#Cached-values">创建并使用缓存值</a>。
</p>
</dd>
</dl>

<p>在 <code>awk</code> 中的标量要么是数值，要么是字串。<code>awk_value_t</code> 结构代表一个值。<code>val_type</code> 成员指示联合体 <code>union</code> 中的具体值的类型。
</p>
<p>表示一个数值很简单——API 使用 C <code>double</code>。字串则需要一点工作。因此 <code>gawk</code> 允许内嵌的 <small>NUL</small> 字节在字串中。一个字串必须使用包含指针与长度一对值来表示。这个类型是 <code>awk_string_t</code> 类型。
</p>
<p>标识符（如全局变量的名字）可以与标题值或者与数组进行关联。另外，<code>gawk</code> 提供了真正的数组之数类型，这样指定的数组元素也可以是一个数组。对于数组的讨论，详细内容要到 <a href="#Array-Manipulation">数组操作</a>。
</p>
<p>早前所列的宏使得更容易使用联合体 <code>union</code> 中的元素，就好像它就是结构体 <code>struct</code> 中的域一样，这在 C 中是一个通用的编程技巧。这些代码也更容易编写与阅读，但是<em>你</em>有责任确保 <code>val_type</code> 成员正确地反映了 <code>awk_value_t</code> 结构中的值的类型。
</p>
<p>从概念上来说，联合体 <code>union</code> 中的头三个成员（number，string 与 array）是与 <code>awk</code> 一起使用时所有需要的类型。但是，因为 API 提供的用来访问与更改全局标量值的例程只可以使用变量名，因此会有性能损耗：<code>gawk</code> 必须在访问或者更改时找到这个变量。这会成为一个真正的问题，而不仅是理论上的。
</p>
<p>所以，如果你知道你的扩展会花相当长的时候来读取/或者改变一个或者多个标量的值。你就可以为那个变量获取一个<em>标量 cookie</em>对象，
<a name="DOCF103" href="#FOOT103">(103)</a>
然后使用这个 cookie 来获取变量的值，或者改变变量的值。<code>awk_scalar_t</code> 类型持有一个标量 cookie，而 <code>scalar_cookie</code> 宏提供了访问在 <code>awk_scalar_t</code> 结构中那个类型值的方式。假设有一个标量 cookie，<code>gawk</code> 可以直接返回或者修改其值，而不需要首先查找它。
</p>
<p><code>awk_value_cookie_t</code> 类型与 <code>value_cookie</code> 宏类似。如果你知道你希望使用相同的数值类型与字串类型的<em>值</em>来用于一个或者多个变量，你可以一次创建值，然后为它保留<em>值 cookie</em>，然后在希望在设置变量的任何时候，将这个 cookie 传递过去产。这个可以在运行的 <code>gawk</code> 中节约存储，并且压缩创建值的时间。
</p>
<hr>
<a name="Memory-Allocation-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#General-Data-Types" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Constructor-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0086_0085aa_00ad_0098aa_0088_0086e_0085_008daa_0087_00bdae_0095_00b0a_00b8_008ec_009b_00b8aa_00ba_0094c_009a_0084c_00ae_0080aa_008c_0096aa_00ae_008f"></a>
<h3 class="subsection">5.4.3 内存分配函数与相应的简化宏</h3>
<a name="index-allocating-memory-for-extensions"></a>
<a name="index-extensions_002c-allocating-memory"></a>

<p>API 提供了很多的内存分配函数用来进行<em>内存分配</em>，并可将内存传递绘画 <code>gawk</code>，以及一些用于方便目的的宏。这个子小节
小节将它们的函数原型呈现，扩展可以通过这种方式来使用它们：
</p>
<dl compact="compact">
<dt><code>void *gawk_malloc(size_t size);</code></dt>
<dd><p>调用正确的 <code>malloc()</code> 版本来分配存储，并可以传递给 <code>gawk</code>。
</p>
</dd>
<dt><code>void *gawk_calloc(size_t nmemb, size_t size);</code></dt>
<dd><p>调用正确的 <code>calloc()</code> 版本来分配内存，并可以传递给 <code>gawk</code>。
</p>
</dd>
<dt><code>void *gawk_realloc(void *ptr, size_t size);</code></dt>
<dd><p>调用正确的 <code>realloc()</code> 版本来分配内存，并可以传递给 <code>gawk</code>。
</p>
</dd>
<dt><code>void gawk_free(void *ptr);</code></dt>
<dd><p>调用正确的 <code>free()</code> 版本来释放由 <code>gawk_malloc()</code>，<code>gawk_calloc()</code>，或者 <code>gawk_realloc()</code> 分配的内存。
</p></dd>
</dl>

<p>API 要提供这些函数，是因为要编译的扩展有可能连接的是不同版本的 C 库，而不是 <code>gawk</code> 执行体所使用的 C 库。
<a name="DOCF104" href="#FOOT104">(104)</a>
如果 <code>gawk</code> 使用的是它自己版本 <code>free()</code> 来释放不相同的版本 <code>malloc()</code> 版本分配的内存时，就可能导致未预期的行为。
</p>
<p>有两个方便的宏可以用来使用 <code>gawk_malloc()</code> 与 <code>gawk_realloc()</code> 来进行内存分配。如果分配失败，会导致 <code>gawk</code> 会以致命错误退出。使用它们就像使用一个不会返回值的过程一样。
</p>
<dl compact="compact">
<dt><code>#define emalloc(pointer, type, size, message) &hellip;</code></dt>
<dd><p>这个宏的参数如下：
</p>
<dl compact="compact">
<dt><code>pointer</code></dt>
<dd><p>变量指向被分配的内存。
</p>
</dd>
<dt><code>type</code></dt>
<dd><p>变量的类型。这个用来创建一个调用 <code>gawk_malloc()</code> 的转换。
</p>
</dd>
<dt><code>size</code></dt>
<dd><p>要分配的字节总大小。
</p>
</dd>
<dt><code>message</code></dt>
<dd><p>在错误信息前附加的消息。典型的是使用这个宏的函数名。
</p></dd>
</dl>

<p>例如，你可以像这样来分配一个字串值：
</p>
<div class="example">
<pre class="example">awk_value_t result;
char *message;
const char greet[] = &quot;Don't Panic!&quot;;

emalloc(message, char *, sizeof(greet), &quot;myfunc&quot;);
strcpy(message, greet);
make_malloced_string(message, strlen(message), &amp; result);
</pre></div>

</dd>
<dt><code>#define erealloc(pointer, type, size, message) &hellip;</code></dt>
<dd><p>这个与 <code>emalloc()</code> 类似，但是调用的是 <code>gawk_realloc()</code> 而不是 <code>gawk_malloc()</code>。参数与 <code>emalloc()</code> 宏一样。
</p></dd>
</dl>

<hr>
<a name="Constructor-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Memory-Allocation-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Registration-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009e_0084e_0080_00a0aa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">5.4.4 构造函数</h3>

<p>API 提供了多个<em>构造函数</em>来创建字串或者数值，以及多个相应的宏。这个子小节呈现所有函数的原型，扩展代码可以使用这些原型来调用它们：
</p>
<dl compact="compact">
<dt><code>static inline awk_value_t *</code></dt>
<dt><code>make_const_string(const char *string, size_t length, awk_value_t *result);</code></dt>
<dd><p>这个函数在通过 <code>result</code> 指向的 <code>awk_value_t</code> 变量中创建一个字串值。函数需要要的 <code>string</code> 是一个 C 字串常量（或者其他的字串数据），并自动创建一个在 <code>result</code> 中的数据<em>复本</em>。然后返回 <code>result</code>。
</p>
</dd>
<dt><code>static inline awk_value_t *</code></dt>
<dt><code>make_malloced_string(const char *string, size_t length, awk_value_t *result);</code></dt>
<dd><p>这个函数在由 <code>result</code> 指向的 <code>awk_value_t</code> 变量中创建一个字串类型。函数需要的 <code>string</code> 是一个 &lsquo;<samp>char *</samp>&rsquo;，指向的之前已经从 <code>gawk_malloc()</code>，<code>gawk_calloc()</code> 或者 <code>gawk_realloc()</code> 中获取的数据。这里的想法是数值会直接传递给 <code>gawk</code>，将对其负责。函数返回 <code>result</code>。
</p>
</dd>
<dt><code>static inline awk_value_t *</code></dt>
<dt><code>make_null_string(awk_value_t *result);</code></dt>
<dd><p>这个特别函数，在一个由 <code>result</code> 指向的 <code>awk_value_t</code> 变量由中创建一个空串。函数返回 <code>result</code>。
</p>
</dd>
<dt><code>static inline awk_value_t *</code></dt>
<dt><code>make_number(double num, awk_value_t *result);</code></dt>
<dd><p>这个函数简单地在由 <code>result</code> 指向的 <code>awk_value_t</code> 变量中创建一个数值。
</p></dd>
</dl>

<hr>
<a name="Registration-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Constructor-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b3_00a8aa_0086_008caa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">5.4.5 注册函数</h3>
<a name="index-register-extension"></a>
<a name="index-extension-registration"></a>

<p>本小节描述用于注册部分扩展到 <code>gawk</code> 中的 API 函数。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Extension-Functions">5.4.5.1 注册扩展函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Registering extension functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Exit-Callback-Functions">5.4.5.2 注册退出函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Registering an exit callback.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Version-String">5.4.5.3 注册扩展版本字串</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Registering a version string.
</td></tr>
<tr><td align="left" valign="top"><a href="#Input-Parsers">5.4.5.4 定制输入分析器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Registering an input parser.
</td></tr>
<tr><td align="left" valign="top"><a href="#Output-Wrappers">5.4.5.5 定制输出包装器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Registering an output wrapper.
</td></tr>
<tr><td align="left" valign="top"><a href="#Two_002dway-processors">5.4.5.6 定制双路处理器</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Registering a two-way processor.
</td></tr>
</table>

<hr>
<a name="Extension-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Registration-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Registration-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Exit-Callback-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b3_00a8aa_0086_008cae_0089_00a9aa_00b1_0095aa_0087_00bdae_0095_00b0"></a>
<h4 class="subsubsection">5.4.5.1 注册扩展函数</h4>

<p>扩展函数是通过下面的记录下进行描述的：
</p>
<div class="example">
<pre class="example">typedef struct awk_ext_func {
&nbsp;&nbsp;&nbsp;&nbsp;const char *name;
&nbsp;&nbsp;&nbsp;&nbsp;awk_value_t *(*function)(int num_actual_args, awk_value_t *result);
&nbsp;&nbsp;&nbsp;&nbsp;size_t num_expected_args;
} awk_ext_func_t;
</pre></div>

<p>域的含义如下：
</p>
<dl compact="compact">
<dt><code>const char *name;</code></dt>
<dd><p>新函数的名字。<code>awk</code> 层的代码通过这个名字来调用函数。这是一个常规的 C 字串。
</p>
<p>函数名必须符合 <code>awk</code> 标识符的规则。也就是，它们必须是以英文字母或者下划线开始，后面可以跟任何的字母，数字与下划线。函数名的字母的大小写是有关的。
</p>
</dd>
<dt><code>awk_value_t *(*function)(int num_actual_args, awk_value_t *result);</code></dt>
<dd><p>这是一个指向提供了扩展功能的 C 函数的指针。函数必须在 <code>*result</code> 中填入数字或者字串。<code>gawk</code> 会接管任意字串内存的所有权。如早先所提，字串内存<em>必须</em>来自于 <code>gawk_malloc()</code>，<code>gawk_calloc()</code> 或 <code>gawk_realloc()</code> 等函数之一。
</p>
<p><code>num_actual_args</code> 参数告知 C 函数，会有多少个实际的函数从调用的 <code>awk</code> 代码中传入。
</p>
<p>函数必须返回 <code>result</code> 的值。这主要是为了 <code>gawk</code> 中调用代码使用上的方便。
</p>
</dd>
<dt><code>size_t num_expected_args;</code></dt>
<dd><p>这个是函数希望接受参数的个数。每一个扩展函数都可以决定如果参数不是它所希望的个数时所要做的事情。对于真正的 <code>awk</code> 函数，忽略额外的参数也是可以的。
</p></dd>
</dl>

<p>一旦你有了一个表示你的扩展的函数，你就可以使用下面的 API 函数来注册：
</p>
<dl compact="compact">
<dt><code>awk_bool_t add_ext_func(const char *namespace, const awk_ext_func_t *func);</code></dt>
<dd><p>这个函数在成功时返回为 true，否则返回 false。<code>namespace</code> 参数当前没有使用，你可以传递一个空串（<code>&quot;&quot;</code>）过去。<code>func</code> 指针是代表你的函数的结构体 <code>struct</code> 指针，其结构如上所述。
</p></dd>
</dl>

<hr>
<a name="Exit-Callback-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Registration-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Version-String" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b3_00a8aa_0086_008ce_0080_0080aa_0087_00baaa_0087_00bdae_0095_00b0"></a>
<h4 class="subsubsection">5.4.5.2 注册退出函数</h4>

<p>一个<em>退出回调</em>函数是在 <code>gawk</code> 退出时要调用的函数。这样的函数会在你的扩展中有一些清理工作要做时非常有用（如关闭数据库连接以及释放其他资源）。你可以使用下面的函数来注册这样的一个函数到 <code>gawk</code> 中：
</p>
<dl compact="compact">
<dt><code>void awk_atexit(void (*funcp)(void *data, int exit_status),</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *arg0);</code></dt>
<dd><p>参数的含义为：
</p>
<dl compact="compact">
<dt><code>funcp</code></dt>
<dd><p>一个在 <code>gawk</code> 退出之前要调用的函数的指针。<code>data</code> 参数就是 <code>arg0</code> 的初始值。<code>exit_status</code> 参数是 <code>gawk</code> 想传递给 <code>exit()</code> 系统调用的状态值。
</p>
</dd>
<dt><code>arg0</code></dt>
<dd><p>一个私有数据的指针，<code>gawk</code> 会保存它，并在调用 <code>funcp</code> 指向的函数时传递给它。 
</p></dd>
</dl>
</dd>
</dl>

<p>退出回调函数会先进先出（LIFO）的顺序调用，也就是以它们注册到 <code>gawk</code> 中的顺序相反的顺序来调用。
</p>
<hr>
<a name="Extension-Version-String"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Exit-Callback-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Registration-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Input-Parsers" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b3_00a8aa_0086_008cae_0089_00a9aa_00b1_0095c_0089_0088ae_009c_00acaa_00ad_0097a_00b8_00b2"></a>
<h4 class="subsubsection">5.4.5.3 注册扩展版本字串</h4>

<p>你可以注意一个版本字串来表示你的扩展在 <code>gawk</code> 中的版本与名字，如下：
</p>
<dl compact="compact">
<dt><code>void register_ext_version(const char *version);</code></dt>
<dd><p>将由 <code>version</code> 指向的版本注册到 <code>gawk</code> 中。要注意 <code>gawk</code> <em>不会</em>拷贝 version 字串，因此它不可以被改变。
</p></dd>
</dl>

<p><code>gawk</code> 当以 &lsquo;<samp>--version</samp>&rsquo; 选项调用时，会打印所有的已经注册了扩展的版本字串。
</p>
<hr>
<a name="Input-Parsers"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Version-String" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Registration-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Output-Wrappers" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_009aaa_0088_00b6e_00be_0093aa_0085_00a5aa_0088_0086ae_009e_0090aa_0099_00a8"></a>
<h4 class="subsubsection">5.4.5.4 定制输入分析器</h4>
<a name="index-customized-input-parser"></a>

<p>默认的情况下，<code>gawk</code> 从输入中读取文本。它使用 <code>RS</code> 的值来查看记录的结束，并且使用 <code>FS</code>（或者 <code>FIELDWIDTHS</code> 或者 <code>FPAT</code>）来将其分割成域（查看 see section <a href="#Reading-Files">读取输入文件</a>）。另外，<code>gawk</code> 还会设置 <code>RT</code> 的值（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）。
</p>
<p>如果你想，你可以提供自己的定制的输入分析器。一个输入分析器的工作就是给 <code>gawk</code> 的记录处理代码返回一条记录，以及用于 <code>RT</code> 的数据的值与长度的指示符，如果有的话。
</p>
<p>为了提供输入分析器，你必须首先提供两个函数（在这里 <var>XXX</var> 是你的扩展的前缀）：
</p>
<dl compact="compact">
<dt><code>awk_bool_t <var>XXX</var>_can_take_file(const awk_input_buf_t *iobuf);</code></dt>
<dd><p>这个函数检查在 <code>iobuf</code> 中的信息（我们后面会讨论）。基于里面的信息，可以确定输入分析器是否用于这个文件。如果可以，则返回 true。否则返回 false。这个函数不应该改变 <code>gawk</code> 中的任何状态（比如变量的值等）。
</p>
</dd>
<dt><code>awk_bool_t <var>XXX</var>_take_control_of(awk_input_buf_t *iobuf);</code></dt>
<dd><p>当 <code>gawk</code> 决定从输入分析器中接手文件的控制权的时候，它会调用这个函数。这个函数接着必须将特定的域填充到 <code>awk_input_buf_t</code> 结构中，并保证特定的条件为 true。函数应当返回 true。如果出现了某种错误，函数不可以再填充任何域，并且返回 false，之后，<code>gawk</code> 不会使用这个输入分析器。细节将在后面呈现。
</p></dd>
</dl>

<p>你的扩展应该要将这些函数包到 <code>awk_input_parser_t</code> 中，这个结构如下：
</p>
<div class="example">
<pre class="example">typedef struct awk_input_parser {
    const char *name;   /* name of parser */
    awk_bool_t (*can_take_file)(const awk_input_buf_t *iobuf);
    awk_bool_t (*take_control_of)(awk_input_buf_t *iobuf);
    awk_const struct awk_input_parser *awk_const next;   /* for gawk */
} awk_input_parser_t;
</pre></div>

<p>这些域为：
</p>
<dl compact="compact">
<dt><code>const char *name;</code></dt>
<dd><p>输入分析器的名字。这是一个常规的 C 字串。
</p>
</dd>
<dt><code>awk_bool_t (*can_take_file)(const awk_input_buf_t *iobuf);</code></dt>
<dd><p>指向 <code><var>XXX</var>_can_take_file()</code> 函数的指针。
</p>
</dd>
<dt><code>awk_bool_t (*take_control_of)(awk_input_buf_t *iobuf);</code></dt>
<dd><p><code><var>XXX</var>_take_control_of()</code> 函数的指针。
</p>
</dd>
<dt><code>awk_const struct input_parser *awk_const next;</code></dt>
<dd><p>这个由 <code>gawk</code> 来使用，因此它被标志为 <code>awk_const</code>，这样扩展就不能够修改它。
</p></dd>
</dl>

<p>实现步骤：
</p>
<ol>
<li>
创建一个静态的 <code>awk_input_parser_t</code> 变量，并且正确地初始化它。

</li><li>
当你的扩展被载入时，使用 <code>register_input_parser()</code> API 函数注册你的输入分析器到 <code>gawk</code> 中（接下来描述）。
</li></ol>

<p><code>awk_input_buf_t</code> 结构如下：
</p>
<div class="example">
<pre class="example">typedef struct awk_input {
    const char *name;       /* filename */
    int fd;                 /* file descriptor */
#define INVALID_HANDLE (-1)
    void *opaque;           /* private data for input parsers */
    int (*get_record)(char **out, struct awk_input *iobuf,
                      int *errcode, char **rt_start, size_t *rt_len);
    ssize_t (*read_func)();
    void (*close_func)(struct awk_input *iobuf);
    struct stat sbuf;       /* stat buf */
} awk_input_buf_t;
</pre></div>

<p>这些域可以分成两类：一类是 <code><var>XXX</var>_can_take_file()</code> 函数使用（最起码是），以及被 <code><var>XXX</var>_take_control_of()</code> 使用，它们使用的第一组域如下：
</p>
<dl compact="compact">
<dt><code>const char *name;</code></dt>
<dd><p>文件的名字。
</p>
</dd>
<dt><code>int fd;</code></dt>
<dd><p>文件的描述符。如果 <code>gawk</code> 能打开文件，<code>fd</code> 则<em>不会</em>等于 <code>INVALID_HANDLE</code>，否则等于。
</p>
</dd>
<dt><code>struct stat sbuf;</code></dt>
<dd><p>如果文件描述符是有效的，<code>gawk</code> 会将这个结构通过 <code>fstat()</code> 系统调用来进行填充。
</p></dd>
</dl>

<p><code><var>XXX</var>_can_take_file()</code> 函数应该检查这些域，并决定输入分析器是否可用于这个文件。决定依赖于 <code>gawk</code> 的状态（通过扩展以及由 <code>awk</code> 代码之前设置的变量的值），文件的名字，文件的描述符是否有效，在 <code>struct stat</code> 中的信息，以及所有这些因素的组合。
</p>
<p>只要 <code><var>XXX</var>_can_take_file()</code> 函数返回 true，<code>gawk</code> 就决定使用你的输入分析器，然后调用 <code><var>XXX</var>_take_control_of()</code>。
这个函数会填充在 <code>awk_input_buf_t</code> 结构中的 <code>get_recordfield</code> 或者 <code>read_func</code> 域。同时也要保证 <code>fd</code> <em>不会</em>被设置为 <code>INVALID_HANDLE</code>。下面的列表描述了可能会被 <code><var>XXX</var>_take_control_of()</code> 函数使用的域：
</p>
<dl compact="compact">
<dt><code>void *opaque;</code></dt>
<dd><p>这被用来存储任何的输入分析器针对这个文件所需要的状态信息。它对 <code>gawk</code> 是“透明”的。输入分析器并不一定要使用这个指针。
</p>
</dd>
<dt><code>int&nbsp;(*get_record)(char&nbsp;**out,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;awk_input *iobuf,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int *errcode,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char **rt_start,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t *rt_len);</code></dt>
<dd><p>这个函数指针指向一个创建输入记录的函数。所述的函数也是输入分析器的核心。它的行为由本列表下面的文本说明。
</p>
</dd>
<dt><code>ssize_t (*read_func)();</code></dt>
<dd><p>这个函数指针应该指向与标准的 POSIX 函数 <code>read()</code> 系统调用行为相同的函数。它是 <code>get_record</code> 函数指针的替代。它的行为也在本列表后面的文本中描述。
</p>
</dd>
<dt><code>void (*close_func)(struct awk_input *iobuf);</code></dt>
<dd><p>这个函数指针指向一个“tear down”（结束）的函数。它应该释放所有由 <code><var>XXX</var>_take_control_of()</code> 分配的资源。它也可以关闭文件。如果它这么做了，它应将 <code>fd</code> 域设置成 <code>INVALID_HANDLE</code>。
</p>
<p>如果 <code>fd</code> 在这个函数调用后还不是 <code>INVALID_HANDLE</code>，<code>gawk</code> 会调用常规的 <code>close()</code> 系统调用。
</p>
<p>是否有“teardown”函数是可选的。如果你的输入分析器不需要它，就不要设置这个域。这样，<code>gawk</code> 会在文件描述上调用常规的 <code>close()</code> 系统调用，因此这个域需要是有效的。
</p></dd>
</dl>

<p><code><var>XXX</var>_get_record()</code> 函数执行创建记录的工作。参数如下：
</p>
<dl compact="compact">
<dt><code>char **out</code></dt>
<dd><p>这个是一个指向 <code>char *</code> 变量的指针，这个指针指向记录。<code>gawk</code> 会复制自己的数据，所以扩展需要自己管理这个存储。
</p>
</dd>
<dt><code>struct awk_input *iobuf</code></dt>
<dd><p>这个是用于文件的 <code>awk_input_buf_t</code>，里面的域应当用于读取数据（<code>fd</code>）以及如果有的话，管理私有状态（<code>opaque</code>）。
</p>
</dd>
<dt><code>int *errcode</code></dt>
<dd><p>如果出现了错误。<code>*errcode</code> 应该被设置成 <code>&lt;errno.h&gt;</code> 文件中的相应代码。
</p>
</dd>
<dt><code>char **rt_start</code></dt>
<dt><code>size_t *rt_len</code></dt>
<dd><p>如果“record terminator”有意义的话，则 <code>*rt_start</code> 应该被设置成指向用于 <code>RT</code> 的数据。而 <code>*rt_len</code> 应该被设置成数据的长度。否则，<code>*rt_len</code> 应该被设置为 0。<code>gawk</code> 会生成自己的数据复本，所以扩展需要自己管理它们的存储。
</p></dd>
</dl>

<p>返回值是由 <code>*out</code> 指向的缓存的长度，或者在文件结束时返回 <code>EOF</code>，以及错误时返回错误。
</p>
<p>必须保证 <code>errcode</code> 是一个有效的指针，因此就没有必要去测试它是否为 <code>NULL</code> 值。<code>gawk</code> 设置 <code>*errcode</code> 为 0，所以如果没有错误的时候，也没有必要设置它。
</p>
<p>如果出现的错误，函数返回 <code>EOF</code>，并且设置 <code>*errcode</code> 为一个大于 0 的值。在这种情况下，如果 <code>*errcode</code> 不等于 0，<code>gawk</code> 会根据 <code>*errcode</code> 的值自动更新 <code>ERRNO</code> 变量。（一般说来，设置 &lsquo;<samp>*errcode = errno</samp>&rsquo; 就可以了。）
</p>
<p>作为替代，提供一个返回输入记录的函数，你提供一个简单地读取字节的函数，<code>gawk</code> 会将它他分析并组合成记录。如果你这么做，数据应该以当前本地语言设置的多字节编码返回。这样的函数的行为应该与 <code>read()</code> 系统调用的一致，你将 <code>awk_input_buf_t</code> 结构中的 <code>read_func</code> 指针填为这个函数指针。
</p>
<p>默认情况下，<code>gawk</code> 会设置 <code>read_func</code> 指向 <code>read()</code> 系统调用的指针。所以你的扩展不需要显式地这么去做。
</p>
<blockquote>
<p><b>提示:</b> 你必须选择一个或者另外一个方法：要么是一个返回记录的函数，或者一个返回原始数据的函数。特别是，如果你提供了一个函数来获取一个记录，<code>gawk</code> 会调用它，而绝不会调用原生的 read 函数。
</p></blockquote>

<p><code>gawk</code> 发布了一个能读取目录的例子扩展，返回某个目录下的每一个记录（查看 see section <a href="#Extension-Sample-Readdir">读取目录</a>）。你可以使用这个代码来作为指导来写你自己的输入分析器。
</p>
<p>当写一个输入分析器时，你应该要考虑（并且用文件记录下来）它如何来与 <code>awk</code> 代码进行交互。你可能想它总是被调用，并且能够正确处理（如 <code>readdir</code> 扩展代码一样）。又或者你想它根据 <code>awk</code> 变量的值来确定是否被调用，如来自 <code>gawkextlib</code> 项目（查看 see section <a href="#gawkextlib"><code>gawkextlib</code> 项目</a>）中的 XML 扩展一样。在后面的例子中，在 <code>BEGINFILE</code> 段中的代码可以查看 <code>FILENAME</code> 与 <code>ERRNO</code> 的值来决定是否激活输入分析器（查看 see section <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>）。
</p>
<p>你通过下面的函数来注册输入分析器：
</p>
<dl compact="compact">
<dt><code>void register_input_parser(awk_input_parser_t *input_parser);</code></dt>
<dd><p>注册通过 <code>input_parser</code> 指向的输入分析器到 <code>gawk</code> 中。
</p></dd>
</dl>

<hr>
<a name="Output-Wrappers"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Input-Parsers" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Registration-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Two_002dway-processors" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_009aaa_0088_00b6e_00be_0093aa_0087_00baaa_008c_0085e_00a3_0085aa_0099_00a8"></a>
<h4 class="subsubsection">5.4.5.5 定制输出包装器</h4>
<a name="index-customized-output-wrapper"></a>

<a name="index-output-wrapper"></a>
<p><em>输出包装器</em>是输入分析器的另一面。它可以使得扩展能够掌握通过 &lsquo;<samp>&gt;</samp>&rsquo; 或者 &lsquo;<samp>&gt;&gt;</samp>&rsquo; 重定向I/O操作符打开文件（查看 see section <a href="#Redirection">重定向 <code>print</code> 与 <code>printf</code> 的输出</a>）。
</p>
<p>输出包装器的结构与输入分析器的结构非常相似：
</p>
<div class="example">
<pre class="example">typedef struct awk_output_wrapper {
    const char *name;   /* name of the wrapper */
    awk_bool_t (*can_take_file)(const awk_output_buf_t *outbuf);
    awk_bool_t (*take_control_of)(awk_output_buf_t *outbuf);
    awk_const struct awk_output_wrapper *awk_const next;  /* for gawk */
} awk_output_wrapper_t;
</pre></div>

<p>成员如下：
</p>
<dl compact="compact">
<dt><code>const char *name;</code></dt>
<dd><p>这里输出包装器的名字。
</p>
</dd>
<dt><code>awk_bool_t (*can_take_file)(const awk_output_buf_t *outbuf);</code></dt>
<dd><p>这个指向一个函数，该函数检测由 <code>outbuf</code> 指向 <code>awk_output_buf_t</code> 结构的信息。如果输出包装器想掌控输出文件，则应该返回 true，否则返回 false。它不应该改变任何 <code>gawk</code> 的状态（比如变量等）。
</p>
</dd>
<dt><code>awk_bool_t (*take_control_of)(awk_output_buf_t *outbuf);</code></dt>
<dd><p>由这个域所指向的函数在 <code>gawk</code> 决定使输出包装器控制文件的时候调用。它应该将 <code>awk_output_buf_t</code> 结构中的成员适应地填充，如果成功则返回 true，否则返回 false。相关的说明在下面描述。
</p>
</dd>
<dt><code>awk_const struct output_wrapper *awk_const next;</code></dt>
<dd><p>这个由 <code>gawk</code> 使用，因此它被标志为 <code>awk_const</code>，这样扩展就不能够修改它。
</p></dd>
</dl>

<p><code>awk_output_buf_t</code> 的结构如下：
</p>
<div class="example">
<pre class="example">typedef struct awk_output_buf {
    const char *name;   /* name of output file */
    const char *mode;   /* mode argument to fopen */
    FILE *fp;           /* stdio file pointer */
    awk_bool_t redirected;  /* true if a wrapper is active */
    void *opaque;       /* for use by output wrapper */
    size_t (*gawk_fwrite)(const void *buf, size_t size, size_t count,
                FILE *fp, void *opaque);
    int (*gawk_fflush)(FILE *fp, void *opaque);
    int (*gawk_ferror)(FILE *fp, void *opaque);
    int (*gawk_fclose)(FILE *fp, void *opaque);
} awk_output_buf_t;
</pre></div>

<p>这里也一样，你的施展要定义 <code><var>XXX</var>_can_take_file()</code> 与 <code><var>XXX</var>_take_control_of()</code> 这些函数，用以检测并更新 <code>awk_output_buf_t</code> 中的成员。数据成员的说明如下：
</p>
<dl compact="compact">
<dt><code>const char *name;</code></dt>
<dd><p>输出文件的名字。
</p>
</dd>
<dt><code>const char *mode;</code></dt>
<dd><p>模式字串（正如 <code>fopen()</code> 第二个参数一样使用），通过使用这些模式来打开文件。
</p>
</dd>
<dt><code>FILE *fp;</code></dt>
<dd><p>来自由 <code>&lt;stdio.h&gt;</code> 的 <code>FILE</code> 指针。<code>gawk</code> 会在查找输出包装器前试着打开文件。
</p>
</dd>
<dt><code>awk_bool_t redirected;</code></dt>
<dd><p>这个域必须被 <code><var>XXX</var>_take_control_of()</code> 设置为 true。
</p>
</dd>
<dt><code>void *opaque;</code></dt>
<dd><p>这个指针对于 <code>gawk</code> 是透明的。扩展可以使用它来存储与文件有关的私有数据的指针。
</p>
</dd>
<dt><code>size_t (*gawk_fwrite)(const void *buf, size_t size, size_t count,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE *fp, void *opaque);</code></dt>
<dt><code>int (*gawk_fflush)(FILE *fp, void *opaque);</code></dt>
<dt><code>int (*gawk_ferror)(FILE *fp, void *opaque);</code></dt>
<dt><code>int (*gawk_fclose)(FILE *fp, void *opaque);</code></dt>
<dd><p>这些指针应该被设置为指向与 <code>&lt;stdio.h&gt;</code> 中相应函数执行相同操作的函数。<code>gawk</code> 使用这些函数来处理所有输出。<code>gawk</code> 会将这些指针初始化指向内部的“过路”函数，这些函数中是调用常规的 <code>&lt;stdio.h&gt;</code> 函数，所以扩展要根据所要做的事情定义合适函数。
</p></dd>
</dl>

<p><code><var>XXX</var>_can_take_file()</code> 函数可以根据 <code>name</code>，<code>mode</code> 域以及其他的状态（如 <code>awk</code> 变量的值）来做出相应的决定。
</p>
<p>当 <code>gawk</code> 调用 <code><var>XXX</var>_take_control_of()</code> 函数时，这个函数应该对其他的域进行适当的填充，不包括 <code>fp</code>，<code>fp</code> 参数只是会进行常规使用。
</p>
<p>你通过下面的函数来注册你的输出包装器：
</p>
<dl compact="compact">
<dt><code>void register_output_wrapper(awk_output_wrapper_t *output_wrapper);</code></dt>
<dd><p>将由 <code>output_wrapper</code> 指向的输出包装器注册到 <code>gawk</code> 中。
</p></dd>
</dl>

<hr>
<a name="Two_002dway-processors"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Output-Wrappers" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Registration-Functions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Printing-Messages" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_009aaa_0088_00b6aa_008f_008ce_00b7_00afaa_00a4_0084c_0090_0086aa_0099_00a8"></a>
<h4 class="subsubsection">5.4.5.6 定制双路处理器</h4>
<a name="index-customized-two_002dway-processor"></a>

<p>一个<em>双路器</em>将输入分析器与输出包装器来处理由 &lsquo;<samp>|&amp;</samp>&rsquo; 打开的双路 I/O（查看 see section <a href="#Redirection">重定向 <code>print</code> 与 <code>printf</code> 的输出</a>）。它的使用与之前描述过的 <code>awk_input_parser_t</code> 与 <code>awk_output_buf_t</code> 相同。
</p>
<p>两路处理器由下面的结构表示：
</p>
<div class="example">
<pre class="example">typedef struct awk_two_way_processor {
    const char *name;   /* name of the two-way processor */
    awk_bool_t (*can_take_two_way)(const char *name);
    awk_bool_t (*take_control_of)(const char *name,
                                  awk_input_buf_t *inbuf,
                                  awk_output_buf_t *outbuf);
    awk_const struct awk_two_way_processor *awk_const next;  /* for gawk */
} awk_two_way_processor_t;
</pre></div>

<p>域如下：
</p>
<dl compact="compact">
<dt><code>const char *name;</code></dt>
<dd><p>双路处理器的名字。
</p>
</dd>
<dt><code>awk_bool_t (*can_take_two_way)(const char *name);</code></dt>
<dd><p>如果由这个域指向的函数想控制文件名的双路 I/O，它应该返回 true。它不应该改变 <code>gawk</code> 中的任何状态（比如变量值）。
</p>
</dd>
<dt><code>awk_bool_t (*take_control_of)(const char *name,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_input_buf_t *inbuf,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_output_buf_t *outbuf);</code></dt>
<dd><p>由这个域指向的函数应该适当地填充由 <code>inbuf</code> 与 <code>outbuf</code> 所指向中的 <code>awk_input_buf_t</code> 与 <code>awk_output_buf_t</code> 的结构。这两个结构之前所描述。
</p>
</dd>
<dt><code>awk_const struct two_way_processor *awk_const next;</code></dt>
<dd><p>这个由 <code>gawk</code> 来使用，所以它被标志成 <code>awk_const</code>，这样扩展就不可以修改它。
</p></dd>
</dl>

<p>对于输入处理器与输出处理器器，你需要提供“yes I can take this”（是的，我可以处理这个） 与“take over for this”（我已经控制这个）类的函数，即 <code><var>XXX</var>_can_take_two_way()</code> 与 <code><var>XXX</var>_take_control_of()</code>。
</p>
<p>你使用下面的函数来注册你的双路处理器：
</p>
<dl compact="compact">
<dt><code>void register_two_way_processor(awk_two_way_processor_t *two_way_processor);</code></dt>
<dd><p>将由 <code>two_way_processor</code> 指向的双路处理器注册到 <code>gawk</code> 中。
</p></dd>
</dl>

<hr>
<a name="Printing-Messages"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Two_002dway-processors" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Updating-ERRNO" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0089_0093aa_008d_00b0a_00bf_00a1ae_0081_00af"></a>
<h3 class="subsection">5.4.6 打印信息</h3>
<a name="index-printing-messages-from-extensions"></a>
<a name="index-messages-from-extensions"></a>

<p>你可以在你的扩展中打印如本节中所描述的不同的各类的告警信息。要注意对于这些函数，你必须提供一个扩展 ID，这个扩展 ID 是在扩展被载入时由 <code>gawk</code> 提供：
<a name="DOCF105" href="#FOOT105">(105)</a>
</p>
<dl compact="compact">
<dt><code>void fatal(awk_ext_id_t id, const char *format, ...);</code></dt>
<dd><p>打印一个消息，并使 <code>gawk</code> 立即退出。
</p>
</dd>
<dt><code>void warning(awk_ext_id_t id, const char *format, ...);</code></dt>
<dd><p>打印告警信息。
</p>
</dd>
<dt><code>void lintwarn(awk_ext_id_t id, const char *format, ...);</code></dt>
<dd><p>打印一个“lint 告警”。正常情况下，这与打印一个告警信息一样，但是如果 <code>gawk</code> 使用了 &lsquo;<samp>--lint=fatal</samp>&rsquo; 选项，则 lint 告警会成为致命错误消息。
</p></dd>
</dl>

<p>所有的这些函数像 C 的 <code>printf()</code> 家庭的函数一样，在这些函数中，<code>format</code> 参数是一个字串，串中为字面字符以及格式代码。
</p>
<hr>
<a name="Updating-ERRNO"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Printing-Messages" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Requesting-Values" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009b_00b4ae_0096_00b0-ERRNO"></a>
<h3 class="subsection">5.4.7 更新 <code>ERRNO</code></h3>

<p>下面的函数可以让你更新 <code>ERRNO</code> 变量：
</p>
<dl compact="compact">
<dt><code>void update_ERRNO_int(int errno_val);</code></dt>
<dd><p>将 <code>ERRNO</code> 设置为与 <code>errno_val</code> 对应的错误字串。值应该定义在 <code>&lt;errno.h&gt;</code> 中。<code>gawk</code> 会使用 C 的 <code>strerror()</code> 函数将它转换为（如果可以转换）字串。
</p>
</dd>
<dt><code>void update_ERRNO_string(const char *string);</code></dt>
<dd><p>直接使用 <code>ERRNO</code> 的字符串值来设置 <code>ERRNO</code>。<code>gawk</code> 会对这个值复制一个复本。
</p>
</dd>
<dt><code>void unset_ERRNO(void);</code></dt>
<dd><p>重置 <code>ERRNO</code>。
</p></dd>
</dl>

<hr>
<a name="Requesting-Values"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Updating-ERRNO" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Accessing-Parameters" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_00b7ae_00b1_0082aa_0080_00bc"></a>
<h3 class="subsection">5.4.8 请求值</h3>

<p>所有的这些函数都以相同的方式从 <code>gawk</code> 中返回值。你可以传递一个 <code>awk_valtype_t</code> 的值来指示你希望什么的样值。如果实际的值与你的请求的匹配，函数返回为 true。并且在 <code>awk_value_t</code> 中填上结果。否则函数返回 false。而 <code>val_type</code> 成员会指示实际的值类型。你然后可以打印一个错误信息或者重新发起针对实际值类型的请求。这结行为在 <a href="#table_002dvalue_002dtypes_002dreturned">Table 5.1</a> 进行了归纳：
</p>
<div class="float"><a name="table_002dvalue_002dtypes_002dreturned"></a>


<table>
<thead><tr><th width="50%"></th><th width="50%">Type of Actual Value</th></tr></thead>
</table>
<table>
<thead><tr><th width="16%"></th><th width="16%"></th><th width="19%">String</th><th width="15%">Number</th><th width="15%">Array</th><th width="16%">Undefined</th></tr></thead>
<tr><td width="16%"></td><td width="16%"><b>String</b></td><td width="19%">String</td><td width="15%">String</td><td width="15%">False</td><td width="16%">False</td></tr>
<tr><td width="16%"></td><td width="16%"><b>Number</b></td><td width="19%">Number if can be converted, else false</td><td width="15%">Number</td><td width="15%">False</td><td width="16%">False</td></tr>
<tr><td width="16%"><b>Type</b></td><td width="16%"><b>Array</b></td><td width="19%">False</td><td width="15%">False</td><td width="15%">Array</td><td width="16%">False</td></tr>
<tr><td width="16%"><b>Requested</b></td><td width="16%"><b>Scalar</b></td><td width="19%">Scalar</td><td width="15%">Scalar</td><td width="15%">False</td><td width="16%">False</td></tr>
<tr><td width="16%"></td><td width="16%"><b>Undefined</b></td><td width="19%">String</td><td width="15%">Number</td><td width="15%">Array</td><td width="16%">Undefined</td></tr>
<tr><td width="16%"></td><td width="16%"><b>Value cookie</b></td><td width="19%">False</td><td width="15%">False</td><td width="15%">False</td><td width="16%">False</td></tr>
</table>
</div><p><strong>Table 5.1: 返回的 API 值类型
</strong>
</p>
<hr>
<a name="Accessing-Parameters"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Requesting-Values" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-Table-Access" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00ae_00bfe_0097_00aea_00b8_008eae_009b_00b4ae_0096_00b0aa_008f_0082ae_0095_00b0"></a>
<h3 class="subsection">5.4.9 访问与更新参数</h3>

<p>有两个函数可以让你访问传递给你的扩展函数的参数。它们是：
</p>
<dl compact="compact">
<dt><code>awk_bool_t get_argument(size_t count,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_valtype_t wanted,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_value_t *result);</code></dt>
<dd><p>用第 <code>count</code> 个参数来填充由 <code>result</code> 指向的 <code>awk_value_t</code> 结构。如果实际的类型与 <code>wanted</code> 是匹配的，则返回 true，否则返回 false。在后面的情况下，<code>result<span class="nolinebreak">-&gt;</span>val_type</code> 指示了实际的类型（查看 see <a href="#table_002dvalue_002dtypes_002dreturned">Table 5.1</a>）。计数是从 0 开始的——第一个参数编号为 0，第二个为 1，等等。<code>wanted</code> 指示了所期望的值类型。
</p>
</dd>
<dt><code>awk_bool_t set_argument(size_t count, awk_array_t array);</code></dt>
<dd><p>将未定义的参数转换为一个数组，这提供了通过数组引用来调用的方式。如果 <code>count</code> 太大，或者如果参数类型是未定义的，则返回 false。查看 <a href="#Array-Manipulation">数组操作</a>，来查看创建数组的更多信息。
</p></dd>
</dl>

<hr>
<a name="Symbol-Table-Access"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Accessing-Parameters" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-table-by-name" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00ac_00a6aa_008f_00b7e_00a1_00a8e_00ae_00bfe_0097_00ae"></a>
<h3 class="subsection">5.4.10 符号表访问</h3>
<a name="index-accessing-global-variables-from-extensions"></a>

<p>有两个集合的例程提供了访问全局变量的能力，以及一个集合的例程可以让你创建并释放缓存值。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Symbol-table-by-name">5.4.10.1 通过名字访问与更新变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Accessing variables by name.
</td></tr>
<tr><td align="left" valign="top"><a href="#Symbol-table-by-cookie">5.4.10.2 通过 Cookie 访问与更新变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Accessing variables by &ldquo;cookie&rdquo;.
</td></tr>
<tr><td align="left" valign="top"><a href="#Cached-values">5.4.10.3 创建并使用缓存值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Creating and using cached values.
</td></tr>
</table>

<hr>
<a name="Symbol-table-by-name"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-Table-Access" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-Table-Access" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-table-by-cookie" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0080_009ae_00bf_0087aa_0090_008daa_00ad_0097e_00ae_00bfe_0097_00aea_00b8_008eae_009b_00b4ae_0096_00b0aa_008f_0098e_0087_008f"></a>
<h4 class="subsubsection">5.4.10.1 通过名字访问与更新变量</h4>

<p>下面的例程提供了通过名字来访问、更新全局的 <code>awk</code> 层变量的能力。以编译器的术语来看，不同各类的标识符都称为<em>符号</em>，这是例程中的“sym”名字的来由。存储符号信息的数组结构称为<em>符号表</em>。这些函数如下：
</p>
<dl compact="compact">
<dt><code>awk_bool_t sym_lookup(const char *name,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_valtype_t wanted,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_value_t *result);</code></dt>
<dd><p>用由字串 <code>name</code> 命令的变量的值来填充由 <code>result</code> 指向听 <code>awk_value_t</code> 的结构，名字为 C 字串。<code>wanted</code> 指示了期望的值的类型。如果实际的类型与其匹配，则返回 true，否则返回 false。在后面的情况下，<code>result-&gt;val_type</code> 指示了实际的类型（查看 see <a href="#table_002dvalue_002dtypes_002dreturned">Table 5.1</a>）。
</p>
</dd>
<dt><code>awk_bool_t sym_update(const char *name, awk_value_t *value);</code></dt>
<dd><p>更新由字串 <code>name</code> 命名的变量，这个名字为 C 字串。如果变量不存在 <code>gawk</code> 的符号表中，则会新增它。如果一切 OK，则返回 true，否则返回 false。
</p>
<p>改变已经存在的变量的类型（从标量到数组，或者相反）是<em>不</em>允许的，这个例程也不能用于数组的更新。这个例程不可以用于更新任何的预定义变量的值（如 <code>ARGC</code> 或者 <code>NF</code>）。
</p></dd>
</dl>

<p>扩展可以查找 <code>gawk</code> 的特定变量。但是，<code>PROCINFO</code> 数组是个例外，扩展不可以改变这些变量的值。
</p>
<blockquote>
<p><b>注意:</b> 有可能查找 <code>PROCINFO</code> 失败。如果 <code>awk</code> 程序在运行时没有使用 <code>PROCINFO</code> 时会引起失败，在这个情况下，<code>gawk</code> 不会创建这个数组并传播它。
</p></blockquote>

<hr>
<a name="Symbol-table-by-cookie"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-table-by-name" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-Table-Access" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Cached-values" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0080_009ae_00bf_0087-Cookie-e_00ae_00bfe_0097_00aea_00b8_008eae_009b_00b4ae_0096_00b0aa_008f_0098e_0087_008f"></a>
<h4 class="subsubsection">5.4.10.2 通过 Cookie 访问与更新变量</h4>

<p><em>标量 cookie</em> 是一个透明的句柄，可以用来访问全局变量以及数组。它是一种优化手段，以免在使用变量时去在 <code>gawk</code> 的符号表中去查找变量，这个早前在 <a href="#General-Data-Types">通用目的的数据类型</a>，已经讨论过。
</p>
<p>下面的函数用来过处理标量 cookies：
</p>
<dl compact="compact">
<dt><code>awk_bool_t sym_lookup_scalar(awk_scalar_t cookie,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_valtype_t wanted,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_value_t *result);</code></dt>
<dd><p>返回标量 cookie 的当前值，一旦你通过 <code>sym_lookup()</code> 获取了一个标量的 cookie 后，你就可以使用这个函数来高效地获取它的值。如果值没有取到，则返回 false。
</p>
</dd>
<dt><code>awk_bool_t sym_update_scalar(awk_scalar_t cookie, awk_value_t *value);</code></dt>
<dd><p>更新与标量 cookie 关联的值。如果新值即不是 <code>AWK_STRING</code>，也不是 <code>AWK_NUMBER</code>，则返回 false。在这里也是一样，预定的义的变量不能被更新的。
</p></dd>
</dl>

<p>一开始这如何来使用标量 Cookie 并不是很明显，也不知道它们的 <i>raison d&rsquo;&ecirc;tre</i> 到底是什么。理论上，<code>sym_lookup()</code> 以及 <code>sym_update()</code> 例程就是你来处理变量时所要的所有例程。例如，你有代码要查找变量的值，对条件进行求值，然后就可以通过求值的结果变更变量的值，如：
</p>
<div class="example">
<pre class="example">/*  do_magic --- do something really great */

static awk_value_t *
do_magic(int nargs, awk_value_t *result)
{
    awk_value_t value;

    if (   sym_lookup(&quot;MAGIC_VAR&quot;, AWK_NUMBER, &amp; value)
        &amp;&amp; some_condition(value.num_value)) {
            value.num_value += 42;
            sym_update(&quot;MAGIC_VAR&quot;, &amp; value);
    }

    return make_number(0.0, result);
}
</pre></div>

<p>这个代码看起来（实际）很简单而直接，但是问题是什么呢？
</p>
<p>考虑一下，如果 <code>awk</code> 层的代码通过调用 <code>magic()</code> 函数（通过 C 的 <code>do_magic()</code> 来实现）来与你的扩展进行关联，一次一条记录来处理数以百万计的记录。变量 <code>MAGIC_VAR</code> 会在每个函数的调用中都在符号表中进行查找！
</p>
<p>符号表的查找真的是个纯的负担，如果得到一个表示这个变量的 cookie 要更高效，并使用它在必要的时候获取与更新它的值。 
<a name="DOCF106" href="#FOOT106">(106)</a>
</p>
<p>所以，使用 cookie 的方式如下。首先，将你的变量通过 <code>sym_update()</code> 来安装到 <code>gawk</code> 的符号表中，然后通过 <code>sym_lookup()</code> 获取一个该变量的 Cookie：
</p>
<div class="example">
<pre class="example">static awk_scalar_t magic_var_cookie;    /* cookie for MAGIC_VAR */

static void
my_extension_init()
{
    awk_value_t value;

    /* install initial value */
    sym_update(&quot;MAGIC_VAR&quot;, make_number(42.0, &amp; value));

    /* get the cookie */
    sym_lookup(&quot;MAGIC_VAR&quot;, AWK_SCALAR, &amp; value);

    /* save the cookie */
    magic_var_cookie = value.scalar_cookie;
    &hellip;
}
</pre></div>

<p>下一步，使用这小节中的函数来并通过 Cookie 来返回与更新变量的值。所以，<code>do_magic()</code> 现在变成如下：
</p>
<div class="example">
<pre class="example">/*  do_magic --- do something really great */

static awk_value_t *
do_magic(int nargs, awk_value_t *result)
{
    awk_value_t value;

    if (   sym_lookup_scalar(magic_var_cookie, AWK_NUMBER, &amp; value)
        &amp;&amp; some_condition(value.num_value)) {
            value.num_value += 42;
            sym_update_scalar(magic_var_cookie, &amp; value);
    }
    &hellip;

    return make_number(0.0, result);
}
</pre></div>

<blockquote>
<p><b>提示:</b> 前面的代码省略了错误检查，为了是表现主题。你的扩展代码应该要更加健壮，并且仔细地检查从 API 函数中返回的值。
</p></blockquote>

<hr>
<a name="Cached-values"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-table-by-cookie" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Symbol-Table-Access" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Manipulation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0088_009baa_00bb_00baaa_00b9_00b6a_00bd_00bfc_0094_00a8c_00bc_0093aa_00ad_0098aa_0080_00bc"></a>
<h4 class="subsubsection">5.4.10.3 创建并使用缓存值</h4>

<p>本小节中的全程可以让你创建与释放缓存值。像标量 cookie 一样，理论上讲，缓存值是不需要的。你可以使用 <a href="#Constructor-Functions">构造函数</a> 中的函数创建数值与字串。你然后可以将这些值赋给使用 <code>sym_update()</code> 或者 <code>sym_update_scalar()</code> 的变量。
</p>
<p>但是，如果你记得<em>所有</em>的字串值的存储<em>必须</em>来自于 <code>gawk_malloc()</code>，<code>gawk_calloc()</code> 或者 <code>gawk_realloc()</code> 这些函数这一点，你就能够理解缓存值的出发点。如果你有 20 个变量，它们都有相同的值，你必须创建 20 个相同的字串复本。 <a name="DOCF107" href="#FOOT107">(107)</a>
</p>
<p>当然，如果可能，一旦创建一个值，就可以告诉 <code>gawk</code> 可以为多个变量重用这个值。这正是本小节中的例程所要做的事情。函数如下：
</p>
<dl compact="compact">
<dt><code>awk_bool_t create_value(awk_value_t *value, awk_value_cookie_t *result);</code></dt>
<dd><p>创建一个缓存的字串或者数值，用于后面的高效赋值。仅支持 <code>AWK_NUMBER</code> 与 <code>AWK_STRING</code> 类型的值。其他的类型会被拒绝。<code>AWK_UNDEFINED</code> 类型也可以使用，但是这么做会导致较差的性能。
</p>
</dd>
<dt><code>awk_bool_t release_value(awk_value_cookie_t vc);</code></dt>
<dd><p>释放与一个通过 <code>create_value()</code> 获取的值 cookie 关联的内存。
</p></dd>
</dl>

<p>使用值 cookie 的方式与使用标量 cookie 的方式是一样的。在扩展初始化例程中，你这样来创建值 cookie：
</p>
<div class="example">
<pre class="example">static awk_value_cookie_t answer_cookie;  /* static value cookie */

static void
my_extension_init()
{
    awk_value_t value;
    char *long_string;
    size_t long_string_len;

    /* code from earlier */
    &hellip;
    /* &hellip; fill in long_string and long_string_len &hellip; */
    make_malloced_string(long_string, long_string_len, &amp; value);
    create_value(&amp; value, &amp; answer_cookie);    /* create cookie */
    &hellip;
}
</pre></div>

<p>值一旦创建，你就可以用它作为任意变量的值：
</p>
<div class="example">
<pre class="example">static awk_value_t *
do_magic(int nargs, awk_value_t *result)
{
    awk_value_t new_value;

    &hellip;    /* as earlier */

    value.val_type = AWK_VALUE_COOKIE;
    value.value_cookie = answer_cookie;
    sym_update(&quot;VAR1&quot;, &amp; value);
    sym_update(&quot;VAR2&quot;, &amp; value);
    &hellip;
    sym_update(&quot;VAR100&quot;, &amp; value);
    &hellip;
}
</pre></div>

<p>通过这样的值 cookies 可以节约大量的存储，从 <code>VAR1</code> 到 <code>VAR100</code> 都共享一样的值。
</p>
<p>你可能会奇怪，“这样的共享不会有问题么？如果 <code>awk</code> 代码给 <code>VAR1</code> 赋了一个新值，是不是所有的其他变量都会改变？”
</p>
<p>这是一个很好的问题。答案是不会，这不会是个问题。在内部，<code>gawk</code> 使用<em>参考计数的字串</em>。这就是说，许多的变量都可以使用共享的字串值，<code>gawk</code> 会跟踪它的使用。当变量值改变时，<code>gawk</code> 仅是简单地递减旧值的参考计数，然后更新变量让其使用新的值。
</p>
<p>最后，作为清除操作的一部分（查看 see section <a href="#Exit-Callback-Functions">注册退出函数</a>），你应该通过 <code>release_value()</code> 来释放你创建的缓存值。
</p>
<hr>
<a name="Array-Manipulation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Cached-values" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Data-Types" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0c_00bb_0084ae_0093_008da_00bd_009c"></a>
<h3 class="subsection">5.4.11 数组操作</h3>
<a name="index-array-manipulation-in-extensions"></a>

<p>在 <code>awk</code> 中，最重要的数据结构<a name="DOCF108" href="#FOOT108">(108)</a>
与数组（查看 see section <a href="#Arrays"><code>awk</code> 数组</a>）相关。扩展需要有能力操作 <code>awk</code> 中的数组。API 中提供了很多的数据结构来处理数组，也提供了处理单个元素的函数，以及处理整个数组的函数。这包含了扁平化数组的能力，这样就很容易使用 C 代码来遍历数组中的每一个元素。数组数据结构很好地与值的数据结构进行了整合，使得很容易来创建真正的多维数组（查看 see section <a href="#General-Data-Types">通用目的的数据类型</a>）。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Array-Data-Types">5.4.11.1 数组数据类型</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Data types for working with arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Array-Functions">5.4.11.2 数组函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Functions for working with arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Flattening-Arrays">5.4.11.3 遍历数组的所有元素</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           How to flatten arrays.
</td></tr>
<tr><td align="left" valign="top"><a href="#Creating-Arrays">5.4.11.4 如何生成与发布数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How to create and populate arrays.
</td></tr>
</table>

<hr>
<a name="Array-Data-Types"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Manipulation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Manipulation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0c_00bb_0084ae_0095_00b0ae_008d_00aec_00b1_00bbaa_009e_008b"></a>
<h4 class="subsubsection">5.4.11.1 数组数据类型</h4>

<p>与数组相关的数据类型有：
</p>
<dl compact="compact">
<dt><code>typedef void *awk_array_t;</code></dt>
<dd><p>如果你请求一个数组变量的值，你可以取得一个 <code>awk_array_t</code> 的值。这个值
<a name="DOCF109" href="#FOOT109">(109)</a>
对于扩展来说是透明的。
这唯一地标识数组，但是只可以将其传递给 API 函数来使用，或者从 API 函数中返回。这个方式与 <code>&lt;stdio.h&gt;</code> 中函数使用 &lsquo;<samp>FILE *</samp>&rsquo; 值类似。
</p>
</dd>
<dt><code>typedef struct awk_element {</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;/* convenience linked list pointer, not used by gawk */</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;struct awk_element *next;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;enum {</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AWK_ELEMENT_DEFAULT = 0,&nbsp;&nbsp;/* set by gawk */</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AWK_ELEMENT_DELETE = 1&nbsp;&nbsp;&nbsp;&nbsp;/* set by extension */</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;} flags;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_value_t    index;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_value_t    value;</code></dt>
<dt><code>} awk_element_t;</code></dt>
<dd><p><code>awk_element_t</code> 是一个平的数组元素。<code>awk</code> 会在 <code>awk_flat_array_t</code> 类型中生成一个此类型的数组（查看下一项的说明）。单个的元素可以被标志成删除。新的元素必须一个个地添加，一次一个。为了完成这个添加，要使用另外的 API。数据结构中的域为：
</p>
<dl compact="compact">
<dt><code>struct awk_element *next;</code></dt>
<dd><p>这是为了方便扩展的编写者的一个指针。它允许扩展创建一个新元素的链表，这样可以在遍历列表时来加入到数组中。
</p>
</dd>
<dt><code>enum { &hellip; } flags;</code></dt>
<dd><p>在扩展与 <code>gawk</code> 之间传递信息的标志值。当前只有一个 <code>AWK_ELEMENT_DELETE</code>，如果设置这个标志，会使得 <code>gawk</code> 释放扁平的数组时，从原始的数组中删除这个元素。
</p>
</dd>
<dt><code>index</code></dt>
<dt><code>value</code></dt>
<dd><p>元素的索引与值。<em>所有</em>被 <code>index</code> 与 <code>value</code> 指向的内存都属于 <code>gawk</code>。
</p></dd>
</dl>

</dd>
<dt><code>typedef struct awk_flat_array {</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_const void *awk_const opaque1;&nbsp;&nbsp;&nbsp;&nbsp;/* for use by gawk */</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_const void *awk_const opaque2;&nbsp;&nbsp;&nbsp;&nbsp;/* for use by gawk */</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_const size_t count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* how many elements */</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;awk_element_t elements[1];&nbsp;&nbsp;/* will be extended */</code></dt>
<dt><code>} awk_flat_array_t;</code></dt>
<dd><p>这是一个平面数组。当扩展从 <code>gawk</code> 中取得其中之一时，元素数组 <code>elements</code> 的实际大小就是 <code>count</code>。<code>opaque1</code> 与 <code>opaque2</code> 指针由 <code>gawk</code> 使用，所以，它们被标志成 <code>awk_const</code>，这样扩展就不可以修改它们。
</p></dd>
</dl>

<hr>
<a name="Array-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Data-Types" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Manipulation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Flattening-Arrays" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b0c_00bb_0084aa_0087_00bdae_0095_00b0"></a>
<h4 class="subsubsection">5.4.11.2 数组函数</h4>

<p>下面的函数与单个的元素相关：
</p>
<dl compact="compact">
<dt><code>awk_bool_t get_element_count(awk_array_t a_cookie, size_t *count);</code></dt>
<dd><p>为由 <code>a_cookie</code> 表示的数组，放入其包含的 <code>*count</code> 个元素。子数组由一个单独的元素表示。如果有错误时，返回 false。
</p>
</dd>
<dt><code>awk_bool_t get_array_element(awk_array_t a_cookie,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const awk_value_t *const index,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_valtype_t wanted,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_value_t *result);</code></dt>
<dd><p>从 <code>a_cookie</code> 表示的数组中，返回元素下标 <code>index</code> 的值到 <code>*result</code> 中。<code>wanted</code> 指定了你希望返回的值类型。如果 <code>wanted</code> 不与实际的类型匹配，或者 <code>index</code> 没有在数组中，则返回 false。（查看 see <a href="#table_002dvalue_002dtypes_002dreturned">Table 5.1</a>）
</p>
<p><code>index</code> 的值可以是数值，这种情况下，<code>gawk</code> 会将其转换为字串。不使用整数值也是可以的，但是需要你了解这样的值如何转换为字串（查看 see section <a href="#Conversion">在字串与数值之间进行转换</a>），所以，使用整数值是最安全的。
</p>
<p>与从扩展中传递到 <code>gawk</code> 中的<em>所有</em>的字串一样，<code>index</code> 的字串值必须来自于 <code>gawk_malloc()</code>，<code>gawk_calloc()</code> 或者 <code>gawk_realloc()</code>，并由 <code>gawk</code> 来释放内存。
</p>
</dd>
<dt><code>awk_bool_t set_array_element(awk_array_t a_cookie,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;awk_value_t *const index,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;awk_value_t *const value);</code></dt>
<dd><p>在由 <code>a_cookie</code> 表示的数组中，创建或者修改一个元素，这个元素的索引由 <code>index</code> 给出。<code>ARGV</code> 与 <code>ENVIRON</code> 数组不可以被改变，但是 <code>PROCINFO</code> 数组则可以。
</p>
</dd>
<dt><code>awk_bool_t set_array_element_by_elem(awk_array_t a_cookie,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_element_t element);</code></dt>
<dd><p>与 <code>set_array_element()</code> 相似，但是是从元素 <code>element</code> 中取得索引 <code>index</code> 与值 <code>value</code>。这是一个便利宏。
</p>
</dd>
<dt><code>awk_bool_t del_array_element(awk_array_t a_cookie,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const awk_value_t* const index);</code></dt>
<dd><p>删除由 <code>a_cookie</code> 表示的数组中指定索引的元素。如果元素被删除，则返回 true。否则，如果元素不存在数组中，则返回 false。
</p></dd>
</dl>

<p>下面的函数与整个数组有关：
</p>
<dl compact="compact">
<dt><code>awk_array_t create_array(void);</code></dt>
<dd><p>创建一个可以添加元素的数组。查看 <a href="#Creating-Arrays">如何生成与发布数组</a>，中对于创建数组并添加元素的讨论。
</p>
</dd>
<dt><code>awk_bool_t clear_array(awk_array_t a_cookie);</code></dt>
<dd><p>清除由 <code>a_cookie</code> 表示的数组。如果有问题返回 false，否则返回 true。数组还是数组，但是调用这个函数后，它就没有元素了。这个与 <code>delete</code> 语句等同（查看 see section <a href="#Delete"><code>delete</code> 语句</a>）。
</p>
</dd>
<dt><code>awk_bool_t flatten_array(awk_array_t a_cookie, awk_flat_array_t **data);</code></dt>
<dd><p>为由 <code>a_cookie</code> 表示的数组，创建一个 <code>awk_flat_array_t</code> 的结构并进行填充。将通过 <code>data</code> 传递的指针的值设置为这个结构的地址。如果成功则返回 true，否则返回 false。
查看 <a href="#Flattening-Arrays">遍历数组的所有元素</a>，
讨论如何来扁平化数组并处理它。
</p>
</dd>
<dt><code>awk_bool_t release_flattened_array(awk_array_t a_cookie,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk_flat_array_t *data);</code></dt>
<dd><p>当完成了数组的扁平化，释放使用这个函数的存储。你必须将最初的数组 cookie 与创建的 <code>awk_flat_array_t</code> 数组结构的地址都传递进去。如果成功返回 true，否则返回 false。
</p></dd>
</dl>

<hr>
<a name="Flattening-Arrays"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Manipulation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Creating-Arrays" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0081_008daa_008e_0086ae_0095_00b0c_00bb_0084c_009a_0084ae_0089_0080ae_009c_0089aa_0085_0083c_00b4_00a0"></a>
<h4 class="subsubsection">5.4.11.3 遍历数组的所有元素</h4>

<p><em>扁平化</em>数组就是创建一个数据结构来表示整个数组，其风格使得很容易使用 C 代码来遍历整个数组。在 &lsquo;<tt>extension/testext.c</tt>&rsquo; 中的一些代码就是来做这些事情，也是一个很好的例子来说明如何来使用 API。
</p>
<p>我们一步步地来过这里面的代码。首先 <code>gawk</code> 脚本来驱动测试扩展：
</p>
<div class="example">
<pre class="example">@load &quot;testext&quot;
BEGIN {
    n = split(&quot;blacky rusty sophie raincloud lucky&quot;, pets)
    printf(&quot;pets has %d elements\n&quot;, length(pets))
    ret = dump_array_and_delete(&quot;pets&quot;, &quot;3&quot;)
    printf(&quot;dump_array_and_delete(pets) returned %d\n&quot;, ret)
    if (&quot;3&quot; in pets)
        printf(&quot;dump_array_and_delete() did NOT remove index \&quot;3\&quot;!\n&quot;)
    else
        printf(&quot;dump_array_and_delete() did remove index \&quot;3\&quot;!\n&quot;)
    print &quot;&quot;
}
</pre></div>

<p>这个代码使用 <code>split()</code> 函数创建了一个数组（查看 <a href="#String-Functions">字串操作函数</a>）然后调用 <code>dump_array_and_delete()</code>。这个函数用于查找数组，其第一个参数是数组名，而删除的元素的索引通过第二个参数来传递。<code>awk</code> 代码然后打印返回的值并检查元素是否真的被删除了。下面是 <code>dump_array_and_delete()</code> 函数的C 代码实现。为了表现上的原因做了一些修改。
</p>
<p>第一部分是声明变量，设置默认的返回值到 <code>result</code> 中，并检查函数的调用是通过正确的参数个来调用的：
</p>
<div class="example">
<pre class="example">static awk_value_t *
dump_array_and_delete(int nargs, awk_value_t *result)
{
    awk_value_t value, value2, value3;
    awk_flat_array_t *flat_array;
    size_t count;
    char *name;
    int i;

    assert(result != NULL);
    make_number(0.0, result);

    if (nargs != 2) {
        printf(&quot;dump_array_and_delete: nargs not right &quot;
               &quot;(%d should be 2)\n&quot;, nargs);
        goto out;
    }
</pre></div>

<p>函数然后一步步地执行，如下。首先返回数组的名字，其作为函数的第一个参数初传递。然后是数组本身。如果有一个操作失败，则打印错误信息并返回：
</p>
<div class="example">
<pre class="example">    /* get argument named array as flat array and print it */
    if (get_argument(0, AWK_STRING, &amp; value)) {
        name = value.str_value.str;
        if (sym_lookup(name, AWK_ARRAY, &amp; value2))
            printf(&quot;dump_array_and_delete: sym_lookup of %s passed\n&quot;,
                   name);
        else {
            printf(&quot;dump_array_and_delete: sym_lookup of %s failed\n&quot;,
                   name);
            goto out;
        }
    } else {
        printf(&quot;dump_array_and_delete: get_argument(0) failed\n&quot;);
        goto out;
    }
</pre></div>

<p>为了测试并确保 C 代码看代的元素个数与 <code>awk</code> 代码看到的元素个数是一样的，第二步是来获取数组元素的个数然后打印它：
</p>
<div class="example">
<pre class="example">    if (! get_element_count(value2.array_cookie, &amp; count)) {
        printf(&quot;dump_array_and_delete: get_element_count failed\n&quot;);
        goto out;
    }

    printf(&quot;dump_array_and_delete: incoming size is %lu\n&quot;,
           (unsigned long) count);
</pre></div>

<p>第三步是执行实际的数组扁平化，然后再次检查 <code>awk_flat_array_t</code> 中的数量是与刚才返回的数量是一样的：
</p>
<div class="example">
<pre class="example">    if (! flatten_array(value2.array_cookie, &amp; flat_array)) {
        printf(&quot;dump_array_and_delete: could not flatten array\n&quot;);
        goto out;
    }

    if (flat_array-&gt;count != count) {
        printf(&quot;dump_array_and_delete: flat_array-&gt;count (%lu)&quot;
               &quot; != count (%lu)\n&quot;,
                (unsigned long) flat_array-&gt;count,
                (unsigned long) count);
        goto out;
    }
</pre></div>

<p>第四步是返回要被删除的元素的索引，这个索引是通过第二个参数来传递的。要记住传递到 <code>get_argument()</code> 函数中的参数编号是从 0 开始的，因此第二个参数被编号为 1 ：
</p>
<div class="example">
<pre class="example">    if (! get_argument(1, AWK_STRING, &amp; value3)) {
        printf(&quot;dump_array_and_delete: get_argument(1) failed\n&quot;);
        goto out;
    }
</pre></div>

<p>第五步是执行“真正的”操作。函数循环数组中的每一个元素，打印其索引与其元素值。另外，当找到要删除元素的索引时，函数设置 <code>AWK_ELEMENT_DELETE</code> 位到元素的 <code>flags</code> 域中。当数组被释放时，<code>gawk</code> 会遍历扁平化后的数组，然后删除那些被设置了该位的元素：
</p>
<div class="example">
<pre class="example">    for (i = 0; i &lt; flat_array-&gt;count; i++) {
        printf(&quot;\t%s[\&quot;%.*s\&quot;] = %s\n&quot;,
            name,
            (int) flat_array-&gt;elements[i].index.str_value.len,
            flat_array-&gt;elements[i].index.str_value.str,
            valrep2str(&amp; flat_array-&gt;elements[i].value));

        if (strcmp(value3.str_value.str,
                   flat_array-&gt;elements[i].index.str_value.str) == 0) {
            flat_array-&gt;elements[i].flags |= AWK_ELEMENT_DELETE;
            printf(&quot;dump_array_and_delete: marking element \&quot;%s\&quot; &quot;
                   &quot;for deletion\n&quot;,
                flat_array-&gt;elements[i].index.str_value.str);
        }
    }
</pre></div>

<p>第六步是释放扁平化后的数组。这会告诉 <code>gawk</code> 扩展已经不再使用数组，它可以删除所有已经被标志的元素。<code>gawk</code> 也会释放被分配的存储，因此，在调用 <code>release_flattened_array()</code> 函数后，你不要再使用里面的指针（在这个代码中为 <code>flat_array</code>）：
</p>
<div class="example">
<pre class="example">    if (! release_flattened_array(value2.array_cookie, flat_array)) {
        printf(&quot;dump_array_and_delete: could not release flattened array\n&quot;);
        goto out;
    }
</pre></div>

<p>最后，由于一切事情都执行良好，函数将返回值设置为成功，然后返回：
</p>
<div class="example">
<pre class="example">    make_number(1.0, result);
out:
    return result;
}
</pre></div>

<p>这里是运行测试部分的输出：
</p>
<div class="example">
<pre class="example">pets has 5 elements
dump_array_and_delete: sym_lookup of pets passed
dump_array_and_delete: incoming size is 5
        pets[&quot;1&quot;] = &quot;blacky&quot;
        pets[&quot;2&quot;] = &quot;rusty&quot;
        pets[&quot;3&quot;] = &quot;sophie&quot;
dump_array_and_delete: marking element &quot;3&quot; for deletion
        pets[&quot;4&quot;] = &quot;raincloud&quot;
        pets[&quot;5&quot;] = &quot;lucky&quot;
dump_array_and_delete(pets) returned 1
dump_array_and_delete() did remove index &quot;3&quot;!
</pre></div>

<hr>
<a name="Creating-Arrays"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Flattening-Arrays" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Array-Manipulation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Variables" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00a6_0082a_00bd_0095c_0094_009fae_0088_0090a_00b8_008eaa_008f_0091aa_00b8_0083ae_0095_00b0c_00bb_0084"></a>
<h4 class="subsubsection">5.4.11.4 如何生成与发布数组</h4>

<p>除了通过 <code>awk</code> 代码来处理数组外，你也可以创建数组然后发布它们，然后 <code>awk</code> 代码也可以访问并处理它们。
</p>
<p>从扩展中创建数组有两个重点：
</p>
<ul>
<li>
你必须将新的数组创建后立即安装到 <code>gawk</code> 的符号表中。这么做了后，就可以发布你的数组。


<p>相似的，如果将某个数组安装成已经存在的数组的子数组，你必须在向它添加任何元素之前将其加到父数组中。
</p>
<p>因此，创建数组的正确方式是“自上而下”。创建一个数组，然后立即使用 <code>sym_update()</code> 将回添加到符号表中，或者使用 <code>set_array_element()</code> 将其添加为一个已经存在的数组的一个元素。我们后面会有例子说明。
</p>
</li><li>
由于 <code>gawk</code> 的内部实现，在使用了 <code>sym_update()</code> 安装了一个数组到 <code>gawk</code> 中后，在使用它做任何事情之前，你必须使用传给 <code>sym_update()</code> 接口中的值来获取一个数组的 cookie：

<div class="example">
<pre class="example">awk_value_t val;
awk_array_t new_array;

new_array = create_array();
val.val_type = AWK_ARRAY;
val.array_cookie = new_array;

/* install array in the symbol table */
sym_update(&quot;array&quot;, &amp; val);

new_array = val.array_cookie;    /* YOU MUST DO THIS */
</pre></div>

<p>如果安装的是一个子数组，你必须在调用 <code>set_element()</code> 之后使用数组的值返回一个数组 cookie。
</p></li></ul>

<p>下面的 C 代码是一个简单测试扩展，用两个常规的元素来创建一个数组，并带有一个子数组。开始的 <code>#include</code> 指示符以及样板式的变量声明（查看 see section <a href="#Extension-API-Boilerplate">样板代码</a>）为了简化而省略了。第一步是创建一个新的数组，然后将其安装到符号表中：
</p>
<div class="example">
<pre class="example">/* create_new_array --- create a named array */

static void
create_new_array()
{
    awk_array_t a_cookie;
    awk_array_t subarray;
    awk_value_t index, value;

    a_cookie = create_array();
    value.val_type = AWK_ARRAY;
    value.array_cookie = a_cookie;

    if (! sym_update(&quot;new_array&quot;, &amp; value))
        printf(&quot;create_new_array: sym_update(\&quot;new_array\&quot;) failed!\n&quot;);
    a_cookie = value.array_cookie;
</pre></div>

<p>注意 <code>a_cookies</code> 是如何使用 <code>value</code> 结构体中的 <code>array_cookie</code> 的域来进行重置的。
</p>
<p>第二步是安装一个常规的到 <code>new_array</code> 中：
</p>
<div class="example">
<pre class="example">    (void) make_const_string(&quot;hello&quot;, 5, &amp; index);
    (void) make_const_string(&quot;world&quot;, 5, &amp; value);
    if (! set_array_element(a_cookie, &amp; index, &amp; value)) {
        printf(&quot;fill_in_array: set_array_element failed\n&quot;);
        return;
    }

    (void) make_const_string(&quot;answer&quot;, 6, &amp; index);
    (void) make_number(42.0, &amp; value);
    if (! set_array_element(a_cookie, &amp; index, &amp; value)) {
        printf(&quot;fill_in_array: set_array_element failed\n&quot;);
        return;
    }
</pre></div>

<p>第三步是创建了一子数组，然后安装它：
</p>
<div class="example">
<pre class="example">    (void) make_const_string(&quot;subarray&quot;, 8, &amp; index);
    subarray = create_array();
    value.val_type = AWK_ARRAY;
    value.array_cookie = subarray;
    if (! set_array_element(a_cookie, &amp; index, &amp; value)) {
        printf(&quot;fill_in_array: set_array_element failed\n&quot;);
        return;
    }
    subarray = value.array_cookie;
</pre></div>

<p>最后一步是发布子数组以及它的元素：
</p>
<div class="example">
<pre class="example">    (void) make_const_string(&quot;foo&quot;, 3, &amp; index);
    (void) make_const_string(&quot;bar&quot;, 3, &amp; value);
    if (! set_array_element(subarray, &amp; index, &amp; value)) {
        printf(&quot;fill_in_array: set_array_element failed\n&quot;);
        return;
    }
}
</pre></div>

<p>这个一个装载扩展的脚本，然后 dump 数组：
</p>
<div class="example">
<pre class="example">@load &quot;subarray&quot;

function dumparray(name, array,     i)
{
    for (i in array)
        if (isarray(array[i]))
            dumparray(name &quot;[\&quot;&quot; i &quot;\&quot;]&quot;, array[i])
        else
            printf(&quot;%s[\&quot;%s\&quot;] = %s\n&quot;, name, i, array[i])
}

BEGIN {
    dumparray(&quot;new_array&quot;, new_array);
}
</pre></div>

<p>下面是运行脚本的结果：
</p>
<div class="example">
<pre class="example">$ <kbd>AWKLIBPATH=$PWD ./gawk -f subarray.awk</kbd>
-| new_array[&quot;subarray&quot;][&quot;foo&quot;] = bar
-| new_array[&quot;hello&quot;] = world
-| new_array[&quot;answer&quot;] = 42
</pre></div>

<p>（查看 <a href="#Finding-Extensions"><code>gawk</code> 如何找到扩展</a>，来获取更多的关于变量 <code>AWKLIBPATH</code> 的信息）。
</p>
<hr>
<a name="Extension-API-Variables"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Creating-Arrays" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Versioning" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="API-aa_008f_0098e_0087_008f"></a>
<h3 class="subsection">5.4.12 API 变量</h3>

<p>API 提供了两种类型的变量。第一种提供 API 版本信息（包括扩展是如何进行编译以及 <code>gawk</code> 如何进行编译的）。第二种是提供 <code>gawk</code> 如何被调用的信息。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Extension-Versioning">5.4.12.1 API Version Constants and Variables</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        API Version information.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-API-Informational-Variables">5.4.12.2 信息变量</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Variables providing information about
                                <code>gawk</code>&rsquo;s invocation.
</td></tr>
</table>

<hr>
<a name="Extension-Versioning"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Variables" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Informational-Variables" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="API-Version-Constants-and-Variables"></a>
<h4 class="subsubsection">5.4.12.1 API Version Constants and Variables</h4>
<a name="index-API-version"></a>
<a name="index-extension-API-version"></a>

<p>API 提供了“主”与“次”版本值。API 版本可以在编译时刻获得。它在 C 语言预处理中定义以支持条件编译，以及作为枚举型常量用于 debug：
</p>
<div class="float"><a name="gawk_002dapi_002dversion"></a>

<table>
<thead><tr><th width="33%">API 版本</th><th width="33%">C 语言预处理器中的定义</th><th width="33%">枚举型常量</th></tr></thead>
<tr><td width="33%">Major</td><td width="33%">gawk_api_major_version</td><td width="33%">GAWK_API_MAJOR_VERSION</td></tr>
<tr><td width="33%">Minor</td><td width="33%">gawk_api_minor_version</td><td width="33%">GAWK_API_MINOR_VERSION</td></tr>
</table>
</div><p><strong>Table 5.2: gawk API 版本号常量
</strong>
</p>
<p>次版本号会在向 API 添加新函数的时候进行递增。这些新函数总是添加在 API 结构体 <code>struct</code> 的尾部。
</p>
<p>如果数组类型改变了大小，或者成员顺序有变化，或者现有的函数改变了签名，会对主版本号递增（次版本号则重设为 0）。
</p>
<p>有可能扩展是以某个版本的 API 进行编译的，而被另一个版本的 <code>gawk</code> 版本进行装载。由于这个原因，执行 <code>gawk</code> API 的主次版本号会包含在 API 结构体 <code>struct</code> 中，并且是只读的：
</p>
<dl compact="compact">
<dt><code>api-&gt;major_version</code></dt>
<dd><p>执行 <code>gawk</code> 的主版本号。
</p>
</dd>
<dt><code>api-&gt;minor_version</code></dt>
<dd><p>执行 <code>gawk</code> 的次版本号。
</p></dd>
</dl>

<p>扩展可以决定 API 是否是兼容的。典型的情况下，像下面这样的检查就可以了：
</p>
<div class="example">
<pre class="example">if (api-&gt;major_version != GAWK_API_MAJOR_VERSION
    || api-&gt;minor_version &lt; GAWK_API_MINOR_VERSION) {
        fprintf(stderr, &quot;foo_extension: version mismatch with gawk!\n&quot;);
        fprintf(stderr, &quot;\tmy version (%d, %d), gawk version (%d, %d)\n&quot;,
                GAWK_API_MAJOR_VERSION, GAWK_API_MINOR_VERSION,
                api-&gt;major_version, api-&gt;minor_version);
        exit(1);
}
</pre></div>

<p>这样的代码被包含在模板 <code>dl_load_func()</code> 宏中，并由 &lsquo;<tt>gawkapi.h</tt>&rsquo; 文件中（在 <a href="#Extension-API-Boilerplate">样板代码</a> 中进行讨论）。
</p>
<hr>
<a name="Extension-API-Informational-Variables"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Versioning" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Variables" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Boilerplate" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bf_00a1ae_0081_00afaa_008f_0098e_0087_008f"></a>
<h4 class="subsubsection">5.4.12.2 信息变量</h4>
<a name="index-API-informational-variables"></a>
<a name="index-extension-API-informational-variables"></a>

<p>API 提供了多个变量的访问，这些变量描述了 <code>gawk</code> 被调用时，相应的命令行选项是否启用。这些变量是：
</p>
<dl compact="compact">
<dt><code>do_debug</code></dt>
<dd><p>这个变量当使用了 &lsquo;<samp>--debug</samp>&rsquo; 选项来调用 <code>gawk</code> 时会为 true。
</p>
</dd>
<dt><code>do_lint</code></dt>
<dd><p>这个变量当使用了 &lsquo;<samp>--lint</samp>&rsquo; 选项来调用 <code>gawk</code> 时会为 true。
</p>
</dd>
<dt><code>do_mpfr</code></dt>
<dd><p>这个变量当使用了 &lsquo;<samp>--bignum</samp>&rsquo; 选项来调用 <code>gawk</code> 时会为 true。
</p>
</dd>
<dt><code>do_profile</code></dt>
<dd><p>这个变量当使用了 &lsquo;<samp>--profile</samp>&rsquo; 选项来调用 <code>gawk</code> 时会为 true。
</p>
</dd>
<dt><code>do_sandbox</code></dt>
<dd><p>这个变量当使用了 &lsquo;<samp>--sandbox</samp>&rsquo; 选项来调用 <code>gawk</code> 时会为 true。
</p>
</dd>
<dt><code>do_traditional</code></dt>
<dd><p>这个变量当使用了 &lsquo;<samp>--traditional</samp>&rsquo; 选项来调用 <code>gawk</code> 时会为 true。
</p></dd>
</dl>

<p><code>do_lint</code> 的值如果 <code>awk</code> 代码修改了 <code>LINT</code> 预定义变量（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）可能会改变。其他的在执行过程中都不会改变。
</p>
<hr>
<a name="Extension-API-Boilerplate"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Informational-Variables" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Description" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Finding-Extensions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00a0_00b7ae_009d_00bfa_00bb_00a3c_00a0_0081"></a>
<h3 class="subsection">5.4.13 样板代码</h3>

<p>如之前所提（查看 see section <a href="#Extension-Mechanism-Outline">在高层级中是它是如何工作的</a>），函数定义的呈现实际上是一个宏。为了使用这些宏，你的扩展必须使用下面的预定义的名字，提供少量的样板代码（变量以及函数）放在你的源代码的头部。所需要的样板代码也提供在 &lsquo;<tt>gawkapi.h</tt>&rsquo; 头文件的注释中：
</p>
<div class="example">
<pre class="example">/* Boilerplate code: */
int plugin_is_GPL_compatible;

static gawk_api_t *const api;
static awk_ext_id_t ext_id;
static const char *ext_version = NULL; /* or &hellip; = &quot;some string&quot; */

static awk_ext_func_t func_table[] = {
    { &quot;name&quot;, do_name, 1 },
    /* &hellip; */
};

/* EITHER: */

static awk_bool_t (*init_func)(void) = NULL;

/* OR: */

static awk_bool_t
init_my_extension(void)
{
    &hellip;
}

static awk_bool_t (*init_func)(void) = init_my_extension;

dl_load_func(func_table, some_name, &quot;name_space_in_quotes&quot;)
</pre></div>

<p>这些变量与函数如下：
</p>
<dl compact="compact">
<dt><code>int plugin_is_GPL_compatible;</code></dt>
<dd><p>这个用来声明扩展是与 GNU GPL 兼容的
This asserts that the extension is compatible with
（查看 see section <a href="#Copying">GNU General Public License</a>）。
如果你的扩展没有这个变量，<code>gawk</code> 不会装载它（查看 see section <a href="#Plugin-License">扩展许可</a>）。
</p>
</dd>
<dt><code>static gawk_api_t *const api;</code></dt>
<dd><p>这个全局的 <code>static</code> 变量应该被设定指向 <code>gawk_api_t</code> 指针，<code>gawk</code> 会在 <code>dl_load()</code> 函数中传递过来。这个变量被所有的宏使用。
</p>
</dd>
<dt><code>static awk_ext_id_t ext_id;</code></dt>
<dd><p>这个全局静态变量应该设置为 <code>awk_ext_id_t</code> 的值，这个值会通过你自己的 <code>dl_load()</code> 函数传递绘画你。这个变量被所有的宏使用。
</p>
</dd>
<dt><code>static const char *ext_version = NULL; /* or &hellip; = &quot;some string&quot; */</code></dt>
<dd><p>这个全局 <code>static</code> 变量要么被设置为 <code>NULL</code>，或者是一个字串的指针，这个字串绘画了了扩展的名字与版本。
</p>
</dd>
<dt><code>static awk_ext_func_t func_table[] = { &hellip; };</code></dt>
<dd><p>这个一个或者多个 <code>awk_ext_func_t</code> 结构的数组，如之所描述的（查看 see section <a href="#Extension-Functions">注册扩展函数</a>）。它之后可以通过循环来多次调用 <code>add_ext_func()</code>。
</p>
</dd>
<dt><code>static awk_bool_t (*init_func)(void) = NULL;</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>OR</var></code></dt>
<dt><code>static awk_bool_t init_my_extension(void) { &hellip; }</code></dt>
<dt><code>static awk_bool_t (*init_func)(void) = init_my_extension;</code></dt>
<dd><p>如果你需要做一些初始化的工作，你应该定义这样的函数（创建变量，打开文件等）然后定义 <code>init_func</code> 指针指向你的函数。函数应该在失败时返回 <code>awk_false</code> ，或者成功时返回 <code>awk_true</code>。
</p>
<p>如果你不需要初始化，定义这个指针，并将其设置为 <code>NULL</code>。
</p>
</dd>
<dt><code>dl_load_func(func_table, some_name, &quot;name_space_in_quotes&quot;)</code></dt>
<dd><p>这个宏会扩展为 <code>dl_load()</code> 函数，该函数执行所有必要的初始化。
</p></dd>
</dl>

<p>所有变量与数组的目的是使 <code>dl_load()</code> 函数（来自于 <code>dl_load_func()</code> 宏中）处理所有的标准工作。它执行下面的工作：
</p>
<ol>
<li>
检查 API 版本。如果扩展的主版本与 <code>gawk</code> 的主版本不匹配，或者扩展的次版本大于 <code>gawk</code> 的次版本号，它会打印错误信息后退出。

</li><li>
装入定义在 <code>func_table</code> 中的函数。如果它们中的任何一个失败，它会打印警告信息，但是继续执行。

</li><li>
如果 <code>init_func</code> 指针不为 <code>NULL</code>，则调用它指向的函数。如果它返回 <code>awk_false</code>，打印一个警告信息。

</li><li>
如果 <code>ext_version</code> 不为 <code>NULL</code>，注册版本字串到 <code>gawk</code> 中。
</li></ol>

<hr>
<a name="Finding-Extensions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-API-Boilerplate" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Example" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-aa_00a6_0082a_00bd_0095ae_0089_00beaa_0088_00b0ae_0089_00a9aa_00b1_0095"></a>
<h2 class="section">5.5 <code>gawk</code> 如何找到扩展</h2>
<a name="index-extension-search-path"></a>
<a name="index-finding-extensions"></a>

<p>编译好的扩展必须安装在 <code>gawk</code> 可以找到它们的路径下。如果 <code>gawk</code> 被配置并以默认的方式进行构建，来搜索扩展的目录为 &lsquo;<tt>/usr/local/lib/gawk</tt>&rsquo;。
你也可以指定一个目录列表来搜索编译好的扩展。查看 <a href="#AWKLIBPATH-Variable">环境变量 <code>AWKLIBPATH</code></a>，来获取其他信息。
</p>
<hr>
<a name="Extension-Example"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Finding-Extensions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Internal-File-Description" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00be_008baa_00ad_0090i_00bc_009aa_00b8_0080a_00ba_009bae_0096_0087a_00bb_00b6aa_0087_00bdae_0095_00b0"></a>
<h2 class="section">5.6 例子：一些文件函数</h2>
<a name="index-extension-example"></a>

<blockquote>
<p><i>
你可以到达任何你想去的地方。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Buckaroo Banzai</em>
</p>

<p>有两个非常有用的函数不在 <code>awk</code> 中，他们是 <code>chdir()</code>（这样 <code>awk</code> 程序可以改变它的目录）与 <code>stat()</code>（这样 <code>awk</code> 程序可以收集文件的信息）。为了用实际的例子说明 API，这一小节会将其实现为 <code>gawk</code> 的扩展。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Internal-File-Description">5.6.1 使用 <code>chdir()</code> 与 <code>stat()</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   What the new functions will do.
</td></tr>
<tr><td align="left" valign="top"><a href="#Internal-File-Ops">5.6.2 <code>chdir()</code> 与 <code>stat()</code> 的C 代码</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           The code for internal file operations.
</td></tr>
<tr><td align="left" valign="top"><a href="#Using-Internal-File-Ops">5.6.3 整合扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     How to use an external extension.
</td></tr>
</table>

<hr>
<a name="Internal-File-Description"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Example" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Example" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Internal-File-Ops" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00bd_00bfc_0094_00a8-chdir_0028_0029-a_00b8_008e-stat_0028_0029"></a>
<h3 class="subsection">5.6.1 使用 <code>chdir()</code> 与 <code>stat()</code></h3>

<p>这一小节展示如何来在 <code>awk</code> 层上如何来使用新函数，只要他们已经整合到了 <code>gawk</code> 中的解释器中。使用 <code>chdir()</code> 非常直接。它只有一个参数，即要更改的新目录：
</p>
<div class="example">
<pre class="example">@load &quot;filefuncs&quot;
&hellip;
newdir = &quot;/home/arnold/funstuff&quot;
ret = chdir(newdir)
if (ret &lt; 0) {
    printf(&quot;could not change to %s: %s\n&quot;, newdir, ERRNO) &gt; &quot;/dev/stderr&quot;
    exit 1
}
&hellip;
</pre></div>

<p>如果 <code>chdir()</code> 失败了会返回一个负值，<code>ERRNO</code>（查看 see section <a href="#Built_002din-Variables">预定义变量</a>） 的值会被设置为指示错误的字串。
</p>
<p>使用 <code>stat()</code> 就有一点复杂。C 的 <code>stat()</code> 函数会填充一个有大量信息的结构。在 <code>awk</code> 中对其进行建模的正确方法是使用关联数组来表示对应的信息：
</p>
<div class="example">
<pre class="example">file = &quot;/home/arnold/.profile&quot;
ret = stat(file, fdata)
if (ret &lt; 0) {
    printf(&quot;could not stat %s: %s\n&quot;,
             file, ERRNO) &gt; &quot;/dev/stderr&quot;
    exit 1
}
printf(&quot;size of %s is %d bytes\n&quot;, file, fdata[&quot;size&quot;])
</pre></div>

<p><code>stat()</code> 函数总会清除数据数组，就算 <code>stat()</code> 失败情况下也如此。它会以填充下面的元素：
</p>
<dl compact="compact">
<dt><code>&quot;name&quot;</code></dt>
<dd><p>要进行 <code>stat()</code> 操作的文件的名字。
</p>
</dd>
<dt><code>&quot;dev&quot;</code></dt>
<dt><code>&quot;ino&quot;</code></dt>
<dd><p>文件的设备与 inode 号。
</p>
</dd>
<dt><code>&quot;mode&quot;</code></dt>
<dd><p>文件的访问权限，为数值。这包含文件的类型以及权限。
</p>
</dd>
<dt><code>&quot;nlink&quot;</code></dt>
<dd><p>硬连接的个数。
</p>
</dd>
<dt><code>&quot;uid&quot;</code></dt>
<dt><code>&quot;gid&quot;</code></dt>
<dd><p>文件所有者的用户 ID 与组 ID。
</p>
</dd>
<dt><code>&quot;size&quot;</code></dt>
<dd><p>文件的字节大小。
</p>
</dd>
<dt><code>&quot;blocks&quot;</code></dt>
<dd><p>文件实际占有块的个数。如果文件有洞，则这个数组不会是其大小的函数。
</p>
</dd>
<dt><code>&quot;atime&quot;</code></dt>
<dt><code>&quot;mtime&quot;</code></dt>
<dt><code>&quot;ctime&quot;</code></dt>
<dd><p>文件的最后访问，修改及 inode 更新时间。它们都是数值的时间戳，适合用于 <code>strftime()</code>（查看 <a href="#Time-Functions">时间函数</a>）。
</p>
</dd>
<dt><code>&quot;pmode&quot;</code></dt>
<dd><p>文件的“printable mode&quot;。这个是一个文件类型与权限的字串表示，如 &lsquo;<samp>ls -l</samp>&rsquo; 输出。如，<code>&quot;drwxr-xr-x&quot;</code>。
</p>
</dd>
<dt><code>&quot;type&quot;</code></dt>
<dd><p>文件类型的可打印字串，值可能是下面之一：
</p>
<dl compact="compact">
<dt><code>&quot;blockdev&quot;</code></dt>
<dt><code>&quot;chardev&quot;</code></dt>
<dd><p>文件是一个块或者字符设备（“特殊文件”）。
</p>

</dd>
<dt><code>&quot;directory&quot;</code></dt>
<dd><p>文件是目录。
</p>
</dd>
<dt><code>&quot;fifo&quot;</code></dt>
<dd><p>文件是一个命名管道（也称为 FIFO）。
</p>
</dd>
<dt><code>&quot;file&quot;</code></dt>
<dd><p>文件是一个常规文件。
</p>
</dd>
<dt><code>&quot;socket&quot;</code></dt>
<dd><p>文件是文件系统中的一个 <code>AF_UNIX</code>（“Unix domain”）socket。
</p>
</dd>
<dt><code>&quot;symlink&quot;</code></dt>
<dd><p>文件是一个符号连接。
</p></dd>
</dl>

</dd>
<dt><code>&quot;devbsize&quot;</code></dt>
<dd><p>文件的通过 <code>&quot;blocks&quot;</code> 进行索引的基本块大小。大多数系统中，这个信息是从 <code>&lt;sys/param.h&gt;</code> 文件中的 <code>DEV_BSIZE</code> 或者是 BSD 系统中 <code>&lt;sys/stat.h&gt;</code> 文件中的 <code>S_BLKSIZE</code> 继承下来的。对于其他的系统，<em>预先</em>的知识为其提供值。当没法确定值的时候，默认为 512。
</p></dd>
</dl>

<p>还可能有几个额外的元素，其依赖于操作系统以及文件的类型。你可以在 <code>awk</code> 程序中使用 <code>in</code> 操作符来对它们进行测试（查看 <a href="#Reference-to-Elements">指向数组元素</a>）：
</p>
<dl compact="compact">
<dt><code>&quot;blksize&quot;</code></dt>
<dd><p>用于文件 I/O 优先块大小。这个域在所有类 POSIX系统中的 C <code>stat</code> 结构中不存在。
</p>
</dd>
<dt><code>&quot;linkval&quot;</code></dt>
<dd><p>如果文件是一个连接，这个元素就是连接文件所指向的文件名（即连接的值）。
</p>
</dd>
<dt><code>&quot;rdev&quot;</code></dt>
<dt><code>&quot;major&quot;</code></dt>
<dt><code>&quot;minor&quot;</code></dt>
<dd><p>如果文件是一个块设备或者是一个字符设备文件，则这个值代表了设备号的数值，以及设备号中的主次设备号。
</p></dd>
</dl>

<hr>
<a name="Internal-File-Ops"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internal-File-Description" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Example" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Using-Internal-File-Ops" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="chdir_0028_0029-a_00b8_008e-stat_0028_0029-c_009a_0084C-a_00bb_00a3c_00a0_0081"></a>
<h3 class="subsection">5.6.2 <code>chdir()</code> 与 <code>stat()</code> 的C 代码</h3>

<p>下面是这些扩展的 C 代码。 
<a name="DOCF110" href="#FOOT110">(110)</a>
</p>
<p>这个文件中包含很多的标准头文件，然后再包含 &lsquo;<tt>gawkapi.h</tt>&rsquo; 头文件，这个文件文件中包了 API 的定义。后再是跟着一些必要变量声明，以使用 API 中的宏与模板代码（查看 see section <a href="#Extension-API-Boilerplate">样板代码</a>）：
</p>
<div class="example">
<pre class="example">#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#include &quot;gawkapi.h&quot;

#include &quot;gettext.h&quot;
#define _(msgid)  gettext(msgid)
#define N_(msgid) msgid

#include &quot;gawkfts.h&quot;
#include &quot;stack.h&quot;

static const gawk_api_t *api;    /* for convenience macros to work */
static awk_ext_id_t *ext_id;
static awk_bool_t init_filefuncs(void);
static awk_bool_t (*init_func)(void) = init_filefuncs;
static const char *ext_version = &quot;filefuncs extension: version 1.0&quot;;

int plugin_is_GPL_compatible;
</pre></div>

<a name="index-programming-conventions_002c-gawk-extensions"></a>
<p>习惯上，对于 <code>awk</code> 函数 <code>foo()</code>，实现它的函数称为 <code>do_foo()</code>。这些函数应该有两个参数。第一个是 <code>int</code>，通常称为 <code>nargs</code>，表示的是函数中实际参数的个数。第二个是 <code>awk_value_t</code> 结构的指针，一般命名为 <code>result</code>：
</p>
<div class="example">
<pre class="example">/*  do_chdir --- provide dynamically loaded chdir() function for gawk */

static awk_value_t *
do_chdir(int nargs, awk_value_t *result)
{
    awk_value_t newdir;
    int ret = -1;

    assert(result != NULL);

    if (do_lint &amp;&amp; nargs != 1)
        lintwarn(ext_id,
                 _(&quot;chdir: called with incorrect number of arguments, &quot;
                   &quot;expecting 1&quot;));
</pre></div>

<p><code>newdir</code> 变量表示要改变的新目录，这个是通过 <code>get_argument()</code> 来获取的。注意第一个参数的编号为 0。
</p>
<p>如果参数被成功返回，则函数调用 <code>chdir()</code> 系统调用。如果 <code>chdir()</code> 失败，则 <code>ERRNO</code> 的值会被更改：
</p>
<div class="example">
<pre class="example">    if (get_argument(0, AWK_STRING, &amp; newdir)) {
        ret = chdir(newdir.str_value.str);
        if (ret &lt; 0)
            update_ERRNO_int(errno);
    }
</pre></div>

<p>最后，函数返回要返回的值到 <code>awk</code> 层：
</p>
<div class="example">
<pre class="example">    return make_number(ret, result);
}
</pre></div>

<p><code>stat()</code> 扩展涉及的东西更多一些。首先是一个将数值模式转换为可打印表示的函数（比如 <code>0644</code> 转换为 &lsquo;<samp>-rw-r--r--</samp>&rsquo;）。简单起见，这里省略了：
</p>
<div class="example">
<pre class="example">/* format_mode --- turn a stat mode field into something readable */

static char *
format_mode(unsigned long fmode)
{
    &hellip;
}
</pre></div>

<p>下一个函数用来读取软链接，也为了简化，在这里省略了：
</p>
<div class="example">
<pre class="example">/* read_symlink --- read a symbolic link into an allocated buffer.
   &hellip; */

static char *
read_symlink(const char *fname, size_t bufsize, ssize_t *linksize)
{
    &hellip;
}
</pre></div>

<p>有两个辅助函数会简化将值输入到数组的过程，这个数组将包含 <code>stat()</code> 的结果：
</p>
<div class="example">
<pre class="example">/* array_set --- set an array element */

static void
array_set(awk_array_t array, const char *sub, awk_value_t *value)
{
    awk_value_t index;

    set_array_element(array,
                      make_const_string(sub, strlen(sub), &amp; index),
                      value);

}

/* array_set_numeric --- set an array element with a number */

static void
array_set_numeric(awk_array_t array, const char *sub, double num)
{
    awk_value_t tmp;

    array_set(array, sub, make_number(num, &amp; tmp));
}
</pre></div>

<p>下面的函数处理大部份的工作，即将从一个有效的 <code>struct stat</code> 中取值，然后将这些值填充到 <code>awk_array_t</code> 类型的结果数组中。这个工作由一个单独的函数来完成，为 <code>gawk</code> 提供 <code>stat()</code> 函数支持，也支持 <code>fts()</code> 扩展。 这个扩展也包含在同一个文件中，但是它的代码没有在这时显示（查看 see section <a href="#Extension-Sample-File-Functions">与文件相关的函数</a>）。
</p>
<p>这个函数的第一部分是变量声明，包含将文件类型影射到字串的表：
</p>
<div class="example">
<pre class="example">/* fill_stat_array --- do the work to fill an array with stat info */

static int
fill_stat_array(const char *name, awk_array_t array, struct stat *sbuf)
{
    char *pmode;    /* printable mode */
    const char *type = &quot;unknown&quot;;
    awk_value_t tmp;
    static struct ftype_map {
        unsigned int mask;
        const char *type;
    } ftype_map[] = {
        { S_IFREG, &quot;file&quot; },
        { S_IFBLK, &quot;blockdev&quot; },
        { S_IFCHR, &quot;chardev&quot; },
        { S_IFDIR, &quot;directory&quot; },
#ifdef S_IFSOCK
        { S_IFSOCK, &quot;socket&quot; },
#endif
#ifdef S_IFIFO
        { S_IFIFO, &quot;fifo&quot; },
#endif
#ifdef S_IFLNK
        { S_IFLNK, &quot;symlink&quot; },
#endif
#ifdef S_IFDOOR /* Solaris weirdness */
        { S_IFDOOR, &quot;door&quot; },
#endif /* S_IFDOOR */
    };
    int j, k;
</pre></div>

<p>然后目标数组也被声明了，后面的代码根据 <code>struct stat</code> 中的值来填充不同的元素：
</p>
<div class="example">
<pre class="example">    /* empty out the array */
    clear_array(array);

    /* fill in the array */
    array_set(array, &quot;name&quot;, make_const_string(name, strlen(name),
                                               &amp; tmp));
    array_set_numeric(array, &quot;dev&quot;, sbuf-&gt;st_dev);
    array_set_numeric(array, &quot;ino&quot;, sbuf-&gt;st_ino);
    array_set_numeric(array, &quot;mode&quot;, sbuf-&gt;st_mode);
    array_set_numeric(array, &quot;nlink&quot;, sbuf-&gt;st_nlink);
    array_set_numeric(array, &quot;uid&quot;, sbuf-&gt;st_uid);
    array_set_numeric(array, &quot;gid&quot;, sbuf-&gt;st_gid);
    array_set_numeric(array, &quot;size&quot;, sbuf-&gt;st_size);
    array_set_numeric(array, &quot;blocks&quot;, sbuf-&gt;st_blocks);
    array_set_numeric(array, &quot;atime&quot;, sbuf-&gt;st_atime);
    array_set_numeric(array, &quot;mtime&quot;, sbuf-&gt;st_mtime);
    array_set_numeric(array, &quot;ctime&quot;, sbuf-&gt;st_ctime);

    /* for block and character devices, add rdev,
       major and minor numbers */
    if (S_ISBLK(sbuf-&gt;st_mode) || S_ISCHR(sbuf-&gt;st_mode)) {
        array_set_numeric(array, &quot;rdev&quot;, sbuf-&gt;st_rdev);
        array_set_numeric(array, &quot;major&quot;, major(sbuf-&gt;st_rdev));
        array_set_numeric(array, &quot;minor&quot;, minor(sbuf-&gt;st_rdev));
    }
</pre></div>

<p>函数的后面的部分用于向目标数组中选择性地添加一些元素，这个要依赖于文件的特定成员以及/或者文件类型。如果成功，则返回 0 ：
</p>
<div class="example">
<pre class="example">#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
    array_set_numeric(array, &quot;blksize&quot;, sbuf-&gt;st_blksize);
#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */

    pmode = format_mode(sbuf-&gt;st_mode);
    array_set(array, &quot;pmode&quot;, make_const_string(pmode, strlen(pmode),
                                                &amp; tmp));

    /* for symbolic links, add a linkval field */
    if (S_ISLNK(sbuf-&gt;st_mode)) {
        char *buf;
        ssize_t linksize;

        if ((buf = read_symlink(name, sbuf-&gt;st_size,
                    &amp; linksize)) != NULL)
            array_set(array, &quot;linkval&quot;,
                      make_malloced_string(buf, linksize, &amp; tmp));
        else
            warning(ext_id, _(&quot;stat: unable to read symbolic link `%s'&quot;),
                    name);
    }

    /* add a type field */
    type = &quot;unknown&quot;;   /* shouldn't happen */
    for (j = 0, k = sizeof(ftype_map)/sizeof(ftype_map[0]); j &lt; k; j++) {
        if ((sbuf-&gt;st_mode &amp; S_IFMT) == ftype_map[j].mask) {
            type = ftype_map[j].type;
            break;
        }
    }

    array_set(array, &quot;type&quot;, make_const_string(type, strlen(type), &amp; tmp));

    return 0;
}
</pre></div>

<p><code>stat()</code> 函数的第三个参数之前没有讨论到。这个参数是可选的。如果存在，则会导致 <code>do_stat()</code> 使用 <code>stat()</code> 调用而不是 <code>lstat()</code> 系统调用。这是通过这个函数指针来完成的：<code>statfunc</code>。<code>statfunc</code> 会被初始化为 <code>lstat()</code>（而不是 <code>stat()</code>），以此来获取文件信息，以防止文件是一个软链接。
但是，如果包含了第三个参数，<code>statfunc</code> 为设置为 <code>stat()</code> 函数的指针。
</p>
<p>下面是 <code>do_stat()</code> 函数，它的开始也是一些变量声明以及参数检查：
</p>
<div class="example">
<pre class="example">/* do_stat --- provide a stat() function for gawk */

static awk_value_t *
do_stat(int nargs, awk_value_t *result)
{
    awk_value_t file_param, array_param;
    char *name;
    awk_array_t array;
    int ret;
    struct stat sbuf;
    /* default is lstat() */
    int (*statfunc)(const char *path, struct stat *sbuf) = lstat;

    assert(result != NULL);

    if (nargs != 2 &amp;&amp; nargs != 3) {
        if (do_lint)
            lintwarn(ext_id,
               _(&quot;stat: called with wrong number of arguments&quot;));
        return make_number(-1, result);
    }
</pre></div>

<p>后面接着的是实际的工作。函数先取得参数，接下来，它会取得文件的信息。如果调用的函数（<code>lstat()</code> 或者 <code>stat()</code>）返回一个错误，则代码设置 <code>ERRNO</code> 的值然后返回：
</p>
<div class="example">
<pre class="example">    /* file is first arg, array to hold results is second */
    if (   ! get_argument(0, AWK_STRING, &amp; file_param)
        || ! get_argument(1, AWK_ARRAY, &amp; array_param)) {
        warning(ext_id, _(&quot;stat: bad parameters&quot;));
        return make_number(-1, result);
    }

    if (nargs == 3) {
        statfunc = stat;
    }

    name = file_param.str_value.str;
    array = array_param.array_cookie;

    /* always empty out the array */
    clear_array(array);

    /* stat the file; if error, set ERRNO and return */
    ret = statfunc(name, &amp; sbuf);
    if (ret &lt; 0) {
        update_ERRNO_int(errno);
        return make_number(ret, result);
    }
</pre></div>

<p>其他的冗长的工作由 <code>fill_stat_array()</code> 来完成，这个已经在前面出现过。当完成时，函数返回从 <code>fill_stat_array()</code> 函数中返回的值：
</p>
<div class="example">
<pre class="example">    ret = fill_stat_array(name, array, &amp; sbuf);

    return make_number(ret, result);
}
</pre></div>

<p>最后，有必须提供一些“胶水”来将新的函数装入 <code>gawk</code>。
</p>
<p><code>filefuncs</code> 扩展也提供了一个 <code>fts()</code> 函数，这个函数在这里进行了省略（查看 see section <a href="#Extension-Sample-File-Functions">与文件相关的函数</a>）。由于这个原因，有一个初始化函数：
</p>
<div class="example">
<pre class="example">/* init_filefuncs --- initialization routine */

static awk_bool_t
init_filefuncs(void)
{
    &hellip;
}
</pre></div>

<p>到目前为止，就差不多完成了。我们需要一个 <code>awk_ext_func_t</code> 结构的数组用来装载每个一个函数到 <code>gawk</code> 中：
</p>
<div class="example">
<pre class="example">static awk_ext_func_t func_table[] = {
    { &quot;chdir&quot;, do_chdir, 1 },
    { &quot;stat&quot;,  do_stat, 2 },
#ifndef __MINGW32__
    { &quot;fts&quot;,   do_fts, 3 },
#endif
};
</pre></div>

<p>每个指针都必须有一个例程名为 <code>dl_load()</code> 来载入所有要被载入的东西。最简单的方法是使用 &lsquo;<tt>gawkapi.h</tt>&rsquo; 中的 <code>dl_load_func()</code> 宏：
</p>
<div class="example">
<pre class="example">/* define the dl_load() function using the boilerplate macro */

dl_load_func(func_table, filefuncs, &quot;&quot;)
</pre></div>

<p>以上即是所有代码！ 
</p>
<hr>
<a name="Using-Internal-File-Ops"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Internal-File-Ops" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Example" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0095_00b4aa_0090_0088ae_0089_00a9aa_00b1_0095"></a>
<h3 class="subsection">5.6.3 整合扩展</h3>

<a name="index-gawk_002c-interpreter_002c-adding-code-to"></a>
<p>现在代码已经写在，但是需要能够在 <code>gawk</code> 解释器运行的时候，将其载入。首先，代码是需要编译的。假充函数在一个名为 &lsquo;<tt>filefuncs.c</tt>&rsquo; 的文件中，而 <var>idir</var> 是 &lsquo;<tt>gawkapi.h</tt>&rsquo; 头文件所在的位置。下面的步骤 用来创建一个 GNU/Linux 共享库：
<a name="DOCF111" href="#FOOT111">(111)</a>
</p>
<div class="example">
<pre class="example">$ <kbd>gcc -fPIC -shared -DHAVE_CONFIG_H -c -O -g -I<var>idir</var> filefuncs.c</kbd>
$ <kbd>gcc -o filefuncs.so -shared filefuncs.o</kbd>
</pre></div>

<p>库一旦生成，就可以通过 <code>@load</code> 关键字来进行载入：
</p>
<div class="example">
<pre class="example"># file testff.awk
@load &quot;filefuncs&quot;

BEGIN {
    &quot;pwd&quot; | getline curdir  # save current directory
    close(&quot;pwd&quot;)

    chdir(&quot;/tmp&quot;)
    system(&quot;pwd&quot;)   # test it
    chdir(curdir)   # go back

    print &quot;Info for testff.awk&quot;
    ret = stat(&quot;testff.awk&quot;, data)
    print &quot;ret =&quot;, ret
    for (i in data)
        printf &quot;data[\&quot;%s\&quot;] = %s\n&quot;, i, data[i]
    print &quot;testff.awk modified:&quot;,
        strftime(&quot;%m %d %Y %H:%M:%S&quot;, data[&quot;mtime&quot;])

    print &quot;\nInfo for JUNK&quot;
    ret = stat(&quot;JUNK&quot;, data)
    print &quot;ret =&quot;, ret
    for (i in data)
        printf &quot;data[\&quot;%s\&quot;] = %s\n&quot;, i, data[i]
    print &quot;JUNK modified:&quot;, strftime(&quot;%m %d %Y %H:%M:%S&quot;, data[&quot;mtime&quot;])
}
</pre></div>

<p><code>AWKLIBPATH</code> 环境变量用来告知 <code>gawk</code> 到哪里去查看扩展（查看 see section <a href="#Finding-Extensions"><code>gawk</code> 如何找到扩展</a>）。我们将其设置为当前目录并执行程序：
</p>
<div class="example">
<pre class="example">$ <kbd>AWKLIBPATH=$PWD gawk -f testff.awk</kbd>
-| /tmp
-| Info for testff.awk
-| ret = 0
-| data[&quot;blksize&quot;] = 4096
-| data[&quot;devbsize&quot;] = 512
-| data[&quot;mtime&quot;] = 1412004710
-| data[&quot;mode&quot;] = 33204
-| data[&quot;type&quot;] = file
-| data[&quot;dev&quot;] = 2053
-| data[&quot;gid&quot;] = 1000
-| data[&quot;ino&quot;] = 10358899
-| data[&quot;ctime&quot;] = 1412004710
-| data[&quot;blocks&quot;] = 8
-| data[&quot;nlink&quot;] = 1
-| data[&quot;name&quot;] = testff.awk
-| data[&quot;atime&quot;] = 1412004716
-| data[&quot;pmode&quot;] = -rw-rw-r--
-| data[&quot;size&quot;] = 666
-| data[&quot;uid&quot;] = 1000
-| testff.awk modified: 09 29 2014 18:31:50
-|
-| Info for JUNK
-| ret = -1
-| JUNK modified: 01 01 1970 02:00:00
</pre></div>

<hr>
<a name="Extension-Samples"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Using-Internal-File-Ops" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-File-Functions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-aa_008f_0091e_00a1_008cc_0089_0088ae_009c_00aca_00b8_00adc_009a_0084a_00be_008baa_00ad_0090ae_0089_00a9aa_00b1_0095"></a>
<h2 class="section">5.7 <code>gawk</code> 发行版本中的例子扩展</h2>
<a name="index-extensions-distributed-with-gawk"></a>

<p>这一小节提供了一个简单的例子扩展的概况，例子与 <code>gawk</code> 版本一起发布。它们中的一些就是用于生产目的的（如 <code>filefuncs</code>，<code>readdir</code>，以及 <code>inplace</code> 扩展）。其他的主要是一些例子代码，以示范如何来使用扩展 API。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Extension-Sample-File-Functions">5.7.1 与文件相关的函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   The file functions sample.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Fnmatch">5.7.2 针对 <code>fnmatch()</code>　的接口</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          An interface to <code>fnmatch()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Fork">5.7.3 针对 <code>fork()</code>，<code>wait()</code>，与 <code>waitpid()</code> 的接口</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             An interface to <code>fork()</code> and other
                                      process functions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Inplace">5.7.4 启用文件就地编辑</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Enabling in-place file editing.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Ord">5.7.5 字符与数值：<code>ord()</code> 与 <code>chr()</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Character to value to character
                                      conversions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Readdir">5.7.6 读取目录</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          An interface to <code>readdir()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Revout">5.7.7 倒转输出</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Reversing output sample output wrapper.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Rev2way">5.7.8 双路 I/O 例子</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Reversing data sample two-way processor.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Read-write-array">5.7.9 输出与恢复数组</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Serializing an array to a file.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Readfile">5.7.10 读取整个文件</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         Reading an entire file into a string.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-Time">5.7.11 扩展的时间函数</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             An interface to <code>gettimeofday()</code>
                                      and <code>sleep()</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Sample-API-Tests">5.7.12 <code>API</code> 测试</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Tests for the API.
</td></tr>
</table>

<hr>
<a name="Extension-Sample-File-Functions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Fnmatch" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_008eae_0096_0087a_00bb_00b6c_009b_00b8aa_0085_00b3c_009a_0084aa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">5.7.1 与文件相关的函数</h3>

<p><code>filefuncs</code> 扩展提供了不同的函数，其使用方法如下：
</p>
<dl compact="compact">
<dt><code>@load &quot;filefuncs&quot;</code></dt>
<dd><p>如何来装载扩展。
</p>
<a name="index-chdir_0028_0029-extension-function"></a>
</dd>
<dt><code>result = chdir(&quot;/some/directory&quot;)</code></dt>
<dd><p><code>chdir()</code> 函数直接是 <code>chdir()</code> 系统调用的钩子函数，用来更改当前目录。如果成功则返回 0，如果错误则返回负值。在后面的情况还会更新 <code>ERRNO</code> 的值。
</p>
<a name="index-stat_0028_0029-extension-function"></a>
</dd>
<dt><code>result = stat(&quot;/some/path&quot;, statdata</code> [<code>, follow</code>]<code>)</code></dt>
<dd><p><code>stat()</code> 函数提供了 <code>stat()</code> 系统调用的钩子。如果成功，则返回 0，如果失败则返回负值。后后还会更新 <code>ERRNO</code>。
</p>
<p>默认的情况下，它使用的是 <code>lstat()</code> 的系统调用。但是，如果传递了第三个参数，则会使用 <code>stat()</code>。
</p>
<p>所有的情况下，它都会清除 <code>statdata</code> 数组。当调用成功时，<code>stat()</code> 会在 <code>statdata</code> 数组中填充从文件系统中返回的值。如下：
</p>
<table>
<thead><tr><th width="15%">下标</th><th width="50%">Stat 中的域 <code>struct stat</code></th><th width="20%">文件类型</th></tr></thead>
<tr><td width="15%"><code>&quot;name&quot;</code></td><td width="50%">The 文件名</td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;dev&quot;</code></td><td width="50%"><code>st_dev</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;ino&quot;</code></td><td width="50%"><code>st_ino</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;mode&quot;</code></td><td width="50%"><code>st_mode</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;nlink&quot;</code></td><td width="50%"><code>st_nlink</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;uid&quot;</code></td><td width="50%"><code>st_uid</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;gid&quot;</code></td><td width="50%"><code>st_gid</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;size&quot;</code></td><td width="50%"><code>st_size</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;atime&quot;</code></td><td width="50%"><code>st_atime</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;mtime&quot;</code></td><td width="50%"><code>st_mtime</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;ctime&quot;</code></td><td width="50%"><code>st_ctime</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;rdev&quot;</code></td><td width="50%"><code>st_rdev</code></td><td width="20%">Device files</td></tr>
<tr><td width="15%"><code>&quot;major&quot;</code></td><td width="50%"><code>st_major</code></td><td width="20%">Device files</td></tr>
<tr><td width="15%"><code>&quot;minor&quot;</code></td><td width="50%"><code>st_minor</code></td><td width="20%">Device files</td></tr>
<tr><td width="15%"><code>&quot;blksize&quot;</code></td><td width="50%"><code>st_blksize</code></td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;pmode&quot;</code></td><td width="50%">人可读的模式值字串，如 ls 打印的情况（如 <code>&quot;-rwxr-xr-x&quot;</code>）</td><td width="20%">All</td></tr>
<tr><td width="15%"><code>&quot;linkval&quot;</code></td><td width="50%">软链接的值。</td><td width="20%">Symbolic links</td></tr>
<tr><td width="15%"><code>&quot;type&quot;</code></td><td width="50%">文件类型字串表示——
<code>&quot;file&quot;</code>,
<code>&quot;blockdev&quot;</code>,
<code>&quot;chardev&quot;</code>,
<code>&quot;directory&quot;</code>,
<code>&quot;socket&quot;</code>,
<code>&quot;fifo&quot;</code>,
<code>&quot;symlink&quot;</code>,
<code>&quot;door&quot;</code>,
或者
<code>&quot;unknown&quot;</code>
其中之一
（并不是所有的系统都支持这些类型）</td><td width="20%">All</td></tr>
</table>

<a name="index-fts_0028_0029-extension-function"></a>
</dd>
<dt><code>flags = or(FTS_PHYSICAL, ...)</code></dt>
<dt><code>result = fts(pathlist, flags, filedata)</code></dt>
<dd><p>遍历由 <code>pathlist</code> 提供的文件树，并填充 <code>filedata</code> 数组，如后所述。<code>flags</code> 是几个预定义值的或，也如后所述。如果没有错误，则返回 0，错误则返回 -1。
</p></dd>
</dl>

<p><code>fts()</code> 函数提供了 <code>C</code> 库中的 <code>fts()</code> 例程的钩子，用来目录结构进行遍历。它不会在流中一次返回一个文件的数据，而是将其信息填充到一个多维数组中。这个数组中包括在遍历目录结构时遇到的每个文件与目录的的数据。
</p>
<p>参数如下：
</p>
<dl compact="compact">
<dt><code>pathlist</code></dt>
<dd><p>文件名数组。使用的是元素的值，而不使用值索引。
</p>
</dd>
<dt><code>flags</code></dt>
<dd><p>这些是下面预定的一个或者多个常量的按位或。<code>FTS_LOGICAL</code> 中 <code>FTS_PHYSICAL</code> 必须要提供一个，否则 <code>fts()</code> 会返回一个错误，并设置 <code>ERRNO</code>。这些标志为：
</p>
<dl compact="compact">
<dt><code>FTS_LOGICAL</code></dt>
<dd><p>执行的是“逻辑”上的文件遍历，在这个情况下针对链接文件返回的信息是被指向文件的信息，而不是链接文件本身。这个标志与 <code>FTS_PHYSICAL</code> 是互斥的。
</p>
</dd>
<dt><code>FTS_PHYSICAL</code></dt>
<dd><p>执行一个“物理”的遍历，其中对于软连接文件的信息是软链接文件本身的信息。这个标志与 <code>FTS_LOGICAL</code> 是互斥的。
</p>
</dd>
<dt><code>FTS_NOCHDIR</code></dt>
<dd><p>作为性能上的优化，<code>C</code> 库中的 <code>fts()</code> 例程会改变在目录结构中遍历文件时的目录，这个标志会禁用这个优化。
</p>
</dd>
<dt><code>FTS_COMFOLLOW</code></dt>
<dd><p>直接跟跟随 <code>pathlist</code> 中命名的软连接，不管是否设置了 <code>FTS_LOGICAL</code> 标志。
</p>
</dd>
<dt><code>FTS_SEEDOT</code></dt>
<dd><p>默认的情况下，<code>C</code> 库中的 <code>fts()</code> 例程不会返回 &lsquo;<tt>.</tt>&rsquo;（dot）以及 &lsquo;<tt>..</tt>&rsquo;（dot-dot）目录项。这个选项会使得 dot-dot 项会被包含进来。（扩展总是会包含 dot 的项，后面会有更多的说明。）
</p>
</dd>
<dt><code>FTS_XDEV</code></dt>
<dd><p>在遍历过程中，不跨越不同的的挂载的文件系统。
</p></dd>
</dl>

</dd>
<dt><code>filedata</code></dt>
<dd><p><code>filedata</code> 数组存储结果。<code>fts()</code> 首先会将其清除。然后会在 <code>filedata</code> 中为会在 <code>pathlist</code> 中的每个元素创建一个元素。索引即是 <code>pathlist</code> 中所给的目录或者文件的名字。这个索引下的元素本身是一个数组。存在两种情况：
</p>
<dl compact="compact">
<dt><em>路径是一个文件</em></dt>
<dd><p>在这种情况下，数组包含两个或者三个元素：
</p>
<dl compact="compact">
<dt><code>&quot;path&quot;</code></dt>
<dd><p>这个文件的全路径，在 <code>pathlist</code> 数组中是从“根”开始。
</p>
</dd>
<dt><code>&quot;stat&quot;</code></dt>
<dd><p>这个元素自己是一个数组，包含与早前讨论的 <code>stat()</code> 函数在自己的 <code>statdata</code> 参数中填充的一样的信息。如果针对文件的系统调用 <code>stat()</code> 函数失败，则可能不存在这个元素。
</p>
</dd>
<dt><code>&quot;error&quot;</code></dt>
<dd><p>如果发什么了某种错误，数组也包含一个名为 “<code>error</code>”的元素，这个元素是描述错误的字串。
</p></dd>
</dl>

</dd>
<dt><em>路径是一个目录</em></dt>
<dd><p>在这种情况下，数组为每个目录生成一个元素。如果相应的项是文件，则元素与刚才描述的文件类型的项一样。如果项是目录，则元素是一个（递归地）描述子目录的元素。如果 <code>FTS_SEEDOT</code> 在标志中进行了设置，则也会成在名字为 <code>&quot;..&quot;</code> 的元素。这个元素也会是一个数组，包含了从 <code>stat()</code> 调用中提供的信息。
</p>
<p>另外，也有一个元素，其索引为 <code>&quot;.&quot;</code>。这个元素是一个包含为文件提供的两个或者三个元素的数组。它们是，<code>&quot;path&quot;</code>，<code>&quot;stat&quot;</code>，<code>&quot;error&quot;</code>。
</p></dd>
</dl>
</dd>
</dl>

<p>如果没有出错，<code>fts()</code> 函数返回 0，否则返回 -1。
</p>
<blockquote>
<p><b>提示:</b> <code>fts()</code> 扩展并不是 <code>C</code> 库中的函数 <code>fts()</code> 完全的模拟，选择提供基于关联数组的接口，是在于在 <code>awk</code> 中使用起来更方便。这里缺少比较函数，因为 <code>gawk</code> 已经提供了非常强大的数组排序功能。尽管像 <code>fts_read()</code> 这样的接口本来应该提供，但是比起创建一个多维数组来表示文件的目录结构以及其信息来，它没有这么自然。
</p></blockquote>

<p>查看 <code>gawk</code> 发面版本中的 &lsquo;<tt>test/fts.awk</tt>&rsquo; 文件来获取使用 <code>fts()</code> 扩展函数的例子。
</p>
<hr>
<a name="Extension-Sample-Fnmatch"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-File-Functions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Fork" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0092_0088aa_00af_00b9-fnmatch_0028_0029a_0080_0080c_009a_0084ae_008e_00a5aa_008f_00a3"></a>
<h3 class="subsection">5.7.2 针对 <code>fnmatch()</code>　的接口</h3>

<p>这个扩展提供了 <code>C</code> 库接口 <code>fnmatch()</code> 函数，使用方法为：
</p>
<dl compact="compact">
<dt><code>@load &quot;fnmatch&quot;</code></dt>
<dd><p>如何来装载这个扩展。
</p>
<a name="index-fnmatch_0028_0029-extension-function"></a>
</dd>
<dt><code>result = fnmatch(pattern, string, flags)</code></dt>
<dd><p>成功时，返回值为 0，如果字串不匹配这个模式则返回 <code>FNM_NOMATCH</code>，如果出错，则返回不同的非零值。
</p></dd>
</dl>

<p>关于 <code>fnmatch()</code> 函数的一些其他信息，<code>fnmatch</code> 扩展则添加了一个常数（<code>FNM_NOMATCH</code>），以及一个名为 <code>FNM</code> 的数组标志值。
</p>
<p><code>fnmatch()</code> 的参数有：
</p>
<dl compact="compact">
<dt><code>pattern</code></dt>
<dd><p>要匹配的文件名的通配符。
</p>
</dd>
<dt><code>string</code></dt>
<dd><p>文件名串。
</p>
</dd>
<dt><code>flag</code></dt>
<dd><p>要么 0，要么是 <code>FNM</code> 数组中多个值的相或。
</p></dd>
</dl>

<p>标志如下：
</p>
<table>
<thead><tr><th width="25%">数组元素</th><th width="75%"><code>fnmatch()</code> 所定义的对应标志</th></tr></thead>
<tr><td width="25%"><code>FNM[&quot;CASEFOLD&quot;]</code></td><td width="75%"><code>FNM_CASEFOLD</code></td></tr>
<tr><td width="25%"><code>FNM[&quot;FILE_NAME&quot;]</code></td><td width="75%"><code>FNM_FILE_NAME</code></td></tr>
<tr><td width="25%"><code>FNM[&quot;LEADING_DIR&quot;]</code></td><td width="75%"><code>FNM_LEADING_DIR</code></td></tr>
<tr><td width="25%"><code>FNM[&quot;NOESCAPE&quot;]</code></td><td width="75%"><code>FNM_NOESCAPE</code></td></tr>
<tr><td width="25%"><code>FNM[&quot;PATHNAME&quot;]</code></td><td width="75%"><code>FNM_PATHNAME</code></td></tr>
<tr><td width="25%"><code>FNM[&quot;PERIOD&quot;]</code></td><td width="75%"><code>FNM_PERIOD</code></td></tr>
</table>

<p>例子如下：
</p>
<div class="example">
<pre class="example">@load &quot;fnmatch&quot;
&hellip;
flags = or(FNM[&quot;PERIOD&quot;], FNM[&quot;NOESCAPE&quot;])
if (fnmatch(&quot;*.a&quot;, &quot;foo.c&quot;, flags) == FNM_NOMATCH)
    print &quot;no match&quot;
</pre></div>

<hr>
<a name="Extension-Sample-Fork"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Fnmatch" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Inplace" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0092_0088aa_00af_00b9-fork_0028_0029i_00bc_008cwait_0028_0029i_00bc_008ca_00b8_008e-waitpid_0028_0029-c_009a_0084ae_008e_00a5aa_008f_00a3"></a>
<h3 class="subsection">5.7.3 针对 <code>fork()</code>，<code>wait()</code>，与 <code>waitpid()</code> 的接口</h3>

<p><code>fork</code> 扩展添加了三个函数，如下：
</p>
<dl compact="compact">
<dt><code>@load &quot;fork&quot;</code></dt>
<dd><p>如何来装入扩展。
</p>
<a name="index-fork_0028_0029-extension-function"></a>
</dd>
<dt><code>pid = fork()</code></dt>
<dd><p>这个函数创建一个新的进程。返回值在子进程中返回为 0，在父进程中返回的是子进程的进程 <code>ID</code>，或者出错的情况下为 -1。在后面的情况，<code>ERRNO</code> 用来指示出错的原因。在子进程中，<code>PROCINFO[&quot;pid&quot;]</code> 以及 <code>PROCINFO[&quot;ppid&quot;]</code> 会被更新用以反映正确的值。
</p>
<a name="index-waitpid_0028_0029-extension-function"></a>
</dd>
<dt><code>ret = waitpid(pid)</code></dt>
<dd><p>这个函数取数值参数，即要等待的进程的 <code>ID</code>。返回值是 <code>waitpid()</code> 系统调用的值。
</p>
<a name="index-wait_0028_0029-extension-function"></a>
</dd>
<dt><code>ret = wait()</code></dt>
<dd><p>这个函数等待第一个子进程死亡。返回值是 <code>wait()</code> 系统调用的返回值。
</p></dd>
</dl>

<p>没有相应的 <code>exec()</code> 函数。
</p>
<p>下面是例子：
</p>
<div class="example">
<pre class="example">@load &quot;fork&quot;
&hellip;
if ((pid = fork()) == 0)
    print &quot;hello from the child&quot;
else
    print &quot;hello from the parent&quot;
</pre></div>

<hr>
<a name="Extension-Sample-Inplace"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Fork" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Ord" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0090_00afc_0094_00a8ae_0096_0087a_00bb_00b6aa_00b0_00b1aa_009c_00b0c_00bc_0096e_00be_0091"></a>
<h3 class="subsection">5.7.4 启用文件就地编辑</h3>

<a name="index-inplace-extension"></a>
<p><code>inplace</code> 扩展模拟 GNU <code>sed</code> 的 &lsquo;<samp>-i</samp>&rsquo; 选项，这个选项表示对每个输入文件进行“就地”编辑。它使用打包文件 &lsquo;<tt>inplace.awk</tt>&rsquo;，其中包含了要调用的扩展的适当文件：
</p>
<div class="example">
<pre class="example"># inplace --- load and invoke the inplace extension.

@load &quot;inplace&quot;

# Please set INPLACE_SUFFIX to make a backup copy.  For example, you may
# want to set INPLACE_SUFFIX to .bak on the command line or in a BEGIN rule.

# By default, each filename on the command line will be edited inplace.
# But you can selectively disable this by adding an inplace=0 argument
# prior to files that you do not want to process this way.  You can then
# reenable it later on the commandline by putting inplace=1 before files
# that you wish to be subject to inplace editing.

# N.B. We call inplace_end() in the BEGINFILE and END rules so that any
# actions in an ENDFILE rule will be redirected as expected.

BEGIN {
    inplace = 1		# enabled by default
}

BEGINFILE {
    if (_inplace_filename != &quot;&quot;)
        inplace_end(_inplace_filename, INPLACE_SUFFIX)
    if (inplace)
        inplace_begin(_inplace_filename = FILENAME, INPLACE_SUFFIX)
    else
        _inplace_filename = &quot;&quot;
}

END {
    if (_inplace_filename != &quot;&quot;)
        inplace_end(_inplace_filename, INPLACE_SUFFIX)
}
</pre></div>

<p>对于要处理的每一个常规文件，扩展重定向输出到一个临时文件中，其与原始的文件具有相同所有权以及访问权限。在处理了相应的文件后，扩展会恢复标准输出到原来的目标。如果 <code>INPLACE_SUFFIX</code> 不为空串，则初始文件将后缀联合创建一个备份文件。最后，临时文件被重新命名为初始文件。
</p>
<p>注意，在使用这个特性的时候，可以通过在命令行中把 &lsquo;<samp>inplace=0</samp>&rsquo; 放在不需要这样处理的文件列表之前，来控制这个特性。你可以通过在需要这么处理的文件列表前加上 &lsquo;<samp>inplace=1</samp>&rsquo; 参数来重新启用这个特性。
</p>
<p><code>_inplace_filename</code> 变量用来跟踪当前的文件名，这样不用在处理第一个文件时调用 <code>inplace_end()</code>。
</p>
<p>如果出现的错误，扩展会生成一个致命错误，以立即结束处理，不会对原始文件造成破坏。
</p>
<p>这是一些简单的例子：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -i inplace '{ gsub(/foo/, &quot;bar&quot;) }; { print }' file1 file2 file3</kbd>
</pre></div>

<p>为了保存原文件的一个备份复本，可以这么执行：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -i inplace -v INPLACE_SUFFIX=.bak '{ gsub(/foo/, &quot;bar&quot;) }</kbd>
&gt; <kbd>{ print }' file1 file2 file3</kbd>
</pre></div>

<p>请注意，尽管这个扩展试图保存原始文件的所有权和许可，但是它不会试图拷贝原始文件的 ACL。
</p>
<p>如果程序过早地终止了，比如可能收到了未处理的信号，可能会留下一个临时文件。
</p>
<hr>
<a name="Extension-Sample-Ord"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Inplace" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Readdir" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ad_0097c_00ac_00a6a_00b8_008eae_0095_00b0aa_0080_00bci_00bc_009aord_0028_0029-a_00b8_008e-chr_0028_0029"></a>
<h3 class="subsection">5.7.5 字符与数值：<code>ord()</code> 与 <code>chr()</code></h3>

<p><code>ordchr</code> 扩展添加了两个函数，名字为 <code>ord()</code> 与 <code>chr()</code>，如下：
</p>
<dl compact="compact">
<dt><code>@load &quot;ordchr&quot;</code></dt>
<dd><p>这里用来进行扩展装载。
</p>
<a name="index-ord_0028_0029-extension-function"></a>
</dd>
<dt><code>number = ord(string)</code></dt>
<dd><p>返回 <code>string</code> 中第一个字符的数值值。
</p>
<a name="index-chr_0028_0029-extension-function"></a>
</dd>
<dt><code>char = chr(number)</code></dt>
<dd><p>返回第一个字母是由数值（<code>number</code>）表示的字串。
</p></dd>
</dl>

<p>这些函数由 Pascal 语言的同名函数借用而来。下面是例子：
</p>
<div class="example">
<pre class="example">@load &quot;ordchr&quot;
&hellip;
printf(&quot;The numeric value of 'A' is %d\n&quot;, ord(&quot;A&quot;))
printf(&quot;The string value of 65 is %s\n&quot;, chr(65))
</pre></div>

<hr>
<a name="Extension-Sample-Readdir"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Ord" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Revout" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_00bbaa_008f_0096c_009b_00aeaa_00bd_0095"></a>
<h3 class="subsection">5.7.6 读取目录</h3>

<p><code>readdir</code> 扩展添加了一个目录的输入分析器，其使用如下：
</p>
<a name="index-readdir-extension"></a>
<div class="example">
<pre class="example">@load &quot;readdir&quot;
</pre></div>

<p>当使用这个扩展时，它不会跳过在命令行中的目录（或者也不会在 <code>getline</code> 中跳过），相反它们会被读取，每一个项作为一个记录。
</p>
<p>记录包含三域。头两个域是 <code>inode</code> 号与文件名，由斜杠（/）进行分隔。在目录项中包含文件类型的系统中，记录会有第三个域（这个域也由斜杠（/）进行分隔，这是一个由单个字母表示的文件的类型。这些字母以及文件的相应的类型，在 <a href="#table_002dreaddir_002dfile_002dtypes">Table 5.3</a> 中。
</p>
<div class="float"><a name="table_002dreaddir_002dfile_002dtypes"></a>

<table>
<thead><tr><th width="10%">字母</th><th width="90%">文件类型</th></tr></thead>
<tr><td width="10%"><code>b</code></td><td width="90%">块设备</td></tr>
<tr><td width="10%"><code>c</code></td><td width="90%">字符设备</td></tr>
<tr><td width="10%"><code>d</code></td><td width="90%">目录</td></tr>
<tr><td width="10%"><code>f</code></td><td width="90%">常规文件</td></tr>
<tr><td width="10%"><code>l</code></td><td width="90%">符号连接</td></tr>
<tr><td width="10%"><code>p</code></td><td width="90%">命令管道（FIFO）</td></tr>
<tr><td width="10%"><code>s</code></td><td width="90%"><code>Socket</code></td></tr>
<tr><td width="10%"><code>u</code></td><td width="90%">其他（未知）</td></tr>
</table>
</div><p><strong>Table 5.3: 由 <code>readdir</code> 扩展返回的文件类型
</strong>
</p>
<p>在没有文件系统的系统中，第三个域总是 &lsquo;<samp>u</samp>&rsquo;。
</p>
<blockquote>
<p><b>提示:</b> 在 GNU/Linux 系统中，有一些文件系统不支持 <code>d_type</code> 项（查看 <code>readdir</code>(3) 手册页），因此文件类型也总是 &lsquo;<samp>u</samp>&rsquo;。你可以使用 <code>filefuncs</code> 扩展来调用 <code>stat()</code> 来取得正确的类型信息。
</p></blockquote>

<p>下面是例子：
</p>
<div class="example">
<pre class="example">@load &quot;readdir&quot;
&hellip;
BEGIN { FS = &quot;/&quot; }
{ print &quot;文件名 is&quot;, $2 }
</pre></div>

<hr>
<a name="Extension-Sample-Revout"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Readdir" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Rev2way" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0080_0092e_00bd_00ace_00be_0093aa_0087_00ba"></a>
<h3 class="subsection">5.7.7 倒转输出</h3>

<p><code>revoutput</code> 扩展添加了一个简单的输出包装器，包含器会将每个输出行的字符进行倒转。这个扩展的主要目的是来演示如何写一个输出包装器，尽管它可能有点无厘头。下面是例子：
</p>
<a name="index-revoutput-extension"></a>
<div class="example">
<pre class="example">@load &quot;revoutput&quot;

BEGIN {
    REVOUT = 1
    print &quot;don't panic&quot; &gt; &quot;/dev/stdout&quot;
}
</pre></div>

<p>这个例子中的输出为 &lsquo;<samp>cinap t'nod</samp>&rsquo;。
</p>
<hr>
<a name="Extension-Sample-Rev2way"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Revout" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Read-write-array" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008f_008ce_00b7_00af-I_002fO-a_00be_008baa_00ad_0090"></a>
<h3 class="subsection">5.7.8 双路 I/O 例子</h3>

<p><code>revtwoway</code> 扩展添加了一个简单的双路处理器，用来将初 <code>awk</code> 程序读取回来的每一行的字母进行倒转。它的目录是演示如何来写一个双路处理串，这也许也很无厘头。下面的例子示范如何来使用：
</p>
<a name="index-revtwoway-extension"></a>
<div class="example">
<pre class="example">@load &quot;revtwoway&quot;

BEGIN {
    cmd = &quot;/magic/mirror&quot;
    print &quot;don't panic&quot; |&amp; cmd
    cmd |&amp; getline result
    print result
    close(cmd)
}
</pre></div>

<p>这个程序的输出
也是：
&lsquo;<samp>cinap t'nod</samp>&rsquo;。
</p>
<hr>
<a name="Extension-Sample-Read-write-array"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Rev2way" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Readfile" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00be_0093aa_0087_00baa_00b8_008eae_0081_00a2aa_00a4_008dae_0095_00b0c_00bb_0084"></a>
<h3 class="subsection">5.7.9 输出与恢复数组</h3>

<p><code>rwarray</code> 扩展添加了两个函数，名字为 <code>writea()</code> 与 <code>reada()</code>，如下：
</p>
<dl compact="compact">
<dt><code>@load &quot;rwarray&quot;</code></dt>
<dd><p>如何来装载扩展。
</p>
<a name="index-writea_0028_0029-extension-function"></a>
</dd>
<dt><code>ret = writea(file, array)</code></dt>
<dd><p>这个函数有一个字串参数，这个参数是要 dump 数组到文件的名字，而数组则为第二个参数。<code>writea()</code> 可以处理数组之数组。如果成功则返回 1，否则返回 0。
</p>
<a name="index-reada_0028_0029-extension-function"></a>
</dd>
<dt><code>ret = reada(file, array)</code></dt>
<dd><p><code>reada()</code> 是 <code>writea()</code> 的相反的版本，它从由第一个参数命令的文件中读取，并将其填充到作为第二个参数的数组。它首先会将数组清空。在这里也是成功时返回 1，否则返回 0。
</p></dd>
</dl>

<p>由 <code>reada()</code> 创建的数组与 <code>writea()</code> 所写的数组在数据相同的情况下是相同的。但是，由于实现的问题，重建的数组的遍历顺序有可能不同于最开始的数组。在 <code>awk</code> 中数组的遍历顺序默认是未定义的，这在技术上来讲并不是什么问题。如果你要保证一个特定的遍历顺序，使用 <code>gawk</code> 中的数组排序特定来处理（查看 see section <a href="#Array-Sorting">控制数组排序与遍历</a>）。
</p>
<p>文件中包含的是二进制数据。所有的整数值都以网络字节序写入的。但是，双精度的浮点数是使用的本地进制数据。所以，只包含字串数据的数组理论上在系统上是以字节序的方式进行输出的，但是在另一个系统上可能是不一样的，但是也没有试过。
</p>
<p>下面是例子：
</p>
<div class="example">
<pre class="example">@load &quot;rwarray&quot;
&hellip;
ret = writea(&quot;arraydump.bin&quot;, array)
&hellip;
ret = reada(&quot;arraydump.bin&quot;, array)
</pre></div>

<hr>
<a name="Extension-Sample-Readfile"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Read-write-array" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Time" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00af_00bbaa_008f_0096ae_0095_00b4a_00b8_00aaae_0096_0087a_00bb_00b6"></a>
<h3 class="subsection">5.7.10 读取整个文件</h3>

<p><code>readfile</code> 扩展添加了一个函数，名字为 <code>readfile()</code>，以及一个输入分析器：
</p>
<dl compact="compact">
<dt><code>@load &quot;readfile&quot;</code></dt>
<dd><p>如何来使用扩展。
</p>
<a name="index-readfile_0028_0029-extension-function"></a>
</dd>
<dt><code>result = readfile(&quot;/some/path&quot;)</code></dt>
<dd><p>参数是要读取的文件的名字。返回值是一个字串，其中包含所请求文件的所有内容。如果错误，函数返回空串，并设置 <code>ERRNO</code> 的值。
</p>
</dd>
<dt><code>BEGIN { PROCINFO[&quot;readfile&quot;] = 1 }</code></dt>
<dd><p>另外，扩展添加了一个输入分析器，如果 <code>PROCINFO[&quot;readfile&quot;]</code> 存在时则会被激活。当被激活时，每个文件都以整个的内容返回为 <code>$0</code>，<code>RT</code> 被设置为空串。
</p></dd>
</dl>

<p>下面的例子：
</p>
<div class="example">
<pre class="example">@load &quot;readfile&quot;
&hellip;
contents = readfile(&quot;/path/to/file&quot;);
if (contents == &quot;&quot; &amp;&amp; ERRNO != &quot;&quot;) {
    print(&quot;problem reading file&quot;, ERRNO) &gt; &quot;/dev/stderr&quot;
    ...
}
</pre></div>

<hr>
<a name="Extension-Sample-Time"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Readfile" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-API-Tests" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0089_00a9aa_00b1_0095c_009a_0084ae_0097_00b6e_0097_00b4aa_0087_00bdae_0095_00b0"></a>
<h3 class="subsection">5.7.11 扩展的时间函数</h3>

<p><code>time</code> 扩展添加了两个函数，名字为 <code>gettimeofday()</code> 以及 <code>sleep</code>，如下：
</p>
<dl compact="compact">
<dt><code>@load &quot;time&quot;</code></dt>
<dd><p>如何来使用扩展。
</p>
<a name="index-gettimeofday_0028_0029-extension-function"></a>
</dd>
<dt><code>the_time = gettimeofday()</code></dt>
<dd><p>返回从 1970-01-01 UTC 以来的消逝的秒数，类型为浮点数。如果时间在平台上不可得，则返回 -1 并设置 <code>ERRNO</code>。返回的时间应该有次秒的精度，但是实际的精度在不同的平台上是不同的。如果标准的  C <code>gettimeofday()</code> 系统调用在平台上是可用的，则它只是简单地返回这个函数的值。否则，如果在 MS-Windows 平台上，它返回 <code>GetSystemTimeAsFileTime()</code> 函数返回的值。
</p>
<a name="index-sleep_0028_0029-extension-function"></a>
</dd>
<dt><code>result = sleep(<var>seconds</var>)</code></dt>
<dd><p>尝试休眠 <var>seconds</var> 秒。如果 <var>seconds</var> 为负数，或者尝试休眠失败，则返回 -1 并且设置 <code>ERRNO</code>。否则在休眠了指定的时间后返回 0。注意，<var>seconds</var> 可以是一个浮点数（非整数）。实现细节是：依赖于平台的可获得性，这个函数会尝试使用 <code>nanosleep()</code> 或者 <code>select</code> 来实现延迟。
</p></dd>
</dl>

<hr>
<a name="Extension-Sample-API-Tests"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-Time" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Samples" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#gawkextlib" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="API-ae_00b5_008be_00af_0095"></a>
<h3 class="subsection">5.7.12 <code>API</code> 测试</h3>
<a name="index-testext-extension"></a>

<p><code>testext</code> 扩展执行扩展 <code>API</code> 中没有在被其他例子测试到的部分。&lsquo;<tt>extension/testext.c</tt>&rsquo; 文件包含扩展的 <code>C</code> 代码以及 <code>awk</code> 测试代码，这些代码注释在执行测试的 C 注释中。测试框架提取 <code>awk</code> 代码来执行测试。查看源代码来获取更多的信息。
</p>
<hr>
<a name="gawkextlib"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Sample-API-Tests" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawkextlib-e_00a1_00b9c_009b_00ae"></a>
<h2 class="section">5.8 <code>gawkextlib</code> 项目</h2>
<a name="index-gawkextlib"></a>
<a name="index-extensions_002c-where-to-find"></a>

<a name="index-gawkextlib-project"></a>
<p><a href="http://sourceforge.net/projects/gawkextlib/"><code>gawkextlib</code></a> 项目提供了很多的 <code>gawk</code> 扩展，包含用于处理 XML 文件的扩展，这是由最开始的 <code>xgawk</code>（XML <code>gawk</code>）项目演化过来的。
</p>
<p>在写本书的时候，一共有七个扩展：
</p>
<ul>
<li>
<code>errno</code> 扩展

</li><li>
GD graphics 库扩展

</li><li>
PDF 扩展

</li><li>
PostgreSQL 扩展

</li><li>
MPFR 库扩展
（这提供了访问很多的 MPFR 函数，这些函数在 <code>gawk</code> 的本地 MPFR 是不被支持的）

</li><li>
Redis 扩展

</li><li>
XML 分析器扩展，这个扩展使用 <a href="http://expat.sourceforge.net">Expat</a> XML 分析库
</li></ul>

<a name="index-git-utility"></a>
<p>你可以查看 <code>gawkextlib</code> 项目的代码，这些代码可以通过 <a href="http://git-scm.com">Git</a> 分布式源代码扩展系统获取。相应的命令为：
</p>
<div class="example">
<pre class="example">git clone git://git.code.sf.net/p/gawkextlib/code gawkextlib-code
</pre></div>

<a name="index-Expat-XML-parser-library"></a>
<p>为了构建 XML 扩展 ，你需要在你的系统已经安装好了 <a href="http://expat.sourceforge.net">Expat</a> XML 分析库。
</p>
<p>另外，你必须还要有 GNU Autotools 安装在系统上（<a href="http://www.gnu.org/software/autoconf，Autoconf">http://www.gnu.org/software/autoconf，Autoconf</a>，<a href="http://www.gnu.org/software/automake，Automake">http://www.gnu.org/software/automake，Automake</a>，<a href="http://www.gnu.org/software/libtool，Libtool">http://www.gnu.org/software/libtool，Libtool</a>，和 <a href="http://www.gnu.org/software/gettext，GNU <code>gettext</code>">http://www.gnu.org/software/gettext，GNU <code>gettext</code></a>）。
</p>
<p>一个简单的构建与测试 <code>gawkextlib</code> 的过程如下。首先是构建与安装  <code>gawk</code>：
</p>
<div class="example">
<pre class="example">cd .../path/to/gawk/code
./configure --prefix=/tmp/newgawk     <i>Install in /tmp/newgawk for now</i>
make &amp;&amp; make check                    <i>Build and check that all is OK</i>
make install                          <i>Install gawk</i>
</pre></div>

<p>接下来，到 <a href="http://sourceforge.net/projects/gawkextlib/files">http://sourceforge.net/projects/gawkextlib/files</a> 中下载 <code>gawkextlib</code> 以及任意的你想要构建的扩展。站点中的 &lsquo;<tt>README</tt>&rsquo; 文件说明了如何来构建代码。如果你将 <code>gawk</code> 安装在一个非标准的位置，你还要指定 <code>./configure --with-gawk=<var>/path/to/gawk</var></code> 来指定它。你可能需要使用 <code>sudo</code> 工具来安装 <code>gawk</code> 与 <code>gawkextlib</code>，这视你所在的系统的工作方式。
</p>
<p>如果你写了一个扩展，而希望与其他的 <code>gawk</code> 用户一起分离，可以考虑通过 <code>gawkextlib</code> 项目来进行分发。查看这个项目的网站来获取更多的信息。
</p>
<hr>
<a name="Extension-summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#gawkextlib" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Exercises" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-3"></a>
<h2 class="section">5.9 总结</h2>

<ul>
<li>
你可以为 <code>gawk</code> 用 C 或者 C++ ，并利用由 <code>gawk</code> 开发者所定义的应用程序接口（API）来写扩展（有时也叫插件）。

</li><li>
扩展必须有一个与 GNU 通用许可证协议（GPL）兼容的许可证，而它们必须通过声明一个名为 <code>plugin_is_GPL_compatible</code> 的变量来进行断言。

</li><li>
在 <code>gawk</code> 与扩展之间的通信是双向的，<code>gawk</code> 将一个结构 <code>struct</code> 传递给扩展，这个结构中包含了各种数组成员以及函数指针。而扩展可以通过 <code>gawk</code> 提供的函数来调用 <code>gawk</code> 以实现特定的任务。

</li><li>
这些工作其中之一是“注册”名字与新的 <code>awk</code> 层功能实现到 <code>gawk</code> 中，这些实现名字为 <code>do_<var>XXXX</var>()</code>，而这个函数实现的是 <code>awk</code> 层的函数 <code><var>XXXX</var>()</code>。

</li><li>
API 定义在头文件 &lsquo;<tt>gawkapi.h</tt>&rsquo; 中。你的源代码中，必须在包含这个头文件<em>之前</em>包含很多的标准头文件。

</li><li>
<code>API</code> 函数指针可提供下面的操作：

<ul>
<li>
分配，重新分析以及释放内存

</li><li>
注册函数（你可以注册扩展函数，退出回调函数，版本字串，输入分析器，输出包装器以及双路处理器）

</li><li>
打印致命错误，告警以及“lint”警告信息

</li><li>
更新 <code>ERRNO</code> 或者重置它

</li><li>
访问参数，其中包括将一个未定义的参数转换为数组

</li><li>
符号表访问（返回全局变量，创建或者更改变量）

</li><li>
创建并翻译缓存值，这会给使用多个变量值提供一种高效的方法，且获取巨大的性能回报

</li><li>
操作数组（返回，添加，删除或者修改元素，获取数组元素个数，创建新数组，清除数组，扁平化数组来使用简单的 C 风格的循环来访问其所有的索引与元素。

</li></ul>

</li><li>
API 定义了很多的标准数组类型用来表示 <code>awk</code> 的值，数组元素以及数组。

</li><li>
API 提供了方便的函数用来构建值。也提供了内存管理函数来保证 <code>gawk</code> 分配的内存与由扩展分配的内存的兼容性。

</li><li>
<em>所有的</em>从 <code>gawk</code> 传递给扩展的内存必须被扩展当成是只读的。

</li><li>
<em>所有的</em>由扩展传递给 <code>gawk</code> 的内存必须通过 <code>API</code> 的内存分配函数来分配。<code>gawk</code> 会管理这些内存并在合适的时间释放它。

</li><li>
API 提供了 <code>gawk</code> 运行时的版本信息，这样扩展可以确定其是否与载入扩展的 <code>gawk</code> 兼容。

</li><li>
最容易的开启一个新扩展的方式是复杂这一章中的样板代码。&lsquo;<tt>gawkapi.h</tt>&rsquo; 中的宏可以简化这个工作。

</li><li>
<code>gawk</code> 发布版包含了很多小的，很有用的例子扩展。<code>gawkextllib</code> 项目包含了几个更大的扩展。如果你希望写一个扩展并将其分享给 <code>gawk</code> 的用户社区，<code>gawkextlib</code> 可以用于这样的目的。

</li></ul>

<hr>
<a name="Extension-Exercises"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00bb_0083a_00b9_00a0"></a>
<h2 class="section">5.10 练习</h2>

<ol>
<li>
添加一个函数来实现系统调用，如 <code>chown()</code>，<code>chmod()</code>，以及 <code>umask()</code> 来执行文件操作。这些函数添加到 <a href="#Internal-File-Ops"><code>chdir()</code> 与 <code>stat()</code> 的C 代码</a> 中的扩展中。

</li><li>
写一个输入分析器，在输入是来自于“终端”设备时则打印一个提示。你可以使用 <code>isatty()</code> 函数以获取输入文件是否是一个终端。（提示：这个函数调用起来通常很慢，最好只调用一次。）提示的内容应该一个可被 <code>awk</code> 层代码设置的变量。你可以将提示写到标准错误中。但是为了最好的结果，是打开一个在 &lsquo;<tt>/dev/tty</tt>&rsquo; 中的一个文件描述符（或者文件指针）并在其上打印提示，因为有可能标准错误可能会被重定向。

<p>为什么标准错误比标准输出是用来输出提示的更好选择？你要替换成什么样的读取机制，是一次一条记录还是一次读取多个原始字节？
</p>
</li><li>
（难）如你何在 <code>gawk</code> 中来提供一个名字空间（<code>namespace</code>），这样不同扩展中的函数名字不会相互冲突？如果你想出了一个好方案，请与 <code>gawk</code> 的维护者联系并告知这个方案。

</li><li>
写一个包装脚本来提供一个与 &lsquo;<samp>sed -i</samp>&rsquo; 相似的接口，以实现在 <a href="#Extension-Sample-Inplace">启用文件就地编辑</a> 中的“inplace”扩展。

</li></ol>

<hr>
<a name="c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Dynamic-Extensions" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Exercises" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#V7_002fSVR3_002e1" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="part">第四部分:<br> 附录</h1>
<hr>


<a name="Language-History"></a>
<a name="awk-e_00af_00ade_00a8_0080c_009a_0084ae_00bc_0094aa_008c_0096"></a>
<h1 class="appendix">Appendix A <code>awk</code> 语言的演化</h1>

<p>本网页描述的 <code>awk</code> 的 GNU 版本，这个版本的 <code>awk</code> 是符号 POSIX 标准的。很多的老 <code>awk</code> 用户使用 Unix Version 7 版本的 <code>awk</code> 开始学习 <code>awk</code> 语言。（这个版本的实现是 Berkeley Unix 4.3 至 Reno 中的 <code>awk</code> 版本的基础。后续的 <code>Berkeley</code> Unix 版本，并且有一段时间，一些由 4.4 <code>BSD</code>-<code>Lite</code> 派生出来 Unix 版本使用不同的版本 <code>gawk</code> 来作为这些系统上的 <code>awk</code>。）这一章简单地描述 <code>awk</code> 语言的演化过程，并对网页中相应的章节做了引用 ，这样你可以看到更多的信息。
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#V7_002fSVR3_002e1">A.1 在 V7 与 SVR3.1 之间的变化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   The major changes between V7 and System V
                                Release 3.1.
</td></tr>
<tr><td align="left" valign="top"><a href="#SVR4">A.2 在 SVR3.1 与 SVR4 之间的变化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Minor changes between System V Releases 3.1
                                and 4.
</td></tr>
<tr><td align="left" valign="top"><a href="#POSIX">A.3 在 SVR4 与 POSIX 之间的变化</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                       New features from the POSIX standard.
</td></tr>
<tr><td align="left" valign="top"><a href="#BTL">A.4 Brian Kernighan 的 <code>awk</code> 的扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         New features from Brian Kernighan&rsquo;s version of
                                <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#POSIX_002fGNU">A.5 不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   The extensions in <code>gawk</code> not in POSIX
                                <code>awk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Feature-History">A.6 <code>gawk</code> 特性历史</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             The history of the features in <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Common-Extensions">A.7 通用扩展汇总</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Common Extensions Summary.
</td></tr>
<tr><td align="left" valign="top"><a href="#Ranges-and-Locales">A.8 正则表达式范围与本地语言设置：又臭又长陈年旧事</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          How locales used to affect regexp ranges.
</td></tr>
<tr><td align="left" valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                The major contributors to <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#History-summary">A.10 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             History summary.
</td></tr>
</table>

<hr>
<a name="V7_002fSVR3_002e1"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#SVR4" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-V7-a_00b8_008e-SVR3_002e1-a_00b9_008be_0097_00b4c_009a_0084aa_008f_0098aa_008c_0096"></a>
<h2 class="appendixsec">A.1 在 V7 与 SVR3.1 之间的变化</h2>
<a name="index-awk_002c-versions-of"></a>
<a name="index-awk_002c-versions-of_002c-changes-between-V7-and-SVR3_002e1"></a>

<p><code>awk</code> 语言在 Unix Version 7（1978）与 System V Release 3.1（1987）中作为通用常用工具第一个新版本之间有非常大的变化。这小节对其中的变化进行归纳，并有相应的参考，这样可以获取进一步的信息：
</p>
<ul>
<li>
需要用 &lsquo;<samp>;</samp>&rsquo; 来分隔一行中的规则（查看 see section <a href="#Statements_002fLines"><code>awk</code> 语句与行</a>）。

</li><li>
用户自定义函数与 <code>return</code> 语句（查看 see section <a href="#User_002ddefined">用户自定义函数</a>）。

</li><li>
<code>delete</code> 语句（查看 see section <a href="#Delete"><code>delete</code> 语句</a>）。

</li><li>
<code>do</code>-<code>while</code> 语句（查看 see section <a href="#Do-Statement"><code>do</code>-<code>while</code> 语句</a>）。

</li><li>
内置函数 <code>atan2()</code>，<code>cos()</code>，<code>sin()</code>，<code>rand()</code> 与 <code>srand()</code>（查看 see section <a href="#Numeric-Functions">数值函数</a>）。

</li><li>
内置函数 <code>gsub()</code>，<code>sub()</code> 与 <code>match()</code>（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>
内置函数 <code>close()</code> 与 <code>system()</code>（查看 see section <a href="#I_002fO-Functions">输入输出函数</a>）。

</li><li>
<code>ARGC</code>，<code>ARGV</code>，<code>FNR</code>，<code>RLENGTH</code>，<code>RSTART</code> 与 <code>SUBSEP</code> 预定义变量（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）。

</li><li>
可赋值的 <code>$0</code>（查看 see section <a href="#Changing-Fields">更改域内容</a>）。

</li><li>
使用三元操作符 &lsquo;<samp>?:</samp>&rsquo; 的条件表达式（查看 see section <a href="#Conditional-Exp">条件表达式</a>）。

</li><li>
在 <code>for</code> 语句之外的 &lsquo;<samp><var>indx</var> in <var>array</var></samp>&rsquo; 表达式（查看 see section <a href="#Reference-to-Elements">指向数组元素</a>）。

</li><li>
幂操作符 &lsquo;<samp>^</samp>&rsquo;（查看 see section <a href="#Arithmetic-Ops">算术操作符</a>）与其赋值操作符形式 &lsquo;<samp>^=</samp>&rsquo;（查看 see section <a href="#Assignment-Ops">赋值表达式</a>）。

</li><li>
与 C 兼容的操作符优先级，这个与一些旧的 <code>awk</code> 程序不同（查看 see section <a href="#Precedence">操作符优先级（操作符的嵌套）</a>）。

</li><li>
正则表达式可以作为 <code>FS</code> 的值（查看 see section <a href="#Field-Separators">指定记录如何进行分隔</a>）以及作为 <code>split()</code> 函数（查看 see section <a href="#String-Functions">字串操作函数</a>）的第三个参数，而不是使用 <code>FS</code> 的第一个字符。

</li><li>
作为 &lsquo;<samp>~</samp>&rsquo; 与 &lsquo;<samp>!~</samp>&rsquo; 操作符操作数的动态正则表达式（查看 see section <a href="#Computed-Regexps">使用动态正则表达式</a>）。

</li><li>
&lsquo;<samp>\b</samp>&rsquo;，&lsquo;<samp>\f</samp>&rsquo; 与 &lsquo;<samp>\r</samp>&rsquo; 转义序列（查看 see section <a href="#Escape-Sequences">转义序列</a>）。

</li><li>
<code>getline</code> 函数（查看 see section <a href="#Getline">用 <code>getline</code> 输入数据</a>）输入重定向。

</li><li>
多 <code>BEGIN</code> 与 <code>END</code> 规则（查看 see section <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）。

</li><li>
多维数组（查看 see section <a href="#Multidimensional">多维数组</a>）。
</li></ul>

<hr>
<a name="SVR4"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#V7_002fSVR3_002e1" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#POSIX" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-SVR3_002e1-a_00b8_008e-SVR4-a_00b9_008be_0097_00b4c_009a_0084aa_008f_0098aa_008c_0096"></a>
<h2 class="appendixsec">A.2 在 SVR3.1 与 SVR4 之间的变化</h2>

<a name="index-awk_002c-versions-of_002c-changes-between-SVR3_002e1-and-SVR4"></a>
<p>System V Release 4（1989）版本的 Unix <code>awk</code> 添加了这些特性（有一些来自于 <code>gawk</code>）：
</p>
<ul>
<li>
<code>ENVIRON</code> 数组（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）。

</li><li>
多个 &lsquo;<samp>-f</samp>&rsquo; 选项（查看 see section <a href="#Options">命令行参数</a>）。

</li><li>
&lsquo;<samp>-v</samp>&rsquo; 选项用于在程序执行前进行变量赋值（查看 see section <a href="#Options">命令行参数</a>）。

</li><li>
&lsquo;<samp>--</samp>&rsquo; 用于表示命令行选项的结束。

</li><li>
&lsquo;<samp>\a</samp>&rsquo;，&lsquo;<samp>\v</samp>&rsquo; 与 &lsquo;<samp>\x</samp>&rsquo; 转义字符（查看 see section <a href="#Escape-Sequences">转义序列</a>）

</li><li>
内置函数 <code>srand()</code> 有确定的返回值（查看 see section <a href="#Numeric-Functions">数值函数</a>）。

</li><li>
<code>toupper()</code> 与 <code>tolower()</code> 内置字串函数，用于大小定转换（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>
对于 <code>printf</code> 中的 &lsquo;<samp>%c</samp>&rsquo; 格式控制字串有更清晰的规范（查看 see section <a href="#Control-Letters">格式控制字母</a>）。

</li><li>
在 <code>printf</code> 与 <code>sprintf()</code> 的参数列表中，可以动态控制域的宽度与精度（<code>&quot;%*.*d&quot;</code>）（查看 see section <a href="#Control-Letters">格式控制字母</a>）。

</li><li>
正则表达式常量的使用，如 <code>/foo/</code> 作为一个表达式，这个与匹配操作符，如 &lsquo;<samp>$0 ~ /foo/</samp>&rsquo; 是一样的的（查看 see section <a href="#Using-Constant-Regexps">使用正则表达式常量</a>）。

</li><li>
在命令行变量赋值中处理转义序列（查看 see section <a href="#Assignment-Options">在命令行中进行变量赋值</a>）。
</li></ul>

<hr>
<a name="POSIX"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SVR4" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#BTL" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-SVR4-a_00b8_008e-POSIX-a_00b9_008be_0097_00b4c_009a_0084aa_008f_0098aa_008c_0096"></a>
<h2 class="appendixsec">A.3 在 SVR4 与 POSIX 之间的变化</h2>
<a name="index-awk_002c-versions-of_002c-changes-between-SVR4-and-POSIX-awk"></a>
<a name="index-POSIX-awk_002c-changes-in-awk-versions"></a>

<p><code>awk</code> 命令语言与工具的 POSIX 标准（1992）引入了下面变量：
</p>
<ul>
<li>
使用 &lsquo;<samp>-W</samp>&rsquo; 特定于实现的选项（查看 see section <a href="#Options">命令行参数</a>）。

</li><li>
使用 <code>CONVFMT</code> 用于控制数值转换为字串（查看 see section <a href="#Conversion">在字串与数值之间进行转换</a>）。

</li><li>
数值字串的概念并引入与更严格的比较规则（查看 see section <a href="#Typing-and-Comparison">变量类型与比较表达式</a>）。

</li><li>
使用预定义的变量作为函数参数名被禁用（查看 see section <a href="#Definition-Syntax">函数定义语法</a>）。

</li><li>
很多之前没有文档的语言特性有了更完备的文档。
</li></ul>

<p>在 2012 年，很多之前很多年都以扩展的方式取得的特性最终被加入到 POSIX 标准中。它们是：
</p>
<ul>
<li>
<code>fflush()</code> 内置函数用来刷出输出（查看 see section <a href="#I_002fO-Functions">输入输出函数</a>）。

</li><li>
<code>nextfile</code> 语句（查看 see section <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>）

</li><li>
通过 &lsquo;<samp>delete <var>array</var></samp>&rsquo; 就可以删除整个数组（查看 see section <a href="#Delete"><code>delete</code> 语句</a>）。

</li></ul>

<p>查看 <a href="#Common-Extensions">通用扩展汇总</a>，来获取还没有被接受为 POSIX 标准的扩展列表。
</p>
<p>2008 年的 POSIX 标准可以在线上找到：<a href="http://www.opengroup.org/onlinepubs/9699919799/">http://www.opengroup.org/onlinepubs/9699919799/</a>
</p>

<hr>
<a name="BTL"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#POSIX" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#POSIX_002fGNU" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Brian-Kernighan-c_009a_0084-awk-c_009a_0084ae_0089_00a9aa_00b1_0095"></a>
<h2 class="appendixsec">A.4 Brian Kernighan 的 <code>awk</code> 的扩展</h2>

<a name="index-awk_002c-versions-of_002c-See-Also-Brian-Kernighan_0027s-awk"></a>
<a name="index-extensions_002c-Brian-Kernighan_0027s-awk"></a>
<a name="index-Brian-Kernighan_0027s-awk_002c-extensions"></a>
<a name="index-Kernighan_002c-Brian-6"></a>
<p>Brian Kernighan 版本的 <code>awk</code> 可以通过它的主页来获取（查看 see section <a href="#Other-Versions">其他可自由获取的 <code>awk</code></a>）。
</p>
<p>这一小节描述的是来自于他的 <code>awk</code> 版本的通用扩展：
</p>
<ul>
<li>
&lsquo;<samp>**</samp>&rsquo; 与 &lsquo;<samp>**=</samp>&rsquo; 操作符（查看 see section <a href="#Arithmetic-Ops">算术操作符</a> 与 <a href="#Assignment-Ops">赋值表达式</a>）。

</li><li>
<code>func</code> 用于 <code>function</code> 的缩写（查看 see section <a href="#Definition-Syntax">函数定义语法</a>）。

</li><li>
<code>fflush()</code> 内置函数用来刷出缓存的输出（查看 see section <a href="#I_002fO-Functions">输入输出函数</a>）

</li></ul>

<p>查看 <a href="#Common-Extensions">通用扩展汇总</a>，来获取在它的 <code>awk</code> 中可以获取的扩展。
</p>
<hr>
<a name="POSIX_002fGNU"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#BTL" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Feature-History" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_008daa_009c_00a8-POSIX-awk-a_00b8_00adc_009a_0084-gawk-ae_0089_00a9aa_00b1_0095"></a>
<h2 class="appendixsec">A.5 不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</h2>

<a name="index-compatibility-mode-_0028gawk_0029_002c-extensions"></a>
<a name="index-extensions_002c-in-gawk_002c-not-in-POSIX-awk"></a>
<a name="index-POSIX_002c-gawk-extensions-not-included-in"></a>
<p><code>awk</code> 的 GNU 实现——<code>gawk</code> 添加了大量的特性。它们在使用 &lsquo;<samp>--traditional</samp>&rsquo; 或者 &lsquo;<samp>--posix</samp>&rsquo; 选项的时候可以被禁用（查看 see section <a href="#Options">命令行参数</a>）。
</p>
<p>很多的特性已经有一些年头了，这一节对这些附加的特性进行描述，这些特性使用在现在的 <code>gawk</code> 版本中，但是超出 POSIX 标准。
</p>
<ul>
<li>
额外的预定义变量：

<ul class="no-bullet">
<li>-
<code>ARGIND</code>，<code>BINMODE</code>，<code>ERRNO</code>，<code>FIELDWIDTHS</code>，<code>FPAT</code>，<code>IGNORECASE</code>，<code>LINT</code>，<code>PROCINFO</code>，<code>RT</code>，和 <code>TEXTDOMAIN</code> 变量（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）。
</li></ul>

</li><li>
I/O 重定向中的特殊文件：

<ul class="no-bullet">
<li>-
/<code>dev</code>/<code>stdin</code>， /<code>dev</code>/<code>stdout</code>， /<code>dev</code>/<code>stderr</code>， 与 /<code>dev</code>/<code>fd</code>/<code>N</code> 特殊文件名（查看 5.8 <code>gawk</code> 中的特殊文件名， 在第 106 页）。
&lsquo;<tt>/dev/stdin</tt>&rsquo;，&lsquo;<tt>/dev/stdout</tt>&rsquo;，&lsquo;<tt>/dev/stderr</tt>&rsquo;，与 &lsquo;<tt>/dev/fd/<var>N</var></tt>&rsquo; 特殊文件名（查看 see section <a href="#Special-Files"><code>gawk</code> 中的特殊文件名</a>）。 

</li><li>-
&lsquo;<tt>/inet</tt>&rsquo;，&lsquo;<tt>/inet4</tt>&rsquo;，和 &lsquo;<tt>/inet6</tt>&rsquo; 等特殊文件用于使用 &lsquo;<samp>|&amp;</samp>&rsquo; TCP/IP 网络通信，来指定使用哪个版本的协议（查看 see section <a href="#TCP_002fIP-Networking">利用 <code>gawk</code> 进行网络通信</a>）。
</li></ul>

</li><li>
语言中的更改与/或者添加：

<ul class="no-bullet">
<li>-
&lsquo;<samp>\x</samp>&rsquo; 转义序列（查看 see section <a href="#Escape-Sequences">转义序列</a>）。

</li><li>-
完全地支持 POSIX 与 GNU 正则表达式（查看 see section <a href="#Regexp">正则表达式</a>）。

</li><li>-
<code>FS</code> 与 <code>split()</code> 的第三个参数可以为空串（查看 see section <a href="#Single-Character-Fields">各字符皆为分隔符</a>）。

</li><li>-
可以设置 <code>RS</code> 为正则表达式（查看 see section <a href="#Records">输入如何拆分为记录</a>）。

</li><li>-
可以在 <code>awk</code> 程序源代码中使用八进制与十六进制（查看 see section <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>）。

</li><li>-
使用 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符来与并程进行双向 I/O 通信（查看 see section <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>）。

</li><li>-
间接函数调用（查看 see section <a href="#Indirect-Calls">间接函数调用</a>）。

</li><li>-
在命令行上输入目录会导致警告产生，但会跳过（查看 see section <a href="#Command_002dline-directories">命令行中的目录</a>）。
</li></ul>

</li><li>
新的关键字：

<ul class="no-bullet">
<li>-
<code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式（查看 see section <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>）。

</li><li>-
<code>switch</code> 语句（查看 see section <a href="#Switch-Statement"><code>switch</code> 语句</a>）。
</li></ul>

</li><li>
对标准 <code>awk</code> 函数的改变：

<ul class="no-bullet">
<li>-
<code>close()</code> 函数的第二个可选参数可以关闭到并程的双向管道的一端（查看 see section <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>）。

</li><li>-
使用 &lsquo;<samp>--posix</samp>&rsquo; 时，<code>gsub()</code> 与 <code>sub()</code> 与 POSIX 兼容。

</li><li>-
<code>length()</code> 函数接受一个数组作为参数并返回数组中元素的个数（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>-
<code>match()</code> 函数的第三个可选参数用于捕获在正则表达式中的文本匹配子表达式（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>-
在 <code>printf</code> 格式中的位置指定符用来简化翻译（查看 see section <a href="#Printf-Ordering">重排 <code>printf</code> 参数</a>）。

</li><li>-
<code>split()</code> 函数的额外可选的第四个参数，是用来存放域分隔文本的数组（查看 see section <a href="#String-Functions">字串操作函数</a>）。
</li></ul>

</li><li>
<code>gawk</code> 中的额外函数：

<ul class="no-bullet">
<li>-
<code>gensub()</code>，<code>patsplit()</code> 与 <code>strtonum()</code> 使得文本操作更加强大（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>-
<code>asort()</code> 与 <code>asorti()</code> 函数用来对数组排序（查看 see section <a href="#Array-Sorting">控制数组排序与遍历</a>）。

</li><li>-
<code>mktime()</code>，<code>systime()</code> 与 <code>strftime()</code> 用来处理时间戳（查看 see section <a href="#Time-Functions">时间函数</a>）。

</li><li>-
<code>and()</code>，<code>compl()</code>，<code>lshift()</code>，<code>or()</code>，<code>rshift()</code>，与 <code>xor()</code> 函数用来处理位操作（查看 see section <a href="#Bitwise-Functions">位操作函数</a>）。

</li><li>-
<code>isarray</code> 函数用来检查一个变量是否为数组（查看 see section <a href="#Type-Functions">获取类型信息</a>）。

</li><li>-
<code>bindtextdomain()</code>，<code>dcgettext()</code>，与 <code>dcngettext()</code> 函数用于国际化（查看 see section <a href="#Programmer-i18n"><code>awk</code> 程序的国际化</a>）。
</li></ul>

</li><li>
命令行中的改变与/或者添加

<ul class="no-bullet">
<li>-
<code>AWKPATH</code> 环境变量用来指定 &lsquo;<samp>-f</samp>&rsquo; 命令选项的搜索路径（查看 see section <a href="#Options">命令行参数</a>）。

</li><li>-
<code>AWKLIBPATH</code> 环境变量用来指定 &lsquo;<samp>-l</samp>&rsquo; 命令行选项的搜索路径（查看 see section <a href="#Options">命令行参数</a>）。

</li><li>-
&lsquo;<samp>-b</samp>&rsquo;,
&lsquo;<samp>-c</samp>&rsquo;,
&lsquo;<samp>-C</samp>&rsquo;,
&lsquo;<samp>-d</samp>&rsquo;,
&lsquo;<samp>-D</samp>&rsquo;,
&lsquo;<samp>-e</samp>&rsquo;,
&lsquo;<samp>-E</samp>&rsquo;,
&lsquo;<samp>-g</samp>&rsquo;,
&lsquo;<samp>-h</samp>&rsquo;,
&lsquo;<samp>-i</samp>&rsquo;,
&lsquo;<samp>-l</samp>&rsquo;,
&lsquo;<samp>-L</samp>&rsquo;,
&lsquo;<samp>-M</samp>&rsquo;,
&lsquo;<samp>-n</samp>&rsquo;,
&lsquo;<samp>-N</samp>&rsquo;,
&lsquo;<samp>-o</samp>&rsquo;,
&lsquo;<samp>-O</samp>&rsquo;,
&lsquo;<samp>-p</samp>&rsquo;,
&lsquo;<samp>-P</samp>&rsquo;,
&lsquo;<samp>-r</samp>&rsquo;,
&lsquo;<samp>-S</samp>&rsquo;,
&lsquo;<samp>-t</samp>&rsquo;,
与
&lsquo;<samp>-V</samp>&rsquo;
短选项。同时也可以使用 GNU 风格的长选项。这些选项以 &lsquo;<samp>--</samp>&rsquo; 开始，
&lsquo;<samp>--assign</samp>&rsquo;,
&lsquo;<samp>--bignum</samp>&rsquo;,
&lsquo;<samp>--characters-as-bytes</samp>&rsquo;,
&lsquo;<samp>--copyright</samp>&rsquo;,
&lsquo;<samp>--debug</samp>&rsquo;,
&lsquo;<samp>--dump-variables</samp>&rsquo;,
&lsquo;<samp>--exec</samp>&rsquo;,
&lsquo;<samp>--field-separator</samp>&rsquo;,
&lsquo;<samp>--file</samp>&rsquo;,
&lsquo;<samp>--gen-pot</samp>&rsquo;,
&lsquo;<samp>--help</samp>&rsquo;,
&lsquo;<samp>--include</samp>&rsquo;,
&lsquo;<samp>--lint</samp>&rsquo;,
&lsquo;<samp>--lint-old</samp>&rsquo;,
&lsquo;<samp>--load</samp>&rsquo;,
&lsquo;<samp>--non-decimal-data</samp>&rsquo;,
&lsquo;<samp>--optimize</samp>&rsquo;,
&lsquo;<samp>--posix</samp>&rsquo;,
&lsquo;<samp>--pretty-print</samp>&rsquo;,
&lsquo;<samp>--profile</samp>&rsquo;,
&lsquo;<samp>--re-interval</samp>&rsquo;,
&lsquo;<samp>--sandbox</samp>&rsquo;,
&lsquo;<samp>--source</samp>&rsquo;,
&lsquo;<samp>--traditional</samp>&rsquo;,
&lsquo;<samp>--use-lc-numeric</samp>&rsquo;,
与
&lsquo;<samp>--version</samp>&rsquo;
是相应的长选项（查看 see section <a href="#Options">命令行参数</a>）。
</li></ul>


</li><li>
支持下面的下面过时系统的被从 <code>gawk</code> 4.0 版本的代码与文档中移除。

<ul class="no-bullet">
<li>-
Amiga

</li><li>-
Atari

</li><li>-
BeOS

</li><li>-
Cray

</li><li>-
MIPS RiscOS

</li><li>-
MS-DOS with the Microsoft Compiler

</li><li>-
MS-Windows with the Microsoft Compiler

</li><li>-
NeXT

</li><li>-
SunOS 3.x, Sun 386 (Road Runner)

</li><li>-
Tandem (non-POSIX)

</li><li>-
Prestandard VAX C compiler for VAX/VMS

</li><li>-
GCC for VAX and Alpha has not been tested for a while.

</li></ul>

</li><li>
支持下面过时系统从 <code>gawk</code> 4.1 版本中被移除了。

<ul class="no-bullet">
<li>-
Ultrix
</li></ul>

</li></ul>



<hr>
<a name="Feature-History"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#POSIX_002fGNU" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Common-Extensions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-c_0089_00b9ae_0080_00a7aa_008e_0086aa_008f_00b2"></a>
<h2 class="appendixsec">A.6 <code>gawk</code> 特性历史</h2>



<p>这一小节描述存在 <code>gawk</code> 但是不在 POSIX <code>awk</code> 中的特性，安它们加入到 <code>gawk</code> 中的顺序进行排序。
</p>
<p><code>gawk</code> 2.10 版本引入了下面的特性：
</p>
<ul>
<li>
<code>AWKPATH</code> 环境变量用于指针 &lsquo;<samp>-f</samp>&rsquo; 命令行选项指定搜索路径（查看 see section <a href="#Options">命令行参数</a>）。

</li><li>
<code>IGNORECASE</code> 变量及其效果（查看 see section <a href="#Case_002dsensitivity">匹配时的大小写</a>）。

</li><li>
&lsquo;<tt>/dev/stdin</tt>&rsquo;，&lsquo;<tt>/dev/stdout</tt>&rsquo;，&lsquo;<tt>/dev/stderr</tt>&rsquo; 与
&lsquo;<tt>/dev/fd/<var>N</var></tt>&rsquo; 特殊文件名（查看 see section <a href="#Special-Files"><code>gawk</code> 中的特殊文件名</a>）。
</li></ul>

<p><code>gawk</code> 2.13 版本引入了下面的特性：
</p>
<ul>
<li>
<code>FIELDWIDTHS</code> 变量与其效果（查看 see section <a href="#Constant-Size">读取固定宽度数据</a>）。

</li><li>
<code>systime()</code> 与 <code>strftime()</code> 内置函数用来获取及打印时间戳（查看 see section <a href="#Time-Functions">时间函数</a>）。

</li><li>
额外的命令选项（查看 see section <a href="#Options">命令行参数</a>）：

<ul class="no-bullet">
<li>-
&lsquo;<samp>-W lint</samp>&rsquo; 选项用于提供源代码与运行时的错误与可移植性检测。

</li><li>-
&lsquo;<samp>-W compat</samp>&rsquo; 兼容选项用来关闭 GNU 扩展。

</li><li>-
&lsquo;<samp>-W posix</samp>&rsquo; 选项用来实现完全的 POSIX 兼容。
</li></ul>
</li></ul>

<p>2.14 版本的 <code>gawk</code> 引入了下面的特性：
</p>
<ul>
<li>
<code>nextfile</code> 语句用来跳到下一个数据文件（查看 see section <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>）。
</li></ul>

<p>2.15 版本 <code>gawk</code> 引入了下面的特性：
</p>
<ul>
<li>
新的变量（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）：

<ul class="no-bullet">
<li>-
<code>ARGIND</code> 用来跟踪 <code>ARGV</code> 中的 <code>FILENAME</code> 的移动。

</li><li>-
<code>ERRNO</code> 在 <code>getline</code> 返回 -1 或者 <code>close()</code> 失败时包含了系统的错误信息。
</li></ul>

</li><li>
&lsquo;<tt>/dev/pid</tt>&rsquo;，&lsquo;<tt>/dev/ppid</tt>&rsquo;，&lsquo;<tt>/dev/pgrpid</tt>&rsquo;，与
&lsquo;<tt>/dev/user</tt>&rsquo; 特殊文件名，这些已经被移除。

</li><li>
可以使用一次 &lsquo;<samp>delete <var>array</var></samp>&rsquo; 来删除数组中的所有元素（查看 see section <a href="#Delete"><code>delete</code> 语句</a>）。

</li><li>
命令行选项变化 （查看 see section <a href="#Options">命令行参数</a>）：

<ul class="no-bullet">
<li>-
可以使用 GNU 风格的以 &lsquo;<samp>--</samp>&rsquo; 开始的长选项。

</li><li>-
通过 &lsquo;<samp>--source</samp>&rsquo; 选项来混合命令行与库文件源代码。
</li></ul>
</li></ul>

<p>3.0 版本的 <code>gawk</code> 引入了下面的特性：
</p>
<ul>
<li>
新的或者变化了的变量：

<ul class="no-bullet">
<li>-
<code>IGNORECASE</code> 已经变化，现在可以用于字串比较以及正则表达式操作（查看 see section <a href="#Case_002dsensitivity">匹配时的大小写</a>）。

</li><li>-
<code>RT</code> 其中包含了输入中匹配 <code>RS</code> 的文本（查看 see section <a href="#Records">输入如何拆分为记录</a>）。
</li></ul>

</li><li>
完全支持 POSIX 与 GNU 正则表达式（查看 see section <a href="#Regexp">正则表达式</a>）。

</li><li>
<code>gensub()</code> 函数可以实现更强大的文本操作（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>
<code>strftime()</code> 函数需要一个默认的时间格式，可以不用参数就可以调用（查看 see section <a href="#Time-Functions">时间函数</a>）。

</li><li>
<code>FS</code> 与 <code>split()</code> 函数的第三个参数可以是空串（查看 see section <a href="#Single-Character-Fields">各字符皆为分隔符</a>）。

</li><li>
<code>RS</code> 可以是一个正则表达式（查看 see section <a href="#Records">输入如何拆分为记录</a>）。

</li><li>
<code>next file</code> 语句变成 <code>nextfile</code>（查看 see section <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>）。

</li><li>
来自于 BWK <code>awk</code> 的 <code>fflush()</code> 函数（当时在 Bell Laboratories，查看 see section <a href="#I_002fO-Functions">输入输出函数</a>）。

</li><li>
新的命令行选项：

<ul class="no-bullet">
<li>-
&lsquo;<samp>--lint-old</samp>&rsquo; 选项来警告在初始的 Version 7 Unix 版本中的 <code>awk</code> 中不支持的结构（查看 see section <a href="#V7_002fSVR3_002e1">在 V7 与 SVR3.1 之间的变化</a>）。

</li><li>-
来自于 BWK <code>awk</code> 的 &lsquo;<samp>-m</samp>&rsquo; 选项。（Brian 那个时候还是在 Bell Laboratories）之后从他的 <code>awk</code> 与 <code>gawk</code> 中都移除了。

</li><li>-
&lsquo;<samp>--re-interval</samp>&rsquo; 选项用来提供在正则表达式中提供区间表达式（查看 see section <a href="#Regexp-Operators">正则表达式操作符</a>）。

</li><li>-
&lsquo;<samp>--traditional</samp>&rsquo; 选项添加成为 &lsquo;<samp>--compat</samp>&rsquo; 更好的名字（查看 see section <a href="#Options">命令行参数</a>）。
</li></ul>

</li><li>
使用 GNU Autoconf 来控制配置过程（查看 see section <a href="#Quick-Installation">为 Unix-like 的系统编译 <code>gawk</code></a>）。

</li><li>
支持 Amiga。这已经被移除了。

</li></ul>

<p>3.1 版本的 <code>gawk</code> 引入了下面的特性：
</p>
<ul>
<li>
新的变量（查看 see section <a href="#Built_002din-Variables">预定义变量</a>）：

<ul class="no-bullet">
<li>-
<code>BINMODE</code> ，来自于非 POSIX 系统，可以用于二进制 I/O 输入输出文件（查看 see section <a href="#PC-Using">在 PC 操作系统上使用 <code>gawk</code></a>）。

</li><li>-
<code>LINT</code> 用来动态地控制 lint 告警。

</li><li>-
<code>PROCINFO</code> 是提供了进程相关信息的数组。

</li><li>-
<code>TEXTDOMAIN</code> 用来设置程序的国际化文件域（查看 see section <a href="#Internationalization"><code>gawk</code> 的国际化</a>）。
</li></ul>

</li><li>
可以在 <code>awk</code> 程序源代码中使用八进制与十六进制（查看 see section <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>）。

</li><li>
使用 &lsquo;<samp>|&amp;</samp>&rsquo; 来与并程进行双路 I/O（查看 see section <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>）。

</li><li>
使用 &lsquo;<tt>/inet</tt>&rsquo; 以及 &lsquo;<samp>|&amp;</samp>&rsquo; 特殊文件来进行 TCP/IP 网络通信（查看 see section <a href="#TCP_002fIP-Networking">利用 <code>gawk</code> 进行网络通信</a>）。

</li><li>
<code>close()</code> 第二个可选参数可以用于关闭到并程的双向管道的一端（查看 see section <a href="#Two_002dway-I_002fO">与其他进程进行双向通信</a>）。

</li><li>
<code>match()</code> 函数的第三个可选参数用于捕获正则表达式中的文本匹配子表达式（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>
<code>printf</code> 格式中的位置指定符用于使国际化更为简单（查看 see section <a href="#Printf-Ordering">重排 <code>printf</code> 参数</a>）。

</li><li>
多个新的内置函数：

<ul class="no-bullet">
<li>-
<code>asort()</code> 与 <code>asorti()</code> 函数用于排序数组（查看 see section <a href="#Array-Sorting">控制数组排序与遍历</a>）。

</li><li>-
<code>bindtextdomain()</code>，<code>dcgettext()</code> 与 <code>dcngettext()</code> 函数用于国际化（查看 see section <a href="#Programmer-i18n"><code>awk</code> 程序的国际化</a>）。

</li><li>-
<code>extension()</code> 函数以及动态添加新的内置函数（查看 see section <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>）。

</li><li>-
<code>mktime()</code> 函数用于创建时间戳（查看 see section <a href="#Time-Functions">时间函数</a>）。

</li><li>-
<code>and()</code>，<code>or()</code>，<code>xor()</code>，<code>compl()</code>，<code>lshift()</code>，<code>rshift()</code> 与 <code>strtonum()</code> 函数（查看 see section <a href="#Bitwise-Functions">位操作函数</a>）。
</li></ul>

</li><li>
<a name="index-next-file-statement"></a>
支持 &lsquo;<samp>next file</samp>&rsquo; 为两个单词的语句已经完全移除（查看 see section <a href="#Nextfile-Statement"><code>nextfile</code> 语句</a>）。

</li><li>
额外的命令行选项（查看 see section <a href="#Options">命令行参数</a>）：

<ul class="no-bullet">
<li>-
&lsquo;<samp>--dump-variables</samp>&rsquo; 选项用于打印所有的全局变量的列表。

</li><li>-
&lsquo;<samp>--exec</samp>&rsquo; 选项用于 CGI 脚本。

</li><li>-
&lsquo;<samp>--gen-po</samp>&rsquo; 命令选项以及前置下划线的使用来标志要被翻译的字串（查看 see section <a href="#String-Extraction">提取已标志字串</a>）。

</li><li>-
&lsquo;<samp>--non-decimal-data</samp>&rsquo; 选项可以输入非十进制数（查看 see section <a href="#Nondecimal-Data">允许非十进制数数据输入</a>）。

</li><li>-
&lsquo;<samp>--profile</samp>&rsquo; 选项以及 <code>pgawk</code>（<code>gawk</code> 的 profiling 版本）用于产生 <code>awk</code> 程序的执行统计（查看 see section <a href="#Profiling">测评你的 <code>awk</code> 程序</a>）。

</li><li>-
&lsquo;<samp>--use-lc-numeric</samp>&rsquo; 选项强制 <code>gawk</code> 使用本地语言的十进制数小数点来分析输入数据（查看 see section <a href="#Conversion">在字串与数值之间进行转换</a>）。
</li></ul>

</li><li>
使用 GNU Automake 来辅助配置过程的标准化（查看 see section <a href="#Quick-Installation">为 Unix-like 的系统编译 <code>gawk</code></a>）。

</li><li>
使用 GNU 的 <code>gettext</code> 来作为 <code>gawk</code> 自己的消息输出（查看 see section <a href="#Gawk-I18N"><code>gawk</code> 可以说你的语言</a>）。

</li><li>
BeOS 支持。后面被移除了。

</li><li>
Tandem 支持。后面被移除了。

</li><li>
Atari 移植版本不被官方支持后面整个地移除了。

</li><li>
源代码改成使用 ISO C 标准风格的函数定义。

</li><li>
POSIX 兼容 <code>sub()</code> 与 <code>gsub()</code>（查看 see section <a href="#Gory-Details"><code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a>）。

</li><li>
<code>length()</code> 函数被扩展为接受数组参数，并返回数组中元素的个数（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>
<code>strftime()</code> 函数需要第三个参数来启用打印 UTC 时间（查看 see section <a href="#Time-Functions">时间函数</a>）。
</li></ul>

<p><code>gawk</code> 4.0 版本引入了下面的特性：
</p>
<ul>
<li>
添加的变量：

<ul class="no-bullet">
<li>-
<code>FPAT</code> 可以让你指定一个正则表达式来匹配域，而不是匹配域分隔符（查看 see section <a href="#Splitting-By-Content">以内容定义域</a>）。

</li><li>-
如果存在 <code>PROCINFO[&quot;sorted_in&quot;]</code>，则 &lsquo;<samp>for(iggy in foo)</samp>&rsquo; 循环会在循环开始之前对索引排序。这个元素的值提供在循环遍历开始之前控制如何来对索引来进行排序（查看 see section <a href="#Controlling-Scanning">在 <code>gawk</code> 中使用预定义的数组遍历顺序</a>）。

</li><li>-
<code>PROCINFO[&quot;strftime&quot;]</code> 用于保存 <code>strftime()</code> 的默认格式（查看 see section <a href="#Time-Functions">时间函数</a>）。
</li></ul>

</li><li>
移除特殊文件 &lsquo;<tt>/dev/pid</tt>&rsquo;，&lsquo;<tt>/dev/ppid</tt>&rsquo;，&lsquo;<tt>/dev/pgrpid</tt>&rsquo; 与 &lsquo;<tt>/dev/user</tt>&rsquo;。

</li><li>
通过 &lsquo;<tt>/inet6</tt>&rsquo; 特殊文件来支持 IPv6。&lsquo;<tt>/inet4</tt>&rsquo; 强制使用 IPv4，而 &lsquo;<tt>/inet</tt>&rsquo; 则使用系统默认的协议，一般是 IPv4（查看 see section <a href="#TCP_002fIP-Networking">利用 <code>gawk</code> 进行网络通信</a>）。

</li><li>
在正则表达式中使用 &lsquo;<samp>\s</samp>&rsquo; 与 &lsquo;<samp>\S</samp>&rsquo; 转换序列（查看 see section <a href="#GNU-Regexp-Operators">特定于 <code>gawk</code> 的正则表达式操作符</a>）。

</li><li>
区间表达式成为默认正则表达式的一部份（查看 see section <a href="#Regexp-Operators">正则表达式操作符</a>）。

</li><li>
即使使用 &lsquo;<samp>--traditional</samp>&rsquo; 情况下，也可以使用 POSIX 字符类型（查看 see section <a href="#Regexp-Operators">正则表达式操作符</a>）。

</li><li>
<code>break</code> 与 <code>continue</code> 在循环外不再有效，即使使用 &lsquo;<samp>--traditional</samp>&rsquo; 选项（查看 see section <a href="#Break-Statement"><code>break</code> 语句</a>，以及 <a href="#Continue-Statement"><code>continue</code> 语句</a>）。

</li><li>
<code>fflush()</code>，<code>nextfile</code>，与 &lsquo;<samp>delete <var>array</var></samp>&rsquo; 在使用 &lsquo;<samp>--posix</samp>&rsquo; 或者 &lsquo;<samp>--traditional</samp>&rsquo; 选项下也是允许的，因此它们已经是 POSIX 标准的一部分。

</li><li>
<code>asort()</code> 与 <code>asorti()</code> 函数有可选的第三个参数，用于指定如何来排序（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>
<code>fflush()</code> 的行为已经改成与 BWK <code>awk</code> 以及 POSIX 匹配，现在 &lsquo;<samp>fflush()</samp>&rsquo; 与 &lsquo;<samp>fflush(&quot;&quot;)</samp>&rsquo; 会刷出所有的重定向输出（查看 see section <a href="#I_002fO-Functions">输入输出函数</a>）。

</li><li>
<code>isarray()</code> 函数可以用于识别某个项是否为数组，这样可以来用于进行数组之数组的遍历（查看 see section <a href="#Type-Functions">获取类型信息</a>）。

</li><li>
<code>patsplit()</code> 函数可以有与 <code>FPAT</code> 一样的分割能力（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>
<code>split()</code> 函数的第四个可选参数是用于存放分割符的数组（查看 see section <a href="#String-Functions">字串操作函数</a>）。

</li><li>
数组之数组（查看 see section <a href="#Arrays-of-Arrays">多维数组</a>）。

</li><li>
<code>BEGINFILE</code> 与 <code>ENDFILE</code> 特定规则（查看 see section <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>）。

</li><li>
间接函数调用（查看 see section <a href="#Indirect-Calls">间接函数调用</a>）。

</li><li>
<code>switch</code> / <code>case</code> 默认情况下是启用的（查看 see section <a href="#Switch-Statement"><code>switch</code> 语句</a>）。

</li><li>
改变的命令行选项（查看 see section <a href="#Options">命令行参数</a>）：

<ul class="no-bullet">
<li>-
&lsquo;<samp>-b</samp>&rsquo; 与 &lsquo;<samp>--characters-as-bytes</samp>&rsquo; 选项用来防止 <code>gawk</code> 将输入当成多字节字串来处理。

</li><li>-
多余的 &lsquo;<samp>--compat</samp>&rsquo;，&lsquo;<samp>--copyleft</samp>&rsquo; 与 &lsquo;<samp>--usage</samp>&rsquo; 长选项已经被移除。

</li><li>-
&lsquo;<samp>--gen-po</samp>&rsquo; 选项最后被改名为 &lsquo;<samp>--gen-pot</samp>&rsquo;。

</li><li>-
&lsquo;<samp>--sandbox</samp>&rsquo; 选项可以禁用特定的特性。

</li><li>-
所有的长选项都需要有相应的短选项，以用于 &lsquo;<samp>#!</samp>&rsquo; 脚本。
</li></ul>

</li><li>
在命令行上输入了目录名现在会产生告警，而不是致命错误。除非使用了 &lsquo;<samp>--posix</samp>&rsquo; 或者 &lsquo;<samp>--traditional</samp>&rsquo; 选项（查看 see section <a href="#Command_002dline-directories">命令行中的目录</a>）。

</li><li>
重写了 <code>gawk</code> 区间表达式，引入了 <code>dgawk</code> 的调试器，并增强了一些性能（查看 see section <a href="#Debugger">调试 <code>awk</code> 程序</a>）。

</li><li>
根据 GNU 编码标准，动态扩展必须要定义一个全局符号来指示它们是使用 GPL 兼容的协议（查看 see section <a href="#Plugin-License">扩展许可</a>）。

</li><li>
在 POSIX 模式下，使用 <code>strcoll()</code> / <code>wcscoll()</code> 来进行字串比较（查看 see section <a href="#POSIX-String-Comparison">POSIX 中的字串比较规则</a>）。

</li><li>
用于进行原生 Socket 通信的选项被移除了，因为它从来没有被实现（查看 see section <a href="#TCP_002fIP-Networking">利用 <code>gawk</code> 进行网络通信</a>）。

</li><li>
&lsquo;<samp>[d-h]</samp>&rsquo; 形式的范围会被当成在 C 语言设置中一样对待，不管使用的是什么样的正则表达式，即使使用了 &lsquo;<samp>--posix</samp>&rsquo;（查看 see section <a href="#Ranges-and-Locales">正则表达式范围与本地语言设置：又臭又长陈年旧事</a>）。

</li><li>
对下面系统的支持被移除了：

<ul class="no-bullet">
<li>-
Atari

</li><li>-
Amiga

</li><li>-
BeOS

</li><li>-
Cray

</li><li>-
MIPS RiscOS

</li><li>-
MS-DOS with Microsoft Compiler

</li><li>-
MS-Windows with Microsoft Compiler

</li><li>-
NeXT

</li><li>-
SunOS 3.x, Sun 386 (Road Runner)

</li><li>-
Tandem (non-POSIX)

</li><li>-
Prestandard VAX C compiler for VAX/VMS
</li></ul>
</li></ul>

<p>4.1 版本的 <code>gawk</code> 引入了下面的特性：
</p>
<ul>
<li>
新加了三个变量：<code>SYMTAB</code>，<code>FUNCTAB</code>，以及 <code>PROCINFO[&quot;identifiers&quot;]</code>（查看 see section <a href="#Auto_002dset">传递信息的内置变量</a>）。

</li><li>
<code>gawk</code>，<code>pgawk</code> 与 <code>dgawk</code> 被整合为一，并命名为 <code>gawk</code>。因为仅是命令行选项有变化。

</li><li>
改变的命令行（查看 see section <a href="#Options">命令行参数</a>）：

<ul class="no-bullet">
<li>-
&lsquo;<samp>-D</samp>&rsquo; 选项用来调用调试器。

</li><li>-
&lsquo;<samp>-i</samp>&rsquo; 与 &lsquo;<samp>--include</samp>&rsquo; 选项用于载入 <code>awk</code> 库文件。

</li><li>-
&lsquo;<samp>-l</samp>&rsquo; 与 &lsquo;<samp>--load</samp>&rsquo; 选项用于载入编译好的动态扩展。

</li><li>-
&lsquo;<samp>-M</samp>&rsquo; 与 &lsquo;<samp>--bignum</samp>&rsquo; 选项用于启用 <code>MPFR</code>。

</li><li>-
&lsquo;<samp>-o</samp>&rsquo; 选项用于简洁打印。

</li><li>-
&lsquo;<samp>-p</samp>&rsquo; 选项用于性能统计。

</li><li>-
移除了 &lsquo;<samp>-R</samp>&rsquo; 选项。
</li></ul>

</li><li>
支持 <code>MPFR</code> 来支持高精度算术计算。（查看 see section <a href="#Arbitrary-Precision-Arithmetic">算术运算与 <code>gawk</code> 中的任意精度算术运算</a>）。

</li><li>
<code>and()</code>，<code>or()</code> 与 <code>xor()</code> 函数更改成可以接受任意数量的参数，最小为两个（查看 see section <a href="#Bitwise-Functions">位操作函数</a>）。

</li><li>
动态扩展接口完全全进行了重构（查看 see section <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>）。

</li><li>
在 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 规则中也允许重定向的 <code>getline</code>（查看 see section <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>）。

</li><li>
<code>where</code> 命令被添加到了调试器中（查看 see section <a href="#Execution-Stack">程序栈</a>）。

</li><li>
移除了 Ultrix。

</li></ul>


<hr>
<a name="Common-Extensions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Feature-History" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Ranges-and-Locales" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0080_009ac_0094_00a8ae_0089_00a9aa_00b1_0095ae_00b1_0087ae_0080_00bb"></a>
<h2 class="appendixsec">A.7 通用扩展汇总</h2>

<a name="index-extensions_002c-Brian-Kernighan_0027s-awk-1"></a>
<a name="index-extensions_002c-mawk"></a>
<p>下面的表中归纳了由 <code>gawk</code>，Brian Kernighan <code>awk</code> 与 <code>mawk</code> 所支持的通用扩展。这是三个用得最多，并且可以自由获取的 <code>awk</code> 版本（查看 see section <a href="#Other-Versions">其他可自由获取的 <code>awk</code></a>）。
</p>
<table>
<thead><tr><th>Feature</th><th>BWK <code>awk</code></th><th><code>mawk</code></th><th><code>gawk</code></th><th>目前标准</th></tr></thead>
<tr><td>&lsquo;<samp>\x</samp>&rsquo; 转义序列</td><td>X</td><td>X</td><td>X</td><td></td></tr>
<tr><td><code>FS</code> 为空串</td><td>X</td><td>X</td><td>X</td><td></td></tr>
<tr><td>&lsquo;<tt>/dev/stdin</tt>&rsquo; 特殊文件</td><td>X</td><td>X</td><td>X</td><td></td></tr>
<tr><td>&lsquo;<tt>/dev/stdout</tt>&rsquo; 特殊文件</td><td>X</td><td>X</td><td>X</td><td></td></tr>
<tr><td>&lsquo;<tt>/dev/stderr</tt>&rsquo; 特殊文件</td><td>X</td><td>X</td><td>X</td><td></td></tr>
<tr><td><code>delete</code> 不需要下标的数组</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
<tr><td><code>fflush()</code> 函数</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
<tr><td><code>length()</code> 的数组版本</td><td>X</td><td>X</td><td>X</td><td></td></tr>
<tr><td><code>nextfile</code> 语句</td><td>X</td><td>X</td><td>X</td><td>X</td></tr>
<tr><td><code>**</code> 和 <code>**=</code> 操作符</td><td>X</td><td></td><td>X</td><td></td></tr>
<tr><td><code>func</code> 关键字</td><td>X</td><td></td><td>X</td><td></td></tr>
<tr><td><code>BINMODE</code> 变量</td><td></td><td>X</td><td>X</td><td></td></tr>
<tr><td><code>RS</code> 可为正则表达式</td><td></td><td>X</td><td>X</td><td></td></tr>
<tr><td>时间相关函数</td><td></td><td>X</td><td>X</td><td></td></tr>
</table>

<hr>
<a name="Ranges-and-Locales"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Common-Extensions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Contributors" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fe_008c_0083aa_009b_00b4a_00b8_008eae_009c_00acaa_009c_00b0e_00af_00ade_00a8_0080e_00ae_00bec_00bd_00aei_00bc_009aaa_008f_0088e_0087_00adaa_008f_0088e_0095_00bfe_0099_0088aa_00b9_00b4ae_0097_00a7a_00ba_008b"></a>
<h2 class="appendixsec">A.8 正则表达式范围与本地语言设置：又臭又长陈年旧事</h2>

<p>这一小节描述的是正则表达式与本地语言设置之间的混乱的历史时期，以及其如何影响不同版本的 <code>gawk</code>。
</p>
<p>最初的 Unix 的正则表达式工具所定义的字符范围（如 &lsquo;<samp>[a-z]</samp>&rsquo;）用于匹配第一个字符到最后一个字符之间的字符（含）。其顺序基于每个字符在机器的本地字符集的数值值。所以，在基于 ASCII 的系统上，&lsquo;<samp>[a-z]</samp>&rsquo; 匹配所有的小字字母，因为这些从 &lsquo;<samp>a</samp>&rsquo; 到 &lsquo;<samp>z</samp>&rsquo; 之间数值值是连续的。（在 EBCDIC 系统上，&lsquo;<samp>[a-z]</samp>&rsquo; 这个范围也包含其他的非字母字符。）
</p>
<p>几乎所有的 Unix 基础讲义都说此类型的范围表达式都是可工作的，还特别教人们说，&lsquo;<samp>[a-z]</samp>&rsquo; 是用来匹配小写字母的“正确”方式，而 &lsquo;<samp>[A-Z]</samp>&rsquo; 则是匹配大写字母的“正确”方式。而实际上，这也是真的。 <a name="DOCF112" href="#FOOT112">(112)</a>
</p>
<p>1992 年 POSIX 标准引入了本地语言设置这样的点子（查看 see section <a href="#Locales">哪里造成差异</a>）。很多的本地语言除了包含英语表中的 26 个字母外，还包含其他的字母，POSIX 标准则添加了字符类（查看 see section <a href="#Bracket-Expressions">使用方括号表达式</a>）来匹配除了 ASCII 字符集中的传统字母之外的字符。
</p>
<p>但是，标准对于范围的解释也发生了<em>变化</em>。在 <code>&quot;C&quot;</code> 以及 <code>&quot;POSIX&quot;</code> 语言配置中，范围表达式如 &lsquo;<samp>[a-dx-z]</samp>&rsquo; 与 &lsquo;<samp>[abcdxyz]</samp>&rsquo; 是一样的，如在 <code>ASCII</code> 中的一样。但是在其他的语言设置中，顺序是按照<em>协同顺序</em>来进行定义的。
</p>
<p>这是什么意思呢？在很多的语言设置中，&lsquo;<samp>A</samp>&rsquo; 与 &lsquo;<samp>a</samp>&rsquo; 两者都小于 &lsquo;<samp>B</samp>&rsquo;。也就是说，这些语言设置会将用字典顺序来对字符进行排序，那么 &lsquo;<samp>[a-dx-z]</samp>&rsquo; 不再与 &lsquo;<samp>[abcdxyz]</samp>&rsquo; 等同了。相反，他有可能与 &lsquo;<samp>[ABCXYabcdxyz]</samp>&rsquo; 等同。
</p>
<p>还需要强调的是：很多的老师都教授用 &lsquo;<samp>[a-z]</samp>&rsquo; 来匹配小写字母。但是在非 ASCII 语言设置的系统上，这也会匹配所有的大写字母，不包括 &lsquo;<samp>A</samp>&rsquo; 或者 &lsquo;<samp>Z</samp>&rsquo;！这导致了持续的困惑，即使到了 21 世纪的今天。
</p>
<p>为了说明这个问题，下面的例子使用 <code>sub()</code> 函数来执行文件匹配（查看 see section <a href="#String-Functions">字串操作函数</a>）。这里，我们的目的是移除后面的大写字母：
</p>
<div class="example">
<pre class="example">$ <kbd>echo something1234abc | gawk-3.1.8 '{ sub(&quot;[A-Z]*$&quot;, &quot;&quot;); print }'</kbd>
-| something1234a
</pre></div>

<p>这个输出并不是所期望的，因为 &lsquo;<samp>bc</samp>&rsquo; 是 &lsquo;<samp>something1234abc</samp>&rsquo; 的结束串，不应该匹配 &lsquo;<samp>[A-Z]*</samp>&rsquo;。是本地语言设置导致了这样的结果（因此你可能在你的系统上看不这样的输出）。
</p>
<a name="index-Unicode-1"></a>
<p>其他范围也有类似的问题。如 &lsquo;<samp>[&quot;-/]</samp>&rsquo; 在 ASCII 中绝对有效，但是在很多的 Unicode 语言设置中，如 <code>en_US.UTF-8</code> 中就不是这样。
</p>
<p><code>gawk</code> 早期的版本使用的正则表达式代码对于语言设置是不敏感的，所以对于范围的解释是之前的做法。
</p>
<p>当 <code>gawk</code> 切换到使用语言设置敏感的正则表达式匹配器，问题就出现了。特别是在 GNU/Linux 与商业 Unix 的厂商开始实现非 <code>ASCII</code> 语言之后，<em>并使这些语言成为默认选项</em>。
也许 FAQ（frequently asked question）的问题已经变成这样，“为什么 &lsquo;<samp>[A-Z]</samp>&rsquo; 会匹配小写字母？！？”
</p>
<a name="index-Berry_002c-Karl-2"></a>
<p>这样的问题已经存在了近 10 年，如果不是更多的话。<code>gawk</code> 已经很好地支持标准，并处理好了用户本地语言的问题，<code>gawk</code> 的维护者对于解释这些问题都已经非常厌倦了。在开发 4.0 版本的过程中，他们修改了 <code>gawk</code>，使其总是按原来的方式对待范围，即在标准前的方式。除非吏用了 &lsquo;<samp>--posix</samp>&rsquo; 选项（查看 see section <a href="#Options">命令行参数</a>）。 
<a name="DOCF113" href="#FOOT113">(113)</a>
</p>
<p>幸运的是，最 <code>gawk</code> 4.0 发布不久，维护者了解到 2008 的标准已经更改了范围的定义，这样 <code>&quot;C&quot;</code> 与 <code>&quot;POSIX&quot;</code> 之外的语言设置，范围表达式的含义是<em>未定义</em>的。 
<a name="DOCF114" href="#FOOT114">(114)</a>
</p>
<p>由于使用了这么一个可爱的技术术语，标准给了实现者相应许可来自己选择实现范围的方式。<code>gawk</code> 维护者选择了使用 POSIX 标准之前的含义，而不论是默认的正则表达式匹配还是使用了 &lsquo;<samp>--traditional</samp>&rsquo; 或者 &lsquo;<samp>--posix</samp>&rsquo; 选项。在所有的情况下，<code>gawk</code> 都与 POSIX 标准是符合的。
</p>
<hr>
<a name="Contributors"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Ranges-and-Locales" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#History-summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-c_009a_0084a_00b8_00bbe_00a6_0081e_00b4_00a1c_008c_00aee_0080_0085"></a>
<h2 class="appendixsec">A.9 <code>gawk</code> 的主要贡献者</h2>
<a name="index-gawk_002c-list-of-contributors-to"></a>
<blockquote>
<p><i>
如果感谢是应该的就得感谢。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Anonymous</em>
</p>
<p>这一小节列出了 <code>gawk</code> 以及/或者本网页的主要贡献者，以大概年代前后顺序列出：
</p>
<ul>
<li>
<a name="index-Aho_002c-Alfred-1"></a>
<a name="index-Weinberger_002c-Peter-1"></a>
<a name="index-Kernighan_002c-Brian-7"></a>
Dr. Alfred V. Aho，Dr. Peter J. Weinberger，and Dr. Brian W. Kernighan，以及贝尔实验室中所有的设计与实现了 Unix <code>awk</code> 的人，从这些人中形成了 <code>awk</code> 的主要特性集合。
</li><li>
<a name="index-Rubin_002c-Paul-1"></a>
Paul Rubin
在 1986 年完成了最初的设计与实现，并写了本网页的第一稿（大概 40 页）。

</li><li>
<a name="index-Fenlason_002c-Jay-1"></a>
Jay Fenlason
完成了最初的实现。

</li><li>
<a name="index-Close_002c-Diane-1"></a>
Diane Close
修订了本网页的第一稿，达到了 90 多页。

</li><li>
<a name="index-Stallman_002c-Richard-2"></a>
Richard Stallman
帮助完成了最开始的实现，以及本网页初稿。他同时也是 FSF 与 GNU 项目的创建者。

</li><li>
<a name="index-Woods_002c-John"></a>
John Woods
贡献了 <code>gawk</code> 初始版本的部分代码（大部份是修复）。

</li><li>
<a name="index-Trueman_002c-David-2"></a>
1988 年，David Trueman
成为 <code>gawk</code> 的主要维护者，并使其与“新”的 <code>awk</code> 兼容，并极大地提高了性能。

</li><li>
<a name="index-Kwok_002c-Conrad"></a>
<a name="index-Garfinkle_002c-Scott"></a>
<a name="index-Williams_002c-Kent"></a>
Conrad Kwok，Scott Garfinkle，与 Kent Williams
使用不同版本的 MSC 完成了最初的向 MS-DOS 的移植。

</li><li>
<a name="index-Rankin_002c-Pat-2"></a>
Pat Rankin
提供了 VMS 的移植及其文档。

</li><li>
<a name="index-Peterson_002c-Hal"></a>
Hal Peterson
提供了移植 <code>gawk</code> 到 Cray Systems 的帮助。（当前已不再支持。）

</li><li>
<a name="index-Rommel_002c-Kai-Uwe"></a>
Kai Uwe Rommel
提供了 OS/2 的最初的移植版本及其文档。

</li><li>
<a name="index-Jaegermann_002c-Michal-1"></a>
Michal Jaegermann
提供了 Atari 系统的移植及其文档。（这个移植不再支持。）他持续提供了可移植性检查，并完成了相当多的工作，以确定 <code>gawk</code> 可以工作在非 32 位系统上。

</li><li>
<a name="index-Fish_002c-Fred"></a>
Fred Fish
提供了 Amiga 系统的移植及其文档。（随着 Fred 的去世，这也不再支持了。）

</li><li>
<a name="index-Deifik_002c-Scott-1"></a>
Scott Deifik
当前使用 <code>DJGPP</code> 维护 MS-DOS 的移植版。

</li><li>
<a name="index-Zaretskii_002c-Eli-1"></a>
Eli Zaretskii
当前使用 MinGW 维护 MS-Windows 的移植版。

</li><li>
<a name="index-Grigera_002c-Juan"></a>
Juan Grigera
提供了 Window32 系统的移植。（这已经不再支持。）

</li><li>
<a name="index-Hankerson_002c-Darrel-1"></a>
很多年以后，
Dr. Darrel Hankerson
作为不同 PC 平台的移植版本的协调者，并构建了不同 PC 操作系统上的二进制发布版本。它也维护不同 PC 平台上的文档，以保持文档的及时更新。

</li><li>
<a name="index-Zoulas_002c-Christos"></a>
Christos Zoulas
提供 <code>extension()</code> 内置函数用于动态添加新功能（这在 <code>gawk</code> 4.1 版本已经取消。）

</li><li>
<a name="index-Kahrs_002c-Jurgen-1"></a>
J&uuml;rgen Kahrs
贡献了最初的 TCP/IP 网络代码版本及其文档，并导致了 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符的加入。

</li><li>
<a name="index-Davies_002c-Stephen-1"></a>
Stephen Davies
提供了 Tandem 系统的最初移植版本及其文档。（但是，这也不再支持。）它也提交了最初的整合字节码实现到 <code>gawk</code> 代码库中的工作。

</li><li>
<a name="index-Woehlke_002c-Matthew"></a>
Matthew Woehlke
提供了 Tandem POSIX 兼容系统的增强。

</li><li>
<a name="index-Brown_002c-Martin"></a>
Martin Brown
提供了 <code>BeOS</code> 的移植版本及其文档。（已不再支持。）

</li><li>
<a name="index-Peters_002c-Arno"></a>
Arno Peters
做了初始工作来将 <code>gawk</code> 切换到 GNU Automake 以及 GNU <code>gettext</code>。

</li><li>
<a name="index-Broder_002c-Alan-J_002e"></a>
Alan J. Broder
提供了最初的 <code>asort()</code> 函数的版本，以及 <code>match()</code> 函数的第三个可选参数的代码。

</li><li>
<a name="index-Buening_002c-Andreas-1"></a>
Andreas Buening
更新了 <code>gawk</code> 的 OS/2 的移植版本。

</li><li>
<a name="index-Hasegawa_002c-Isamu"></a>
Isamu Hasegawa,
IBM 日本的 Isamu Hasegawa（长谷川勇）贡献了对多字节字符的支持。

</li><li>
<a name="index-Benzinger_002c-Michael"></a>
Michael Benzinger 贡献了 <code>switch</code> 语句的最初代码。

</li><li>
<a name="index-McPhee_002c-Patrick"></a>
Patrick T.J. McPhee 贡献了在 Windows32 环境下动态装载的代码。（不再支持。）

</li><li>
<a name="index-Wallin_002c-Anders"></a>
帮助维护了 VMS 移植版本多年。

</li><li>
<a name="index-Gordon_002c-Assaf"></a>
Assaf Gordon 
贡献了实现 &lsquo;<samp>--sandbox</samp>&rsquo; 选项的实现代码。

</li><li>
<a name="index-Haque_002c-John"></a>
John Haque 作了如下贡献:

<ul class="no-bullet">
<li>-
修改 <code>gawk</code>，将其切换为一个字节码解释器，及其调试器

</li><li>-
添加了真正的数组之数组

</li><li>-
其他修改以支持任意精度的算术运算

</li><li>-
<a href="#Arbitrary-Precision-Arithmetic">算术运算与 <code>gawk</code> 中的任意精度算术运算</a> 的初始文本

</li><li>-
将三个版本的 <code>gawk</code> 合并为一的工作，以配合 4.1 的发布

</li><li>-
增强了由整数进索引的数组的内部实现。

</li><li>-
增强了由 John 与 Pat Rankin 驱动的数组排序特性
</li></ul>

<a name="index-Papadopoulos_002c-Panos"></a>
</li><li>
Panos Papadopoulos 
贡献了 <a href="#Include-Files">在你的程序中包含其他的文件</a> 的初始文本。

</li><li>
<a name="index-Yawitz_002c-Efraim"></a>
Efraim Yawitz 贡献了 <a href="#Debugger">调试 <code>awk</code> 程序</a> 的初始文本。

</li><li>
<a name="index-Schorr_002c-Andrew-2"></a>
在 <code>gawk</code> 4.1 版本的扩展 <code>API</code> 的开发主要由 Arnold Robbins 与 Andrew Schorr 驱动，并在后面的开发团队中做了巨大的贡献。

<a name="index-Malmberg_002c-John-E_002e"></a>
</li><li>
John Malmberg 对于 OpenVMS 移植版及其文档做了巨大的贡献与增强。

</li><li>
<a name="index-Colombo_002c-Antonio-1"></a>
Antonio Giovanni Colombo 重写了之前章节中的很多例子，因为那些例子很多已经严重过时，我对其感谢不尽。

</li><li>
<a name="index-Robbins_002c-Arnold-5"></a>
Arnold Robbins
从 1988 年以来一直工作在 <code>gawk</code> 上，第一个协助 David Trueman，也是 1994 年以来的最主要的维护者。
</li></ul>

<hr>
<a name="History-summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Contributors" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-8"></a>
<h2 class="appendixsec">A.10 总结</h2>

<ul>
<li>
<code>awk</code> 语言已经发展了很久。第一个发布版本大约在 1978 年的 V7 Unix 系统上。在 System V Release 3.1 的 1987 年的时候，一些主要的新增功能，包含用户自定义函数已经加入到语言中。其他的改变在 1989 年的 System V Release 4 加入。从此之后，其他的次要的变量都在 POSIX 标准的框架下进行。

</li><li>
Brian Kernighan 的 <code>awk</code> 提供了一些扩展，并被实现为其他 <code>awk</code> 版本的通用扩展。

</li><li>
<code>gawk</code> 提供了大量的 POSIX <code>awk</code> 所没有的扩展。它们可以使用 &lsquo;<samp>--traditional</samp>&rsquo; 或者 &lsquo;<samp>--posix</samp>&rsquo; 选项来禁用。

</li><li>
<code>gawk</code> 中的 POSIX 本地语言设置与正则表达式匹配之间的纠葛一直让人困惑了好多年。现在，<code>gawk</code> 实现了“合理范围解释”，如此，&lsquo;<samp>[a-z]</samp>&rsquo; 这样的范围形式<em>只</em>匹配所在机器的本地字符集中的，数值在 &lsquo;<samp>a</samp>&rsquo; 到 &lsquo;<samp>z</samp>&rsquo; 之间的字符。字符集通常是 ASCII，但是在 IBM S/390 上可能是 EBCDIC。

</li><li>
很多人多来来对 <code>gawk</code> 的开发做出了贡献。 我们希望本章中所提供的列表是完整的，并在值得感谢的地方给予了相应的感谢。

</li></ul>

<hr>
<a name="Installation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#History-summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Gawk-Distribution" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_0089e_00a3_0085-gawk"></a>
<h1 class="appendix">Appendix B 安装 <code>gawk</code></h1>

<a name="index-operating-systems_002c-See-Also-GNU_002fLinux_002c-PC-operating-systems_002c-Unix"></a>
<a name="index-gawk_002c-installing"></a>
<a name="index-installing-gawk"></a>
<p>本附录提供了用于安装 <code>gawk</code> 到由开发者所支持的不同平台上的指导。主要的开发者支持 GNU/Linux（以及 Unix）平台，其他则由贡献决定。查看 <a href="#Bugs">报告问题与 BUG</a>，来获取维护相应移植版本的维护者的邮件。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Gawk-Distribution">B.1 <code>gawk</code> 发布版</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           What is in the <code>gawk</code> distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Unix-Installation">B.2 在 Unix-like 的系统上编译与安装 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Installing <code>gawk</code> under various
                                versions of Unix.
</td></tr>
<tr><td align="left" valign="top"><a href="#Non_002dUnix-Installation">B.3 安装到其他操作系统上</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       Installation on Other Operating Systems.
</td></tr>
<tr><td align="left" valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Reporting Problems and Bugs.
</td></tr>
<tr><td align="left" valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Other freely available <code>awk</code>
                                implementations.
</td></tr>
<tr><td align="left" valign="top"><a href="#Installation-summary">B.6 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Summary of installation.
</td></tr>
</table>

<hr>
<a name="Gawk-Distribution"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Getting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-aa_008f_0091aa_00b8_0083c_0089_0088"></a>
<h2 class="appendixsec">B.1 <code>gawk</code> 发布版</h2>
<a name="index-source-code_002c-gawk"></a>

<p>这一小节 描述如何来获取 <code>gawk</code> 发布版本，如何解释，并列出不同的文件以及子目录。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Getting">B.1.1 取得 <code>gawk</code> 发布版</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     How to get the distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extracting">B.1.2 提取发布版</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  How to extract the distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#Distribution-contents">B.1.3 <code>gawk</code> 发布版的内容</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       What is in the distribution.
</td></tr>
</table>

<hr>
<a name="Getting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Gawk-Distribution" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Gawk-Distribution" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extracting" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_008f_0096aa_00be_0097-gawk-aa_008f_0091aa_00b8_0083c_0089_0088"></a>
<h3 class="appendixsubsec">B.1.1 取得 <code>gawk</code> 发布版</h3>
<a name="index-gawk_002c-source-code_002c-obtaining"></a>
<p>有两个方式来获取 GNU 软件：
</p>
<ul>
<li>
从某人那里直接复制。

<a name="index-FSF-_0028Free-Software-Foundation_0029-1"></a>
<a name="index-Free-Software-Foundation-_0028FSF_0029-1"></a>
</li><li>
从 Internet 主机 <code>ftp.gnu.org</code> 中的目录 &lsquo;<tt>/gnu/gawk</tt>&rsquo; 中来取得 <code>gawk</code>。匿名的 <code>ftp</code> 与 <code>http</code> 访问都是受支持的。如果你有 <code>wget</code> 程序，你可以如下来使用命令：

<div class="example">
<pre class="example">wget http://ftp.gnu.org/gnu/gawk/gawk-4.1.4.tar.gz
</pre></div>
</li></ul>

<p>GNU 软件文档在全世界都有镜像。同步更新的镜像站点可以从 <a href="http://www.gnu.org/order/ftp.html">主 FSF 网站</a>上获取 。尝试其中一个镜像站点，如果不太忙，你可以使用一个离你近一点的站点。
</p>
<p>你也可以从官方 Git 仓库获取 <code>gawk</code> 的源代码；更多信息请看 <a href="#Accessing-The-Source">访问 <code>gawk</code> 的 Git 仓库</a>。
</p>
<hr>
<a name="Extracting"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Getting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Gawk-Distribution" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Distribution-contents" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008f_0090aa_008f_0096aa_008f_0091aa_00b8_0083c_0089_0088"></a>
<h3 class="appendixsubsec">B.1.2 提取发布版</h3>
<p><code>gawk</code> 的发布版本有内个 <code>tar</code> 文件并用不同的压缩程序进行压缩：<code>gzip</code>，<code>bzip2</code> 以及 <code>xz</code>。为简单起见，后面的说明假设你使用 GNU Gzip 程序进行压缩的（<code>gzip</code>）。
</p>
<p>只要有了发布片（如 &lsquo;<tt>gawk-4.1.4.tar.gz</tt>&rsquo;），则可以使用 <code>gzip</code> 来解压文件然后使用 <code>tar</code> 来提取。你可以使用下面的管线来生成 <code>gawk</code> 的发布文件：
</p>
<div class="example">
<pre class="example">gzip -d -c gawk-4.1.4.tar.gz | tar -xvpf -
</pre></div>

<p>在使用 GNU <code>tar</code> 的系统上，你可以让 <code>tar</code> 来帮你进行解压：
</p>
<div class="example">
<pre class="example">tar -xvpzf gawk-4.1.4.tar.gz
</pre></div>

<p>解压后的文件会在当前目录下创建一个名字为 &lsquo;<tt>gawk-4.1.4</tt>&rsquo; 的目录。
</p>
<p>发布文件名是 &lsquo;<tt>gawk-<var>V</var>.<var>R</var>.<var>P</var>.tar.gz</tt>&rsquo; 形式的名字。<var>V</var> 代表了 <code>gawk</code> 的主要版本，<var>R</var> 表示了当前 <var>V</var> 版本的发布版本，<var>P</var> 代表了<em>补丁等级</em>，表示在这个发布中修复了一些将要的 Bug。当补丁等级是 4，但是当返回发布时，你会取得最高版本号，发布版以及补丁等级。
（提示，补丁等级大于等于 70，表示是“beta”或者是非生产用软件，除非你不介意实验，否则你不要使用这样的版本。）如果你不在 Unix 或者 GNU/Linux 系统上，你需要对获取了解压 <code>gawk</code> 发布版另做打算。你可以咨询一下身边的专家。
</p>
<hr>
<a name="Distribution-contents"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extracting" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Gawk-Distribution" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Unix-Installation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-aa_008f_0091aa_00b8_0083c_0089_0088c_009a_0084aa_0086_0085aa_00ae_00b9"></a>
<h3 class="appendixsubsec">B.1.3 <code>gawk</code> 发布版的内容</h3>
<a name="index-gawk_002c-distribution"></a>

<p><code>gawk</code> 发布版有很多的 C 源文件，文档文件，子目录以及与配置过程相关的文件（查看 see section <a href="#Unix-Installation">在 Unix-like 的系统上编译与安装 <code>gawk</code></a>），还有几个子目录与不同的非 Unix 操作系统相关：
</p>
<dl compact="compact">
<dt>各种 &lsquo;<samp>.c</samp>&rsquo;，&lsquo;<samp>.y</samp>&rsquo; 与 &lsquo;<samp>.h</samp>&rsquo; 文件</dt>
<dd><p>这些文件包含实现的 <code>gawk</code> 源代码。
</p></dd>
</dl>

<dl compact="compact">
<dt>&lsquo;<tt>ABOUT-NLS</tt>&rsquo;</dt>
<dd><p>文件中包含关于 GNU <code>gettext</code> 与翻译的相关信息。
</p>
</dd>
<dt>&lsquo;<tt>AUTHORS</tt>&rsquo;</dt>
<dd><p>一些关于 <code>gawk</code> 的作者信息。它的存在只是为了符合自由软件基金会的规范。
</p>
</dd>
<dt>&lsquo;<tt>README</tt>&rsquo;</dt>
<dt>&lsquo;<tt>README_d/README.*</tt>&rsquo;</dt>
<dd><p>描述性文件：&lsquo;<tt>README</tt>&rsquo; 用于 Unix 下的 <code>gawk</code>，以及其他不同的软硬件组合。
</p>
</dd>
<dt>&lsquo;<tt>INSTALL</tt>&rsquo;</dt>
<dd><p>提供了配置与安装过程的基本过程的文件。
</p>
</dd>
<dt>&lsquo;<tt>ChangeLog</tt>&rsquo;</dt>
<dd><p><code>bugs</code> 修复或者增强的源代码详细列表。
</p>
</dd>
<dt>&lsquo;<tt>ChangeLog.0</tt>&rsquo;</dt>
<dd><p>源代码更改的旧列表。
</p>
</dd>
<dt>&lsquo;<tt>NEWS</tt>&rsquo;</dt>
<dd><p>最后一个版本以来 <code>gawk</code> 的更改列表。
</p>
</dd>
<dt>&lsquo;<tt>NEWS.0</tt>&rsquo;</dt>
<dd><p><code>gawk</code> 的旧的更改列表。
</p>
</dd>
<dt>&lsquo;<tt>COPYING</tt>&rsquo;</dt>
<dd><p>GNU 通用许可证文本。
</p>
</dd>
<dt>&lsquo;<tt>POSIX.STD</tt>&rsquo;</dt>
<dd><p><code>awk</code> 的 POSIX 标准中定义为未定义的行为描述，或者 <code>gawk</code> 中那结不完全符合，或者 POSIX 本身应该描述，但是没有描述的那些事性。
</p>
<a name="index-artificial-intelligence_002c-gawk-and"></a>
</dd>
<dt>&lsquo;<tt>doc/awkforai.txt</tt>&rsquo;</dt>
<dd><p>指向初始文稿，该文稿简单地描述了为什么 <code>gawk</code> 是一个用于人工智能（AI）的好的编程语言的原因。
</p>
</dd>
<dt>&lsquo;<tt>doc/bc_notes</tt>&rsquo;</dt>
<dd><p><code>gawk</code> 的内部“字节码”的简单描述。
</p>
</dd>
<dt>&lsquo;<tt>doc/README.card</tt>&rsquo;</dt>
<dt>&lsquo;<tt>doc/ad.block</tt>&rsquo;</dt>
<dt>&lsquo;<tt>doc/awkcard.in</tt>&rsquo;</dt>
<dt>&lsquo;<tt>doc/cardfonts</tt>&rsquo;</dt>
<dt>&lsquo;<tt>doc/colors</tt>&rsquo;</dt>
<dt>&lsquo;<tt>doc/macros</tt>&rsquo;</dt>
<dt>&lsquo;<tt>doc/no.colors</tt>&rsquo;</dt>
<dt>&lsquo;<tt>doc/setter.outline</tt>&rsquo;</dt>
<dd><p>五色 <code>awk</code> 参考卡的 <code>troff</code> 源代码。像 GNU <code>troff</code>（<code>groff</code>）这样的现代版本的 <code>troff</code> 用于产生彩色的版本。查看 &lsquo;<tt>README.card</tt>&rsquo; 文件。如果你有旧的 <code>troff</code>，卡是说明文档。
</p>
</dd>
<dt>&lsquo;<tt>doc/gawk.1</tt>&rsquo;</dt>
<dd><p>用于描述  <code>gawk</code> 手册的 <code>troff</code> 的源代码。这个文件是为了方便 Unix 用户。
</p>
<a name="index-Texinfo-4"></a>
</dd>
<dt>&lsquo;<tt>doc/gawktexi.in</tt>&rsquo;</dt>
<dt>&lsquo;<tt>doc/sidebar.awk</tt>&rsquo;</dt>
<dd><p>本网页的 Texinfo 源代码文件。它应该由 &lsquo;<tt>doc/sidebar.awk</tt>&rsquo; 文件进行处理，并在使用 <code>texi2dvi</code> 或者 <code>texi2pdf</code> 产生可打印的文档之前进行，使用 <code>makeinfo</code> 来产生 Info 或者 HTML 文件。
&lsquo;<tt>Makefile</tt>&rsquo; 会处理这些处理过程，并产生使用 <code>texi2dvi</code> 或者 <code>texi2pdf</code> 来产生可打印的输出。
</p>
</dd>
<dt>&lsquo;<tt>doc/gawk.texi</tt>&rsquo;</dt>
<dd><p>使用 &lsquo;<tt>gawktexi.in</tt>&rsquo; 处理 &lsquo;<tt>sidebar.awk</tt>&rsquo; 文件之后产生的文件。
</p>
</dd>
<dt>&lsquo;<tt>doc/gawk.info</tt>&rsquo;</dt>
<dd><p>为本网页产生 Info 文件。
</p>
</dd>
<dt>&lsquo;<tt>doc/gawkinet.texi</tt>&rsquo;</dt>
<dd><p><cite>TCP/IP Internetworking with <code>gawk</code></cite>.
的 Texinfo 源文件。
它应该由 TeX 处理（通过 <code>texi2dvi</code> 或者 <code>texi2pdf</code>）来产生可打印的文档以及用 <code>makeinfo</code> 来产生 Info 或者 HTML 文件。
</p>
</dd>
<dt>&lsquo;<tt>doc/gawkinet.info</tt>&rsquo;</dt>
<dd><p><cite>TCP/IP Internetworking with <code>gawk</code></cite> 生成的 Info 文件。
</p>
</dd>
<dt>&lsquo;<tt>doc/igawk.1</tt>&rsquo;</dt>
<dd><p>在 <a href="#Igawk-Program">使用库函数的简单方式</a> 中描述的 <code>igawk</code> 程序手册的 <code>troff</code> 源代码。
</p>
</dd>
<dt>&lsquo;<tt>doc/Makefile.in</tt>&rsquo;</dt>
<dd><p>在配置过程中使用的输入文件，用于产生实际的生成文档的 &lsquo;<tt>Makefile</tt>&rsquo;。
</p>
</dd>
<dt>&lsquo;<tt>Makefile.am</tt>&rsquo;</dt>
<dt>&lsquo;<tt>*/Makefile.am</tt>&rsquo;</dt>
<dd><p>被 GNU Automake 软件使用的文件，以生成由 Autoconf 与 <code>configure</code>使用的 &lsquo;<tt>Makefile.in</tt>&rsquo; 文件。
</p>
</dd>
<dt>&lsquo;<tt>Makefile.in</tt>&rsquo;</dt>
<dt>&lsquo;<tt>aclocal.m4</tt>&rsquo;</dt>
<dt>&lsquo;<tt>bisonfix.awk</tt>&rsquo;</dt>
<dt>&lsquo;<tt>config.guess</tt>&rsquo;</dt>
<dt>&lsquo;<tt>configh.in</tt>&rsquo;</dt>
<dt>&lsquo;<tt>configure.ac</tt>&rsquo;</dt>
<dt>&lsquo;<tt>configure</tt>&rsquo;</dt>
<dt>&lsquo;<tt>custom.h</tt>&rsquo;</dt>
<dt>&lsquo;<tt>depcomp</tt>&rsquo;</dt>
<dt>&lsquo;<tt>install-sh</tt>&rsquo;</dt>
<dt>&lsquo;<tt>missing_d/*</tt>&rsquo;</dt>
<dt>&lsquo;<tt>mkinstalldirs</tt>&rsquo;</dt>
<dt>&lsquo;<tt>m4/*</tt>&rsquo;</dt>
<dd><p>这些文件与子目录在在不同的 Unix 系统中配置及编译 <code>gawk</code> 时使用。它们大多数在 <a href="#Unix-Installation">在 Unix-like 的系统上编译与安装 <code>gawk</code></a>，中进行的解释，共余的则作为主框架的支持文件。
</p>
</dd>
<dt>&lsquo;<tt>po/*</tt>&rsquo;</dt>
<dd><p>包含信息翻译的 &lsquo;<tt>po</tt>&rsquo; 库。
</p>
</dd>
<dt>&lsquo;<tt>awklib/extract.awk</tt>&rsquo;</dt>
<dt>&lsquo;<tt>awklib/Makefile.am</tt>&rsquo;</dt>
<dt>&lsquo;<tt>awklib/Makefile.in</tt>&rsquo;</dt>
<dt>&lsquo;<tt>awklib/eg/*</tt>&rsquo;</dt>
<dd><p>&lsquo;<tt>awklib</tt>&rsquo; 目录包含了 &lsquo;<tt>extract.awk</tt>&rsquo; 的复本（查看 see section <a href="#Extract-Program">从 Texinfo 源文件中提取程序</a>），这个文件用于从本网页的 Texinfo 源文件中提供例子程序。同时也包含了 &lsquo;<tt>Makefile.in</tt>&rsquo; 文件，<code>configure</code> 使用其来生成 &lsquo;<tt>Makefile</tt>&rsquo; 文件。&lsquo;<tt>Makefile.am</tt>&rsquo; 文件被 GNU Automake 用来创建 &lsquo;<tt>Makefile.in</tt>&rsquo; 文件。来自于 <a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098"><code>awk</code> 函数库</a> 的库函数，以及来自于 <a href="#Igawk-Program">使用库函数的简单方式</a> 的 <code>igawk</code> 程序，已经含在发布版本中，并且开箱即用。在安装过程中作为一部分进行安装。本网页的其他程序在 &lsquo;<tt>awklib/eg</tt>&rsquo; 等子目录中都可以获取 。
</p>
</dd>
<dt>&lsquo;<tt>extension/*</tt>&rsquo;</dt>
<dd><p>被 <code>gawk</code> 包含的例子扩展的源代码，手册，以及基础文件。查看 <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>，来获取更多信息。
</p>
</dd>
<dt>&lsquo;<tt>posix/*</tt>&rsquo;</dt>
<dd><p>用于在 POSIX 兼容的系统上构建 <code>gawk</code> 所需要的文件。
</p>
</dd>
<dt>&lsquo;<tt>pc/*</tt>&rsquo;</dt>
<dd><p>用于在 MS-Windows
Files needed for building <code>gawk</code> under MS-Windows
与 OS/2 
系统上构建 <code>gawk</code> 所需要的文件（查看 see section <a href="#PC-Installation">安装到 PC 操作系统</a>，获取相关信息）。
</p>
</dd>
<dt>&lsquo;<tt>vms/*</tt>&rsquo;</dt>
<dd><p>用于在 Vax/VMS 与 OpenVMS 系统上构建 <code>gawk</code> 所需要的文件（查看 see section <a href="#VMS-Installation">在 Vax/VMS 以及 OpenVMS 系统上编译安装 <code>gawk</code></a>，获取相关信息）。
</p>
</dd>
<dt>&lsquo;<tt>test/*</tt>&rsquo;</dt>
<dd><p><code>gawk</code> 的测试包。你可以在 <code>gawk</code> 的顶层目录中使用 &lsquo;<samp>make check</samp>&rsquo; 来执行 <code>gawk</code> 的测试包。如果 <code>gawk</code> 测试成功，则你可以认为移植是成功的。
</p></dd>
</dl>

<hr>
<a name="Unix-Installation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Distribution-contents" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Quick-Installation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-Unix_002dlike-c_009a_0084c_00b3_00bbc_00bb_009fa_00b8_008ac_00bc_0096e_00af_0091a_00b8_008eaa_00ae_0089e_00a3_0085-gawk"></a>
<h2 class="appendixsec">B.2 在 Unix-like 的系统上编译与安装 <code>gawk</code></h2>

<p>一般情况下，你只需要两个命令来编译与安装 <code>gawk</code>。但是，如果你使用的是不常用的系统，你可能需要自己来为你的系统来配置 <code>gawk</code>。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Quick-Installation">B.2.1 为 Unix-like 的系统编译 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Compiling <code>gawk</code> under Unix.
</td></tr>
<tr><td align="left" valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Other compile-time options.
</td></tr>
<tr><td align="left" valign="top"><a href="#Configuration-Philosophy">B.2.3 配置过程</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         How it&rsquo;s all supposed to work.
</td></tr>
</table>

<hr>
<a name="Quick-Installation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Unix-Installation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Unix-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Additional-Configuration-Options" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_00ba-Unix_002dlike-c_009a_0084c_00b3_00bbc_00bb_009fc_00bc_0096e_00af_0091-gawk"></a>
<h3 class="appendixsubsec">B.2.1 为 Unix-like 的系统编译 <code>gawk</code></h3>

<p>在所有的现代由 Unix 派生出来的系统中，都可以使用上面的常规步骤，如 GNU/Linux，BSD 派生的系统，以及 MS-Windows 中的 Cygwin 环境。
</p>
<p>在解压了 <code>gawk</code> 发布文件后，<code>cd</code> 到 &lsquo;<tt>gawk-4.1.4</tt>&rsquo; 目录。与大多的 GNU 软件类似，你通过执行 <code>configure</code> 文件来在系统上对 <code>gawk</code> 进行配置。这个程序是一个 Bourne Shell 脚本，由 GNU 的 Autoconf 自动产生。
（Autoconf 软件在 <cite>Autoconf——配置脚本自动力生成</cite>，中有全面的描述，这个可以在 <a href="http://www.gnu.org/software/autoconf/manual/index.html">自由软件基金会的网站</a> 上找到。）
</p>
<p>简单地运行 <code>configure</code> 命令来配置 <code>gawk</code>：
</p>
<div class="example">
<pre class="example">sh ./configure
</pre></div>

<p>这会产生 &lsquo;<tt>Makefile</tt>&rsquo; 与你的系统匹配 &lsquo;<tt>config.h</tt>&rsquo; 文件描述了你的系统的各种特性。你可以编辑 &lsquo;<tt>Makefile</tt>&rsquo; 来改变 <code>CFLAGS</code> 变量，用以控制传递到 C 编译的命令行选项（如优化等级或者调试编译选项）。
</p>
<p>还有一种方法，在运行 <code>configure</code> 的时候，你可以添加你自己的 <code>make</code> 变量到命令行中，像 <code>CC</code> 以及 <code>CFLAGS</code> 等，如下：
</p>
<div class="example">
<pre class="example">CC=cc CFLAGS=-g sh ./configure
</pre></div>

<p>查看 <code>gawk</code> 发行中的文件 &lsquo;<tt>INSTALL</tt>&rsquo; 来获取详细内容。
</p>
<p>完成了 <code>configure</code>，并对 &lsquo;<tt>Makefile</tt>&rsquo; 做了相应修改，输入：
</p>
<div class="example">
<pre class="example">make
</pre></div>

<p>不久后，你就可以有一个可以运行的 <code>gawk</code> 版本。所有的就是这些了。为了确认<code>gawk</code> 是可以工作正常的，执行 &lsquo;<samp>make check</samp>&rsquo;。
所有的测试都应该是成功的。如果这些步骤没有成功，或者测试失败，检查 &lsquo;<tt>README_d</tt>&rsquo; 目录来查看是否找到已知的问题。如果在那里并没有相关的失败的描述内容，则发送一个 Bug 报告（查看 see section <a href="#Bugs">报告问题与 BUG</a>）。
</p>
<p>当然，一旦完成了构建 <code>gawk</code>，你可以安装它。为了安装 <code>gawk</code>，你还需要执行 &lsquo;<samp>make
install</samp>&rsquo;，所执行的用户需要有一定的权限。如何来完成安装，不同的系统是不同的，但是在多数的系统中，你可以通过 <code>sudo</code> 来完成。则命令会变成 &lsquo;<samp>sudo make install</samp>&rsquo;。有可能有密码输入请求，在这之前，你应该有配置好哪些用户可以执行 <code>sudo</code> 命令。
</p>
<hr>
<a name="Additional-Configuration-Options"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Quick-Installation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Unix-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Configuration-Philosophy" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_00b6a_00bb_0096e_0085_008dc_00bd_00aee_0080_0089e_00a1_00b9"></a>
<h3 class="appendixsubsec">B.2.2 其他配置选项</h3>
<a name="index-gawk_002c-configuring_002c-options"></a>
<a name="index-configuration-options_002c-gawk"></a>

<p>当从头编译 <code>gawk</code> 时，还有几个额外的选项可以用在 <code>configure</code> 命令行上，它们是：
</p>
<dl compact="compact">
<dd>
<a name="index-_002d_002ddisable_002dextensions-configuration-option"></a>
<a name="index-configuration-option_002c-_002d_002ddisable_002dextensions"></a>
</dd>
<dt><code>--disable-extensions</code></dt>
<dd><p>禁用配置与构建 &lsquo;<tt>extension</tt>&rsquo; 目录下的例子扩展。在交叉编译的时候，这个很有用。默认的行为是动态地检查扩展是否可以配置与编译。
</p>
<a name="index-_002d_002ddisable_002dlint-configuration-option"></a>
<a name="index-configuration-option_002c-_002d_002ddisable_002dlint"></a>
</dd>
<dt><code>--disable-lint</code></dt>
<dd><p>禁用所有的 <code>gawk</code> 的 &lsquo;<samp>--lint</samp>&rsquo; 检查。&lsquo;<samp>--lint</samp>&rsquo; 与 &lsquo;<samp>--lint-old</samp>&rsquo; 选项（查看 see section <a href="#Options">命令行参数</a>）可以被接受，但是什么也不做。类似地，设置 <code>LINT</code> 变量（查看 see section <a href="#User_002dmodified">控制 <code>awk</code> 的内置变量</a>）在运行的 <code>awk</code> 程序中也没有任务效果。
</p>
<p>当使用 GCC 的自动力的死代码清除功能时，这个选项可以使 <code>gawk</code> 的可选择体在 GNU/Linux x86-64 系统上小 23KB。在其他系统与编译器上的结果有差异。使用这个选项，可以给你带来一点性能上的提升。
</p>
<blockquote>
<p><b>注意:</b> 使用这个选项可能导致测试包中的一些测试无法通过。这个选项可能在后面会被移除。
</p></blockquote>

<a name="index-_002d_002ddisable_002dnls-configuration-option"></a>
<a name="index-configuration-option_002c-_002d_002ddisable_002dnls"></a>
</dd>
<dt><code>--disable-nls</code></dt>
<dd><p>禁用所有的消息翻译功能。一般来说这并不是所期望的，但是可以给你带来一点性能提升。
</p>
<a name="index-_002d_002dwith_002dwhiny_002duser_002dstrftime-configuration-option"></a>
<a name="index-configuration-option_002c-_002d_002dwith_002dwhiny_002duser_002dstrftime"></a>
</dd>
<dt><code>--with-whiny-user-strftime</code></dt>
<dd><p>强制在低效的系统上使用 C 版本的 <code>strftime()</code> 函数。
</p></dd>
</dl>

<p>使用命令 &lsquo;<samp>./configure --help</samp>&rsquo; 来查看 <code>configure</code> 提供的完整的选项列表。
</p>
<hr>
<a name="Configuration-Philosophy"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Additional-Configuration-Options" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Unix-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Non_002dUnix-Installation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_0085_008dc_00bd_00aee_00bf_0087c_00a8_008b"></a>
<h3 class="appendixsubsec">B.2.3 配置过程</h3>

<a name="index-gawk_002c-configuring"></a>
<p>这一小节只有在你了解 C 语言以及类 Unix 操作系统时才会有趣。
</p>
<p><code>gawk</code> 的代码一般会尝试尽量符合正式的标准。这就是说，<code>gawk</code> 会使用由 ISO C 标准以及 POSIX 操作系统接口标准的库例程。<code>gawk</code> 源代码需要使用 ISO C 的编译器（1990 标准）。
</p>
<p>很多的 Unix 系统要么不支持 ISO，要么不支持 POSIX 标准。<code>gawk</code> 中的 &lsquo;<tt>missing_d</tt>&rsquo; 子目录包含了那些最可以缺失的函数。
</p>
<p><code>configure</code> 生成的 &lsquo;<tt>config.h</tt>&rsquo; 文件包含了那些你编译 <code>gawk</code> 所在系统的特定特性。这个文件描述的三件事情是：可以包含哪些头文件，这样它们可以正确地包含，在你的 C 库中可以使用哪些标准的函数，以及其他的系统特性。如，有可能在 <code>stat</code> 结构中没有 <code>st_blksize</code> 元素。在这个情况下，&lsquo;<samp>HAVE_STRUCT_STAT_ST_BLKSIZE</samp>&rsquo; 就会被反定义。
</p>
<a name="index-custom_002eh-file"></a>
<p>也有可能你的 C 编译器会对 <code>configure</code> 说谎。当某个库函数不可用时，不会以错误退出。为了解决这个问题，修改 &lsquo;<tt>custom.h</tt>&rsquo; 文件。使用适用于你的系统的 &lsquo;<samp>#ifdef</samp>&rsquo; 或者 <code>#define</code> 所有那些应该定义而没有定义的常量，或者 <code>#undef</code> 那些本不应该定义而定义了的常量。&lsquo;<tt>config.h</tt>&rsquo; 文件会被 &lsquo;<tt>config.h</tt>&rsquo; 文件自动包含。
</p>
<p>有可能由 Autoconf 生成的 <code>configure</code> 文件在你的系统上没法工作。如果有问题，&lsquo;<tt>configure.ac</tt>&rsquo; 文件作为 Autoconf 的输入文件，你以修改这个文件来产生一个新版本的 <code>configure</code> 文件，使其可以运行在你的系统上（查看 see section <a href="#Bugs">报告问题与 BUG</a>，来获取如何来报告 <code>gawk</code> 的配置问题）。类似的机制可以应用于 &lsquo;<tt>configure.ac</tt>&rsquo; 与/或者 &lsquo;<tt>custom.h</tt>&rsquo;文件。
</p>
<hr>
<a name="Non_002dUnix-Installation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Configuration-Philosophy" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Installation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_0089e_00a3_0085aa_0088_00b0aa_0085_00b6a_00bb_0096ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009fa_00b8_008a"></a>
<h2 class="appendixsec">B.3 安装到其他操作系统上</h2>

<p>这一小节描述如何将 <code>gawk</code> 安装到其他的非 Unix 系统上。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#PC-Installation">B.3.1 安装到 PC 操作系统</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             Installing and Compiling <code>gawk</code> on
                                MS-DOS and OS/2.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Installation">B.3.2 在 Vax/VMS 以及 OpenVMS 系统上编译安装 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Installing <code>gawk</code> on VMS.
</td></tr>
</table>


<hr>
<a name="PC-Installation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Non_002dUnix-Installation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Non_002dUnix-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Binary-Installation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_0089e_00a3_0085aa_0088_00b0-PC-ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009f"></a>
<h3 class="appendixsubsec">B.3.1 安装到 PC 操作系统</h3>

<a name="index-PC-operating-systems_002c-gawk-on_002c-installing"></a>
<a name="index-operating-systems_002c-PC_002c-gawk-on_002c-installing"></a>
<p>本小节包含的内容为在运行于 Intel 架构的机器上的 
This 小节 covers installation and usage of <code>gawk</code>
on Intel architecture machines
MS-DOS，任意的 MS-Windows 或者 OS/2 系统中 <code>gawk</code> 的安装与使用。
这一小节中所使用的术语“Windows32”指的是 Microsoft 的 Windows95/98/ME/NT/2000/XP/Vista/7/8。
</p>
<p>MS-DOS 的范围（以及在其他操作系统下的 MS-DOS 外壳程序）指的是不同的“DOS 扩展器”，常与 <code>gawk</code> 这样的程序一起使用。Microsoft Windows 3.1 与 Windows32 不同的能力导致了困惑的产生。为了对这些考量有个全面的概况，请查看发布程序中的 &lsquo;<tt>README_d/README.pc</tt>&rsquo; 文件。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#PC-Binary-Installation">B.3.1.1 为 PC 系统安装一个编译版</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Installing a prepared distribution.
</td></tr>
<tr><td align="left" valign="top"><a href="#PC-Compiling">B.3.1.2 为 PC 操作系统编译 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                Compiling <code>gawk</code> for MS-DOS,
                                Windows32, and OS/2.
</td></tr>
<tr><td align="left" valign="top"><a href="#PC-Testing">B.3.1.3 在 PC 操作系统上测试 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  Testing <code>gawk</code> on PC systems.
</td></tr>
<tr><td align="left" valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Running <code>gawk</code> on MS-DOS, Windows32
                                and OS/2.
</td></tr>
<tr><td align="left" valign="top"><a href="#Cygwin">B.3.1.5 在 Cygwin 中使用 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      Building and running <code>gawk</code> for
                                Cygwin.
</td></tr>
<tr><td align="left" valign="top"><a href="#MSYS">B.3.1.6 在 MSYS 环境中使用 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                        Using <code>gawk</code> In The MSYS Environment.
</td></tr>
</table>

<hr>
<a name="PC-Binary-Installation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Installation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Compiling" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_00ba-PC-c_00b3_00bbc_00bb_009faa_00ae_0089e_00a3_0085a_00b8_0080a_00b8_00aac_00bc_0096e_00af_0091c_0089_0088"></a>
<h4 class="appendixsubsubsec">B.3.1.1 为 PC 系统安装一个编译版</h4>

<p>如果你有一个维护者为 MS-DOS 提供二进制版本，<code>gawk</code> 以及相关的支持文件会存存在 &lsquo;<tt>gnu</tt>&rsquo; 目录下，执行文件存在 &lsquo;<tt>gnu/bin</tt>&rsquo;，库存存储在 &lsquo;<tt>gnu/lib/awk</tt>&rsquo; 目录中，手册存放在 &lsquo;<tt>gnu/man</tt>&rsquo;。这是为了能够非常容易地将 <code>gawk</code> 安装到你的驱动程序中的 &lsquo;<tt>/gnu</tt>&rsquo; 目录——但是，只要正确设置 <code>AWKPATH</code>，你可以安装在任何位置。如果不考虑安装目录，&lsquo;<tt>igawk.cmd</tt>&rsquo; 与 &lsquo;<tt>igawk.bat</tt>&rsquo;（在 &lsquo;<tt>gnu/bin</tt>&rsquo; 目录中）有可能需要修改。
</p>
<p>二进制发布版本包含一个独立的文件来描述内容。有一些特别情况下，它可能包含多于一个版本的 <code>gawk</code> 可执行文件。
</p>
<p>OS/2（32 位 EMS）二进制发布版本会安装在你选择的驱动的 &lsquo;<tt>/usr</tt>&rsquo; 目录下。如果你想将 <code>gawk</code> 安装到一个不是硬编码的 &lsquo;<samp>c:</samp>&rsquo; 分区上，你可以将 <code>UNIXROOT</code> 设置为你安装的驱动器上（如，&lsquo;<samp>c:</samp>&rsquo;）。可执行文件会出现在 &lsquo;<tt>/usr/bin</tt>&rsquo; 目录下，库会存储在 &lsquo;<tt>/usr/share/awk</tt>&rsquo; 目录下，而手册则在 &lsquo;<tt>/usr/man</tt>&rsquo; 目录下，Texinfo 文档存在 &lsquo;<tt>/usr/info</tt>&rsquo;，NLS 文件存在 &lsquo;<tt>/usr/share/locale</tt>&rsquo; 中。注意，只要正确地设置 <code>AWKPATH</code>，你可以安装到任何位置。
</p>
<p>如果你已经有一个文件 &lsquo;<tt>/usr/info/dir</tt>&rsquo; 是另一个包的，<em>不要覆盖它！</em>相反在你提示符下输入命令（将 &lsquo;<samp>x:</samp>&rsquo; 按成你的安装驱动器）：
</p>
<div class="example">
<pre class="example">install-info --info-dir=x:/usr/info x:/usr/info/gawk.info
install-info --info-dir=x:/usr/info x:/usr/info/gawkinet.info
</pre></div>

<p>二进制发布版本中可能还包含单独的文件，其中包含了一些额外的更详细的安装指导。
</p>
<hr>
<a name="PC-Compiling"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Binary-Installation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Testing" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_00ba-PC-ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009fc_00bc_0096e_00af_0091-gawk"></a>
<h4 class="appendixsubsubsec">B.3.1.2 为 PC 操作系统编译 <code>gawk</code></h4>


<p>可以使用来自于 MinGW（Windows32）或者 Eberhard Mattes(EMX: MS-DOS，Windows32 与 OS/2) 为 MS-DOS，Windows32 与 OS/2 编译 <code>gawk</code>。
<code>gawk</code> 发行中的文件 &lsquo;<tt>README_d/README.pc</tt>&rsquo; 中包含了额外的提示，&lsquo;<tt>pc/Makefile</tt>&rsquo; 包含了编译编译选项的重要信息。
</p>
<a name="index-compiling-gawk-for-MS_002dDOS-and-MS_002dWindows"></a>
<p>为了为 MS-DOS 与 Windows32 构建 <code>gawk</code>，将 &lsquo;<tt>pc</tt>&rsquo; 目录下（<em>除了</em> &lsquo;<tt>ChangeLog</tt>&rsquo;）的文件与 <code>gawk</code> 其他的源文件复制到某个目录下，然后调用 <code>make</code> 来执行特定的目标以构建 <code>gawk</code>。从 &lsquo;<tt>pc</tt>&rsquo; 目录下复制而来的 &lsquo;<tt>Makefile</tt>&rsquo; 中包含了一个配置段，其中带有相应的注释，有可能需要修改以使其可以使用你的 <code>make</code> 工具用于其上。
</p>
<p>&lsquo;<tt>Makefile</tt>&rsquo; 支持很多的构建目标，用于构建不同的 MS-DOS 与 Windows32 版本。如果 <code>make</code> 时没有带上目标，则可用的目标会被打印出来。
如，使用 MinGW 构建本地的 MS-Windows 的二进制版本的 <code>gawk</code>，则输入 &lsquo;<samp>make mingw32</samp>&rsquo;。
</p>
<a name="index-compiling-gawk-with-EMX-for-OS_002f2"></a>
<p><code>gawk</code> 的 32 位 EMX 版本在 OS/2 下是“开箱即用”的。但是，我们强烈建议你用 GCC 2.95.3 来进行编译。总的来说，可以通过下面的方式来对 <code>gawk</code> 进行编译：
</p>
<div class="example">
<pre class="example">$ <kbd>./configure</kbd>
$ <kbd>make</kbd>
</pre></div>

<p>但是我们不建议这么做。为了要取得一个 OMF 的可执行文件，在你的 <code>sh</code> 提示符下，你应该使用下面的命令行：
</p>
<div class="example">
<pre class="example">$ <kbd>CFLAGS=&quot;-O2 -Zomf -Zmt&quot;</kbd>
$ <kbd>export CFLAGS</kbd>
$ <kbd>LDFLAGS=&quot;-s -Zcrtdll -Zlinker /exepack:2 -Zlinker /pm:vio -Zstack 0x6000&quot;</kbd>
$ <kbd>export LDFLAGS</kbd>
$ <kbd>RANLIB=&quot;echo&quot;</kbd>
$ <kbd>export RANLIB</kbd>
$ <kbd>./configure --prefix=c:/usr</kbd>
$ <kbd>make AR=emxomfar</kbd>
</pre></div>

<p>这是对使用 GCC 2.x 的建议。你可以使用任何其他的环境集变量（自包含的）以及编译选项。
</p>


<p>如果使用的是 GCC 2.95，我们还建议如下：
</p>
<div class="example">
<pre class="example">$ <kbd>LIBS=&quot;-lgcc&quot;</kbd>
$ <kbd>export LIBS</kbd>
</pre></div>

<p>如果你想的话，你还可以得到一个 <code>a.out</code> 可执行文件：
</p>
<div class="example">
<pre class="example">$ <kbd>CFLAGS=&quot;-O2 -Zmt&quot;</kbd>
$ <kbd>export CFLAGS</kbd>
$ <kbd>LDFLAGS=&quot;-s -Zstack 0x6000&quot;</kbd>
$ <kbd>LIBS=&quot;-lgcc&quot;</kbd>
$ <kbd>unset RANLIB</kbd>
$ <kbd>./configure --prefix=c:/usr</kbd>
$ <kbd>make</kbd>
</pre></div>

<blockquote>
<p><b>提示:</b> <code>a.out</code> 可执行文件的编译在 GCC 3.2 下也是可用的。GCC 3.2 后的版本还没有测试成功过。
</p></blockquote>

<p>&lsquo;<samp>make install</samp>&rsquo; 在 EMX 构建时会如预期的方式执行。
</p>
<blockquote>
<p><b>提示:</b> GNU <code>make</code> 的古老 OS/2 移植版本无法处理这个包中的 Makefile 文件。如果你使用 <code>make</code> 遇到了这样的问题，尝试一下 GNU Make 3.79.1 或者更新的版本。你应该在 <a href="ftp://hobbes.nmsu.edu/pub/os2/">ftp://hobbes.nmsu.edu/pub/os2/</a> 上查找最新版本。
<a name="DOCF115" href="#FOOT115">(115)</a>
</p></blockquote>

<hr>
<a name="PC-Testing"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Compiling" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Using" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-PC-ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009fa_00b8_008aae_00b5_008be_00af_0095-gawk"></a>
<h4 class="appendixsubsubsec">B.3.1.3 在 PC 操作系统上测试 <code>gawk</code></h4>

<p>使用 <code>make</code> 来执行标准的测试并安装 <code>gawk</code> 需要一些其他的类 Unix 的工具，这些工具包括 <code>sh</code>，<code>sed</code> 以及 <code>cp</code>。为了要执行测试，&lsquo;<tt>test/*.ok</tt>&rsquo; 文件必须要进行相应的更改，这样它们就有通常的 MS-DOS 风格的换行标志。另外，可以执行 <code>make check CMP=&quot;diff -a&quot;</code> 来在文本模式下使用 GNU 的 <code>diff</code> 工具而不是 <code>cmp</code> 来比较结果文件。
</p>
<p>大多数的测试在 Stewartson 的 shell 环境中都应该是成功的，这个 Shell 中带有相应的工具以及适当的 GNU 工具。但是，需要对 &lsquo;<tt>test/Makefile</tt>&rsquo; 做一些修改。我们建议你复制 &lsquo;<tt>pc/Makefile.tst</tt>&rsquo; 文件到 &lsquo;<tt>test/Makefile</tt>&rsquo; 中进行替换。相关的细节可以在 &lsquo;<tt>README_d/README.pc</tt>&rsquo; 文件以及 &lsquo;<tt>pc/Makefile.tst</tt>&rsquo; 文件中找到。
</p>
<p>在 OS/2 中，由于使用了 <code>spawnl()</code> 而不是 <code>fork()</code>/<code>execl()</code> 来开启子进程，所以 <code>pid</code> 测试会失败。由于所需要的多字节函数不可用，所以 <code>mbfw1</code> 与 <code>mbprintf1</code> 测试也会失败。
</p>
<hr>
<a name="PC-Using"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Testing" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Cygwin" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-PC-ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009fa_00b8_008aa_00bd_00bfc_0094_00a8-gawk"></a>
<h4 class="appendixsubsubsec">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></h4>
<a name="index-operating-systems_002c-PC_002c-gawk-on"></a>
<a name="index-PC-operating-systems_002c-gawk-on"></a>

<p>在 MS-DOS 与 MS-Windows 平台下，Cygwin 与 MinGW 环境支持 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符与 TCP/IP 网络（查看 see section <a href="#TCP_002fIP-Networking">利用 <code>gawk</code> 进行网络通信</a>）。
EMX (仅 OS/2)至少支持 &lsquo;<samp>|&amp;</samp>&rsquo; 操作符。
</p>
<a name="index-search-paths-1"></a>
<a name="index-search-paths_002c-for-source-files-2"></a>
<a name="index-gawk_002c-MS_002dDOS-version-of"></a>
<a name="index-gawk_002c-MS_002dWindows-version-of"></a>
<a name="index-_003b-_0028semicolon_0029_002c-AWKPATH-variable-and"></a>
<a name="index-semicolon-_0028_003b_0029_002c-AWKPATH-variable-and"></a>
<a name="index-AWKPATH-environment-variable-1"></a>
<p>MS-DOS 与 MS-Windows 版本的 <code>gawk</code> 会搜索在 <a href="#AWKPATH-Variable">环境变量 <code>AWKPATH</code></a>，中描述的程序文件。但是，是用分号（而不是冒号）来分隔 <code>AWKPATH</code> 变量中的元素。如果没有设置 <code>AWKPATH</code> 或者为空，则默认的搜索路径是 &lsquo;<samp>.;c:/lib/awk;c:/gnu/lib/awk</samp>&rsquo;。
</p>
<a name="index-gawk_002c-OS_002f2-version-of"></a>
<a name="index-UNIXROOT-variable_002c-on-OS_002f2-systems"></a>
<p>对于 OS/2(32位，EMX）的搜索路径是前缀路径来确定（多为 &lsquo;<tt>/usr</tt>&rsquo; 或者 &lsquo;<tt>c:/usr</tt>&rsquo;），在 Unix 版本的情况下，这个前缀已经在 <code>configure</code> 配置时的一个选项中进行了指定。如果 &lsquo;<tt>c:/usr</tt>&rsquo; 是目录缀，则默认的搜索路径包含 &lsquo;<tt>.</tt>&rsquo; 与 &lsquo;<tt>c:/usr/share/awk</tt>&rsquo;。另外，为了支持在 OS/2 系统中的二进制发布，在该系统上 &lsquo;<samp>c:</samp>&rsquo; 分区有可能不支持长文件名或者，或者根本就不存在，因此需要一个特殊的环境变量。如果 <code>UNIXROOT</code> 指定了一个驱动器，这个驱动器也会进行程序文件的搜索。比如，如果 <code>UNIXROOT</code> 被设置为 &lsquo;<tt>e:</tt>&rsquo;，则完全的默认搜索路径为 &lsquo;<samp>.;c:/usr/share/awk;e:/usr/share/awk</samp>&rsquo;。
</p>
<p>如像 <code>sh</code> 样的 shell（相比于 MS-DOS 中的 <code>command.com</code> 或者 MS Windows 或者 OS/2 中的 <code>cmd.exe</code>）对于 <code>awk</code> 编译会大有用处。DJGPP 工具组件
<a name="DOCF116" href="#FOOT116">(116)</a>
包含了一个 MS-DOS 版本的 Bash，也包含了多个用于 OS/2 中的 Shell，如 <code>ksh</code>。
</p>
<a name="index-common-extensions_002c-BINMODE-variable"></a>
<a name="index-extensions_002c-common_002c-BINMODE-variable"></a>
<a name="index-differences-in-awk-and-gawk_002c-BINMODE-variable-1"></a>
<a name="index-BINMODE-variable-1"></a>
<p>在 MS-Windows，OS/2 以及 MS-DOS 中，
<code>gawk</code>（以及很多的其他的文件程序）会默默地将 &lsquo;<samp>\r\n</samp>&rsquo; 这样的行尾转换成成 &lsquo;<samp>\n</samp>&rsquo;，或者将输入中的 &lsquo;<samp>\n</samp>&rsquo; 转换成 &lsquo;<samp>\r\n</samp>&rsquo; 输出。特殊变量 <code>BINMODE</code> (c.e.) 可以控制这样的转换，并做如下解释：
</p>
<ul>
<li>
如果 <code>BINMODE</code> 为 <code>&quot;r&quot;</code> 或者 1，则二进制模式被设置在“读”操作上（即在读时不会进行转换）。

</li><li>
如果 <code>BINMODE</code> 为 <code>&quot;w&quot;</code> 或者 2，则二进制模式设计在“写”操作上（即写时不会进行转换。）

</li><li>
如果 <code>BINMODE</code> 为 <code>&quot;rw&quot;</code> 或者 <code>&quot;wr&quot;</code> 或者 3，则二进制模式会设置在读写操作上。

</li><li>
<code>BINMODE=<var>non-null-string</var></code> 与 &lsquo;<samp>BINMODE=3</samp>&rsquo; 一样（即，在读写时都不进行转换）。但是 <code>gawk</code> 会在字串不是 <code>&quot;rw&quot;</code> 或者 <code>&quot;wr&quot;</code> 时，会生成一个告警信息。
</li></ul>

<p>标准输入或者标准输出的模式只会设置一次（在读取命令行之后，但是在处理任何 <code>awk</code> 程序之前）。在命令行中，使用适当的 &lsquo;<samp>-v BINMODE=<var>N</var></samp>&rsquo; 的选项来设置标准输出与标准输出的 <code>BINMODE</code>。<code>BINMODE</code> 在文件或者管道打开时，并且在流处理过程中不能够改变。
</p>
<p><code>BINMODE</code> 的名字的选择与 <code>mawk</code> 匹配（查看 see section <a href="#Other-Versions">其他可自由获取的 <code>awk</code></a>）。<code>mawk</code> 与 <code>gawk</code> 处理 <code>BINMODE</code> 是类似的，但是 <code>mawk</code> 添加了一个 &lsquo;<samp>-W BINMODE=<var>N</var></samp>&rsquo; 选项以及环境变量来设置 <code>BINMODE</code>，<code>RS</code>，以及 <code>ORS</code>。文件 &lsquo;<tt>binmode[1-3].awk</tt>&rsquo;（一些二进制发布版本会在目录 &lsquo;<tt>gnu/lib/awk</tt>&rsquo; 下）选择与 <code>mawk</code> 的 &lsquo;<samp>-W
BINMODE=<var>N</var></samp>&rsquo; 选项匹配。这即可以改变也可以取消。特别是 对于 <code>RS</code> 的设置带来最小的“惊奇”还在争论。如果二进制模式在读操作时设置了，则 <code>mawk</code> 会使用 &lsquo;<samp>RS = &quot;\r\n&quot;</samp>&rsquo;，这对于 MS-DOS 风格的行结尾的文件是合适的。
</p>
<p>为了说明，下面的例子在写到标准输出及其他文件时设置了二进制模式，并且将 <code>ORS</code> 设置成“正常”的 MS-DOS 风格的行尾。
</p>
<div class="example">
<pre class="example">gawk -v BINMODE=2 -v ORS=&quot;\r\n&quot; &hellip;
</pre></div>

<p>或者：
</p>
<div class="example">
<pre class="example">gawk -v BINMODE=w -f binmode2.awk &hellip;
</pre></div>

<p>这与 <code>mawk</code> 中的 &lsquo;<samp>-W BINMODE=2</samp>&rsquo; 有相同的结果。下面将记录的分隔符改成 <code>&quot;\r\n&quot;</code> 并设置读的二进制模式，但是不影响标准输入的模式：
</p>
<div class="example">
<pre class="example">gawk -v RS=&quot;\r\n&quot; -e &quot;BEGIN { BINMODE = 1 }&quot; &hellip;
</pre></div>

<p>或者：
</p>
<div class="example">
<pre class="example">gawk -f binmode1.awk &hellip;
</pre></div>

<p>如果引号恰当，第一个例子中对 <code>RS</code> 的设置可以移到 <code>BEGIN</code> 规则中。
</p>
<hr>
<a name="Cygwin"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Using" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#MSYS" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-Cygwin-a_00b8_00ada_00bd_00bfc_0094_00a8-gawk"></a>
<h4 class="appendixsubsubsec">B.3.1.5 在 Cygwin 中使用 <code>gawk</code></h4>
<a name="index-compiling-gawk-for-Cygwin"></a>

<p>如果你在 MS-Windows 系统中使用 <a href="http://www.cygwin.com">Cygwin 环境</a>，则 <code>gawk</code> 可以构建完成后即可使用。这个提供了对使用 <code>Bash</code>，GCC，GNU Make 及其他 GNU 程序的 GNU/Linux 系统很好的模拟环境。在 Cygwin 上编译与安装与在 Unix 系统上是一样的：
</p>
<div class="example">
<pre class="example">tar -xvpzf gawk-4.1.4.tar.gz
cd gawk-4.1.4
./configure
make &amp;&amp; make check
</pre></div>

<p>与同一个系统上的 GNU/Linux 相比，&lsquo;<samp>configure</samp>&rsquo; 在 Cygwin 中要花长得多的时间。但是，它一旦完成，就可以像通常那样使用 &lsquo;<samp>make</samp>&rsquo; 。
</p>
<hr>
<a name="MSYS"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Cygwin" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#PC-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-MSYS-c_008e_00afaa_00a2_0083a_00b8_00ada_00bd_00bfc_0094_00a8-gawk"></a>
<h4 class="appendixsubsubsec">B.3.1.6 在 MSYS 环境中使用 <code>gawk</code></h4>

<p>在 MS-Windows 系统中的 <code>MSYS</code> 环境，<code>gawk</code> 会自动地使用读写二进制模式。所以，没有必要设置 <code>BINMODE</code> 变量。
</p>
<p>对于其他已移植到 MS-Windows 的类 Unix 组件，这可能会导致问题。因为它们可能认为 <code>gawk</code> 会自动转换 <code>&quot;\r\n&quot;</code>，但是实际上却没有。
</p>
<hr>
<a name="VMS-Installation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#MSYS" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Non_002dUnix-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Compilation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-Vax_002fVMS-a_00bb_00a5aa_008f_008a-OpenVMS-c_00b3_00bbc_00bb_009fa_00b8_008ac_00bc_0096e_00af_0091aa_00ae_0089e_00a3_0085-gawk"></a>
<h3 class="appendixsubsec">B.3.2 在 Vax/VMS 以及 OpenVMS 系统上编译安装 <code>gawk</code></h3>


<a name="index-gawk_002c-VMS-version-of"></a>
<a name="index-installation_002c-VMS"></a>
<p>这个子小节描述如何来编译并安装 <code>gawk</code> 到 VMS 中。下面使用“VMS”这个老的术语来表示 OpenVMS。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#VMS-Compilation">B.3.2.1 在 VMS 上编译 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             How to compile <code>gawk</code> under VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Dynamic-Extensions">B.3.2.2 在 VMS 编译 <code>gawk</code> 动态扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      Compiling <code>gawk</code> dynamic extensions on
                                VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Installation-Details">B.3.2.3 在VMS 上安装<code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    How to install <code>gawk</code> under VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Running">B.3.2.4 在 VMS 上运行 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 How to run <code>gawk</code> under VMS.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-GNV">B.3.2.5 VMS 的 GNV 项目</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     The VMS GNV Project.
</td></tr>
<tr><td align="left" valign="top"><a href="#VMS-Old-Gawk">B.3.2.6 有一些 VMS 系统有旧版本的 <code>gawk</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                An old version comes with some VMS systems.
</td></tr>
</table>

<hr>
<a name="VMS-Compilation"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Dynamic-Extensions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-VMS-a_00b8_008ac_00bc_0096e_00af_0091-gawk"></a>
<h4 class="appendixsubsubsec">B.3.2.1 在 VMS 上编译 <code>gawk</code></h4>
<a name="index-compiling-gawk-for-VMS"></a>

<p>为了在 VMS 下编译 <code>gawk</code>，有一个 DCL 命令过程会发起所有的 <code>CC</code> 与 <code>LINK</code> 命令。也有一个 &lsquo;<tt>Makefile</tt>&rsquo; 与 <code>MMS</code> 以及 <code>MMK</code> 一起使用。在源代码目录下，使用：
</p>
<div class="example">
<pre class="example">$ <kbd>@[.vms]vmsbuild.com</kbd>
</pre></div>

<p>或者：
</p>
<div class="example">
<pre class="example">$ <kbd>MMS/DESCRIPTION=[.vms]descrip.mms gawk</kbd>
</pre></div>

<p>或者：
</p>
<div class="example">
<pre class="example">$ <kbd>MMK/DESCRIPTION=[.vms]descrip.mms gawk</kbd>
</pre></div>

<p><code>MMK</code> 是开源免费的，几乎是 <code>MMS</code> 的克隆，并能够很好地处理 ODS-5 中的大小写文件名。<code>MMK</code> 可以从 <a href="https://github.com/endlesssoftware/mmk">https://github.com/endlesssoftware/mmk</a> 取得。
</p>
<p>在 ODS-5 存储和扩展解析可用的时候，可能需要精确的目标参数。
</p>
<p><code>gawk</code> 在使用 Compaq C V6.4 的 VAX/VMS 7.3 以及 Alpha/VMS 7.3-1，Alpha/VMS 7.3，Alpha/VMS 7.3-2，与 IA64/VMS 8.3 上都已经做了相应的测试。最近的构建使用 Alpha VMS 8.3 上的 HP C V7.3，以及使用 HP C 7.3 的 Alpha 与 IA64。 
<a name="DOCF117" href="#FOOT117">(117)</a>
</p>
<p>查看 <a href="#VMS-GNV">VMS 的 GNV 项目</a>，来获取将 <code>gawk</code> 构建成与 GNV 产品兼容的 PCSI 包相关的信息。
</p>
<hr>
<a name="VMS-Dynamic-Extensions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Compilation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation-Details" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-VMS-c_00bc_0096e_00af_0091-gawk-aa_008a_00a8ae_0080_0081ae_0089_00a9aa_00b1_0095"></a>
<h4 class="appendixsubsubsec">B.3.2.2 在 VMS 编译 <code>gawk</code> 动态扩展</h4>

<p>被移植到 VMS 的扩展可以使用下面的命令之一来进行构建 ：
</p>
<div class="example">
<pre class="example">$ <kbd>MMS/DESCRIPTION=[.vms]descrip.mms extensions</kbd>
</pre></div>

<p>或者：
</p>
<div class="example">
<pre class="example">$ <kbd>MMK/DESCRIPTION=[.vms]descrip.mms extensions</kbd>
</pre></div>

<p><code>gawk</code> 使用 <code>AWKLIBPATH</code> 来作为环境变量，或者是查找动态扩展的逻辑名。
</p>
<p>动态扩展需要使用与编译 <code>gawk</code> 一样的编译器来编译，这样使用与 <code>gawk</code> 一样的方式来处理浮点数，指针大小 以及符号名。Alpha 与 Itanium 平台应该使用 IEEE 清点数。指针大小是 32 位，而符号名处理会使用 CRC 来缩短大于 32 位的符号。
</p>
<p>对于 Alpha 与 Itanium 平台：
</p>
<div class="example">
<pre class="example">/name=(as_is,short)
/float=ieee/ieee_mode=denorm_results
</pre></div>

<p>对于 VAX 平台：
</p>
<div class="example">
<pre class="example">/name=(as_is,short)
</pre></div>

<p>编译时间宏需要在 VMS 提供的头文件被包含前进行定义，如：
</p>
<div class="example">
<pre class="example">#if (__CRTL_VER &gt;= 70200000) &amp;&amp; !defined (__VAX)
#define _LARGEFILE 1
#endif

#ifndef __VAX
#ifdef __CRTL_VER
#if __CRTL_VER &gt;= 80200000
#define _USE_STD_STAT 1
#endif
#endif
#endif
</pre></div>

<p>如果你写了自己的扩展运行在 VMS 上，你必须提供这些定义。&lsquo;<tt>config.h</tt>&rsquo; 文件会在 VMS 平台上构建 <code>gawk</code> 时为你完成这个工作。如果你使用这个文件，或者类似的其他文件，则你必须要记住在要包含 VMS 所提供的头文件之前包含它。
</p>
<hr>
<a name="VMS-Installation-Details"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Dynamic-Extensions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Running" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8VMS-a_00b8_008aaa_00ae_0089e_00a3_0085gawk"></a>
<h4 class="appendixsubsubsec">B.3.2.3 在VMS 上安装<code>gawk</code></h4>

<p>要使用 <code>gawk</code> ，你所需要是一个“外部”命令，这是一个 DCL 符号，它的值以美元符号开始。如：
</p>
<div class="example">
<pre class="example">$ <kbd>GAWK :== $disk1:[gnubin]gawk</kbd>
</pre></div>

<p>将 <code>gawk.exe</code> 的实际路径替换 &lsquo;<samp>$disk1:[gnubin]</samp>&rsquo;。符号需要在任何的想使用 <code>gawk</code> 的用户的 &lsquo;<tt>login.com</tt>&rsquo; 中替换，这样每次用户登录时都会进行定义。另外 ，符号也可以用全系统的 &lsquo;<tt>sylogin.com</tt>&rsquo; 过程来替换，这样所有的用户都可以使用 <code>gawk</code>。
</p>
<p>如果你的 <code>gawk</code> 是通过 PCSI 包来安装到 &lsquo;<tt>GNV$GNU:</tt>&rsquo; 目录树的，程序的名字则为 &lsquo;<tt>GNV$GNU:[bin]gnv$gawk.exe</tt>&rsquo; ，帮助文件则为 &lsquo;<tt>GNV$GNU:[vms_help]gawk.hlp</tt>&rsquo;。
</p>
<p>PCSI 包也会安装 &lsquo;<tt>GNV$GNU:[vms_bin]gawk_verb.cld</tt>&rsquo; 文件，这个文件可以用来将将 <code>gawk</code> 与 <code>awk</code> 为 DCL 命令。
</p>
<p>对于当前的过程，你可以使用：
</p>
<div class="example">
<pre class="example">$ <kbd>set command gnv$gnu:[vms_bin]gawk_verb.cld</kbd>
</pre></div>

<p>或者系统管理员可以使用 &lsquo;<tt>GNV$GNU:[vms_bin]gawk_verb.cld</tt>&rsquo; 来将 <code>gawk</code> 与 <code>awk</code> 加到系统级的 &lsquo;<samp>DCLTABLES</samp>&rsquo; 中。
</p>
<p>DCL 语法在 &lsquo;<tt>gawk.hlp</tt>&rsquo; 文件中有记录。
</p>
<p>另外，&lsquo;<tt>gawk.hlp</tt>&rsquo; 项可以被加入到 VMS 帮助库中：
</p>
<div class="example">
<pre class="example">$ <kbd>LIBRARY/HELP sys$help:helplib [.vms]gawk.hlp</kbd>
</pre></div>

<p>（你可能想将特定于站点的帮助库进行替换，而不是标准的 VMS 库 &lsquo;<samp>HELPLIB</samp>&rsquo;）在载入了帮助文件后，命令：
</p>
<div class="example">
<pre class="example">$ <kbd>HELP GAWK</kbd>
</pre></div>

<p>提供了关于 <code>gawk</code> 实现 与 <code>awk</code> 程序语言的信息。
</p>
<p>逻辑名 &lsquo;<samp>AWK_LIBRARY</samp>&rsquo; 可以设设成 <code>awk</code> 程序文件的默认位置。对于 &lsquo;<samp>-f</samp>&rsquo; 选项，如果所指定的文件名没有设备或者路径信息，<code>gawk</code> 会在首先在当前的目录下搜索，如果没有找到，则会在由 &lsquo;<samp>AWK_LIBRARY</samp>&rsquo; 所指定路径下搜索。如果在搜索了两个目录下，文件还没有找到，<code>gawk</code> 会加上 &lsquo;<samp>.awk</samp>&rsquo; 后缀到文件名中，将再次尝试搜索。如果 &lsquo;<samp>AWK_LIBRARY</samp>&rsquo; 没有定义，则会使用 &lsquo;<samp>SYS$LIBRARY:</samp>&rsquo; 的值。
</p>
<hr>
<a name="VMS-Running"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation-Details" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-GNV" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009c_00a8-VMS-a_00b8_008ae_00bf_0090e_00a1_008c-gawk"></a>
<h4 class="appendixsubsubsec">B.3.2.4 在 VMS 上运行 <code>gawk</code></h4>

<p>在 VMS 上，命令行的分析与引号规范完全不同，因此这本网页中的例子，或者其他的源代码要做一些小变化。虽然小，所有的 <code>awk</code> 程序都应该是可以正常执行的。
</p>
<p>这是一些简单的测试：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk -- &quot;BEGIN {print &quot;&quot;Hello, World!&quot;&quot;}&quot;</kbd>
$ <kbd>gawk -&quot;W&quot; version</kbd>
! could also be -&quot;W version&quot; or &quot;-W version&quot;
</pre></div>

<p>注意大小混用时，文本必须引起来。
</p>
<p><code>gawk</code> 的 VMS 移植版本包含了一个 DCL 风格的接口，以及原始 Shell 风格的接口（查看 help 项来获取详细信息）。双路径行分析的副作用是，如果只有一个参数（如程序中引起来的程序），则命令则会有一点模棱两可。为了解决这个问题，常规的可选的 &lsquo;<samp>--</samp>&rsquo; 标志则用来强制使用 Unix 风格的分析方法，而不是 DCL 的分析方法。如果还有其他任何的 “横杠类型”的选项（或者多个参数，如要处理的数据文件），则就不会有二义性，&lsquo;<samp>--</samp>&rsquo; 则可以省略掉。
</p>
<a name="index-exit-status_002c-of-VMS"></a>
<p><code>exit</code> 值是一个 Unix 风格的值，当程序退出时，会被编码为 VMS 的退出值。
</p>
<p>VMS 的严重程序位会根据 <code>exit</code> 值来进行设置。1 表示失败，VMS 会设置 <code>ERROR</code> 状态。2 表示致命错误，VMS 会设置 <code>FATAL</code> 状态。所有其他的值都表示 <code>SUCCESS</code> 状态。退出值的编码符合 VMS 的编码标准并使用<code>C_FACILITY_NO</code> 值 <code>0x350000</code> 与常量 <code>0xA0000</code> 加到为腾出严重程度编码位而左移了 3 位的数值上。
</p>
<p>从 VMS 状态码中提取实际的 <code>gawk</code> 退出码，使用下面的代码：
</p>
<div class="example">
<pre class="example">unix_status = (vms_status .and. %x7f8) / 8
</pre></div>

<p>使用 <code>exec()</code> 的 C 程序调用 <code>gawk</code> 会得到最初的 Unix 风格的退出值。
</p>
<p>用于 VMS 的旧版 <code>gawk</code> 会将 Unix 的退出码 0 当成 1，失败则为 2，致命错误则为 4，其他的值则直接传递。这违反了 VMS 的退出状态编码要求。
</p>
<a name="index-floating_002dpoint_002c-VAX_002fVMS"></a>
<p>VAX/VMS 浮点数使用无倾向的舍入舍出方案。查看 <a href="#Round-Function">数值舍入舍出</a>。
</p>
<p>VMS 会用 <code>GMT</code> 的格式报告时间，除非设置了 <code>SYS$TIMEZONE_RULE</code> 或者 <code>TZ</code> 逻辑名字。旧版本的 VMS，例如 VAX/VMS 7.3 不设置这些逻辑名字。
</p>
<a name="index-search-paths-2"></a>
<a name="index-search-paths_002c-for-source-files-3"></a>
<p>当搜索由 &lsquo;<samp>-f</samp>&rsquo; 指定的 <code>awk</code> 程序文件时，默认的搜索路径是 <code>&quot;SYS$DISK:[],AWK_LIBRARY:&quot;</code>。逻辑名字 <code>AWKPATH</code> 可以用来覆盖这个默认设置。<code>AWKPATH</code> 的格式是一个逗号分隔的目录列表。如果定义了这个变量，值应该被引起来，这样它会保留为独立转换，而不是 <code>RMS</code> 搜索列表的多转换。
</p>
<a name="index-redirection-on-VMS"></a>

<p>这个限制也适用于在 GNV 下运行 <code>gawk</code>，在 GNV 下重定向总是指向一个 DCL 命令。
</p>
<p>如果你要重定向数据到一个 VMS 命令或工具，目前的实现需要设置一个 VMS 外部命令，在调用
<code>gawk</code> 之前，这个命令会运行一个命令文件。
（未来，这个限制可能会从 VMS 上的 <code>gawk</code> 发行版中删除。）
</p>
<p>没有这个命令文件，输入数据也会出现在输出文件的前面。
</p>
<p>这里也允许模拟 VMS 或 GNV 工具中没有的 POSIX 命令。
</p>
<p>下面是 <code>gawk</code> 重定向数据到 VMS 命令 <code>sort</code> 的例子：
</p>
<div class="example">
<pre class="example">$ sort = &quot;@device:[dir]vms_gawk_sort.com&quot;
</pre></div>

<p>命令文件需要按下面的例子的格式写。
</p>
<p>第一行阻碍了输出数据出现在输出数据中国。它必须是按照这个例子中的格式写。
</p>
<p>下一行创造了一个外部命令，这个命令重写了阻止命令文件无限递归的外部命令。
</p>
<p>下一行到最后一行的命令，重定向 <code>sys$input</code> 到 <code>sys$command</code>，为了选择被重定向到这个命令的数据。 
</p>
<p>最后一行运行真正的命令。它必须是最后一个命令，因为当命令文件读完的时候，从 <code>gawk</code> 重定向的数据会被读取。
</p>
<div class="example">
<pre class="example">$!'f$verify(0,0)'
$ sort := sort
$ define/user sys$input sys$command:
$ sort sys$input: sys$output:
</pre></div>


<hr>
<a name="VMS-GNV"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Running" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Old-Gawk" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="VMS-c_009a_0084-GNV-e_00a1_00b9c_009b_00ae"></a>
<h4 class="appendixsubsubsec">B.3.2.5 VMS 的 GNV 项目</h4>

<p>VMS GNV 包提供了与 POSIX 类似的构建环境，并带了很多开源工作的移植版本。<code>gawk</code> 可以在 GNV 的库中找到，但是是一个旧移植版本。当前，GNU 项目被重新组织了，以为每个组件提供单独的 PCSI 包。查看 <a href="https://sourceforge.net/p/gnv/wiki/InstallingGNVPackages/">https://sourceforge.net/p/gnv/wiki/InstallingGNVPackages/</a>。
</p>
<p><code>gawk</code> 的常规的构建过程会生成一个适用于 GNV 的程序。
</p>
<p>在发行版中的 &lsquo;<tt>vms/gawk_build_steps.txt</tt>&rsquo; 文件记录了构建与 GNV 兼容的 VMS PCSI 包的过程。
</p>

<hr>
<a name="VMS-Old-Gawk"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-GNV" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Bugs" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009c_0089a_00b8_0080a_00ba_009b-VMS-c_00b3_00bbc_00bb_009fae_009c_0089ae_0097_00a7c_0089_0088ae_009c_00acc_009a_0084-gawk"></a>
<h4 class="appendixsubsubsec">B.3.2.6 有一些 VMS 系统有旧版本的 <code>gawk</code></h4>


<p>有一些 VMS 的版本带有旧的 <code>gawk</code> 版本。为了访问它，定义如下的符号：
</p>
<div class="example">
<pre class="example">$ <kbd>gawk :== $sys$common:[syshlp.examples.tcpip.snmp]gawk.exe</kbd>
</pre></div>

<p>这个版本是 版本 2.15.6，相当的老。我们建议你编译与使用当前的版本。
</p>

<hr>
<a name="Bugs"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#VMS-Old-Gawk" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Versions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_008a_00a5aa_0091_008ae_0097_00aee_00a2_0098a_00b8_008e-BUG"></a>
<h2 class="appendixsec">B.4 报告问题与 BUG</h2>
<a name="index-archaeologists"></a>
<blockquote>
<p><i>
没有什么比一个无聊的考古学家更危险。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Douglas Adams, @cite{The Hitchhiker's Guide to the Galaxy}</em>
</p>
<a name="index-debugging-gawk_002c-bug-reports"></a>
<a name="index-troubleshooting_002c-gawk_002c-bug-reports"></a>
<p>如果你的 <code>gawk</code> 有问题，或者你认为你找到了一个 Bug，请将它报告给开发者，我们不承诺做任何事情，但是我们也是想要修复它的。
</p>
<p>在报告 Bug 之前，确认你确实是找到了一个真的 Bug。仔细重读文档，看是否你尝试要做的事。如果不是很清楚你应该做些什么，也请报告出来。这是文档中的一个 Bug。
</p>
<p>在报告 Bug 或者你自己尝试修复它之前，尝试分离出能复现问题的最小的 <code>awk</code> 程序和输入数据文件。
然后将下列信息发给我们：程序代码和数据文件，你使用的 Unix 系统的种类，你用来编译 <code>gawk</code> 的编译器，以及你的 <code>gawk</code> 所返回来的确切的结果。你也可以说一下你预期的结果；这会帮助我们决定这个文件是否真的在文档里。
</p>
<p>确保包含你所使用的 <code>gawk</code> 的版本号。你可以通过下面的命令来获取 &lsquo;<samp>gawk --version</samp>&rsquo;。
</p>
<a name="index-bug_002dgawk_0040gnu_002eorg-bug-reporting-address"></a>
<a name="index-email-address-for-bug-reports_002c-bug_002dgawk_0040gnu_002eorg"></a>
<a name="index-bug-reports_002c-email-address_002c-bug_002dgawk_0040gnu_002eorg"></a>
<p>一旦你的问题有了全面精确的描述，你就可以给 &ldquo;bug-gawk at gnu dot org&rdquo; 发送邮件。
</p>
<p><code>gawk</code> 的维护者会订阅这个邮件地址，因此他们会收到你的 Bug 报告。尽管你可以直接给维护者发送邮件，但是最好还是使用专用的报告地址，因此邮件地址在 GNU 项目中是有的。<em>所有的邮件都用英语。这是唯一被所有维护者都理解的语言。</em>
另外，请确保所有的邮件是用纯文本写的，不要用（或者不要仅仅用）HTML。
</p>
<a name="index-comp_002elang_002eawk-newsgroup"></a>
<blockquote>
<p><b>注意:</b> <em>不要</em>将 <code>gawk</code> 的 Bug 报告到由 <code>comp.lang.awk</code> 所指向的 Usenet/Internet 新闻组。<code>gawk</code> 的开发者偶尔才会去看这个新闻组，但是不保证我们可以看得到你提交的内容。这里所描述的步骤是官方认可的组织方式。真的。
</p></blockquote>


<blockquote>
<p><b>提示:</b> 很多的 GNU/Linux 以及不同的基于 BSD 的操作系统发布版有他们自己的 Bug 报告系统。如果你使用这些发布版的 Bug 报告系统，你也要发送一个复本到 &ldquo;bug-gawk at gnu dot org&rdquo;。
</p>
<p>这有两个原因。首先，尽管一些发布版本将 Bug 报告推送到 GNU 邮件列表，但是很多的都没有，所以很有可能 <code>gawk</code> 的维护者很有可能看不到你的报告。其次，发送到 GNU 邮件列表的邮件会被归档，将所有的关东西都放在 GNU 项目中，使得其是自说明的，而不依赖于其他的组织。
</p></blockquote>

<p>非 Bug 建议也是受欢迎的。如果你看到文档中的东西说明不清，或者不理解其中的特性，你也可以在 Bug 列表中进行提问，我们会尽可能地帮助你。
</p>
<p>如果你在一个非 Unix 移植版本中发现 Bug ，也将邮件发送到 Bug 列表，并抄送给维护这个移植版本的人。维护者在下面在的列表中，也存 <code>gawk</code> 发布版中的 &lsquo;<tt>README</tt>&rsquo; 文件里。&lsquo;<tt>README</tt>&rsquo; 文件中的信息如果与本网页中的有冲突，那里的信息会更加权威。
</p>
<p>维护不同的移植版本的人如下：
</p>
<a name="index-Buening_002c-Andreas-2"></a>
<a name="index-Deifik_002c-Scott-2"></a>
<a name="index-Malmberg_002c-John-1"></a>
<a name="index-Pitts_002c-Dave-1"></a>
<a name="index-G_002e_002c-Daniel-Richard-1"></a>
<a name="index-Robbins_002c-Arnold-6"></a>
<a name="index-Zaretskii_002c-Eli-2"></a>
<table>
<tr><td>Unix and POSIX systems</td><td>Arnold Robbins, &ldquo;arnold at skeeve dot com&rdquo;</td></tr>
<tr><td>MS-Windows with MinGW</td><td>Eli Zaretskii, &ldquo;eliz at gnu dot org&rdquo;</td></tr>
<tr><td>OS/2</td><td>Andreas Buening, &ldquo;andreas dot buening at nexgo dot de&rdquo;</td></tr>
<tr><td>VMS</td><td>John Malmberg, &ldquo;wb8tyw at qsl.net&rdquo;</td></tr>
<tr><td>z/OS (OS/390)</td><td>Daniel Richard G. &ldquo;skunk at iSKUNK.ORG&rdquo;</td></tr>
<tr><td></td><td>Dave Pitts (Maintainer Emeritus), &ldquo;dpitts at cozx dot com&rdquo;</td></tr>
</table>

<p>如果 Bug 在 Unix 下也是可重现的，也抄送一份报告给 &ldquo;bug-gawk at gnu dot org&rdquo; 邮件列表。
</p>
<p>DJGPP 端口不再支持；它仍会在代码库中一段时间，以防有志愿者愿意接管它。如果没人愿意接管，最终这个端口的代码会被删除。
</p>
<hr>
<a name="Other-Versions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Bugs" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Installation-summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_00b6a_00bb_0096aa_008f_00afe_0087_00aac_0094_00b1e_008e_00b7aa_008f_0096c_009a_0084-awk"></a>
<h2 class="appendixsec">B.5 其他可自由获取的 <code>awk</code></h2>
<a name="index-awk_002c-implementations"></a>
<a name="index-Brennan_002c-Michael-5"></a>
<blockquote>
<p><i>如果在 <code>awk</code> 代码中这样来输入注释就有味了：</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// C++ 类型的注释可用么？答案是：当然可以啦。</code>
</p></blockquote>
<p align="center">&mdash; <em>Michael Brennan</em>
</p>

<p>还有很多的可以免费获取的 <code>awk</code> 实现版本，这一小节简单地进行说明如何来获取它们：
</p>
<dl compact="compact">
<dd><a name="index-Kernighan_002c-Brian-8"></a>
<a name="index-source-code_002c-Brian-Kernighan_0027s-awk"></a>
<a name="index-awk_002c-versions-of_002c-See-Also-Brian-Kernighan_0027s-awk-1"></a>
<a name="index-Brian-Kernighan_0027s-awk_002c-source-code"></a>
</dd>
<dt>Unix <code>awk</code></dt>
<dd><p>Brian Kernighan 是 Unix <code>awk</code> 的最初设计者，将他自己的 <code>awk</code> 开发出来了。
你可以通过<a href="http://www.cs.princeton.edu/~bwk">他的主页</a>来获取，可以有几种文档格式：
</p>
<dl compact="compact">
<dt>Shell archive</dt>
<dd><p><a href="http://www.cs.princeton.edu/~bwk/btl.mirror/awk.shar">http://www.cs.princeton.edu/~bwk/btl.mirror/awk.shar</a>
</p>
</dd>
<dt>Compressed <code>tar</code> file</dt>
<dd><p><a href="http://www.cs.princeton.edu/~bwk/btl.mirror/awk.tar.gz">http://www.cs.princeton.edu/~bwk/btl.mirror/awk.tar.gz</a>
</p>
</dd>
<dt>Zip file</dt>
<dd><p><a href="http://www.cs.princeton.edu/~bwk/btl.mirror/awk.zip">http://www.cs.princeton.edu/~bwk/btl.mirror/awk.zip</a>
</p></dd>
</dl>

<a name="index-git-utility-1"></a>
<p>你也可以从 GitHub 上取得：
</p>
<div class="example">
<pre class="example">git clone git://github.com/onetrueawk/awk bwkawk
</pre></div>

<p>这个命令创建了一个名为 &lsquo;<tt>bwkawk</tt>&rsquo; 的 <a href="http://git-scm.com">Git</a> 库的复本。如果你将这个参数在 <code>git</code> 命令里省略，则 <code>git</code> 库的复本会创建在名字为 &lsquo;<tt>awk</tt>&rsquo; 的目录中。
</p>
<p>这个版本需要 ISO C（1990 标准）的编译器，来自于 GCC（GNU Compiler Collection）的 C 编译器可以工作得很好。
</p>
<p>查看 <a href="#Common-Extensions">通用扩展汇总</a>，来获取这个 <code>awk</code> 扩展列表，这些扩展不在 POSIX <code>awk</code> 中。
</p>
<p>另外，Dan Bornstein 创建了一个 Git 仓库，追踪了所有他能找到的 BWK <code>awk</code> 版本。在 <a href="git://github.com/danfuzz/one-true-awk">git://github.com/danfuzz/one-true-awk</a> 可以访问。
</p>
<a name="index-Brennan_002c-Michael-6"></a>
<a name="index-mawk-utility-4"></a>
<a name="index-source-code_002c-mawk"></a>
</dd>
<dt><code>mawk</code></dt>
<dd><p>Michael Brennan 实现了一个独立的 <code>awk</code>，称为 <code>mawk</code>。
这可以以
GPL (see section <a href="#Copying">GNU General Public License</a>),
的方式获取，如 <code>gawk</code> 一样。
</p>
<p><code>mawk</code> 源代码的最初的发布地址中已经不再有 <code>mawk</code>，可以在 <a href="http://www.skeeve.com/gawk/mawk1.3.3.tar.gz">http://www.skeeve.com/gawk/mawk1.3.3.tar.gz</a> 取得。
</p>
<p>2009 年，Thomas Dickey 负责起 <code>mawk</code> 的维护工作。基本的信息可以在<a href="http://www.invisible-island.net/mawk">它的项目网站</a>中可以得到。
下载地址为 <a href="http://invisible-island.net/datafiles/release/mawk.tar.gz">http://invisible-island.net/datafiles/release/mawk.tar.gz</a>。
</p>
<p>一旦取得后，用 <code>gunzip</code> 来解压这个文件。安装与 <code>gawk</code> 的相同（查看 see section <a href="#Unix-Installation">在 Unix-like 的系统上编译与安装 <code>gawk</code></a>）。
</p>
<p>查看 <a href="#Common-Extensions">通用扩展汇总</a>，获取不在 POSIX <code>awk</code> 中的 <code>mawk</code> 扩展列表。
</p>
<a name="index-Sumner_002c-Andrew"></a>
<a name="index-awka-compiler-for-awk"></a>
<a name="index-source-code_002c-awka"></a>
</dd>
<dt><code>awka</code></dt>
<dd><p>由 Andrew Sumner 编写，<code>awka</code> 将 <code>awk</code> 程序转换为 C 程序，然后编译，将他们与提供了 <code>awk</code> 核心功能的库进行连接。它也有很多的扩展。
</p>
<p><code>awk</code> 翻译器也在 GPL 许可下发布，而库则在 LGPL 下发布。
</p>
<p>要获取 <code>awka</code>，请进入 <a href="http://sourceforge.net/projects/awka">http://sourceforge.net/projects/awka</a>。
</p>
<p>项目看起来已经冻结起来了，从 2001 年起好像就没有新代码的变动了。
</p>
<a name="index-Beebe_002c-Nelson-H_002eF_002e-1"></a>
<a name="index-pawk-_0028profiling-version-of-Brian-Kernighan_0027s-awk_0029"></a>
<a name="index-source-code_002c-pawk"></a>
</dd>
<dt><code>pawk</code></dt>
<dd><p>Utah 大学的 Nelson H.F. Beebe 修改了 BWK <code>awk</code> 来提供计时与采样信息。它与 <code>gawk</code> 的 &lsquo;<samp>--profile</samp>&rsquo; （查看 see section <a href="#Profiling">测评你的 <code>awk</code> 程序</a>）是不同的，其不同在于 <code>pawk</code> 中使用的是基于 CPU 的采样，而不是基于行的采样。
你可以在 <a href="ftp://ftp.math.utah.edu/pub/pawk/pawk-20030606.tar.gz">ftp://ftp.math.utah.edu/pub/pawk/pawk-20030606.tar.gz</a> 或者 <a href="http://www.math.utah.edu/pub/pawk/pawk-20030606.tar.gz">http://www.math.utah.edu/pub/pawk/pawk-20030606.tar.gz</a> 来获取。
</p>
</dd>
<dt>BusyBox <code>awk</code></dt>
<dd><a name="index-BusyBox-Awk"></a>
<a name="index-source-code_002c-BusyBox-Awk"></a>
<p>BusyBox 是一个 GPL 授权的程序，在单独的执行体中提供了很多应用的小版本。其目标是嵌入式系统。它包含了 POSIX <code>awk</code> 的完整实现。
当构建时，不要使用 &lsquo;<samp>make install</samp>&rsquo;，因为它会覆盖 &lsquo;<tt>/usr/local/bin</tt>&rsquo; 目录下的其他复本程序。
可以浏览<a href="http://busybox.net">它的主页</a>来获取更多信息。
</p>
<a name="index-OpenSolaris"></a>
<a name="index-Solaris_002c-POSIX_002dcompliant-awk"></a>
<a name="index-source-code_002c-Solaris-awk"></a>
</dd>
<dt>The OpenSolaris POSIX <code>awk</code></dt>
<dd><p>在 Solaris 系统中 &lsquo;<tt>/usr/xpg4/bin</tt>&rsquo; 与 &lsquo;<tt>/usr/xpg6/bin</tt>&rsquo; 下的 <code>awk</code> 多多少少与 POSIX 是兼容的。它们是基于 PC 版的 Mortice Kern Systems 中的 <code>awk</code> 版本。我们可以在 GNU/Linux 下用一两个小时来编译它的源代码。要将它弄得更可移植（使用 GNU Autoconf 与/或 Automake）需要很多的工作，而且还没有完成，至少以我们现有的了解看来是这样的。
</p>
<a name="index-Illumos"></a>
<a name="index-Illumos_002c-POSIX_002dcompliant-awk"></a>
<a name="index-source-code_002c-Illumos-awk"></a>
<p>它的源代码过去在 OpenSolaris 站点里。但是，那个项目已经结束，网站已经关闭。幸运的是 <a href="http://wiki.illumos.org/display/illumos/illumos+Home">Illumos project</a> 项目让这个实现再次可用。
你可以访问 <a href="https://github.com/joyent/illumos-joyent/blob/master/usr/src/cmd/awk_xpg4">https://github.com/joyent/illumos-joyent/blob/master/usr/src/cmd/awk_xpg4</a> 来查看其中的文件。
</p>
<a name="index-jawk"></a>
<a name="index-Java-implementation-of-awk"></a>
<a name="index-source-code_002c-jawk"></a>
</dd>
<dt><code>jawk</code></dt>
<dd><p>这是用 Java 写的 <code>awk</code> 解释器。它声称完全是解释器，尽管因为它使用 <code>Java</code> 的工具来进行 I/O 以及正则表达式匹配，它所支持的语言与 POSIX <code>awk</code> 是不同的。可以在<a href="http://jawk.sourceforge.net">网页</a>上获取更多的信息。
</p>
</dd>
<dt>Libmawk</dt>
<dd><a name="index-libmawk"></a>
<a name="index-source-code_002c-libmawk"></a>
<p>这是可嵌入的 <code>awk</code> 解释器，来自于 <code>mawk</code>。要了解信息，请浏览 <a href="http://repo.hu/projects/libmawk/">http://repo.hu/projects/libmawk/</a>。
</p>
</dd>
<dt><code>pawk</code></dt>
<dd><a name="index-source-code_002c-pawk-_0028Python-version_0029"></a>
<a name="index-pawk_002c-awk_002dlike-facilities-for-Python"></a>
<p>这是一个 Python 模式，它声称将 <code>awk</code> 类似的特性加入到 Python 中。查看 <a href="https://github.com/alecthomas/pawk">https://github.com/alecthomas/pawk</a> 来获取更多信息（这个与早前所说的 Nelson Beebe 的 BWK <code>awk</code> 版本没有关系。）
</p>
</dd>
<dt>QSE&nbsp;<code>awk</code></dt>
<dd><a name="index-QSE-awk"></a>
<a name="index-source-code_002c-QSE-awk"></a>
<p>这是一个可嵌入的 <code>awk</code> 解释器。更多我信息请看 <a href="http://code.google.com/p/qse/">http://code.google.com/p/qse/</a> 以及 <a href="http://awk.info/?tools/qse">http://awk.info/?tools/qse</a>。
</p>
</dd>
<dt><code>QTawk</code></dt>
<dd><a name="index-QuikTrim-Awk"></a>
<a name="index-source-code_002c-QuikTrim-Awk"></a>
<p>这个是独立实现的，在 GPL 许可下发布的 <code>awk</code>。它有比标准 <code>awk</code> 多得多的扩展，有可能并不是 100% 与 <code>awk</code> 语法兼容。查看 <a href="http://www.quiktrim.org/qtawk.html">http://www.quiktrim.org/qtawk.html</a> 获取更多信息，其中包括手册。
里面的下载链接已经过时了；查看 <a href="http://www.quiktrim.org/#AdditionalResources">http://www.quiktrim.org/#AdditionalResources</a> 获取最新的下载链接。
</p>
<p>这个项目可能也已经冻结了，从大约 2014 年起，就没有新代码变更了。
</p>
</dd>
<dt>Other versions</dt>
<dd><p>查看 <a href="http://en.wikipedia.org/wiki/Awk_language#Versions_and_implementations">Wikipedia article</a> 中的 “Versions and implementations” 节来获取其他版本的信息。
</p>
</dd>
</dl>

<hr>
<a name="Installation-summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Other-Versions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093"></a>
<h2 class="appendixsec">B.6 总结</h2>

<ul>
<li>
<code>gawk</code> 发布版本可以从 GNU 项目的主发布站点 <code>ftp.gnu.org</code> 获取到。正规的构建过程是：

<div class="example">
<pre class="example">wget http://ftp.gnu.org/gnu/gawk/gawk-4.1.4.tar.gz
tar -xvpzf gawk-4.1.4.tar.gz
cd gawk-4.1.4
./configure &amp;&amp; make &amp;&amp; make check
</pre></div>

</li><li>
<code>gawk</code> 可以构建在非 POSIX 系统上。当前支持的系统包含使用 DJGPP，MSYS，MinGW 以及 Cygwin 的 MS-Windows，
使用 EMX 的 OS/2，
以及 <code>Vax</code>/VMS 与 OpenVMS。在相应系统上的指导也在这个附录中了。

</li><li>
Bug 报告应该通过邮件发送给 <a href="mailto:bug-gawk@gnu.org">bug-gawk@gnu.org</a>。Bug 报告应该使用英语，并包含 <code>gawk</code> 的版本，如何进行编译的，以及一个短程序与数据文件来说明其中的问题。

</li><li>
很多的的自由获取 <code>awk</code> 实现，很多与 POSIX 兼容，有的则兼容得较少。

</li></ul>


<hr>
<a name="Notes"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Installation-summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Compatibility-Mode" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_009ec_008e_00b0ae_008f_0090c_00a4_00ba"></a>
<h1 class="appendix">Appendix C 实现提示</h1>
<a name="index-gawk_002c-implementation-issues"></a>
<a name="index-implementation-issues_002c-gawk"></a>

<p>这个附录中包含了主对是 <code>gawk</code> 的实现与维护者感兴趣的内容。里面的东西都只针对 <code>gawk</code> 而不是其他的实现。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Compatibility-Mode">C.1 后向兼容与调试</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          How to disable certain <code>gawk</code>
                                extensions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Additions">C.2 <code>gawk</code> 添加功能</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Making Additions To <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#Future-Extensions">C.3 后续可能的扩展</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           New features that may be implemented one day.
</td></tr>
<tr><td align="left" valign="top"><a href="#Implementation-Limitations">C.4 实现的一些限制</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Some limitations of the implementation.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Design">C.5 扩展 API 设计</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            Design notes about the extension API.
</td></tr>
<tr><td align="left" valign="top"><a href="#Old-Extension-Mechanism">C.6 对旧扩展的兼容性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     Some compatibility for old extensions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Notes-summary">C.7 总结</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Summary of implementation notes.
</td></tr>
</table>

<hr>
<a name="Compatibility-Mode"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Additions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0090_008eaa_0090_0091aa_0085_00bcaa_00ae_00b9a_00b8_008ee_00b0_0083e_00af_0095"></a>
<h2 class="appendixsec">C.1 后向兼容与调试</h2>
<a name="index-gawk_002c-implementation-issues_002c-downward-compatibility"></a>
<a name="index-gawk_002c-implementation-issues_002c-debugging"></a>
<a name="index-troubleshooting_002c-gawk"></a>
<a name="index-implementation-issues_002c-gawk_002c-debugging"></a>

<p>查看 <a href="#POSIX_002fGNU">不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</a>，来获取 GNU 对于 <code>awk</code> 语言与程序的扩展的概况。所有的这些特性都可以通过以 &lsquo;<samp>--traditional</samp>&rsquo; 或者 &lsquo;<samp>--posix</samp>&rsquo; 选项来调用 <code>gawk</code> 而进行关闭。
</p>
<p>如果 <code>gawk</code> 是使用 &lsquo;<samp>-DDEBUG</samp>&rsquo; 进行编译的，则会在命令行上有额外的一个可用的命令行选项：
</p>
<dl compact="compact">
<dt><code>-Y</code></dt>
<dt><code>--parsedebug</code></dt>
<dd><p>如果程序正在被分析时，则打印出分析栈信息。
</p></dd>
</dl>

<p>这个选项的目的仅用于很正式的 <code>gawk</code> 开发者，而不用于普通用户。有可能都没有编译进你的 <code>gawk</code> 版本，因此它会降低执行的速度。
</p>
<hr>
<a name="Additions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Compatibility-Mode" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Accessing-The-Source" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="gawk-ae_00b7_00bbaa_008a_00a0aa_008a_009fe_0083_00bd"></a>
<h2 class="appendixsec">C.2 <code>gawk</code> 添加功能</h2>

<p>如果你发现你想以一种特别的方式增强 <code>gawk</code>，那随意好了。那正是自由软件的目的，源代码是可以获取的，你也可以按你的方式来改变（查看 see section <a href="#Copying">GNU General Public License</a>）。
</p>
<p>这一小节讨论你更改 <code>gawk</code> 的方式以及需要你同时记住的一些点。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Accessing-The-Source">C.2.1 访问 <code>gawk</code> 的 Git 仓库</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">        Accessing the Git repository.
</td></tr>
<tr><td align="left" valign="top"><a href="#Adding-Code">C.2.2 添加新特性</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Adding code to the main body of
                                <code>gawk</code>.
</td></tr>
<tr><td align="left" valign="top"><a href="#New-Ports">C.2.3 将 <code>gawk</code> 移植到新系统中</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                   Porting <code>gawk</code> to a new operating
                                system.
</td></tr>
<tr><td align="left" valign="top"><a href="#Derived-Files">C.2.4 为什么自动生成的文件要放在 Git 中</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Why derived files are kept in the Git
                                repository.
</td></tr>
</table>

<hr>
<a name="Accessing-The-Source"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Additions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Additions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Adding-Code" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00ae_00bfe_0097_00ae-gawk-c_009a_0084-Git-a_00bb_0093aa_00ba_0093"></a>
<h3 class="appendixsubsec">C.2.1 访问 <code>gawk</code> 的 Git 仓库</h3>

<p>因为 <code>gawk</code> 是一个免费软件，总是可以获取到它的源代码。<a href="#Gawk-Distribution"><code>gawk</code> 发布版</a>，中描述了如何来获取及构建 <code>gawk</code> 发布版本。
</p>
<a name="index-git-utility-2"></a>
<p>但是，如果你想修改 <code>gawk</code> 并且将这些修改发布，你可能需要使用开发版本。因此，你需要访问 <code>gawk</code> 的源代码库。代码是使用 <a href="http://git-scm.com">Git 分布式的版本控制系统</a> 来进行维护的。如果你的系统上没有，则先需要安装它。完成后，你就可以使用下面的命令：
</p>
<div class="example">
<pre class="example">git clone git://git.savannah.gnu.org/gawk.git
</pre></div>

<p>这个复制 <code>gawk</code> 的库。如果你在防火墙后面，而不许使用 Git 的本地协议，你可以使用下面的方式来访问库：
</p>
<div class="example">
<pre class="example">git clone http://git.savannah.gnu.org/r/gawk.git
</pre></div>

<p>一旦你做了修改，你可以使用 &lsquo;<samp>git diff</samp>&rsquo; 来产生一个 patch，然后发送给 <code>gawk</code> 的维护者，查看 <a href="#Bugs">报告问题与 BUG</a>，来获取如何做。
</p>
<p>之前有一段时间有 Git&ndash;CVS 网关可以被那些没有安装的 Git 的人使用。但是，这个网关已经不再工作了，因此你最好一些更加现代的版本控制系统，如 Bazaar，它有一个 Git 插件可以用于 Git 库。
</p>
<hr>
<a name="Adding-Code"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Accessing-The-Source" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Additions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#New-Ports" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_00b7_00bbaa_008a_00a0ae_0096_00b0c_0089_00b9ae_0080_00a7"></a>
<h3 class="appendixsubsec">C.2.2 添加新特性</h3>

<a name="index-adding_002c-features-to-gawk"></a>
<a name="index-features_002c-adding-to-gawk"></a>
<a name="index-gawk_002c-features_002c-adding"></a>
<p>你可以自由地将新特性加入到 <code>gawk</code> 中。但是，如果你想将你的改变加入到 <code>gawk</code> 发布版中，有几个步骤可以让你有可能将它们加入到 <code>gawk</code> 中：
</p>
<ol>
<li>
在构建新的特性到 <code>gawk</code> 前，先考虑将其写成一个扩展（查看 see section <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>）。如果不可能，则往下走。

</li><li>
准备签署合适的协议。为了让 FSF 能够发布你的修改，你必须要么将这些修改发布到公共域里，并提交一个签署有相同效果的协议，或者将版本赋给 FSF。这两个做法都是很容易完成的，<em>很多</em>的人都已经这么做了。如果有问题，请联系我（查看 see section <a href="#Bugs">报告问题与 BUG</a>），或者是 &ldquo;assign at gnu dot org&rdquo;。

</li><li>
获取最新版本。
对我而言，如果这些更改相关于最新的 <code>gawk</code> 版本而变，我就很容易进行合并。最好的是，你的更改是相对于 Git 库的最新代码。如果你的 <code>gawk</code> 版本非常老，我就根本没法将它们合并了。（查看 <a href="#Getting">取得 <code>gawk</code> 发布版</a>，来了解如何获取最新的 <code>gawk</code> 版本。）

</li><li>
遵守 <cite>gnu coding standards</cite> 的代码标准。
这个文档描述如何来写 GNU 软件。如果你还没有读过，请先读，特别是在修改 <code>gawk</code> <em>之前</em>（<cite>GNU Coding Standards</cite> 可以从 <a href="http://www.gnu.org/prep/standards/">GNU 项目的站点</a> 上获取。也可以获取到 Texinfo，Info，DVI 的版本。）

<a name="index-gawk_002c-coding-style-in"></a>
</li><li>
使用 <code>gawk</code> 编码风格。
<code>gawk</code> 的 C 代码遵守 GNU 编译标准中的指导，只有一些小例外。代码使用传统的 “K&amp;R” 风格，特别在替换花括号以及 TABs 的使用上要注意。简单地说，代码规则如下：

<ul>
<li>
使用 ANSI/ISO 风格（原型）函数来定义函数。

</li><li>
将函数放在一行的前面。

</li><li>
使用 &lsquo;<samp>#elif</samp>&rsquo; 代替 &lsquo;<samp>#else</samp>&rsquo; 中嵌套的 &lsquo;<samp>#if</samp>&rsquo;。

</li><li>
将函数的返回值，即使是 <code>int</code> 放在有参数的函数名字的上一行。

</li><li>
在控制结构与括号之间放一个空格（<code>if</code>，<code>while</code>，<code>for</code>，<code>do</code>，<code>switch</code>， 以及 <code>return</code>）。

</li><li>
在函数调用时，不要在括号之前放空格。

</li><li>
在所以的 C 操作符前后和函数调用中的逗号后，加上空格。

</li><li>
不要使用逗号操作符来产生多种副作用，除非在 <code>for</code> 循环中初始化与递增的部分，以及在宏定义里。

</li><li>
使用真正的 TABs 来进行缩进，而不是空格。

</li><li>
使用 “K&amp;R” 风格的花括号布局风格。

</li><li>
在 <code>if</code>，<code>while</code>，以及 <code>for</code> 语句的条件中，使用与 <code>NULL</code> 与 <code>'\0'</code> 的比较，在 <code>switch</code> 语句中也是一样，而不要使用光指针与字符值。

</li><li>
使用 <code>true</code> 与 <code>false</code> 来用于 <code>bool</code> 值，<code>NULL</code> 符号常量是用于指针值的，而字符常量则用 <code>'\0'</code>，而不是 <code>1</code> 与 <code>0</code>。

</li><li>
对每个函数都提供一行描述性的注释。

</li><li>
不要使用 <code>alloca()</code> 函数用进行栈内的内存分配。它的使用会导致移植性问题，而带来的一点好处就是不用进行内存释放。要使用 <code>malloc()</code> 与 <code>free()</code>。

</li><li>
不要使用 &lsquo;<samp>! strcmp(a, b)</samp>&rsquo; 类似的比较。Henry Spencer 说过，“<code>strcmp()</code> 不是布尔值”，相反，要使用 &lsquo;<samp>strcmp(a, b) == 0</samp>&rsquo;。

</li><li>
如果添加了新的位标志值，要使用显式的十六进制常量（<code>0x001</code>, <code>0x002</code>, <code>0x004</code> 等等），而不要使用对 1 进行连续的左移（&lsquo;<samp>(1&lt;&lt;0)</samp>&rsquo;, &lsquo;<samp>(1&lt;&lt;1)</samp>&rsquo; 等等）。
</li></ul>

<blockquote>
<p><b>提示:</b> 如果我要修改了你的代码来遵守 <code>gawk</code> 中的代码风格，是我根本就不会将你的更改整合进去的。
</p></blockquote>

<a name="index-Texinfo-5"></a>
</li><li>
更新文档。
跟你的代码一起，请提供新的章节到本网页中。如果有可能，请使用真正的 Texinfo，而不是提供一些未格式化的 ASCII 文本（尽管有文档要比没文档要好）。请遵守 <cite>GAWK: Effective AWK Programming</cite> 中的规则，由在 Texinfo 源文件尾部的 &lsquo;<samp>@bye</samp>&rsquo; 所提供。
如果可能，请也请更新 <code>man</code> 手册页。

<p>你对你的文档也需要签署相应的协议。
</p>
<a name="index-git-utility-3"></a>
</li><li>
使用统一的 diffs 来提供更改。使用 &lsquo;<samp>diff -u -r -N</samp>&rsquo; 来比较最初的 <code>gawk</code> 源代码与你的代码变化。我建议使用 GNU 版本的 <code>diff</code> 或者最好，直接使用 &lsquo;<samp>git diff</samp>&rsquo; 或者 &lsquo;<samp>git format-patch</samp>&rsquo;。将 <code>diff</code> 产生的输出发送给我。（查看 <a href="#Bugs">报告问题与 BUG</a>，来获得电子邮件信息。）

<p>使用这样的格式，我很容易将你的更改合并到 <code>gawk</code> 的主版本的源代码中（使用 <code>patch</code>）。如果我必须要使用文本编辑器手动更改，我可能不这么做，特别是有很多的变化时。
</p>
</li><li>
在 &lsquo;<tt>ChangeLog</tt>&rsquo; 文件中包含一项，与你的更改一起提交。这可以帮助进一步最小化我的工作，这样我就比较容易接受补丁。如果你只使用你的 diff 的这部分，那就是最简单的了。
</li></ol>

<p>这听起来要做很多的事情，但是请记住当你写了新代码，而我就得维护并且支持它。如果对我而言不能最小化这些额外工作，我可能就不会做。
</p>
<hr>
<a name="New-Ports"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Adding-Code" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Additions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Derived-Files" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00b0_0086-gawk-c_00a7_00bbae_00a4_008daa_0088_00b0ae_0096_00b0c_00b3_00bbc_00bb_009fa_00b8_00ad"></a>
<h3 class="appendixsubsec">C.2.3 将 <code>gawk</code> 移植到新系统中</h3>
<a name="index-portability_002c-gawk"></a>
<a name="index-operating-systems_002c-porting-gawk-to"></a>

<a name="index-porting-gawk"></a>
<p>如果你想将 <code>gawk</code> 移植到新的操作系统，下面是相应的步骤：
</p>
<ol>
<li>
遵守
上一小节
所说的代码规范，提供 diff 等等。

</li><li>
准备签署相应的文件。这样 FSF 可以发布你的代码，你要么将你的代码放在公共域里，要么签署一个等同于相应效果的文件，或者将版本赋给 FSF。这两个工作都是容易做的，<em>很多人</em>也这么做了。如果你有问题，请联系我，或者 <a href="mailto:gnu@gnu.org">gnu@gnu.org</a>。

</li><li>
当完成了一个移植，要记住你的代码要与 <code>gawk</code> 其他的部分一起共存。避免对系统无关的代码部分做无谓的修改。如果可能，请不要在你的部分里到处加 &lsquo;<samp>#ifdef</samp>&rsquo;。

<p>如果改变需要一种特定系统特性，会影响太多的代码，我可能不会接受它们。在这样的情况下，你当然可以自己来发布你的更改，只要你符合 GPL 即可（查看 see section <a href="#Copying">GNU General Public License</a>）。
</p>
</li><li>
很多 <code>gawk</code> 带有的文件是被其他的用人维护的。所以，你不可以更改它们，除非有很好的理由。即，修改它们不是绝对不行，但是对这些文件的修改也要额外的仔细。
这些文件是 
&lsquo;<tt>dfa.c</tt>&rsquo;，
&lsquo;<tt>dfa.h</tt>&rsquo;，
&lsquo;<tt>getopt.c</tt>&rsquo;，
&lsquo;<tt>getopt.h</tt>&rsquo;，
&lsquo;<tt>getopt1.c</tt>&rsquo;，
&lsquo;<tt>getopt_int.h</tt>&rsquo;，
&lsquo;<tt>gettext.h</tt>&rsquo;，
&lsquo;<tt>regcomp.c</tt>&rsquo;，
&lsquo;<tt>regex.c</tt>&rsquo;，
&lsquo;<tt>regex.h</tt>&rsquo;，
&lsquo;<tt>regex_internal.c</tt>&rsquo;，
&lsquo;<tt>regex_internal.h</tt>&rsquo;，
和
&lsquo;<tt>regexec.c</tt>&rsquo;。

</li><li>
有很多文件是由 GNU Autotools 提供的（Autoconf，Automake 及 GNU <code>gettext</code>）。你也不可以更改它们，除非有好的理由。
这些文件是 
&lsquo;<tt>ABOUT-NLS</tt>&rsquo;，
&lsquo;<tt>config.guess</tt>&rsquo;，
&lsquo;<tt>config.rpath</tt>&rsquo;，
&lsquo;<tt>config.sub</tt>&rsquo;，
&lsquo;<tt>depcomp</tt>&rsquo;，
&lsquo;<tt>INSTALL</tt>&rsquo;，
&lsquo;<tt>install-sh</tt>&rsquo;，
&lsquo;<tt>missing</tt>&rsquo;，
&lsquo;<tt>mkinstalldirs</tt>&rsquo;，
&lsquo;<tt>xalloc.h</tt>&rsquo;，
和
&lsquo;<tt>ylwrap</tt>&rsquo;。

</li><li>
要愿意持续维护这个移植版本。非 Unix 的操作系统是由志愿者来维护的，他们维护需要在他们的系统中的代码的维护及运行。如果没有人愿意维护这个移植版本，会成为不受支持的版本，有可能有必要从发行版本中移除掉。

</li><li>
提供合适的 &lsquo;<tt>gawkmisc.???</tt>&rsquo; 文件。每个移植版本都有自己的 &lsquo;<tt>gawkmisc.???</tt>&rsquo; 文件，这些文件实现了特定于操作系统的函数。这个比在代码中用大量的 &lsquo;<samp>#ifdef</samp>&rsquo; 要更加清晰。在源代码主目录中的 &lsquo;<tt>gawkmisc.c</tt>&rsquo; 包含了相应的 &lsquo;<tt>gawkmisc.???</tt>&rsquo; 文件，这个文件来自于其子目录。记得也要更新。

<p>每个移植版本的 &lsquo;<tt>gawkmisc.???</tt>&rsquo; 文件有一个后缀来表示机器以及操作系统，如 &lsquo;<tt>pc/gawkmisc.pc</tt>&rsquo; 和 &lsquo;<tt>vms/gawkmisc.vms</tt>&rsquo;。
使用其他的后缀，而不是普通的 &lsquo;<tt>gawkmisc.c</tt>&rsquo;，使其有可能将文件从移植版本的子目录行色移到主线子目录，而不会导致偶然的对 &lsquo;<tt>gawkmisc.c</tt>&rsquo; 文件的破坏。（当前，这个只对 PC 操作系统移植才会是问题。）
</p>
</li><li>
提供必要的 &lsquo;<tt>Makefile</tt>&rsquo; 用于你的操作系统。你的所有代码都应该在一个单独的子目录下，名字可以与操作系统名字相同，或者是操作系统名字一部分。如果可能，将事情结构化，这样没有必须将文件从子目录中移动到主子目录下。如果不可能，则要确保使用你的文件的名字不会与主源代码目录下的文件相同。

</li><li>
更新文档。
写为本网页写一个小节（或者多个小节）来描述其安装与编译步骤，这样可以在你的系统上编译与安装 <code>gawk</code>。
</li></ol>

<p>按这样的步骤，可以使其容易来将你的变化整合到 <code>gawk</code> 中，并使其与其他的已经存在操作系统代码和平共处。
</p>
<p>在你提供与维护的代码中，可以自由使用你的风格以及括号布局。
</p>
<hr>
<a name="Derived-Files"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#New-Ports" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Additions" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Future-Extensions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="a_00b8_00baa_00bb_0080a_00b9_0088e_0087_00aaaa_008a_00a8c_0094_009fae_0088_0090c_009a_0084ae_0096_0087a_00bb_00b6e_00a6_0081ae_0094_00beaa_009c_00a8-Git-a_00b8_00ad"></a>
<h3 class="appendixsubsec">C.2.4 为什么自动生成的文件要放在 Git 中</h3>

<a name="index-Git_002c-use-of-for-gawk-source-code"></a>

<p>如果你查看  Git 库中的 <code>gawk</code> 源代码，你会注意到里面包含了由 GNU 基础工作自动力生成的文件，如 &lsquo;<tt>Makefile.in</tt>&rsquo; 由 Automake 生成，甚至是由 Autoconf 生成的 &lsquo;<tt>configure</tt>&rsquo; 。
</p>
<p>这个不同于不存储衍生文件其他自由软件项目，因为这使得库不会这么混乱，而且更容易在比较在不同提交之间的真正改变。
</p>
<p>但是，有几个原因，使得 <code>gawk</code> 要把所有的东西放在库中。
</p>
<p>首先，这更容易生成完整的版本，而不依赖于其他工作的能力（有一些老的，被丢弃，甚至没办法找得到。）
</p>
<p>一个极端例子是，如果你想编译，比方说 V7 的 <code>awk</code>，你会发现你不仅要用 V7 的 <code>yacc</code> 来处理，还需要 V7 的 <code>lex</code>。对于后者，在现代的 GNU/Linux 系统根本没有。 
<a name="DOCF118" href="#FOOT118">(118)</a>
</p>
<p>（或者说，<code>gawk</code> 1.2 所需要 1989 年中的 <code>bison</code> 什么什么的，在库中没有 &lsquo;<tt>awkgram.c</tt>&rsquo; 这个文件。有保证说我们可以找到 <code>bison</code> 版本？或者<em>它</em>可以构建么？）
</p>
<p>如果库有都有生成的文件，则很容易检查并构建。（或者，依赖于我们所回到的位置可能更容易。）
</p>
<p>这使得我们有第二个理由（更强的）为什么把所有的文件都放在 Git 中。简单地说就是你让谁开心——是 <code>gawk</code> 的开发者，还是仅想取某个版本然后试试它的用户？
</p>
<p><code>gawk</code> 的维护维护者想全世界所有的对 <code>awk</code> 有兴趣的用户，只要克隆库，然后检出所感兴趣的分支构建即可。而不需要他们必须有正确的 <code>autotools</code> 版本。
<a name="DOCF119" href="#FOOT119">(119)</a>
这也是 &lsquo;<tt>bootstrap.sh</tt>&rsquo; 文件的目的。它以正确的顺序来处理不同的文件，这样：
</p>
<div class="example">
<pre class="example"># The canonical incantation for building GNU software:
./bootstrap.sh &amp;&amp; ./configure &amp;&amp; make
</pre></div>

<p>也<em>可以工作</em>。
</p>
<p>这对于 <code>master</code> 主干以及 <code>gawk-<var>X</var>.<var>Y</var>-stable</code> 分支来说尤其重要。
</p>
<p>再者，<code>gawk</code> 的维护者也觉得这对于 <code>gawk</code> 的开发者也非常重要。当某人尝试检出 <code>xgawk</code> 的分支
<a name="DOCF120" href="#FOOT120">(120)</a>
来构建时，却发现不能。（没有 &lsquo;<tt>ltmain.sh</tt>&rsquo; 文件，也不知道如何来生成，并且这也不是唯一的问题。）
</p>
<p>此人会感觉<em>精疲力尽</em>。对于相应的分支，维护者与 <code>Jane</code> 这样的想构建从库中取得的 <code>gawk-4.1-stable</code> 或者 <code>master</code> 用户没有什么不同。
</p>
<p>因此，维护者觉得对于任何分支而言，上面的代码<em>能工作</em>，这样不仅是重要，而且非常关键。
</p>
<p>第三个原因是，如果没有这些文件，使用 &lsquo;<samp>git
bisect</samp>&rsquo; 来查找引入 bug 的提交会变成相当困难。维护者会在其他的项目中使用这个方法，这个项目需要运行自举脚本，以创建 <code>configure</code> 等文件，这相当痛苦。当库自己是自包含的，使用 <code>git bisect</code> 就相应容易了。
</p>

<p>有什么结果与/或者采取什么行动呢？
</p>
<ol>
<li>
我们不介意在不同的分支下有不同的文件，这是不同的 autotools 版本的结果。

<ol>
<li>
合并与处理，这是维护者的事。

</li><li>
为了检查代码，维护者会使用 &lsquo;<samp>git diff x y &gt; /tmp/diff1 ; gvim /tmp/diff1</samp>&rsquo; 来移除不感兴趣的差别，他在这方面确实非常拿手。
</li></ol>

</li><li>
如果所有的人都使用与维护者一样的 GNU tools 的话，肯定会有帮助，一般是最新版本的 Automake，Autoconf，<code>bison</code> 以及 GNU <code>gettext</code>。


<p>从源代码安装非常容易。几年来维护者都是这么做的（而且还在这么做）。只需要将 &lsquo;<tt>/usr/local/bin</tt>&rsquo; 放在 <code>PATH</code> 的前面，然后执行：
</p>
<div class="example">
<pre class="example">wget http://ftp.gnu.org/gnu/<var>package</var>/<var>package</var>-<var>x</var>.<var>y</var>.<var>z</var>.tar.gz
tar -xpzvf <var>package</var>-<var>x</var>.<var>y</var>.<var>z</var>.tar.gz
cd <var>package</var>-<var>x</var>.<var>y</var>.<var>z</var>
./configure &amp;&amp; make &amp;&amp; make check
make install    # as root
</pre></div>



</li></ol>

<p>上面大多数一开始是由其他的 <code>gawk</code> 维护者写的。有一个开发者提出的反对意见“&hellip; 从 Git 库中提取源代码的人并不都是终端用户。”
</p>
<p>但是，事情不是这么回事。有“大牛级的 <code>awk</code> 用户”，他们可以构建 <code>gawk</code>（使用之前所列的代码），但是他们没办法用 C 写程序。所以，主要的分支应该一直保持是可构建的。
</p>
<p>然后建议，应该有一个 <code>cron</code> 任务来每晚来创建所有代码的 tar ball。这里的问题是，有不同分支的代码线，因此，每晚的 tar ball 不是最终解决方法，特别是库有可能几周都不会有大的变化。
</p>
<p>幸运的是，Git 服务器可以来满足这样的需要。对于每一个名字为 <var>branchname</var> 的分支，使用：
</p>
<div class="example">
<pre class="example">wget http://git.savannah.gnu.org/cgit/gawk.git/snapshot/gawk-<var>branchname</var>.tar.gz
</pre></div>

<p>来返回所指定分支的快照。
</p>
<hr>
<a name="Future-Extensions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Derived-Files" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Implementation-Limitations" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0090_008ec_00bb_00adaa_008f_00afe_0083_00bdc_009a_0084ae_0089_00a9aa_00b1_0095"></a>
<h2 class="appendixsec">C.3 后续可能的扩展</h2>
<a name="index-Perl"></a>
<a name="index-Wall_002c-Larry-1"></a>
<a name="index-Robbins_002c-Arnold-7"></a>
<blockquote>
<p><i>
<code>AWK</code> 是像 <code>PERL</code> 语言一样，只是要比它优美得多了。
</i>
</p></blockquote>
<p align="center">&mdash; <em>Arnold Robbins</em>
</p>
<blockquote>
<p><i>
嘿，怎么说的！
</i>
</p></blockquote>
<p align="center">&mdash; <em>Larry Wall</em>
</p>
<p>在 Git 库中的 <code>gawk</code> 的 <code>master</code> 主分支中的 &lsquo;<tt>TODO</tt>&rsquo; 文件列出来未来可能的增加。有一些与源代码相关，其他的是一些新特性。请查看这个文件来获取相关列表。如果你有兴趣跟踪列在其中的项目，请查看 <a href="#Additions"><code>gawk</code> 添加功能</a>。
</p>
<hr>
<a name="Implementation-Limitations"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Future-Extensions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Design" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00ae_009ec_008e_00b0c_009a_0084a_00b8_0080a_00ba_009be_0099_0090aa_0088_00b6"></a>
<h2 class="appendixsec">C.4 实现的一些限制</h2>

<p>下表描述了 <code>gawk</code> 在类 Unix 系统中的一些限制（尽管还会有变量）。其他的系统可能还有不同的限制。
</p>
<table>
<thead><tr><th width="40%">项</th><th width="60%">限制</th></tr></thead>
<tr><td width="40%">字符类内的字符数</td><td width="60%">2^(每字节的位数)</td></tr>
<tr><td width="40%">输入记录的长度</td><td width="60%"><code>MAX_INT</code></td></tr>
<tr><td width="40%">输出记录的长度</td><td width="60%">Unlimited</td></tr>
<tr><td width="40%">源代码长度</td><td width="60%">Unlimited</td></tr>
<tr><td width="40%">记录中的域数</td><td width="60%"><code>MAX_LONG</code></td></tr>
<tr><td width="40%">文件重定向数</td><td width="60%">Unlimited</td></tr>
<tr><td width="40%">一个文件中的记录数</td><td width="60%"><code>MAX_LONG</code></td></tr>
<tr><td width="40%">总是输入记录数</td><td width="60%"><code>MAX_LONG</code></td></tr>
<tr><td width="40%">重定向管道数</td><td width="60%">min(每用进程数， 打开文件数)</td></tr>
<tr><td width="40%">数值</td><td width="60%">双精度浮点数 (如果没有使用 MPFR)</td></tr>
<tr><td width="40%">域大小</td><td width="60%"><code>MAX_INT</code></td></tr>
<tr><td width="40%">字串大小</td><td width="60%"><code>MAX_INT</code></td></tr>
<tr><td width="40%">printf 字串大小</td><td width="60%"><code>MAX_INT</code></td></tr>
</table>

<hr>
<a name="Extension-Design"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Implementation-Limitations" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Old-Extension-Problems" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0089_00a9aa_00b1_0095-API-e_00ae_00bee_00ae_00a1"></a>
<h2 class="appendixsec">C.5 扩展 API 设计</h2>

<p>这一小节，记录了扩展 API 的设计，包括一些需要解决的历史问题的讨论。
</p>
<p>用于 <code>gawk</code> 第一个版本的扩展在 1990 年代中期开发，并与 <code>gawk</code> 3.1 一起发布。15 年来基本的机制并没有什么变量，直到 2012 年。
</p>
<p>旧扩展的机制使用使用来自 <code>gawk</code> 的数据类型与函数，通过“聪明黑客”手段来安装扩展函数。
</p>
<p><code>gawk</code> 包含了一些扩展，很多都很有用。但是很明显，从一开始扩展机制都只强制一边，而没有经过详细思考。
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Old-Extension-Problems">C.5.1 旧机制的问题</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           Problems with the old mechanism.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-New-Mechanism-Goals">C.5.2 新机制的目标</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Goals for the new mechanism.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Other-Design-Decisions">C.5.3 其他的设计决策</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Some other design decisions.
</td></tr>
<tr><td align="left" valign="top"><a href="#Extension-Future-Growth">C.5.4 未来的增长空间</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Some room for future growth.
</td></tr>
</table>

<hr>
<a name="Old-Extension-Problems"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Design" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Design" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-New-Mechanism-Goals" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0097_00a7ae_009c_00baaa_0088_00b6c_009a_0084e_0097_00aee_00a2_0098"></a>
<h3 class="appendixsubsec">C.5.1 旧机制的问题</h3>

<p>旧的扩展机制有下面的几个问题：
</p>
<ul>
<li>
严重依赖于 <code>gawk</code> 的内部实现。<code>NODE</code> 结点结构
<a name="DOCF121" href="#FOOT121">(121)</a>
一旦变化，扩展就得重新编译。而且，要真写一扩展，需要了解 <code>gawk</code> 内部功能的一些东西。这里面有一些记录在本网页里，但是相当有限。

</li><li>
要能够从扩展调用到 <code>gawk</code>，这需要连接工具在 Unix 派生出来的系统中是很通用的，但是在 MS-Windows 上却不是，用户在 MS-Windows 上的扩展需要静态地连接到 <code>gawk</code> 中，尽管 MS-Windows 也支持动态装载共享对象。

</li><li>
当 <code>gawk</code> 变化时，API 也会偶尔变量，并且不同的版本之间不兼容，也没有相应的计划来兼容。
</li></ul>

<p>尽管有这么些缺陷，<code>xgawk</code> 项目的开发者复制了 <code>gawk</code> 并且开发了几个很好的扩展。它们也增强了 <code>gawk</code> 中与文件包含与共享对象访问的功能。
</p>
<p>新的 API 经过的长时间的设计，直到 2012 年，<code>gawk</code> 的维护者与开发者最终才开始实现。关于 <code>xgawk</code> 项目的信息在 <a href="#gawkextlib"><code>gawkextlib</code> 项目</a>，这里提供。
</p>
<hr>
<a name="Extension-New-Mechanism-Goals"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Old-Extension-Problems" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Design" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Other-Design-Decisions" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0096_00b0ae_009c_00baaa_0088_00b6c_009a_0084c_009b_00aeae_00a0_0087"></a>
<h3 class="appendixsubsec">C.5.2 新机制的目标</h3>

<p>新 API 的目标是：
</p>
<ul>
<li>
API 应该独立于 <code>gawk</code> 的内部实现。<code>gawk</code> 的内部实现的变更不对于扩展函数的实现者是不可见的。

</li><li>
API 应该提供<em>二进制</em>兼容性，只要 <code>gawk</code> 的发行版本之间 API 没有变更。

</li><li>
API 应该可以用 C 或者 C++ 来写，使其与 <code>awk</code> 层的代码有一样的“外观”，就像 <code>awk</code> 函数一样。这就是说，扩展应该：

<ul class="no-bullet">
<li>-
有能力访问函数参数。

</li><li>-
有能力将一个未定义的函数转换为数组（通过引用调用）。

</li><li>-
有能力创建，访问与更新全局变量。

</li><li>-
方便一次性访问数组的所有元素（“数组扁平化”），使其可以用 C 代码的循环就可以迭代数组中的所有的元素。

</li><li>-
有能力创建数组（包含 <code>gawk</code> 真正的数组之数组）。
</li></ul>
</li></ul>

<p>其他的重要目标是：
</p>
<ul>
<li>
API 应该只使用 ISO C 90 的特性，这样扩展可以使用最广泛的 C 与 C++ 编译器。头文件应该包含适当的 &lsquo;<samp>#ifdef __cplusplus</samp>&rsquo; 与 &lsquo;<samp>extern &quot;C&quot;</samp>&rsquo; 等代码，这样可以使用 C++ 编译器。（如果使用 C++ 时，运行时系统要足够聪明来调用任何的构造函数与析构函数，因为 <code>gawk</code> 是一个 C 程序。在写本书时，这还没有测试过。）

</li><li>
无论是编译时还是动态连接时，API 机制应该不需要访问 <code>gawk</code> 的符号。
<a name="DOCF122" href="#FOOT122">(122)</a>
这样创建的扩展也可以用在 MS-Windows 平台上。
</li></ul>

<p>在开发的过程中，越来越清晰的是有一些特性需要提供给扩展，后面也提供了：
</p>
<ul>
<li>
扩展应该有能力将勾子打入 <code>gawk</code> 的 I/O 重向机制中。特别是 <code>xgawk</code> 的开发者提供了一种所谓的“开放勾子”来读取记录。在开发过程中，扩展对于输入处理、输出处理以及双路 I/O 的勾子都进了一般化。

</li><li>
扩展应该可以提供回调函数来执行 <code>gawk</code> 退出时的清理动作。

</li><li>
扩展应该可以提供版本字串，这样 <code>gawk</code> 的 &lsquo;<samp>--version</samp>&rsquo; 选项可以提供扩展的相关信息。
</li></ul>

<p>初看起来，避免访问 <code>gawk</code> 的符号是比较难实现的一个。
</p>
<p>在设计上，很明显 Perl 与 Ruby 以及其他的语言，可以使主线的 <code>gawk</code> 代码成为一个库，<code>gawk</code> 使用小的 C <code>main()</code> 函数来连接这个库。
</p>
<p>这看起来像摇着尾巴的狗，会导致构建与安装复杂化，使得在不同的系统中（或者同一个系统中的不同地方）都使用一个单独的 <code>gawk</code> 执行文件。
</p>
<p>我们接受了 Pat Rankin 提出的建议。查看 <a href="#Extension-Mechanism-Outline">在高层级中是它是如何工作的</a>，来获取详细信息。
</p>
<hr>
<a name="Extension-Other-Design-Decisions"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-New-Mechanism-Goals" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Design" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Future-Growth" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0085_00b6a_00bb_0096c_009a_0084e_00ae_00bee_00ae_00a1aa_0086_00b3c_00ad_0096"></a>
<h3 class="appendixsubsec">C.5.3 其他的设计决策</h3>

<p>作为任意的设计决策，扩展可以读取预定义变量与数组的值（如 <code>ARGV</code> 与 <code>FS</code>），但是不可以改变它们，除了 <code>PROCINFO</code> 外。
</p>
<p>原因是为了扩展函数影响 <code>awk</code> 程序流，使其不可按。而一个真正的 <code>awk</code> 函数可以做它自己想做的事情，这个则由程序员自己来判断。扩展函数 应该提供一个服务或者使 C API 可以在 <code>awk</code> 中可以使用。而不是将 <code>FS</code>，<code>ARGC</code> 以及 <code>ARGV</code> 弄乱。
</p>
<p>另外，很容易就可以在一个滑滑的斜坡上开头（即一旦开启刹不住——译者注）。扩展到底需要访问多少的 <code>gawk</code> 工具？它们是否需要 <code>getline</code>？是否可以调用 <code>gsub()</code> 或者编译正则表达式？直接调用 <code>awk</code> 函数如何？（<em>这</em>会弄得乱乱的）
</p>
<p>为了避免这样的问题，<code>gawk</code> 开发者以最容易的，最基础的但是确实有用的开始。
</p>
<p>另一个决策是，尽管 <code>gawk</code> 提供了像  MPFR 这样的好东西，内部使用整数索引的数组，这些特性并没有开放出来，为的是保证事情的简单，并封闭 <code>awk</code> 的传统的语义（不扩张其语义范围，如 <code>gawk</code> 是用来做字符处理的工具，而不是数学运算的工具——译者注）。（事实上，内部使用整数来索引数组如此透明，在文档中都没有记录！）
</p>
<p>其次，在 API 中的所有函数都要检查它们的指针输入参数是不是都不是 <code>NULL</code>。如果是，就返回错误。（对于扩展代码来说，验证从 <code>gawk</code> 返回的指针是不是 <code>NULL</code> 也是个好主意。这样的事情不会发生，但是 <code>gawk</code> 开发者也是人，他们据知一直以来也会偶尔犯错误。）
</p>
<p>随着时间的推移，API 也会演化，<code>gawk</code> 开发者希望这可以由用户的需要来驱动。目前，当前的 API 看起来是提供了最小的，但是功能强大的用来创建扩展的特性集合。
</p>
<hr>
<a name="Extension-Future-Growth"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Other-Design-Decisions" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Design" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Old-Extension-Mechanism" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_009c_00aaae_009d_00a5c_009a_0084aa_00a2_009ee_0095_00bfc_00a9_00bae_0097_00b4"></a>
<h3 class="appendixsubsec">C.5.4 未来的增长空间</h3>

<p>后面 API 可以两种方式被扩展：
</p>
<ul>
<li>
在第一次装载时，<code>gawk</code> 传递一个“扩展 id”到扩展中。相应的扩展然后在每个函数调用时，传递这个 id 回 <code>gawk</code>。这个机制可以使 <code>gawk</code> 来区别调用它的扩展，而它也应该知道。

</li><li>
类似的，在注册时，扩展传递一个“name space”到 <code>gawk</code> 中。这个可以实现一个未来的机制，如对扩展功能进行分组，以避免名字的冲突。
</li></ul>

<p>当然，在写这个文字的时候，对上面的东西都还没有做相应的决策。
</p>
<hr>
<a name="Old-Extension-Mechanism"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Extension-Future-Growth" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Notes-summary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_00af_00b9ae_0097_00a7ae_0089_00a9aa_00b1_0095c_009a_0084aa_0085_00bcaa_00ae_00b9ae_0080_00a7"></a>
<h2 class="appendixsec">C.6 对旧扩展的兼容性</h2>

<p>在 <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a>，中描述了所支持 API 以及为 <code>gawk</code> 写扩展的机制。这个 API 在 4.1 版本中引入。但是，很多年以来，<code>gawk</code> 提供的扩展机制都需要了解 <code>gawk</code> 的内部，这设计得并不好。
</p>
<p>为了提供一个转换时期，<code>gawk</code> 版本 4.1 还会支持最初的扩展机制。这对于一个主要的发行版本周期是这样的。在下一个主要版本发布时，这个支持也会被丢弃，并且从源代码中移除。
</p>
<p>简单地说，初始风格的扩展可以包含 &lsquo;<tt>awk.h</tt>&rsquo; 来进行编译。另外，你必须在构建时定义标识符 &lsquo;<samp>GAWK</samp>&rsquo;（在 Unix 风格的编译器中使用 &lsquo;<samp>-DGAWK</samp>&rsquo;）。否则，在 &lsquo;<tt>gawkapi.h</tt>&rsquo; 中的定义会与 &lsquo;<tt>awk.h</tt>&rsquo; 中的定义相冲突，你的扩展就没办法成功编译。
</p>
<p>如前一个版本，你使用 <code>extension()</code> 内置函数来装载一个旧风格的扩展（这个并没有文档）。这个函数然后找到并装载包含了扩展的共享对象文件，并调用 <code>dl_load()</code> C 函数。
</p>
<p>因为初始风格与新风格的扩展使用不同的初始化函数（<code>dl_load()</code> 与 <code>dlload()</code>）他们可以安全地装载在同一个目录下（可以在 <code>AWKLIBPATH</code> 中找到）而没有冲突。
</p>
<p><code>gawk</code> 的开发团队强烈建议你将旧的扩展进行转换，这样不得不使用新的 API，它们都在 <a href="#Dynamic-Extensions">编写 <code>gawk</code> 扩展</a> 中进行了描述。
</p>
<hr>
<a name="Notes-summary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Old-Extension-Mechanism" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="ae_0080_00bbc_00bb_0093-14"></a>
<h2 class="appendixsec">C.7 总结</h2>

<ul>
<li>
<code>gawk</code> 的扩展可以使用 &lsquo;<samp>--traditional</samp>&rsquo; 或者 &lsquo;<samp>--posix</samp>&rsquo; 选项被禁用。如果 <code>gawk</code> 被编译时使用了 &lsquo;<samp>-DDEBUG</samp>&rsquo;，则 &lsquo;<samp>--parsedebug</samp>&rsquo; 选项也可以使用。

</li><li>
<code>gawk</code> 的源代码通过公共的 Git 库进行维护。所有人都可以检出并查看代码。

</li><li>
欢迎对 <code>gawk</code> 作出贡献。本章中随后的步骤指出步骤可以让你的贡献更容易地与代码库进行整合。对即可用于新特性的贡献，也用于将 <code>gawk</code> 移植到其他的系统。

</li><li>
<code>gawk</code> 有一些限制——一般都是由机器的架构所导致的。

</li><li>
扩展 API 的设置目标是解决前一个扩展机制的大量问题，启用 <code>xgawk</code> 项目所需要的特性，并提供后向的二进制兼容性。

</li><li>
之前的扩展机制在 <code>gawk</code> 4.1 版本还是支持的，但是<em>会</em>在下一个主要发布版本中移除。

</li></ul>


<hr>
<a name="Basic-Concepts"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Notes" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Notes-summary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-High-Level" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Glossary" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_009f_00baae_009c_00acc_00bc_0096c_00a8_008bae_00a6_0082aa_00bf_00b5"></a>
<h1 class="appendix">Appendix D 基本编程概念</h1>
<a name="index-programming_002c-concepts"></a>
<a name="index-programming_002c-concepts-1"></a>

<p>这一附录中尝试定义一些基本的概念与术语，它们会在本网页中余下部分使用到。由于本书是一关于 <code>awk</code> 的网页，而不是计算通用编程的网页，这里所包含的内容相当粗糙简单。（如果需要更多的背景，你可以参考更多入门性质的内容。）
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            The high level view.
</td></tr>
<tr><td align="left" valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           A very quick intro to data types.
</td></tr>
</table>

<hr>
<a name="Basic-High-Level"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Basic-Concepts" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Data-Typing" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Glossary" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="c_00a8_008baa_00ba_008faa_0081_009ac_009a_0084ae_0098_00afa_00bb_0080a_00b9_0088"></a>
<h2 class="appendixsec">D.1 程序做的是什么</h2>

<a name="index-processing-data"></a>
<p>最基本的，程序的任务是处理输入数据，然后产生输出结果。
</p>
<p>如图 <a href="#figure_002dgeneral_002dflow">Figure D.1</a>.
</p>
<div class="float"><a name="figure_002dgeneral_002dflow"></a>

<img src="general-program.png" alt="General program flow">
</div><p><strong>Figure D.1: 通用的程序流程
</strong>
</p>

<a name="index-compiled-programs"></a>
<a name="index-interpreted-programs"></a>
<p>图中的“程序”可以是一个编译型程序
<a name="DOCF123" href="#FOOT123">(123)</a>
（如 <code>ls</code>），或者是<em>解释型</em>程序。后者中，特定机器上的可执行程序，如 <code>awk</code> 读入你的程序，然后使用你程序中的指令来处理数据。
</p>
<a name="index-programming_002c-basic-steps"></a>
<p>当写程序时，其包含如下最基本的步骤，
When you write a program, it usually consists
of the following, very basic set of steps,
如图 <a href="#figure_002dprocess_002dflow">Figure D.2</a>:
</p>
<div class="float"><a name="figure_002dprocess_002dflow"></a>

<img src="process-flow.png" alt="Basic Program Stages">
</div><p><strong>Figure D.2: Basic Program Steps
</strong>
</p>

<dl compact="compact">
<dt>初始化</dt>
<dd><p>这是在程序开始处理数据之前所要做的事情，如检查参数，初始化需要使用的数据等等。这个步骤对应于 <code>awk</code> 的 <code>BEGIN</code> 规则（查看 see section <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）。
</p>
<p>就像你烤蛋糕，这可能包含将所有的不同的碗与烤箱摆放好，并确保准备好所有的原料。
</p>
</dd>
<dt>处理</dt>
<dd><p>这里执行实际工作。你的程序读数据，一次一个逻辑块，然后处理它。
</p>
<p>在多数的编程语言中，你需要手工管理数据的读取，检查看是否一次读取了多块。<code>awk</code> 的模式-动作范围（查看 see section <a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">开始 <code>awk</code></a>）帮你处理了这个机制。
</p>
<p>在烤面包中，处理对应于实际的劳动：打蛋，和面、水及其他原料，并且将它们放到烤箱中。
</p>
</dd>
<dt>Clean Up</dt>
<dd><p>一旦处理完了所有的数据，你退出前你还需要做一些事情。这一个步骤对应于 <code>awk</code> 中的 <code>END</code> 规则（查看 see section <a href="#BEGIN_002fEND"><code>BEGIN</code> 与 <code>END</code> 特殊模式</a>）。
</p>
<p>当蛋糕从烤箱中取出后，你还需要将他们放到塑料盒中以防别是染指，并洗干净碗及其他器皿。
</p></dd>
</dl>

<a name="index-algorithms"></a>
<p><em>算法</em>是详细的指令集，由此来完成工作或者处理数据。这个与烤蛋糕的方法是一样的。程序实现了算法。通常，是由你来设计并实现算法。
</p>
<a name="index-records-1"></a>
<a name="index-fields-2"></a>
<p>我们在前面所说的“逻辑块”称为<em>记录</em>，如一个公司对员工所做的记录，或者学校对学生的记录，或者医生对病人所做的记录类似。每个记录都有很多组件，如名与姓，生日，地址等等。组件指的是记录中的<em>域</em>。
</p>
<p>读取数据的动作称为<em>输入</em>，毫无疑问，产生结果称为<em>输出</em>。它们一般合称为“输入/输出”，更常用的是 “I/O”的简称（你也可以看到将 “输入”与“输出”当成动词使用。）
</p>
<a name="index-data_002ddriven-languages"></a>
<a name="index-languages_002c-data_002ddriven"></a>
<p><code>awk</code> 简单数据的读取，以及将记录分拆成域。你的程序的任务就是告诉 <code>awk</code> 如何来处理数据。你通过描述要查找数据的<em>模式</em>，以及当发现这些模式的记录时所做的<em>动作</em>来完成你所要完成的任务。这是 <code>awk</code> 程序<em>数据驱动</em>的特点，因此使用这些程序易写易读。
</p>
<hr>
<a name="Basic-Data-Typing"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Basic-Concepts" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-High-Level" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Concepts" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Glossary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Glossary" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="e_00ae_00a1c_00ae_0097ae_009c_00baa_00b8_00adae_0095_00b0ae_008d_00aec_009a_0084aa_0080_00bc"></a>
<h2 class="appendixsec">D.2 计算机中数据的值</h2>

<a name="index-variables-1"></a>
<p>在程序中，你会跟踪事件的值与信息，我们称之为<em>变量</em>。一个变量只是一个给定的值的名字，例如 <code>first_name</code>,
<code>last_name</code>, <code>address</code> 等等。对于当前的输入记录以及记录的域有特殊的名字。你可以将一组有关的值组合在一起而成为数组。
</p>
<a name="index-values_002c-numeric"></a>
<a name="index-values_002c-string"></a>
<a name="index-scalar-values"></a>
<p>数据，特别是在 <code>awk</code> 中，由数组，如 42 或者 3.1415927 或者字串组成。字串实质上是非数值外的一切，例如一个名字。字串有时指<em>字符值</em>，因为们每存储组成字串的单个的字符。单个的变量，包含数组与字串变量都指的是<em>标量值</em>。一组值，如数组，就不是标量。
</p>
<p>在 <a href="#Computer-Arithmetic">计算机算术计算说明</a> 中提供了数值类型（整数与浮点数）的基本介绍，以及它们在计算机中如何被使用。请参考那里的信息，其中也包含一些注意事项。
</p>
<a name="index-null-strings-3"></a>
<p>当你可能习惯于没有数没有值（如 0）的概念时，你要习惯于零长度的字符数组可能要多费点功夫。但是，确实存在这样的事情。它被称为空串。<em>空串</em>是字符数据中没有值。就是说，它是空的。它在 <code>awk</code> 程序中写成：<code>&quot;&quot;</code>。
</p>
<p>人类习惯于以十进制，如以 10 为底，在以 10 为底的情况下，数字从 0 到 9，然后进行进位到下一个数字位。（还记得学校里的 42 = 4 x 10 + 2 吗？）
</p>
<p>有其他的数值底数。计算一般使用底数为 2，或者<em>二进制</em>，底数为 8 或者<em>八进制</em>，以及底数为 16 或者<em>十六进制</em>。在二进制中，每一个数值位表示 2 乘以所在数字列的值。每个位要么包含 0，要么包含 1。因此二进制 1010 表示  (1 x 8) + (0 x 4) + (1 x 2) + (0 x 1)，或者十进制的 10。八进制与十六进制在这里有更多的讨论 <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>。
</p>
<p>在很底层的层级上，计算机都将值存成一组二进制数字，或者是<em>位</em>。现代计算机将这些位组成在 8 位一组，称为<em>字节</em>。高级的应用程序有时需要直接处理位操作，<code>gawk</code> 也提供了这些的操作函数。
</p>
<p>程序用程序语言写成。如果没有上千，也是成百的程序语言存在。最流行的是 C 程序语言。C 语言对于 <code>awk</code> 语言的设计有巨大的影响。
</p>
<a name="index-Kernighan_002c-Brian-9"></a>
<a name="index-Ritchie_002c-Dennis"></a>
<p>有几个版本的 C 语言。第一个称为 “K&amp;R” C，由 Brian Kernighan 与 Dennis Ritchie 发明，也是第一本关于 C 语言书的作者。（Dennis Ritchie 创造了这个语言，Brian Kernighan 是 <code>awk</code> 的作者之一。）
</p>
<p>在 1980 年代中期，人们开始努力形成一个 C 的国际标准。这个工作在 1989 年完成，产生了 C 的 ANSI 标准。这个标准在 1990 年成为 ISO 标准。1999 年，一个修订版的 ISO C 标准提出并发布。因此 ，POSIX <code>awk</code> 是与 ISO 1999 的 C 的兼容的。
</p>

<hr>
<a name="Glossary"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Basic-Concepts" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Basic-Data-Typing" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Copying" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Copying" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="aa_0090_008de_00af_008de_00a7_00a3e_0087_008a"></a>
<h1 class="unnumbered">名词解释</h1>

<dl compact="compact">
<dt>Action（动作）</dt>
<dd><p>一连串的附加到规则中的语名。如果规则的模式匹配于输入记录，则 <code>awk</code> 会执行规则的动作。动作总是包含在花括号中。（查看 <a href="#Action-Overview">动作</a>）
</p>
<a name="index-Ada-programming-language"></a>
<a name="index-programming-languages_002c-Ada"></a>
</dd>
<dt>Ada</dt>
<dd><p>一种最初由美国国防部定义的编程语言。它设计用来强制使用一种好的软件工程实践。
</p>
<a name="index-Spencer_002c-Henry"></a>
<a name="index-sed-utility-2"></a>
<a name="index-amazing-awk-assembler-_0028aaa_0029"></a>
</dd>
<dt>Amazing <code>awk</code> Assembler</dt>
<dd><p>来自多伦多大学的 Henry Spencer 写了一个可重定目标机器的汇编器作为 <code>sed</code> 与 <code>awk</code> 的脚本。它只有几千行，包含了几个 8 位的微型计算机的机器描述。它应该是用另一个语言写成的很好的程序例子。你可以从这里取得：<a href="http://awk.info/?awk100/aaa">http://awk.info/?awk100/aaa</a>。
</p>
<a name="index-amazingly-workable-formatter-_0028awf_0029"></a>
<a name="index-awf-_0028amazingly-workable-formatter_0029-program"></a>
</dd>
<dt>Amazingly Workable Formatter (<code>awf</code>)</dt>
<dd><p>来自多伦多大学的 Henry Spencer 用 <code>awk</code> 与 <code>sh</code> 写了一个格式化器，可以接受 &lsquo;<samp>nroff -ms</samp>&rsquo; 与 &lsquo;<samp>nroff -man</samp>&rsquo; 格式命令的很大的子集。可以从这里获取：<a href="http://awk.info/?tools/awf">http://awk.info/?tools/awf</a>
</p>
</dd>
<dt>Anchor（锚）</dt>
<dd><p>正则表达式元字符 &lsquo;<samp>^</samp>&rsquo; 与 &lsquo;<samp>$</samp>&rsquo;，用来强制匹配串的开始与结束。
</p>
<a name="index-ANSI"></a>
</dd>
<dt>ANSI</dt>
<dd><p>美国国家标准学会。这个组织产生了很多的标准，它们中有 C 与 C++ 的编译语言标准。这些标准通常也会成为国际标准。查看 “ISO.”。
</p>
</dd>
<dt>Argument（参数）</dt>
<dd><p>参数可以表示两个不同的东西。可以是一个选项或者是传递到一个从命令行中调用的命令的文件名，或者是传递到程序，如在 <code>awk</code> 中<em>函数</em>中的任何东西。
</p>
<p>在后一种情况，参数可以通过两种方式来传递。一种是将值传递给被调用的函数，如变量的一个复本可以在被调用的函数中使用，但是原始的值不可以被函数更改；或者是通过引用来传递，如一个变量的指针传递给函数，这样，函数就可以直接修改它。在 <code>awk</code> 中，标量都是通过值传递，而数组是通过引用传递。查看 “以值/引用传递”。
</p>
</dd>
<dt>Array（数组）</dt>
<dd><p>同一个名字下的一组数值。很多的语言只提供顺序数组。<code>awk</code> 提供关联数组。
</p>
</dd>
<dt>Assertion（断言）</dt>
<dd><p>在程序中的语句指出程序在中某点上条件为真。对于合理化程序的行为很有用。
</p>
</dd>
<dt>Assignment（赋值）</dt>
<dd><p>一个 <code>awk</code> 表达式，用一塌糊涂改变 <code>awk</code> 变量或者数据对象的值。一个对象可被赋值则称为 <em>lvalue</em>。被赋的值称为 <em>rvalue</em>。查看 <a href="#Assignment-Ops">赋值表达式</a>。
</p>
</dd>
<dt>Associative Array（关联数组）</dt>
<dd><p>数组的索引可以是数值，也可以是字串，不仅仅是固定长度的顺序整数。
</p>
</dd>
<dt><code>awk</code> Language（<code>awk</code> 语言）</dt>
<dd><p><code>awk</code> 程序所使用的语言。
</p>
</dd>
<dt><code>awk</code> Program（<code>awk</code> 程序）</dt>
<dd><p><code>awk</code> 程序由一连续的<em>模式</em>与<em>动作</em>组成。这些动作统称为<em>规则</em>。对于每个输入的程序的记录，程序的规则会顺序处理。<code>awk</code> 程序也包含定义的函数。
</p>
</dd>
<dt><code>awk</code> Script（<code>awk</code> 脚本）</dt>
<dd><p><code>awk</code> 程序的别一个名字。
</p>
</dd>
<dt>Bash</dt>
<dd><p>GNU 版的标准 Shell
The GNU version of the standard shell
(the <b>B</b>ourne-<b>A</b>gain <b>SH</b>ell).
查看 “Bourne Shell”。
</p>
</dd>
<dt>Binary</dt>
<dd><p>基于两个符号，其值为 <code>0</code>&ndash;<code>1</code>。因为电路“自然地”以 2 为底进行工作（可以相像成开与关），在计算机的所有东西都以 2 为底进行计算。每一位都表示 2 的幂，被称为<em>位</em>。所以，以 2 为底的值 10101 与十进制的 21 ((1 x 16) + (1 x 4) + (1 x 1)) 相同。
</p>
<p>由于以 2 为底的数值很快变得太长而难于读写，它们一般被按 3 位进行分组（即它们可以按八进制来读），或者按 4 位进行分组（即它们可以按十六进制来读）。在 C 程序没有直接的方式来插入以 2 为底的数。存储在寄存器中以 2 为底用来表示计算机中的整数，可以直接表示了计算机的处理能力。现令的大多数计算机使用 64 位来表示整数，但是过去很多使用 32 位，16 位或者 8 位。查看 <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>。
</p>
</dd>
<dt>Bit（位）</dt>
<dd><p>“二进制数字”的简称。在计算机内存中的所有值最终都成为二进制数字：要么是 1 要么是 0。一组位则可以有不同的解释——当成整数，浮点数，字符，另一个内存对象的地址等等。<code>awk</code> 可以让你处理浮点数与字串。<code>gawk</code> 可以让你用位操作函数来操作位（查看 <a href="#Bitwise-Functions">位操作函数</a>）。
</p>
<p>计算机一般都是以用多少位来表示整数来定义的。典型的系统有 32 位系统，但是 64 位系统也起来越流行，16 位的系统会慢慢消失。
</p>
</dd>
<dt>Boolean Expression（布林表达式）</dt>
<dd><p>以英国数数家 Boole 来命名，查看“逻辑表达式”。
</p>
</dd>
<dt>Bourne Shell</dt>
<dd><p>在 Unix 或者类 Unix 系统上的标准 Shell（&lsquo;<tt>/bin/sh</tt>&rsquo;），最初由贝尔实验室的 Steven  R. Bourne 写成。很多的 Shell （Bash, <code>ksh</code>, <code>pdksh</code>, <code>zsh</code>）都与 Bourne  Shell 兼容。
</p>
</dd>
<dt>Braces（花括号）</dt>
<dd><p>字符 &lsquo;<samp>{</samp>&rsquo; 与 &lsquo;<samp>}</samp>&rsquo;。花括号用在 <code>awk</code> 用于区分由语句与函数体组成的动作。
</p>
</dd>
<dt>Bracket Expression（方括号表达式）</dt>
<dd><p>在<em>正则表达式</em>中，包含在方括号中的表达式，用来代表属于某个字符类的字符。方括号表达式可以包含一个或者多个字符的列表，如 &lsquo;<samp>[abc]</samp>&rsquo;，或者字符范围，如 &lsquo;<samp>[A-Z]</samp>&rsquo;，或者一个用 &lsquo;<samp>:</samp>&rsquo; 分割的名字，其表示一个已知的字符集，如 &lsquo;<samp>[:digit:]</samp>&rsquo;。包含在 &lsquo;<samp>:</samp>&rsquo; 之间的表达式的方括号表达式形式与字符本身的表示是无关的，可以是 ASCII  ，也可以ECBDIC ，还可以是 Unicode  编码集，则要视计算系统的架构与本地配置。查看“正则表达式”。
</p>
</dd>
<dt>Built-in Function（内置函数）</dt>
<dd><p><code>awk</code> 语言提供了内置函数来执行各种数值、I/O相关、字串计算等操作。例子有 <code>sqrt()</code>（用来计算数组的平方根）与 <code>substr()</code>（用来取字串的子串）。<code>gawk</code> 提供了用于时间戳处理，位操作，数组排序，类型检查以及运行时字串翻译的函数。（查看 <a href="#Built_002din">内置函数</a>。）
</p>
</dd>
<dt>Built-in Variable（内置变量）</dt>
<dd><p><code>ARGC</code>,
<code>ARGV</code>,
<code>CONVFMT</code>,
<code>ENVIRON</code>,
<code>FILENAME</code>,
<code>FNR</code>,
<code>FS</code>,
<code>NF</code>,
<code>NR</code>,
<code>OFMT</code>,
<code>OFS</code>,
<code>ORS</code>,
<code>RLENGTH</code>,
<code>RSTART</code>,
<code>RS</code>
和
<code>SUBSEP</code>
是对 <code>awk</code> 都有特殊的含义的变量。另外，
<code>ARGIND</code>,
<code>BINMODE</code>,
<code>ERRNO</code>,
<code>FIELDWIDTHS</code>,
<code>FPAT</code>,
<code>IGNORECASE</code>,
<code>LINT</code>,
<code>PROCINFO</code>,
<code>RT</code>
和
<code>TEXTDOMAIN</code>
是对于 <code>gawk</code> 有特殊含义的变量。对些变量的更改，会影响 <code>awk</code> 的运行时环境。（查看 <a href="#Built_002din-Variables">预定义变量</a>）
</p>
</dd>
<dt>C</dt>
<dd><p>很多的 GNU 软件都使用其编写的一种系统编程语言。<code>awk</code> 编程语言有 C 风格的语法，本网页中，我们在合适的时候也提出了 <code>awk</code> 与 C 之间的差异。
</p>
<p>一般来讲，<code>gawk</code> 尝试使其与 1990 年的 ISO C 版本相似还有有意义的。
</p>
</dd>
<dt>C Shell</dt>
<dd><p>C Shell（<code>csh</code> 或者其增强版本 <code>tcsh</code>）是一个 Unix Shell，由 Bill Joy 在 1970 年晚些时候编写。C Shell 与其他的 Shell 之间的不同在于其交互特性以整体风格，它看起来更像 C。C Shell 没有向后兼容 Bourne Shell，所以，将其他的 Unix Shell 写的脚本转换成 C Shell 的时候要特别注意，特别是对于变量的管理。查看“Bourne Shell”。
</p>
</dd>
<dt>C++</dt>
<dd><p>由 C 衍生出来的一种面向对象的很流行的编程语言。
</p>
</dd>
<dt>Character Class</dt>
<dd><p>查看“方括号表达式”。
</p>
</dd>
<dt>Character List</dt>
<dd><p>查看“方括号表达式”。
</p>
<p>#TODO
<a name="index-ASCII-1"></a>
<a name="index-ISO-8859_002d1"></a>
<a name="index-ISO-Latin_002d1"></a>
<a name="index-character-sets-_0028machine-character-encodings_0029-1"></a>
<a name="index-Unicode-2"></a>
</p></dd>
<dt>字符集</dt>
<dd><p>由计算机系统用来表示特定国家或者地区的字符（字母，数字，标点等）的数值编码集合。目前使用最多的常用字符集是 ASCII（美国信息交换标准编码）。很多的欧洲国家使用 ASCII 的扩展集，ISO-8859-1（ISO-Latin-1）。<a href="http://www.unicode.org">Unicode 字符集</a>使用得越来越普遍，并形成相应的标准，特别是在 GNU/Linux 系统上被广泛地使用。
</p>

<a name="index-Kernighan_002c-Brian-10"></a>
<a name="index-Bentley_002c-Jon"></a>
<a name="index-chem-utility"></a>
</dd>
<dt>CHEM</dt>
<dd><p><code>pic</code> 的预处理器，用来读取分子的描述并产生 <code>pic</code> 输入，用于描述。它由 Brian Kernighan 与 Jon Bentley 用 <code>awk</code> 写成。并在此可得到：<a href="http://netlib.org/typesetting/chem">http://netlib.org/typesetting/chem</a>。
</p>
</dd>
<dt>Comparison Expression（比较表达式）</dt>
<dd><p>结果为 true 或者 false 的关系，如 &lsquo;<samp>a &lt; b</samp>&rsquo;。比较表达式使用在 <code>if</code>, <code>while</code>, <code>do</code> 与 <code>for</code> 语句中，以及模式中用来从输入记录中选择记录进行处理。（查看 <a href="#Typing-and-Comparison">变量类型与比较表达式</a>。）
</p>
<a name="index-compiled-programs-1"></a>
</dd>
<dt>Compiler（编译器）</dt>
<dd><p>用来将人可读的源代码翻译成机器可执行对象代码的程序。对象代码然后直接被计算机执行。查看“解释器”。
</p>
</dd>
<dt>Complemented Bracket Expression（补方括号表达式）</dt>
<dd><p><em>方括号表达式</em>的反面。表示所有的<em>没有</em>在给定的方括号表达式的东西。符号 &lsquo;<samp>^</samp>&rsquo; 放在反方括号表达式的前面。如：&lsquo;<samp>[[^:digit:]</samp>&rsquo; 表示所有的非数字字符。&lsquo;<samp>[^bad]</samp>&rsquo; 表示不是 &lsquo;<samp>b</samp>&rsquo;, &lsquo;<samp>a</samp>&rsquo; 或 &lsquo;<samp>d</samp>&rsquo; 的所有字符。查看“方括号表达式”。
</p>
</dd>
<dt>Compound Statement（复合语句）</dt>
<dd><p>连续的包含在花括号中的 <code>awk</code> 语句。复合语句可以内嵌。（查看 <a href="#Statements">动作中的控制语句</a>。）
</p>
</dd>
<dt>Computed Regexps（计算型正则表达式）</dt>
<dd><p>查看 “动态正则表达式”。
</p>
</dd>
<dt>Concatenation（连接）</dt>
<dd><p>将两个字串进行连接表示将它们合成一块，一个接一个，来产生一个新的串。如串 &lsquo;<samp>foo</samp>&rsquo; 与串 &lsquo;<samp>bar</samp>&rsquo; 进行连接，会产生串 &lsquo;<samp>foobar</samp>&rsquo;。（查看 <a href="#Concatenation">字串连接</a>.。）
</p>
</dd>
<dt>Conditional Expression（条件表达式）</dt>
<dd><p>使用 &lsquo;<samp>?:</samp>&rsquo; 三元操作符的表达式，如 &lsquo;<samp><var>expr1</var> ? <var>expr2</var> : <var>expr3</var></samp>&rsquo;。表达式 <var>expr1</var> 求值，如果结果为 true，则整个表达式的值为 <var>expr2</var> 的值，否则为 <var>expr3</var> 的值。在每种情况下，只会对 <var>expr2</var> 或者 <var>expr3</var> 之一进行求值。（查看 <a href="#Conditional-Exp">条件表达式</a>。）
</p>
</dd>
<dt>Control Statement（控制语句）</dt>
<dd><p>控制语句是 <code>awk</code> 程序中的，如果条件为 true，则会执行一个执行给定操作或者操作集的指令。控制语句有：<code>if</code>，<code>for</code>，<code>while</code>，以及 <code>do</code>（查看 see section <a href="#Statements">动作中的控制语句</a>）。
</p>
<a name="index-McIlroy_002c-Doug"></a>
<a name="index-cookie"></a>
</dd>
<dt>Cookie</dt>
<dd><p>一种特殊的甜点符号，由程序产生或者传递给程序的影像。（感谢 Doug McIlroy 教授。）
</p>
</dd>
<dt>Coprocess（并程）</dt>
<dd><p>一种子程序，通过它可进行两路通信。
</p>
</dd>
<dt>Curly Braces（曲括号）</dt>
<dd><p>查看“花括号”。
</p>
<a name="index-dark-corner-1"></a>
</dd>
<dt>Dark Corner（暗角）</dt>
<dd><p>语言规范中常常（或者依然）不清楚的地方，从而导致非期望或者不想要的行为。这些地方在本网页中通过在页边空白用
文本中的 &ldquo;(d.c.)&rdquo; 
标志出来，并在“暗角”段中进行了索引。
</p>
</dd>
<dt>Data Driven（数据驱动）</dt>
<dd><p><code>awk</code> 程序的描述，表示你指定你感兴趣的数据来进行处理，以及在发现这些数据时所执行的动作。
</p>
</dd>
<dt>Data Objects（数据对象）</dt>
<dd><p>为数值或者字符串。在需要的时候，数值被转换成字串，或者反之。（查看 <a href="#Conversion">在字串与数值之间进行转换</a>.。）
</p>
</dd>
<dt>Deadlock（死锁）</dt>
<dd><p>两个通信的进程相互在等待对方执行某种动作的状态。
</p>
</dd>
<dt>Debugger（调试器）</dt>
<dd><p>用来帮助开发者从程序中去掉 Bug（debug）的程序。
</p>
</dd>
<dt>Double Precision（双精度）</dt>
<dd><p>数值的内部表达，这个表式可以有分数部分。双精度数可以比单精度跟踪更多的数值位，但是对他们的操作的代码也更高。这是 <code>awk</code> 存储数据的方式。它的类型为 C 的 <code>double</code> 类型。
</p>
</dd>
<dt>Dynamic Regular Expression（动态正则表达式）</dt>
<dd><p>动态正则表达式是写在常规表达式的正则表达式。它可以是一个字串常量，如 <code>&quot;foo&quot;</code>，但是也可以是基值可以变化的表达式。（查看 <a href="#Computed-Regexps">使用动态正则表达式</a>。）
</p>
</dd>
<dt>Empty String</dt>
<dd><p>See &ldquo;Null String.&rdquo;
查看“<code>Null</code> <code>String</code>”
</p>
</dd>
<dt>Environment（环境）</dt>
<dd><p>字串的集合，其格式为 &lsquo;<samp><var>name</var>=<var>val</var></samp>&rsquo;，每个程序都可以取得它。用户通常将值放到环境中，以向不同的程序传递信息。典型的例子是环境变量 <code>HOME</code> 与 <code>PATH</code>。
</p>
<a name="index-epoch_002c-definition-of"></a>
</dd>
<dt>Epoch</dt>
<dd><p>用来表示时间戳的“开始时间”的日期。大多数系统中的时间值都用从 epoch 开始的秒来表示。使用库的函数可将这些值转换为标准日期以及时间格式。
</p>
<p>Unix 与 POSIX 系统上的 epoch 是 1970-01-01 00:00:00 UTC。查看 “GMT” 与 “UTC”。
</p>
</dd>
<dt>Escape Sequences</dt>
<dd><p>特殊字符序列用来描述非打印字符，如 &lsquo;<samp>\n</samp>&rsquo; 用来表示换行行符，或者 &lsquo;<samp>\033</samp>&rsquo; 用来表示 ASCII 中的 ESC（Escape）字符。（查看 <a href="#Escape-Sequences">转义序列</a>。）
</p>
</dd>
<dt>Extension（扩展）</dt>
<dd><p>额外的特性，或者成为编程语言或者工具，但未被相应语言以及工具标准所定义。<code>gawk</code> （也）有许多的在POSIX <code>awk</code> 之外的扩展。
</p>
</dd>
<dt>FDL</dt>
<dd><p>查看 “自由文档许可”。
</p>
</dd>
<dt>Field（域）</dt>
<dd><p>当 <code>awk</code> 读取一个输入记录时，它将记录分割为由空白（或者通过改变预定义的 <code>FS</code> 变量而将正则表达式设置成的分割符）分割的片段。这些片段被称为域。如果片段是固定长度的，你可以使用内置变量 <code>FIELDWIDTHS</code> 来描述它们的长度。
如果你希望指定域的内容而不是域分割符，你可以使用即定义的变量 <code>FPAT</code> 来处理。（查看 <a href="#Field-Separators">指定记录如何进行分隔</a>，<a href="#Constant-Size">读取固定宽度数据</a>，与 <a href="#Splitting-By-Content">以内容定义域</a>。）
</p>
</dd>
<dt>Flag（标志）</dt>
<dd><p>一个变量，其真值表示某种条件是存在还是不存在。
</p>
</dd>
<dt>Floating-Point Number（浮点数）</dt>
<dd><p>在数学的术语中常指为“有理数”或者实数，这只是一个有小数部分的数。查看“双精度”与“单精度”。
</p>
</dd>
<dt>Format（格式）</dt>
<dd><p>格式串控制 <code>strftime()</code> 与 <code>sprintf()</code> 函数的输出样式，同时也会控制 <code>printf</code> 语句中的样式。另外，将数值转换为字串的转换也由预定义的变量 <code>CONVFMT</code> 与 <code>OFMT</code> 的格式串来控制。（查看 <a href="#Control-Letters">格式控制字母</a>。）
</p>
</dd>
<dt>Fortran</dt>
<dd><p>FORmula TRANslator 的缩写，第一个用于科学计算的编程语言。由 John Backus 创建 ，并在 1957 年就发布，目前依然还在使用。
</p>
</dd>
<dt>Free Documentation License（自由文档许可）</dt>
<dd><p>这个文档描述了一些条款，本网页也在这些条款下进行发布，也可以复制。（查看 <a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>.。）
</p>
<a name="index-FSF-_0028Free-Software-Foundation_0029-2"></a>
<a name="index-Free-Software-Foundation-_0028FSF_0029-2"></a>
<a name="index-Stallman_002c-Richard-3"></a>
</dd>
<dt>Free Software Foundation（自由软件基金会）</dt>
<dd><p>一个非盈利性组织，其致力于生产与发布自由发布的软件。由 Richard M. Stallman，即 Emacs 编辑器的最初作者创立。GNU Emacs 是目前使用最多的 Emacs 版本。
</p>
</dd>
<dt>FSF</dt>
<dd><p>查看“自由软件基金会”。
</p>
</dd>
<dt>Function（函数）</dt>
<dd><p>是 <code>awk</code> 程序的一部分，可以在程序中的任何位置进行调用，以执行某个任务。<code>awk</code> 有多个内置函数。用户可以定义他们自己的函数，可以放在程序中的任何位置。函数可以是递归的，即它们可以调用自己。
查看 <a href="#Functions">函数</a>。在 <code>gawk</code> 中，也可以在不同的程序中共享函数，在需要的程序中使用 <code>@include</code> 指令来包含（查看 see section <a href="#Include-Files">在你的程序中包含其他的文件</a>）。
在 <code>gawk</code> 中，可以调用的函数的名字可以在运行时生成，即动态生成。<code>gawk</code> 扩展 API 提供了构造函数（查看 see section <a href="#Constructor-Functions">构造函数</a>）。
</p>

</dd>
<dt><code>gawk</code></dt>
<dd><p><code>awk</code> 的 GNU 版本。
</p>
<a name="index-GPL-_0028General-Public-License_0029-1"></a>
<a name="index-General-Public-License-_0028GPL_0029"></a>
<a name="index-GNU-General-Public-License"></a>
</dd>
<dt>General Public License（通用公共许可）</dt>
<dd><p>这些文件描述的一些条款，<code>gawk</code> 以及它的原代码在这些条款下发布。（查看 <a href="#Copying">GNU General Public License</a>。）
</p>
</dd>
<dt>GMT</dt>
<dd><p>“Greenwich Mean Time”（格林尼治标准时间）。这是 <code>UTC</code> 的旧术语。它是 Unix 与 POSIX 系统内部使用的时期时间。查看 “Epoch” 与 “UTC”。
</p>
<a name="index-FSF-_0028Free-Software-Foundation_0029-3"></a>
<a name="index-Free-Software-Foundation-_0028FSF_0029-3"></a>
<a name="index-GNU-Project-1"></a>
</dd>
<dt>GNU</dt>
<dd><p>“GNU&rsquo;s not Unix”。是一个持续运行的自由软件基金会的项目，用来创建一个完全的，自由发布的 POSIX 兼容的计算环境。
</p>
</dd>
<dt>GNU/Linux</dt>
<dd><p>是使用 Linux Kernel 的 GNU 系统的变体，而不是自由软件基金会的 Hurd 内核。Linux 内核是一个稳定，高效，全功能的 Unix 克隆，其被移植到不各种不同的构架中。它是最流行的 PC 级的系统，但是也在其他的系统中运行。Linux 内核源代码可以在 GNU 通用公共许可的条款下获取，这可能是其最重要方面。
</p>
</dd>
<dt>GPL</dt>
<dd><p>查看“通用公共许可”。
</p>
</dd>
<dt>Hexadecimal（十六进制）</dt>
<dd><p>以 16 为底的表示法，其数字为 <code>0</code>&ndash;<code>9</code> 以及 <code>A</code>&ndash;<code>F</code>，&lsquo;<samp>A</samp>&rsquo; 表示 10，&lsquo;<samp>B</samp>&rsquo; 表示 11，等等，以此类推， &lsquo;<samp>F</samp>&rsquo; 表示 15。十六进制数组在 C 中以 &lsquo;<samp>0x</samp>&rsquo; 开头以表示其底数。因此 <code>0x12</code> 为 18((1 x 16) + 2)。查看 <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>。
</p>
</dd>
<dt>I/O</dt>
<dd><p>“Input/Output” 的缩写，是将数据移入或者移出执行程序的动作。
</p>
</dd>
<dt>Input Record（输入记录）</dt>
<dd><p>由 <code>awk</code> 读取的一块数据。通常，一个 <code>awk</code> 输入记录由一行文本构成。（查看 <a href="#Records">输入如何拆分为记录</a>。）
</p>
</dd>
<dt>Integer（整数）</dt>
<dd><p>完整之数，即没有包含小数部分的数值。
</p>
</dd>
<dt>Internationalization（国际化）</dt>
<dd><p>编写或者修改程序的过程，使其可以在多种语言下使用，而不用修改源代码。
</p>
<a name="index-interpreted-programs-1"></a>
</dd>
<dt>Interpreter（解释器）</dt>
<dd><p>读取人可读的源代码，然后使用其内部的指令来处理数据并产生结果的程序。<code>awk</code> 典型的情况下（但并不总是）实现为解释器。查看“编译器”。
</p>
</dd>
<dt>Interval Expression（区间表达式）</dt>
<dd><p>正则表达式的一个组件，可以让你重复匹配正则表达式的某个部分。区间表达式最初在 <code>awk</code> 程序中不可用。
</p>
<a name="index-ISO"></a>
</dd>
<dt>ISO</dt>
<dd><p>标准化的国际组织。这个组织为各个方面产生国际标准，包含程序语言，如 C 与 C++。在计算时代，重要的标准诸如 C，C++ 以及 POSIX 即成为美国美标，也会同时成为 ISO 的国际标准。本网页所指的标准 C 均为 “ISO C”。查看 <a href="http://www.iso.org/iso/home/about.htm">ISO 的站点</a>来获取更多的组织名字及其语言无关的三字母同意词。
</p>
<a name="index-Java-programming-language"></a>
<a name="index-programming-languages_002c-Java"></a>
</dd>
<dt>Java</dt>
<dd><p>一个由 Sun Microsystems（现在为 Oracle）开发的现代编程语言，其支持面向对象的程序方式。尽管通常通过编译为标准虚拟机指令的方式来实现（JVM），这个语言也可以编译为本地代码。
</p>
</dd>
<dt>Keyword（关键词）</dt>
<dd><p>在 <code>awk</code> 语言中，关键词有特殊的含义。关键词是保留的，不可以使用的变量名。<code>gawk</code> 的关键词有：
<code>BEGIN</code>,
<code>BEGINFILE</code>,
<code>END</code>,
<code>ENDFILE</code>,
<code>break</code>,
<code>case</code>,
<code>continue</code>,
<code>default</code>
<code>delete</code>,
<code>do&hellip;while</code>,
<code>else</code>,
<code>exit</code>,
<code>for&hellip;in</code>,
<code>for</code>,
<code>function</code>,
<code>func</code>,
<code>if</code>,
<code>next</code>,
<code>nextfile</code>,
<code>switch</code>,
和
<code>while</code>.
</p>
</dd>
<dt>Korn Shell</dt>
<dd><p><code>Korn</code> Shell（<code>ksh</code>）是由在贝尔实验室的 David Korn 在 1980 年代早期开发的。Korn Shell 与 Bourne Shell 以及很多的 C shell 特性是后向兼容的。查看 “Bourne Shell”。
</p>
<a name="index-LGPL-_0028Lesser-General-Public-License_0029"></a>
<a name="index-Lesser-General-Public-License-_0028LGPL_0029"></a>
<a name="index-GNU-Lesser-General-Public-License"></a>
</dd>
<dt>Lesser General Public License（次通用公共许可）</dt>
<dd><p>这个文档描述了相应条款，在此条款下可以发布二进制文档或者共享对象，也可以发布相应的源代码。
</p>
</dd>
<dt>LGPL</dt>
<dd><p>查看“次通用公共许可”。
</p>
</dd>
<dt>Linux</dt>
<dd><p>查看 “GNU/Linux”。
</p>
</dd>
<dt>Localization（本地化）</dt>
<dd><p>The process of providing the data necessary for an
internationalized program to work in a particular language.
</p>
</dd>
<dt>Logical Expression（逻辑表达式）</dt>
<dd><p>使用逻辑操作符 AND，OR 与 NOT 的表达式，在 <code>awk</code> 中分别写在 &lsquo;<samp>&amp;&amp;</samp>&rsquo;, &lsquo;<samp>||</samp>&rsquo;, 以及 &lsquo;<samp>!</samp>&rsquo;。通常也称为布尔表达式。以开创这种数学逻辑的数学家来命令。
</p>
</dd>
<dt>Lvalue（左值）</dt>
<dd><p>可以出现在赋值表达式左边的表达式。在很多语言中，左值（<code>lvalue</code>）可以是变量，也可以是数组元素。在 <code>awk</code> 中，域引用也可以用作左值。
</p>
</dd>
<dt>Matching（匹配）</dt>
<dd><p>将一个字串与正则表达式进行测试的动作。如果正则表达式描述了字串的内容，则说是<em>匹配</em>的。
</p>
</dd>
<dt>Metacharacters（元字符）</dt>
<dd><p>在正则表达式中并不用作为其自身的那些字符。相反，它们代表正则表达式操作，如重复，组合，选择等。
</p>
</dd>
<dt>Nesting（内嵌）</dt>
<dd><p>内嵌指的是信息以层的方式进行组织，或者对象包含了类似的对象。在 <code>gawk</code> 中，<code>@include</code> 指令可以内嵌。算术与逻辑操作“自然的”内嵌可以通过括号来改变（查看 see section <a href="#Precedence">操作符优先级（操作符的嵌套）</a>。）
</p>
</dd>
<dt>No-op</dt>
<dd><p>什么也不做的操作。
</p>
</dd>
<dt>Null String</dt>
<dd><p>没有字符的串。在 <code>awk</code> 程序中，其由两个紧邻的引号（<code>&quot;&quot;</code>）来表示。它会出现在两个紧邻的域分隔符间。
</p>
</dd>
<dt>Number（数值）</dt>
<dd><p>一个数值数据对象。现代的 <code>awk</code> 实现使用双精度浮点数来表示数值。古董级的 <code>awk</code> 实现使用单粒度浮点数。
</p>
</dd>
<dt>Octal（八进制）</dt>
<dd><p>以 8 为底的表示法，其数字为 <code>0</code>&ndash;<code>7</code>。八进制在 C 中使用前导的 &lsquo;<samp>0</samp>&rsquo; 来表示其底数。因此，<code>013</code> 表示 11 ((1 x 8) + 3)。查看 <a href="#Nondecimal_002dnumbers">八进制与十六进制数值</a>。
</p>
</dd>
<dt>Output Record（输出记录）</dt>
<dd><p>由 <code>awk</code> 输出的一块数据。通常 <code>awk</code> 输入由一到多行的文本组成。查看 <a href="#Records">输入如何拆分为记录</a>。
</p>
</dd>
<dt>Pattern（模式）</dt>
<dd><p>模式告诉 <code>awk</code> 输入记录中哪些是规则所感兴趣的。
</p>
<p>模式是任意的条件表达式，用于对输入记录进行测试。如果条件满足，则说模式与输入记录是<em>匹配</em>的。一个典型的模式会将输入记录与正则表达式匹配。（查看 <a href="#Pattern-Overview">模式元素</a>。）
</p>
</dd>
<dt>PEBKAC</dt>
<dd><p>是计算机使用问题最可能的来源的同义词。(Problem Exists Between
Keyboard And Chair.)
</p>
</dd>
<dt>Plug-in（插件）</dt>
<dd><p>查看“扩展”。
</p>
</dd>
<dt>POSIX</dt>
<dd><p>指定了可移植操作系统接口（Portable Operating System interface）一系列标准名字。“IX”表示这些标准来自于 Unix。<code>awk</code> 用户感兴趣的主要标准是用于信息技术的 IEEE 标准，1003.1-2008 标准。2008 POSIX 标准可以在线访问：<a href="http://www.opengroup.org/onlinepubs/9699919799/">http://www.opengroup.org/onlinepubs/9699919799/</a>
</p>
</dd>
<dt>Precedence（优先级）</dt>
<dd><p>当操作符使用时没有显式的括号时，操作符的执行顺序。
</p>
</dd>
<dt>Private（私有）</dt>
<dd><p>由库函数而不是主 <code>awk</code> 程序使用的变量与/或者函数。对这些变量与函数的命令要特别注意。（查看 <a href="#Library-Names">命名函数库的全局变量</a>。）
</p>
</dd>
<dt>Range (of input lines)（（输入行的）范围）</dt>
<dd><p>从输入文件中输入了一连串的连续行。一个模式可以指定输入行范围，使 <code>awk</code> 可以处理，或者它也可以指定单独的行。（查看 <a href="#Pattern-Overview">模式元素</a>。）
</p>
</dd>
<dt>Record（记录）</dt>
<dd><p>查看“输入记录”与“输入记录”。
</p>
</dd>
<dt>Recursion（递归）</dt>
<dd><p>函数直接或者间接调用它自己。如果这非常清楚，则停止，并进入下一个词条。否则参考“递归”项。（这是作用在用递归方式描述这个词条——译者注）
</p>
</dd>
<dt>Redirection（重定向）</dt>
<dd><p>重定向表示从其他的地方而不是标准输入来执行输入，或者输出到其他地方而不是标准输出。
</p>
<p>你可以使用 &lsquo;<samp>&lt;</samp>&rsquo;, &lsquo;<samp>|</samp>&rsquo;, and &lsquo;<samp>|&amp;</samp>&rsquo; 操作符将输入重定向到 <code>getline</code> 语句。也可以使用 &lsquo;<samp>&gt;</samp>&rsquo;, &lsquo;<samp>&gt;&gt;</samp>&rsquo;, &lsquo;<samp>|</samp>&rsquo;, 与 &lsquo;<samp>|&amp;</samp>&rsquo;操作符将 <code>print</code> 与 <code>printf</code> 语句的输出重定向到文件或者一个系统命令。（查看 <a href="#Getline">用 <code>getline</code> 输入数据</a> 与 <a href="#Redirection">重定向 <code>print</code> 与 <code>printf</code> 的输出</a>。）
</p>
</dd>
<dt>Reference Counts（参考记数）</dt>
<dd><p>在 <code>gawk</code> 中的一种内部机制，以最小化内存使用来存储字串变量的值。如果值所假设的变量的值在多于一个地方使用，只会有一个复本保留，当相应的值被另一个变量使用时，则参考计数会被递增，并且在相关的变量不再使用时，则递减它。当参考计算变为 0 时，存储变量值的内存空间会被释放掉。
</p>
</dd>
<dt>Regexp</dt>
<dd><p>查看“正则表达式”。
</p>
</dd>
<dt>Regular Expression（正则表达式）</dt>
<dd><p>正则表达式（“regexp”为简称）是一种模式，用来表示字串集，有可能是无限集。例如，正则表达式 &lsquo;<samp>R.*xp</samp>&rsquo; 匹配以字母 &lsquo;<samp>R</samp>&rsquo; 开头，并以 &lsquo;<samp>xp</samp>&rsquo; 结尾的所有字串。在 <code>awk</code> 中，正则表达式使用在模式以及条件表达式中。正则表达式可以包含转义序列。（查看 <a href="#Regexp">正则表达式</a>。）
</p>
</dd>
<dt>Regular Expression Constant</dt>
<dd><p>正则表达式常量是一个写在斜杠中的正则表达式，如 <code>/foo/</code>。这个正则表达式在写 <code>awk</code> 程序时就已经选定，并且在执行的过程中不可以更改。（查看 <a href="#Regexp-Usage">如何使用正则表达式</a>。）
</p>
</dd>
<dt>Regular Expression Operators（正则表达式操作符）</dt>
<dd><p>查看“元字符”。
</p>
</dd>
<dt>Rounding（舍入舍出）</dt>
<dd><p>对算术操作的结果进行舍入舍出会有诡异。有多于一种的舍入舍出方式，在 <code>gawk</code> 中，可以选择其中一种用在程序中。查看 <a href="#Setting-the-rounding-mode">设置舍入转出模式</a>。
</p>
</dd>
<dt>Rule（规则）</dt>
<dd><p><code>awk</code> 程序中的一段，用来指定如何来处理单个的输入记录。一个规则由一个<em>模式</em>与一个<em>动作</em>组成。<code>awk</code> 读取输入记录，然后针对每一个规则，如果输入记录满足规则的模式，则 <code>awk</code> 会执行规则的动作。否则，规则不会对输入记录做任何操作。
</p>
</dd>
<dt>Rvalue（右值）</dt>
<dd><p>可以出现在赋值操作符右边的值。在 <code>awk</code> 中，本质上每一个表达式都有一个值，这些值就是右值。
</p>
</dd>
<dt>Scalar（标量）</dt>
<dd><p>单一的值，可以是一个数值或者是一个字串。常规的变量是标题，数组与函数则不是。
</p>
</dd>
<dt>Search Path（搜索路径）</dt>
<dd><p>在 <code>gawk</code> 中，是用于 <code>awk</code> 程序搜索文件的目录列表。在 Shell 中，是用来搜索可执行文件的路径的列表。
</p>
</dd>
<dt><code>sed</code></dt>
<dd><p>查看“流编辑器”。
</p>
</dd>
<dt>Seed</dt>
<dd><p>一系列随机数的初始值，或者开始值。
</p>
</dd>
<dt>Shell</dt>
<dd><p>用于 Unix 或者 POSIX 兼容系统的命令解释器。Shell 即可以用于交互式，也可以用于指处理文件或者 Shell 脚本的编程语言。
</p>
</dd>
<dt>Short-Circuit（短路）</dt>
<dd><p><code>awk</code> 逻辑操作符 &lsquo;<samp>&amp;&amp;</samp>&rsquo; 与 &lsquo;<samp>||</samp>&rsquo; 的自然特性。如果整个表达式的值只需要对操作符的左边的表达式进行求值就可以确定，而右边的表达式则不会被求值。（查看 <a href="#Boolean-Ops">布林表达式</a>。）
</p>
</dd>
<dt>Side Effect（副作用）</dt>
<dd><p>如果一个表达式仅产生一个值则有一个其他的效果会随着发生，则就会发生副作用。赋值表达式，递增与递减表达式，还有函数调用都有副作用。（查看 <a href="#Assignment-Ops">赋值表达式</a>。）
</p>
</dd>
<dt>Single Precision（单精度）</dt>
<dd><p>数值的内部表示，其可以有小数部分。单精度的数值所跟踪的数值位要比双精度的数值少，但是对这些数值的操作按 CPU 时间也会少得多。这种类型被一些很老的 <code>awk</code> 版本用来存储数值值。它的类型是 C 的 <code>float</code>。
</p>
</dd>
<dt>Space（空格）</dt>
<dd><p>敲击键盘上的空格键而产生的字符。
</p>
</dd>
<dt>Special File（特殊文件）</dt>
<dd><p>文件名由 <code>gawk</code> 在内部进行解释，而不是被操作系统来直接处理，比如，&lsquo;<tt>/dev/stderr</tt>&rsquo;。（查看 <a href="#Special-Files"><code>gawk</code> 中的特殊文件名</a>。）
</p>
</dd>
<dt>Statement（语句）</dt>
<dd><p><code>awk</code> 程序中模式-动作规则中的动作部分中的表达式，或者 <code>awk</code> 函数中的表达式。一个语句可以是一个变量赋值，一个数组操作，或者一个循环等等。
</p>
</dd>
<dt>Stream Editor（流编辑器）</dt>
<dd><p>从输入流中读取记录，然后一次一个进行处理的程序。这个是批处理程序的反面。在批处理文件中，它希望它的所有输入文件在开始处理之前是完整的，同时交互式的程序则要求从用户中输入数据。
</p>
</dd>
<dt>String（字串）</dt>
<dd><p>由一串字符所组成的数据，如 &lsquo;<samp>I am a string</samp>&rsquo;。在 <code>awk</code> 中，常量字串写在双引号中，并且可能包含转义字符。（查看 <a href="#Escape-Sequences">转义序列</a>。）
</p>
</dd>
<dt>Tab</dt>
<dd><p>由敲击解盘的 <kbd>TAB</kbd> 键而产生的字符。它在输出中通常展开为 8 个空格。
</p>
</dd>
<dt>Text Domain（文本域）</dt>
<dd><p>一个标识一种应用的唯一的名字。用来在运行时将翻译的消息分组到本地语言中。
</p>
</dd>
<dt>Timestamp（时间戳）</dt>
<dd><p>一个“从 epoch 以来的秒数”格式的值，用在 Unix 与 POSIX 系统中。被用在 <code>gawk</code> 中的函数中，如 <code>mktime()</code>， <code>strftime()</code>， 与 <code>systime()</code>。查看 “Epoch”，“GMT”与“UTC”。
</p>
<a name="index-Linux-2"></a>
<a name="index-GNU_002fLinux-2"></a>
<a name="index-Unix"></a>
<a name="index-BSD_002dbased-operating-systems"></a>
<a name="index-NetBSD"></a>
<a name="index-FreeBSD"></a>
<a name="index-OpenBSD"></a>
</dd>
<dt>Unix</dt>
<dd><p>一种计算机操作系统，在 1970 年代最初由 AT&amp;T 贝尔实验室开发。一开始其在全世界的大学非常流行，然后进行了商用化，作为软件开发系统以及网络服务器系统。有很多版本的 Unix，也有几个类型相似的可自由获取的 Unix 版本的源代码（如 GNU/Linux，<a href="http://www.netbsd.org">NetBSD</a>，<a href="http://www.freebsd.org">FreeBSD</a> 以及 <a href="http://www.openbsd.org">OpenBSD</a>）。
</p>
</dd>
<dt>UTC</dt>
<dd><p>已经被授受为“Universal Coordinated Time（统一协调时）”的缩写。这是英格兰格林尼治标准时间，用于时间与日期计算的参考时间。查看 “Epoch”与“GMT”。
</p>
</dd>
<dt>Variable（变量）</dt>
<dd><p>值的名字。在 <code>awk</code> 中变量可以是标量，也可是是数组。
</p>
</dd>
<dt>Whitespace（空白）</dt>
<dd><p>一连串的空格，TAB，或者换行符出现在输入记录或者字串中。
</p>
</dd>
</dl>


<hr>
<a name="Copying"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Glossary" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Glossary" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#GNU-Free-Documentation-License" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#GNU-Free-Documentation-License" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="GNU-General-Public-License"></a>
<h1 class="unnumbered">GNU General Public License</h1>
<p align="center">Version 3, 29 June 2007
</p>

<div class="display">
<pre class="display">Copyright &copy; 2007 Free Software Foundation, Inc. <a href="http://fsf.org/">http://fsf.org/</a>

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.
</pre></div>

<a name="Preamble"></a>
<h2 class="heading">Preamble</h2>

<p>The GNU General Public License is a free, copyleft license for
software and other kinds of works.
</p>
<p>The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom
to share and change all versions of a program&mdash;to make sure it remains
free software for all its users.  We, the Free Software Foundation,
use the GNU General Public License for most of our software; it
applies also to any other work released this way by its authors.  You
can apply it to your programs, too.
</p>
<p>When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.
</p>
<p>To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you
have certain responsibilities if you distribute copies of the
software, or if you modify it: responsibilities to respect the freedom
of others.
</p>
<p>For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too,
receive or can get the source code.  And you must show them these
terms so they know their rights.
</p>
<p>Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.
</p>
<p>For the developers&rsquo; and authors&rsquo; protection, the GPL clearly explains
that there is no warranty for this free software.  For both users&rsquo; and
authors&rsquo; sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.
</p>
<p>Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so.  This is fundamentally incompatible with the
aim of protecting users&rsquo; freedom to change the software.  The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable.
Therefore, we have designed this version of the GPL to prohibit the
practice for those products.  If such problems arise substantially in
other domains, we stand ready to extend this provision to those
domains in future versions of the GPL, as needed to protect the
freedom of users.
</p>
<p>Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish
to avoid the special danger that patents applied to a free program
could make it effectively proprietary.  To prevent this, the GPL
assures that patents cannot be used to render the program non-free.
</p>
<p>The precise terms and conditions for copying, distribution and
modification follow.
</p>
<a name="TERMS-AND-CONDITIONS"></a>
<h2 class="heading">TERMS AND CONDITIONS</h2>

<ol>
<li> Definitions.

<p>&ldquo;This License&rdquo; refers to version 3 of the GNU General Public License.
</p>
<p>&ldquo;Copyright&rdquo; also means copyright-like laws that apply to other kinds
of works, such as semiconductor masks.
</p>
<p>&ldquo;The Program&rdquo; refers to any copyrightable work licensed under this
License.  Each licensee is addressed as &ldquo;you&rdquo;.  &ldquo;Licensees&rdquo; and
&ldquo;recipients&rdquo; may be individuals or organizations.
</p>
<p>To &ldquo;modify&rdquo; a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of
an exact copy.  The resulting work is called a &ldquo;modified version&rdquo; of
the earlier work or a work &ldquo;based on&rdquo; the earlier work.
</p>
<p>A &ldquo;covered work&rdquo; means either the unmodified Program or a work based
on the Program.
</p>
<p>To &ldquo;propagate&rdquo; a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.
</p>
<p>To &ldquo;convey&rdquo; a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user
through a computer network, with no transfer of a copy, is not
conveying.
</p>
<p>An interactive user interface displays &ldquo;Appropriate Legal Notices&rdquo; to
the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.
</p>
</li><li> Source Code.

<p>The &ldquo;source code&rdquo; for a work means the preferred form of the work for
making modifications to it.  &ldquo;Object code&rdquo; means any non-source form
of a work.
</p>
<p>A &ldquo;Standard Interface&rdquo; means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.
</p>
<p>The &ldquo;System Libraries&rdquo; of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
&ldquo;Major Component&rdquo;, in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.
</p>
<p>The &ldquo;Corresponding Source&rdquo; for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work&rsquo;s
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.
</p>
<p>The Corresponding Source need not include anything that users can
regenerate automatically from other parts of the Corresponding Source.
</p>
<p>The Corresponding Source for a work in source code form is that same
work.
</p>
</li><li> Basic Permissions.

<p>All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.
</p>
<p>You may make, run and propagate covered works that you do not convey,
without conditions so long as your license otherwise remains in force.
You may convey covered works to others for the sole purpose of having
them make modifications exclusively for you, or provide you with
facilities for running those works, provided that you comply with the
terms of this License in conveying all material for which you do not
control copyright.  Those thus making or running the covered works for
you must do so exclusively on your behalf, under your direction and
control, on terms that prohibit them from making any copies of your
copyrighted material outside their relationship with you.
</p>
<p>Conveying under any other circumstances is permitted solely under the
conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.
</p>
</li><li> Protecting Users&rsquo; Legal Rights From Anti-Circumvention Law.

<p>No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.
</p>
<p>When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such
circumvention is effected by exercising rights under this License with
respect to the covered work, and you disclaim any intention to limit
operation or modification of the work as a means of enforcing, against
the work&rsquo;s users, your or third parties&rsquo; legal rights to forbid
circumvention of technological measures.
</p>
</li><li> Conveying Verbatim Copies.

<p>You may convey verbatim copies of the Program&rsquo;s source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.
</p>
<p>You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.
</p>
</li><li> Conveying Modified Source Versions.

<p>You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these
conditions:
</p>
<ol>
<li>
The work must carry prominent notices stating that you modified it,
and giving a relevant date.

</li><li>
The work must carry prominent notices stating that it is released
under this License and any conditions added under section 7.  This
requirement modifies the requirement in section 4 to &ldquo;keep intact all
notices&rdquo;.

</li><li>
You must license the entire work, as a whole, under this License to
anyone who comes into possession of a copy.  This License will
therefore apply, along with any applicable section 7 additional terms,
to the whole of the work, and all its parts, regardless of how they
are packaged.  This License gives no permission to license the work in
any other way, but it does not invalidate such permission if you have
separately received it.

</li><li>
If the work has interactive user interfaces, each must display
Appropriate Legal Notices; however, if the Program has interactive
interfaces that do not display Appropriate Legal Notices, your work
need not make them do so.
</li></ol>

<p>A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
&ldquo;aggregate&rdquo; if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation&rsquo;s users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.
</p>
</li><li>  Conveying Non-Source Forms.

<p>You may convey a covered work in object code form under the terms of
sections 4 and 5, provided that you also convey the machine-readable
Corresponding Source under the terms of this License, in one of these
ways:
</p>
<ol>
<li>
Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by the
Corresponding Source fixed on a durable physical medium customarily
used for software interchange.

</li><li>
Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by a written
offer, valid for at least three years and valid for as long as you
offer spare parts or customer support for that product model, to give
anyone who possesses the object code either (1) a copy of the
Corresponding Source for all the software in the product that is
covered by this License, on a durable physical medium customarily used
for software interchange, for a price no more than your reasonable
cost of physically performing this conveying of source, or (2) access
to copy the Corresponding Source from a network server at no charge.

</li><li>
Convey individual copies of the object code with a copy of the written
offer to provide the Corresponding Source.  This alternative is
allowed only occasionally and noncommercially, and only if you
received the object code with such an offer, in accord with subsection
6b.

</li><li>
Convey the object code by offering access from a designated place
(gratis or for a charge), and offer equivalent access to the
Corresponding Source in the same way through the same place at no
further charge.  You need not require recipients to copy the
Corresponding Source along with the object code.  If the place to copy
the object code is a network server, the Corresponding Source may be
on a different server (operated by you or a third party) that supports
equivalent copying facilities, provided you maintain clear directions
next to the object code saying where to find the Corresponding Source.
Regardless of what server hosts the Corresponding Source, you remain
obligated to ensure that it is available for as long as needed to
satisfy these requirements.

</li><li>
Convey the object code using peer-to-peer transmission, provided you
inform other peers where the object code and Corresponding Source of
the work are being offered to the general public at no charge under
subsection 6d.

</li></ol>

<p>A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.
</p>
<p>A &ldquo;User Product&rdquo; is either (1) a &ldquo;consumer product&rdquo;, which means any
tangible personal property which is normally used for personal,
family, or household purposes, or (2) anything designed or sold for
incorporation into a dwelling.  In determining whether a product is a
consumer product, doubtful cases shall be resolved in favor of
coverage.  For a particular product received by a particular user,
&ldquo;normally used&rdquo; refers to a typical or common use of that class of
product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected
to use, the product.  A product is a consumer product regardless of
whether the product has substantial commercial, industrial or
non-consumer uses, unless such uses represent the only significant
mode of use of the product.
</p>
<p>&ldquo;Installation Information&rdquo; for a User Product means any methods,
procedures, authorization keys, or other information required to
install and execute modified versions of a covered work in that User
Product from a modified version of its Corresponding Source.  The
information must suffice to ensure that the continued functioning of
the modified object code is in no case prevented or interfered with
solely because modification has been made.
</p>
<p>If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).
</p>
<p>The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or
updates for a work that has been modified or installed by the
recipient, or for the User Product in which it has been modified or
installed.  Access to a network may be denied when the modification
itself materially and adversely affects the operation of the network
or violates the rules and protocols for communication across the
network.
</p>
<p>Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.
</p>
</li><li> Additional Terms.

<p>&ldquo;Additional permissions&rdquo; are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.
</p>
<p>When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.
</p>
<p>Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders
of that material) supplement the terms of this License with terms:
</p>
<ol>
<li>
Disclaiming warranty or limiting liability differently from the terms
of sections 15 and 16 of this License; or

</li><li>
Requiring preservation of specified reasonable legal notices or author
attributions in that material or in the Appropriate Legal Notices
displayed by works containing it; or

</li><li>
Prohibiting misrepresentation of the origin of that material, or
requiring that modified versions of such material be marked in
reasonable ways as different from the original version; or

</li><li>
Limiting the use for publicity purposes of names of licensors or
authors of the material; or

</li><li>
Declining to grant rights under trademark law for use of some trade
names, trademarks, or service marks; or

</li><li>
Requiring indemnification of licensors and authors of that material by
anyone who conveys the material (or modified versions of it) with
contractual assumptions of liability to the recipient, for any
liability that these contractual assumptions directly impose on those
licensors and authors.
</li></ol>

<p>All other non-permissive additional terms are considered &ldquo;further
restrictions&rdquo; within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.
</p>
<p>If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.
</p>
<p>Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions; the
above requirements apply either way.
</p>
</li><li> Termination.

<p>You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).
</p>
<p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.
</p>
<p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.
</p>
<p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.
</p>
</li><li> Acceptance Not Required for Having Copies.

<p>You are not required to accept this License in order to receive or run
a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.
</p>
</li><li> Automatic Licensing of Downstream Recipients.

<p>Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.
</p>
<p>An &ldquo;entity transaction&rdquo; is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party&rsquo;s predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.
</p>
<p>You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.
</p>
</li><li> Patents.

<p>A &ldquo;contributor&rdquo; is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor&rsquo;s &ldquo;contributor version&rdquo;.
</p>
<p>A contributor&rsquo;s &ldquo;essential patent claims&rdquo; are all patent claims owned
or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, &ldquo;control&rdquo; includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.
</p>
<p>Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor&rsquo;s essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.
</p>
<p>In the following three paragraphs, a &ldquo;patent license&rdquo; is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To &ldquo;grant&rdquo; such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.
</p>
<p>If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  &ldquo;Knowingly relying&rdquo; means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient&rsquo;s use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.
</p>
<p>If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.
</p>
<p>A patent license is &ldquo;discriminatory&rdquo; if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on
the non-exercise of one or more of the rights that are specifically
granted under this License.  You may not convey a covered work if you
are a party to an arrangement with a third party that is in the
business of distributing software, under which you make payment to the
third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties
who would receive the covered work from you, a discriminatory patent
license (a) in connection with copies of the covered work conveyed by
you (or copies made from those copies), or (b) primarily for and in
connection with specific products or compilations that contain the
covered work, unless you entered into that arrangement, or that patent
license was granted, prior to 28 March 2007.
</p>
<p>Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.
</p>
</li><li> No Surrender of Others&rsquo; Freedom.

<p>If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey
a covered work so as to satisfy simultaneously your obligations under
this License and any other pertinent obligations, then as a
consequence you may not convey it at all.  For example, if you agree
to terms that obligate you to collect a royalty for further conveying
from those to whom you convey the Program, the only way you could
satisfy both those terms and this License would be to refrain entirely
from conveying the Program.
</p>
</li><li> Use with the GNU Affero General Public License.

<p>Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.
</p>
</li><li> Revised Versions of this License.

<p>The Free Software Foundation may publish revised and/or new versions
of the GNU General Public License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.
</p>
<p>Each version is given a distinguishing version number.  If the Program
specifies that a certain numbered version of the GNU General Public
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that numbered version or
of any later version published by the Free Software Foundation.  If
the Program does not specify a version number of the GNU General
Public License, you may choose any version ever published by the Free
Software Foundation.
</p>
<p>If the Program specifies that a proxy can decide which future versions
of the GNU General Public License can be used, that proxy&rsquo;s public
statement of acceptance of a version permanently authorizes you to
choose that version for the Program.
</p>
<p>Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.
</p>
</li><li> Disclaimer of Warranty.

<p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &ldquo;AS IS&rdquo; WITHOUT
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
CORRECTION.
</p>
</li><li> Limitation of Liability.

<p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR
CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
</p>
</li><li> Interpretation of Sections 15 and 16.

<p>If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.
</p>
</li></ol>

<a name="END-OF-TERMS-AND-CONDITIONS"></a>
<h2 class="heading">END OF TERMS AND CONDITIONS</h2>

<a name="How-to-Apply-These-Terms-to-Your-New-Programs"></a>
<h2 class="heading">How to Apply These Terms to Your New Programs</h2>

<p>If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.
</p>
<p>To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the &ldquo;copyright&rdquo; line and a pointer to where the full notice is found.
</p>
<div class="smallexample">
<pre class="smallexample"><var>one line to give the program's name and a brief idea of what it does.</var>
Copyright (C) <var>year</var> <var>name of author</var>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</pre></div>

<p>Also add information on how to contact you by electronic and paper mail.
</p>
<p>If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:
</p>
<div class="smallexample">
<pre class="smallexample"><var>program</var> Copyright (C) <var>year</var> <var>name of author</var>
This program comes with ABSOLUTELY NO WARRANTY; for details type &lsquo;<samp>show w</samp>&rsquo;.
This is free software, and you are welcome to redistribute it
under certain conditions; type &lsquo;<samp>show c</samp>&rsquo; for details.
</pre></div>

<p>The hypothetical commands &lsquo;<samp>show w</samp>&rsquo; and &lsquo;<samp>show c</samp>&rsquo; should show
the appropriate parts of the General Public License.  Of course, your
program&rsquo;s commands might be different; for a GUI interface, you would
use an &ldquo;about box&rdquo;.
</p>
<p>You should also get your employer (if you work as a programmer) or school,
if any, to sign a &ldquo;copyright disclaimer&rdquo; for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</p>
<p>The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use
the GNU Lesser General Public License instead of this License.  But
first, please read <a href="http://www.gnu.org/philosophy/why-not-lgpl.html">http://www.gnu.org/philosophy/why-not-lgpl.html</a>.
</p>
<hr>
<a name="GNU-Free-Documentation-License"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Copying" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Copying" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#ADDENDUM_003a-How-to-use-this-License-for-your-documents" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="GNU-Free-Documentation-License-1"></a>
<h1 class="unnumbered">GNU Free Documentation License</h1>
<p align="center">Version 1.3, 3 November 2008
</p>

<a name="index-FDL-_0028Free-Documentation-License_0029"></a>
<a name="index-Free-Documentation-License-_0028FDL_0029"></a>
<a name="index-GNU-Free-Documentation-License"></a>


<div class="display">
<pre class="display">Copyright &copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
<a href="http://fsf.org/">http://fsf.org/</a>

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</pre></div>

<ol>
<li>
PREAMBLE

<p>The purpose of this License is to make a manual, textbook, or other
functional and useful document <em>free</em> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
</p>
<p>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.
</p>
<p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.
</p>
</li><li>
APPLICABILITY AND DEFINITIONS

<p>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &ldquo;Document&rdquo;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &ldquo;you&rdquo;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
</p>
<p>A &ldquo;Modified Version&rdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
</p>
<p>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document&rsquo;s overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
</p>
<p>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.
</p>
<p>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
</p>
<p>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.
</p>
<p>Examples of suitable formats for Transparent copies include plain
<small>ASCII</small> without markup, Texinfo input format, LaTeX input
format, <acronym>SGML</acronym> or <acronym>XML</acronym> using a publicly available
<acronym>DTD</acronym>, and standard-conforming simple <acronym>HTML</acronym>,
PostScript or <acronym>PDF</acronym> designed for human modification.  Examples
of transparent image formats include <acronym>PNG</acronym>, <acronym>XCF</acronym> and
<acronym>JPG</acronym>.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, <acronym>SGML</acronym> or
<acronym>XML</acronym> for which the <acronym>DTD</acronym> and/or processing tools are
not generally available, and the machine-generated <acronym>HTML</acronym>,
PostScript or <acronym>PDF</acronym> produced by some word processors for
output purposes only.
</p>
<p>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &ldquo;Title Page&rdquo; means
the text near the most prominent appearance of the work&rsquo;s title,
preceding the beginning of the body of the text.
</p>
<p>The &ldquo;publisher&rdquo; means any person or entity that distributes copies
of the Document to the public.
</p>
<p>A section &ldquo;Entitled XYZ&rdquo; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, &ldquo;Endorsements&rdquo;, or &ldquo;History&rdquo;.)  To &ldquo;Preserve the Title&rdquo;
of such a section when you modify the Document means that it remains a
section &ldquo;Entitled XYZ&rdquo; according to this definition.
</p>
<p>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
</p>
</li><li>
VERBATIM COPYING

<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</p>
<p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.
</p>
</li><li>
COPYING IN QUANTITY

<p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document&rsquo;s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
</p>
<p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
</p>
<p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
</p>
<p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
</p>
</li><li>
MODIFICATIONS

<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:
</p>
<ol>
<li>
Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

</li><li>
List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

</li><li>
State on the Title page the name of the publisher of the
Modified Version, as the publisher.

</li><li>
Preserve all the copyright notices of the Document.

</li><li>
Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

</li><li>
Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

</li><li>
Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document&rsquo;s license notice.

</li><li>
Include an unaltered copy of this License.

</li><li>
Preserve the section Entitled &ldquo;History&rdquo;, Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled &ldquo;History&rdquo; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

</li><li>
Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &ldquo;History&rdquo; section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

</li><li>
For any section Entitled &ldquo;Acknowledgements&rdquo; or &ldquo;Dedications&rdquo;, Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

</li><li>
Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

</li><li>
Delete any section Entitled &ldquo;Endorsements&rdquo;.  Such a section
may not be included in the Modified Version.

</li><li>
Do not retitle any existing section to be Entitled &ldquo;Endorsements&rdquo; or
to conflict in title with any Invariant Section.

</li><li>
Preserve any Warranty Disclaimers.
</li></ol>

<p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version&rsquo;s license notice.
These titles must be distinct from any other section titles.
</p>
<p>You may add a section Entitled &ldquo;Endorsements&rdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties&mdash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
</p>
<p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
</p>
</li><li>
COMBINING DOCUMENTS

<p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
</p>
<p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
</p>
<p>In the combination, you must combine any sections Entitled &ldquo;History&rdquo;
in the various original documents, forming one section Entitled
&ldquo;History&rdquo;; likewise combine any sections Entitled &ldquo;Acknowledgements&rdquo;,
and any sections Entitled &ldquo;Dedications&rdquo;.  You must delete all
sections Entitled &ldquo;Endorsements.&rdquo;
</p>
</li><li>
COLLECTIONS OF DOCUMENTS

<p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
</p>
<p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
</p>
</li><li>
AGGREGATION WITH INDEPENDENT WORKS

<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &ldquo;aggregate&rdquo; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation&rsquo;s users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
</p>
<p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document&rsquo;s Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
</p>
</li><li>
TRANSLATION

<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
</p>
<p>If a section in the Document is Entitled &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, or &ldquo;History&rdquo;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
</p>
</li><li>
TERMINATION

<p>You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.
</p>
<p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.
</p>
<p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.
</p>
<p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.
</p>
</li><li>
FUTURE REVISIONS OF THIS LICENSE

<p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.
</p>
<p>Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy&rsquo;s public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.
</p>
</li><li>
RELICENSING

<p>&ldquo;Massive Multiauthor Collaboration Site&rdquo; (or &ldquo;MMC Site&rdquo;) means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
&ldquo;Massive Multiauthor Collaboration&rdquo; (or &ldquo;MMC&rdquo;) contained in the
site means any set of copyrightable works thus published on the MMC
site.
</p>
<p>&ldquo;CC-BY-SA&rdquo; means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.
</p>
<p>&ldquo;Incorporate&rdquo; means to publish or republish a Document, in whole or
in part, as part of another Document.
</p>
<p>An MMC is &ldquo;eligible for relicensing&rdquo; if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole
or in part into the MMC, (1) had no cover texts or invariant sections,
and (2) were thus incorporated prior to November 1, 2008.
</p>
<p>The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.
</p>
</li></ol>

<hr>
<a name="ADDENDUM_003a-How-to-use-this-License-for-your-documents"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#GNU-Free-Documentation-License" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#GNU-Free-Documentation-License" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#GNU-Free-Documentation-License" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="unnumberedsec">ADDENDUM: How to use this License for your documents</h2>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
</p>
<div class="smallexample">
<pre class="smallexample">  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</pre></div>

<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &ldquo;with&hellip;Texts.&rdquo; line with this:
</p>
<div class="smallexample">
<pre class="smallexample">    with the Invariant Sections being <var>list their titles</var>, with
    the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
    being <var>list</var>.
</pre></div>

<p>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.
</p>
<p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
</p>

<hr>
<a name="Index"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#GNU-Free-Documentation-License" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#ADDENDUM_003a-How-to-use-this-License-for-your-documents" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[ &gt; ]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Index-1"></a>
<h1 class="unnumbered">Index</h1>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index-1_cp_symbol-1"><b>!</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-2"><b>&quot;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-3"><b>#</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-4"><b>$</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-5"><b>%</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-6"><b>&amp;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-7"><b>'</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-8"><b>(</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-9"><b>*</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-10"><b>+</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-11"><b>,</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-12"><b>-</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-13"><b>.</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-14"><b>/</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-15"><b>;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-16"><b>&lt;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-17"><b>=</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-18"><b>&gt;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-19"><b>?</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-20"><b>@</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-21"><b>[</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-22"><b>\</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-23"><b>^</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-24"><b>_</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-25"><b>{</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-26"><b>|</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-27"><b>~</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Index-1_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-X"><b>X</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-Y"><b>Y</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-Z"><b>Z</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-1">!</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021--operator"><code>!</code> (exclamation point), <code>!</code>  operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021-operator"><code>!</code> (exclamation point), <code>!</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021-operator-1"><code>!</code> (exclamation point), <code>!</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021-operator-2"><code>!</code> (exclamation point), <code>!</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_003d-operator"><code>!</code> (exclamation point), <code>!=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_003d-operator-1"><code>!</code> (exclamation point), <code>!=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator"><code>!</code> (exclamation point), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-1"><code>!</code> (exclamation point), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-2"><code>!</code> (exclamation point), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-3"><code>!</code> (exclamation point), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Constants">6.1.1.3 正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-4"><code>!</code> (exclamation point), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-5"><code>!</code> (exclamation point), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-6"><code>!</code> (exclamation point), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021-_0028exclamation-point_0029_002c-_0021_007e-operator-7"><code>!</code> (exclamation point), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-2">&quot;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0022-_0028double-quote_0029_002c-in-regexp-constants"><code>&quot;</code> (double quote), in regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0022-_0028double-quote_0029_002c-in-shell-commands"><code>&quot;</code> (double quote), in shell commands</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-3">#</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0023-_0028number-sign_0029_002c-_0023_0021-_0028executable-scripts_0029"><code>#</code> (number sign), <code>#!</code> (executable scripts)</a></td><td>&nbsp;</td><td valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0023-_0028number-sign_0029_002c-commenting"><code>#</code> (number sign), commenting</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-4">$</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024-_0028dollar-sign_0029_002c-_0024-field-operator"><code>$</code> (dollar sign), <code>$</code> field operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024-_0028dollar-sign_0029_002c-_0024-field-operator-1"><code>$</code> (dollar sign), <code>$</code> field operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024-_0028dollar-sign_0029_002c-incrementing-fields-and-arrays"><code>$</code> (dollar sign), incrementing fields and arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0024-_0028dollar-sign_0029_002c-regexp-operator"><code>$</code> (dollar sign), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-5">%</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025-_0028percent-sign_0029_002c-_0025-operator"><code>%</code> (percent sign), <code>%</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025-_0028percent-sign_0029_002c-_0025_003d-operator"><code>%</code> (percent sign), <code>%=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025-_0028percent-sign_0029_002c-_0025_003d-operator-1"><code>%</code> (percent sign), <code>%=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-6">&amp;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0026-_0028ampersand_0029_002c-_0026_0026-operator"><code>&amp;</code> (ampersand), <code>&amp;&amp;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0026-_0028ampersand_0029_002c-_0026_0026-operator-1"><code>&amp;</code> (ampersand), <code>&amp;&amp;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0026-_0028ampersand_0029_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions-and"><code>&amp;</code> (ampersand), <code>gsub()</code>/<code>gensub()</code>/<code>sub()</code> functions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-7">&rsquo;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0027-_0028single-quote_0029"><code>'</code> (single quote)</a></td><td>&nbsp;</td><td valign="top"><a href="#One_002dshot">1.1.1 一次性 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0027-_0028single-quote_0029-in-gawk-command-lines"><code>'</code> (single quote) in <code>gawk</code> command lines</a></td><td>&nbsp;</td><td valign="top"><a href="#Long">1.1.3 运行长程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0027-_0028single-quote_0029_002c-in-shell-commands"><code>'</code> (single quote), in shell commands</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0027-_0028single-quote_0029_002c-vs_002e-apostrophe"><code>'</code> (single quote), vs. apostrophe</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0027-_0028single-quote_0029_002c-with-double-quotes"><code>'</code> (single quote), with double quotes</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-8">(</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0028_0029-_0028parentheses_0029_002c-in-a-profile"><code>()</code> (parentheses), in a profile</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0028_0029-_0028parentheses_0029_002c-regexp-operator"><code>()</code> (parentheses), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-9">*</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a-operator_002c-as-multiplication-operator"><code>*</code> (asterisk), <code>*</code> operator, as multiplication operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a-operator_002c-as-regexp-operator"><code>*</code> (asterisk), <code>*</code> operator, as regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a-operator_002c-null-strings_002c-matching"><code>*</code> (asterisk), <code>*</code> operator, null strings, matching</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a_002a-operator"><code>*</code> (asterisk), <code>**</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a_002a-operator-1"><code>*</code> (asterisk), <code>**</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a_002a_003d-operator"><code>*</code> (asterisk), <code>**=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a_002a_003d-operator-1"><code>*</code> (asterisk), <code>**=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a_003d-operator"><code>*</code> (asterisk), <code>*=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a-_0028asterisk_0029_002c-_002a_003d-operator-1"><code>*</code> (asterisk), <code>*=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-10">+</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028plus-sign_0029_002c-_002b-operator"><code>+</code> (plus sign), <code>+</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028plus-sign_0029_002c-_002b-operator-1"><code>+</code> (plus sign), <code>+</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028plus-sign_0029_002c-_002b_002b-operator"><code>+</code> (plus sign), <code>++</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028plus-sign_0029_002c-_002b_002b-operator-1"><code>+</code> (plus sign), <code>++</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028plus-sign_0029_002c-_002b_002b-operator-2"><code>+</code> (plus sign), <code>++</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028plus-sign_0029_002c-_002b_003d-operator"><code>+</code> (plus sign), <code>+=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028plus-sign_0029_002c-_002b_003d-operator-1"><code>+</code> (plus sign), <code>+=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b-_0028plus-sign_0029_002c-regexp-operator"><code>+</code> (plus sign), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-11">,</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002c-_0028comma_0029_002c-in-range-patterns"><code>,</code> (comma), in range patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-12">-</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028hyphen_0029_002c-_002d-operator"><code>-</code> (hyphen), <code>-</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028hyphen_0029_002c-_002d-operator-1"><code>-</code> (hyphen), <code>-</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028hyphen_0029_002c-_002d_002d-operator"><code>-</code> (hyphen), <code>--</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028hyphen_0029_002c-_002d_002d-operator-1"><code>-</code> (hyphen), <code>--</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028hyphen_0029_002c-_002d_003d-operator"><code>-</code> (hyphen), <code>-=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028hyphen_0029_002c-_002d_003d-operator-1"><code>-</code> (hyphen), <code>-=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028hyphen_0029_002c-filenames-beginning-with"><code>-</code> (hyphen), filenames beginning with</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d-_0028hyphen_0029_002c-in-bracket-expressions"><code>-</code> (hyphen), in bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dassign-option">&lsquo;<samp>--assign</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dbignum-option">&lsquo;<samp>--bignum</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dcharacters_002das_002dbytes-option">&lsquo;<samp>--characters-as-bytes</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dcopyright-option">&lsquo;<samp>--copyright</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddebug-option">&lsquo;<samp>--debug</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddisable_002dextensions-configuration-option">&lsquo;<samp>--disable-extensions</samp>&rsquo; configuration option</a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddisable_002dlint-configuration-option">&lsquo;<samp>--disable-lint</samp>&rsquo; configuration option</a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddisable_002dnls-configuration-option">&lsquo;<samp>--disable-nls</samp>&rsquo; configuration option</a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddump_002dvariables-option">&lsquo;<samp>--dump-variables</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002ddump_002dvariables-option_002c-using-for-library-functions">&lsquo;<samp>--dump-variables</samp>&rsquo; option, using for library functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dexec-option">&lsquo;<samp>--exec</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dfield_002dseparator-option">&lsquo;<samp>--field-separator</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dfile-option">&lsquo;<samp>--file</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dgen_002dpot-option">&lsquo;<samp>--gen-pot</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dgen_002dpot-option-1">&lsquo;<samp>--gen-pot</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dgen_002dpot-option-2">&lsquo;<samp>--gen-pot</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dhelp-option">&lsquo;<samp>--help</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dinclude-option">&lsquo;<samp>--include</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dlint-option">&lsquo;<samp>--lint</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dlint-option-1">&lsquo;<samp>--lint</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dlint_002dold-option">&lsquo;<samp>--lint-old</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dload-option">&lsquo;<samp>--load</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dnon_002ddecimal_002ddata-option">&lsquo;<samp>--non-decimal-data</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dnon_002ddecimal_002ddata-option-1">&lsquo;<samp>--non-decimal-data</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dnon_002ddecimal_002ddata-option_002c-strtonum_0028_0029-function-and">&lsquo;<samp>--non-decimal-data</samp>&rsquo; option, <code>strtonum()</code> function and</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002doptimize-option">&lsquo;<samp>--optimize</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dposix-option">&lsquo;<samp>--posix</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dposix-option_002c-_002d_002dtraditional-option-and">&lsquo;<samp>--posix</samp>&rsquo; option, <code>--traditional</code> option and</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dpretty_002dprint-option">&lsquo;<samp>--pretty-print</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dprofile-option">&lsquo;<samp>--profile</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dprofile-option-1">&lsquo;<samp>--profile</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dre_002dinterval-option">&lsquo;<samp>--re-interval</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dsandbox-option">&lsquo;<samp>--sandbox</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dsandbox-option_002c-disabling-system_0028_0029-function">&lsquo;<samp>--sandbox</samp>&rsquo; option, disabling <code>system()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dsandbox-option_002c-input-redirection-with-getline">&lsquo;<samp>--sandbox</samp>&rsquo; option, input redirection with <code>getline</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dsandbox-option_002c-output-redirection-with-print_002c-printf">&lsquo;<samp>--sandbox</samp>&rsquo; option, output redirection with <code>print</code>, <code>printf</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dsource-option">&lsquo;<samp>--source</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dtraditional-option">&lsquo;<samp>--traditional</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dtraditional-option_002c-_002d_002dposix-option-and">&lsquo;<samp>--traditional</samp>&rsquo; option, <code>--posix</code> option and</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002duse_002dlc_002dnumeric-option">&lsquo;<samp>--use-lc-numeric</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dversion-option">&lsquo;<samp>--version</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d_002dwith_002dwhiny_002duser_002dstrftime-configuration-option">&lsquo;<samp>--with-whiny-user-strftime</samp>&rsquo; configuration option</a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002db-option">&lsquo;<samp>-b</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dc-option">&lsquo;<samp>-c</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dC-option">&lsquo;<samp>-C</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dd-option">&lsquo;<samp>-d</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dD-option">&lsquo;<samp>-D</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002de-option">&lsquo;<samp>-e</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dE-option">&lsquo;<samp>-E</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002de-option-1">&lsquo;<samp>-e</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002df-option">&lsquo;<samp>-f</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Long">1.1.3 运行长程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dF-option">&lsquo;<samp>-F</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002df-option-1">&lsquo;<samp>-f</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dF-option_002c-_002dFt-sets-FS-to-TAB">&lsquo;<samp>-F</samp>&rsquo; option, &lsquo;<samp>-Ft</samp>&rsquo; sets <code>FS</code> to TAB</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dF-option_002c-command_002dline">&lsquo;<samp>-F</samp>&rsquo; option, command-line</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002df-option_002c-multiple-uses">&lsquo;<samp>-f</samp>&rsquo; option, multiple uses</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dg-option">&lsquo;<samp>-g</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dh-option">&lsquo;<samp>-h</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002di-option">&lsquo;<samp>-i</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dl-option">&lsquo;<samp>-l</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dl-option-1">&lsquo;<samp>-l</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dL-option">&lsquo;<samp>-L</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dM-option">&lsquo;<samp>-M</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dn-option">&lsquo;<samp>-n</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dN-option">&lsquo;<samp>-N</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002do-option">&lsquo;<samp>-o</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dO-option">&lsquo;<samp>-O</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dp-option">&lsquo;<samp>-p</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dP-option">&lsquo;<samp>-P</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dr-option">&lsquo;<samp>-r</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dS-option">&lsquo;<samp>-S</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dv-option">&lsquo;<samp>-v</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dV-option">&lsquo;<samp>-V</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dv-option-1">&lsquo;<samp>-v</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Options">6.1.3.2 在命令行中进行变量赋值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002dW-option">&lsquo;<samp>-W</samp>&rsquo; option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-13">.</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002e-_0028period_0029_002c-regexp-operator"><code>.</code> (period), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002egmo-files"><code>.gmo</code> files</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002egmo-files_002c-specifying-directory-of"><code>.gmo</code> files, specifying directory of</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002egmo-files_002c-specifying-directory-of-1"><code>.gmo</code> files, specifying directory of</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002emo-files_002c-converting-from-_002epo"><code>.mo</code> files, converting from <code>.po</code></a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002epo-files"><code>.po</code> files</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002epo-files-1"><code>.po</code> files</a></td><td>&nbsp;</td><td valign="top"><a href="#Translator-i18n">2.4 翻译 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002epo-files_002c-converting-to-_002emo"><code>.po</code> files, converting to <code>.mo</code></a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002epot-files"><code>.pot</code> files</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-14">/</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002f-_0028forward-slash_0029-to-enclose-regular-expressions"><code>/</code> (forward slash) to enclose regular expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp">3 正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002f-_0028forward-slash_0029_002c-_002f-operator"><code>/</code> (forward slash), <code>/</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002f-_0028forward-slash_0029_002c-_002f_003d-operator"><code>/</code> (forward slash), <code>/=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002f-_0028forward-slash_0029_002c-_002f_003d-operator-1"><code>/</code> (forward slash), <code>/=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002f-_0028forward-slash_0029_002c-_002f_003d-operator_002c-vs_002e-_002f_003d_2026_002f-regexp-constant"><code>/</code> (forward slash), <code>/=</code> operator, vs. <code>/=&hellip;/</code> regexp constant</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002f-_0028forward-slash_0029_002c-patterns-and"><code>/</code> (forward slash), patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002f_003d-operator-vs_002e-_002f_003d_2026_002f-regexp-constant"><code>/=</code> operator vs. <code>/=&hellip;/</code> regexp constant</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002fdev_002f_2026-special-files"><code>/dev/&hellip;</code> special files</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002fdev_002ffd_002fN-special-files-_0028gawk_0029"><code>/dev/fd/<var>N</var></code> special files (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002finet_002f_2026-special-files-_0028gawk_0029"><code>/inet/&hellip;</code> special files (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002finet4_002f_2026-special-files-_0028gawk_0029"><code>/inet4/&hellip;</code> special files (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002finet6_002f_2026-special-files-_0028gawk_0029"><code>/inet6/&hellip;</code> special files (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-15">;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003b-_0028semicolon_0029_002c-AWKPATH-variable-and"><code>;</code> (semicolon), <code>AWKPATH</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003b-_0028semicolon_0029_002c-separating-statements-in-actions"><code>;</code> (semicolon), separating statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003b-_0028semicolon_0029_002c-separating-statements-in-actions-1"><code>;</code> (semicolon), separating statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Action-Overview">7.3 动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003b-_0028semicolon_0029_002c-separating-statements-in-actions-2"><code>;</code> (semicolon), separating statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-16">&lt;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c-_0028left-angle-bracket_0029_002c-_003c-operator"><code>&lt;</code> (left angle bracket), <code>&lt;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c-_0028left-angle-bracket_0029_002c-_003c-operator-1"><code>&lt;</code> (left angle bracket), <code>&lt;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c-_0028left-angle-bracket_0029_002c-_003c-operator-_0028I_002fO_0029"><code>&lt;</code> (left angle bracket), <code>&lt;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c-_0028left-angle-bracket_0029_002c-_003c_003d-operator"><code>&lt;</code> (left angle bracket), <code>&lt;=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c-_0028left-angle-bracket_0029_002c-_003c_003d-operator-1"><code>&lt;</code> (left angle bracket), <code>&lt;=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-17">=</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003d-_0028equals-sign_0029_002c-_003d-operator"><code>=</code> (equals sign), <code>=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003d-_0028equals-sign_0029_002c-_003d_003d-operator"><code>=</code> (equals sign), <code>==</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003d-_0028equals-sign_0029_002c-_003d_003d-operator-1"><code>=</code> (equals sign), <code>==</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-18">&gt;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e-_0028right-angle-bracket_0029_002c-_003e-operator"><code>&gt;</code> (right angle bracket), <code>&gt;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e-_0028right-angle-bracket_0029_002c-_003e-operator-1"><code>&gt;</code> (right angle bracket), <code>&gt;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e-_0028right-angle-bracket_0029_002c-_003e-operator-_0028I_002fO_0029"><code>&gt;</code> (right angle bracket), <code>&gt;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e-_0028right-angle-bracket_0029_002c-_003e_003d-operator"><code>&gt;</code> (right angle bracket), <code>&gt;=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e-_0028right-angle-bracket_0029_002c-_003e_003d-operator-1"><code>&gt;</code> (right angle bracket), <code>&gt;=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e-_0028right-angle-bracket_0029_002c-_003e_003e-operator-_0028I_002fO_0029"><code>&gt;</code> (right angle bracket), <code>&gt;&gt;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e-_0028right-angle-bracket_0029_002c-_003e_003e-operator-_0028I_002fO_0029-1"><code>&gt;</code> (right angle bracket), <code>&gt;&gt;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-19">?</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f-_0028question-mark_0029_002c-_003f_003a-operator"><code>?</code> (question mark), <code>?:</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f-_0028question-mark_0029_002c-regexp-operator"><code>?</code> (question mark), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f-_0028question-mark_0029_002c-regexp-operator-1"><code>?</code> (question mark), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-20">@</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040_002dnotation-for-indirect-function-calls"><code>@</code>-notation for indirect function calls</a></td><td>&nbsp;</td><td valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040include-directive"><code>@include</code> directive</a></td><td>&nbsp;</td><td valign="top"><a href="#Include-Files">2.7 在你的程序中包含其他的文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040load-directive"><code>@load</code> directive</a></td><td>&nbsp;</td><td valign="top"><a href="#Loading-Shared-Libraries">2.8 在你的程序装入动态扩展</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-21">[</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005b_005d-_0028square-brackets_0029_002c-regexp-operator"><code>[]</code> (square brackets), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-22">\</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029"><code>\</code> (backslash)</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-as-field-separator"><code>\</code> (backslash), as field separator</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-continuing-lines-and"><code>\</code> (backslash), continuing lines and</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-continuing-lines-and_002c-comments-and"><code>\</code> (backslash), continuing lines and, comments and</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-continuing-lines-and_002c-in-csh"><code>\</code> (backslash), continuing lines and, in <code>csh</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions-and"><code>\</code> (backslash), <code>gsub()</code>/<code>gensub()</code>/<code>sub()</code> functions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-in-bracket-expressions"><code>\</code> (backslash), in bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-in-escape-sequences"><code>\</code> (backslash), in escape sequences</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-in-escape-sequences-1"><code>\</code> (backslash), in escape sequences</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-in-escape-sequences_002c-POSIX-and"><code>\</code> (backslash), in escape sequences, POSIX and</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-in-regexp-constants"><code>\</code> (backslash), in regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-in-shell-commands"><code>\</code> (backslash), in shell commands</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-regexp-operator"><code>\</code> (backslash), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005c_0022-escape-sequence"><code>\</code> (backslash), <code>\&quot;</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005c_0027-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\'</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005c_002f-escape-sequence"><code>\</code> (backslash), <code>\/</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005c_003c-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\&lt;</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005c_003e-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\&gt;</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005ca-escape-sequence"><code>\</code> (backslash), <code>\a</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cb-escape-sequence"><code>\</code> (backslash), <code>\b</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cB-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\B</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cf-escape-sequence"><code>\</code> (backslash), <code>\f</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cn-escape-sequence"><code>\</code> (backslash), <code>\n</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cnnn-escape-sequence"><code>\</code> (backslash), <code>\</code><var>nnn</var> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cr-escape-sequence"><code>\</code> (backslash), <code>\r</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cs-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\s</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cS-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\S</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005ct-escape-sequence"><code>\</code> (backslash), <code>\t</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cv-escape-sequence"><code>\</code> (backslash), <code>\v</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cw-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\w</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cW-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\W</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cx-escape-sequence"><code>\</code> (backslash), <code>\x</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005cy-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\y</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005c-_0028backslash_0029_002c-_005c_0060-operator-_0028gawk_0029"><code>\</code> (backslash), <code>\`</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-23">^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e-_0028caret_0029_002c-in-bracket-expressions"><code>^</code> (caret), in bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e-_0028caret_0029_002c-in-FS"><code>^</code> (caret), in <code>FS</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e-_0028caret_0029_002c-regexp-operator"><code>^</code> (caret), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e-_0028caret_0029_002c-regexp-operator-1"><code>^</code> (caret), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e-_0028caret_0029_002c-_005e-operator"><code>^</code> (caret), <code>^</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e-_0028caret_0029_002c-_005e_003d-operator"><code>^</code> (caret), <code>^=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e-_0028caret_0029_002c-_005e_003d-operator-1"><code>^</code> (caret), <code>^=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-24">_</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005f-_0028underscore_0029_002c-C-macro"><code>_</code> (underscore), C macro</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005f-_0028underscore_0029_002c-in-names-of-private-variables"><code>_</code> (underscore), in names of private variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005f-_0028underscore_0029_002c-translatable-string"><code>_</code> (underscore), translatable string</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005fgr_005finit_0028_0029-user_002ddefined-function"><code>_gr_init()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005ford_005finit_0028_0029-user_002ddefined-function"><code>_ord_init()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005fpw_005finit_0028_0029-user_002ddefined-function"><code>_pw_init()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-25">{</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007b_007d-_0028braces_0029"><code>{}</code> (braces)</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007b_007d-_0028braces_0029_002c-actions-and"><code>{}</code> (braces), actions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Action-Overview">7.3 动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007b_007d-_0028braces_0029_002c-statements_002c-grouping"><code>{}</code> (braces), statements, grouping</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-26">|</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029"><code>|</code> (vertical bar)</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c-operator-_0028I_002fO_0029"><code>|</code> (vertical bar), <code>|</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c-operator-_0028I_002fO_0029-1"><code>|</code> (vertical bar), <code>|</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c-operator-_0028I_002fO_0029-2"><code>|</code> (vertical bar), <code>|</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029"><code>|</code> (vertical bar), <code>|&amp;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029-1"><code>|</code> (vertical bar), <code>|&amp;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029-2"><code>|</code> (vertical bar), <code>|&amp;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029-3"><code>|</code> (vertical bar), <code>|&amp;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c_0026-operator-_0028I_002fO_0029_002c-pipes_002c-closing"><code>|</code> (vertical bar), <code>|&amp;</code> operator (I/O), pipes, closing</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c_007c-operator"><code>|</code> (vertical bar), <code>||</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c-_0028vertical-bar_0029_002c-_007c_007c-operator-1"><code>|</code> (vertical bar), <code>||</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_symbol-27">~</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029_002c-_007e-operator"><code>~</code> (tilde), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029_002c-_007e-operator-1"><code>~</code> (tilde), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029_002c-_007e-operator-2"><code>~</code> (tilde), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029_002c-_007e-operator-3"><code>~</code> (tilde), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Constants">6.1.1.3 正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029_002c-_007e-operator-4"><code>~</code> (tilde), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029_002c-_007e-operator-5"><code>~</code> (tilde), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029_002c-_007e-operator-6"><code>~</code> (tilde), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e-_0028tilde_0029_002c-_007e-operator-7"><code>~</code> (tilde), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-accessing-fields">accessing fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-accessing-global-variables-from-extensions">accessing global variables from extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Symbol-Table-Access">5.4.10 符号表访问</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-account-information">account information</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-account-information-1">account information</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-actions">actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Action-Overview">7.3 动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-actions_002c-control-statements-in">actions, control statements in</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-actions_002c-default">actions, default</a></td><td>&nbsp;</td><td valign="top"><a href="#Very-Simple">1.3 一些简单例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-actions_002c-empty">actions, empty</a></td><td>&nbsp;</td><td valign="top"><a href="#Very-Simple">1.3 一些简单例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ada-programming-language">Ada programming language</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-adding_002c-features-to-gawk">adding, features to <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Adding-Code">C.2.2 添加新特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-adding_002c-fields">adding, fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advanced-features_002c-fixed_002dwidth-data">advanced features, fixed-width data</a></td><td>&nbsp;</td><td valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advanced-features_002c-gawk">advanced features, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">1 <code>gawk</code> 的高级特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advanced-features_002c-network-programming">advanced features, network programming</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advanced-features_002c-nondecimal-input-data">advanced features, nondecimal input data</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advanced-features_002c-processes_002c-communicating-with">advanced features, processes, communicating with</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advanced-features_002c-specifying-field-content">advanced features, specifying field content</a></td><td>&nbsp;</td><td valign="top"><a href="#Splitting-By-Content">4.7 以内容定义域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Aho_002c-Alfred">Aho, Alfred</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Aho_002c-Alfred-1">Aho, Alfred</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-alarm-clock-example-program">alarm clock example program</a></td><td>&nbsp;</td><td valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-alarm_002eawk-program"><code>alarm.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-algorithms">algorithms</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-allocating-memory-for-extensions">allocating memory for extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Memory-Allocation-Functions">5.4.3 内存分配函数与相应的简化宏</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-amazing-awk-assembler-_0028aaa_0029">amazing <code>awk</code> assembler (<code>aaa</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-amazingly-workable-formatter-_0028awf_0029">amazingly workable formatter (<code>awf</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ambiguity_002c-syntactic_003a-_002f_003d-operator-vs_002e-_002f_003d_2026_002f-regexp-constant">ambiguity, syntactic: <code>/=</code> operator vs. <code>/=&hellip;/</code> regexp constant</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ampersand-_0028_0026_0029_002c-_0026_0026-operator">ampersand (<code>&amp;</code>), <code>&amp;&amp;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ampersand-_0028_0026_0029_002c-_0026_0026-operator-1">ampersand (<code>&amp;</code>), <code>&amp;&amp;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ampersand-_0028_0026_0029_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions-and">ampersand (<code>&amp;</code>), <code>gsub()</code>/<code>gensub()</code>/<code>sub()</code> functions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-anagram_002eawk-program"><code>anagram.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Anagram-Program">2.3.10 从字典中查找单词</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-anagrams_002c-finding">anagrams, finding</a></td><td>&nbsp;</td><td valign="top"><a href="#Anagram-Program">2.3.10 从字典中查找单词</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AND-bitwise-operation">AND bitwise operation</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-and-Boolean_002dlogic-operator">and Boolean-logic operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-and_0028_0029-function-_0028gawk_0029"><code>and()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ANSI">ANSI</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-API-informational-variables">API informational variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-API-Informational-Variables">5.4.12.2 信息变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-API-version">API version</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Versioning">5.4.12.1 API Version Constants and Variables</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arbitrary-precision">arbitrary precision</a></td><td>&nbsp;</td><td valign="top"><a href="#Arbitrary-Precision-Arithmetic">4 算术运算与 <code>gawk</code> 中的任意精度算术运算</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arbitrary-precision-integers">arbitrary precision integers</a></td><td>&nbsp;</td><td valign="top"><a href="#Arbitrary-Precision-Integers">4.5 <code>gawk</code> 中的任意精度整数计算</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-archaeologists">archaeologists</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arctangent">arctangent</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ARGC_002fARGV-variables"><code>ARGC</code>/<code>ARGV</code> variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ARGC_002fARGV-variables_002c-command_002dline-arguments"><code>ARGC</code>/<code>ARGV</code> variables, command-line arguments</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ARGC_002fARGV-variables_002c-how-to-use"><code>ARGC</code>/<code>ARGV</code> variables, how to use</a></td><td>&nbsp;</td><td valign="top"><a href="#ARGC-and-ARGV">7.5.3 使用 <code>ARGC</code> 与 <code>ARGV</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ARGC_002fARGV-variables_002c-portability-and"><code>ARGC</code>/<code>ARGV</code> variables, portability and</a></td><td>&nbsp;</td><td valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ARGIND-variable"><code>ARGIND</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ARGIND-variable_002c-command_002dline-arguments"><code>ARGIND</code> variable, command-line arguments</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arguments_002c-command_002dline">arguments, command-line</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arguments_002c-command_002dline-1">arguments, command-line</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arguments_002c-command_002dline-2">arguments, command-line</a></td><td>&nbsp;</td><td valign="top"><a href="#ARGC-and-ARGV">7.5.3 使用 <code>ARGC</code> 与 <code>ARGV</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arguments_002c-command_002dline_002c-invoking-awk">arguments, command-line, invoking <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arguments_002c-in-function-calls">arguments, in function calls</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Calls">6.4 函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arguments_002c-processing">arguments, processing</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ARGV-array_002c-indexing-into"><code>ARGV</code> array, indexing into</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arithmetic-operators">arithmetic operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-array-manipulation-in-extensions">array manipulation in extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Manipulation">5.4.11 数组操作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-array-members">array members</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-array-scanning-order_002c-controlling">array scanning order, controlling</a></td><td>&nbsp;</td><td valign="top"><a href="#Controlling-Scanning">8.1.6 在 <code>gawk</code> 中使用预定义的数组遍历顺序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-array_002c-number-of-elements">array, number of elements</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays">arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Arrays">8 <code>awk</code> 数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays-of-arrays">arrays of arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Arrays-of-Arrays">8.6 多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-an-example-of-using">arrays, an example of using</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Example">8.1.4 基本数组实例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-and-IGNORECASE-variable">arrays, and <code>IGNORECASE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-as-parameters-to-functions">arrays, as parameters to functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-associative">arrays, associative</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-associative_002c-library-functions-and">arrays, associative, library functions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-deleting-entire-contents">arrays, deleting entire contents</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-elements-that-don_0027t-exist">arrays, elements that don&rsquo;t exist</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-elements_002c-assigning-values">arrays, elements, assigning values</a></td><td>&nbsp;</td><td valign="top"><a href="#Assigning-Elements">8.1.3 给数组元素赋值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-elements_002c-deleting">arrays, elements, deleting</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-elements_002c-order-of-access-by-in-operator">arrays, elements, order of access by <code>in</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-elements_002c-retrieving-number-of">arrays, elements, retrieving number of</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-for-statement-and">arrays, <code>for</code> statement and</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-indexing">arrays, indexing</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-merging-into-strings">arrays, merging into strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Join-Function">1.2.6 将数组合并成字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-multidimensional">arrays, multidimensional</a></td><td>&nbsp;</td><td valign="top"><a href="#Multidimensional">8.5 多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-multidimensional_002c-scanning">arrays, multidimensional, scanning</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiscanning">8.5.1 遍历多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-numeric-subscripts">arrays, numeric subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-referencing-elements">arrays, referencing elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-scanning">arrays, scanning</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-sorting">arrays, sorting</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-sorting_002c-and-IGNORECASE-variable">arrays, sorting, and <code>IGNORECASE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-sparse">arrays, sparse</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-subscripts_002c-uninitialized-variables-as">arrays, subscripts, uninitialized variables as</a></td><td>&nbsp;</td><td valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-arrays_002c-unassigned-elements">arrays, unassigned elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-artificial-intelligence_002c-gawk-and">artificial intelligence, <code>gawk</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#Distribution-contents">B.1.3 <code>gawk</code> 发布版的内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ASCII">ASCII</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ASCII-1">ASCII</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asort_0028_0029-function-_0028gawk_0029"><code>asort()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asort_0028_0029-function-_0028gawk_0029-1"><code>asort()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asort_0028_0029-function-_0028gawk_0029_002c-arrays_002c-sorting"><code>asort()</code> function (<code>gawk</code>), arrays, sorting</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asorti_0028_0029-function-_0028gawk_0029"><code>asorti()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asorti_0028_0029-function-_0028gawk_0029-1"><code>asorti()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asorti_0028_0029-function-_0028gawk_0029_002c-arrays_002c-sorting"><code>asorti()</code> function (<code>gawk</code>), arrays, sorting</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assert_0028_0029-function-_0028C-library_0029"><code>assert()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Assert-Function">1.2.2 断言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assert_0028_0029-user_002ddefined-function"><code>assert()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Assert-Function">1.2.2 断言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assertions">assertions</a></td><td>&nbsp;</td><td valign="top"><a href="#Assert-Function">1.2.2 断言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assign-values-to-variables_002c-in-debugger">assign values to variables, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assignment-operators">assignment operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assignment-operators_002c-evaluation-order">assignment operators, evaluation order</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assignment-operators_002c-lvalues_002frvalues">assignment operators, lvalues/rvalues</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-assignments-as-filenames">assignments as filenames</a></td><td>&nbsp;</td><td valign="top"><a href="#Ignoring-Assigns">1.3.5 将赋值当成是文件名</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-associative-arrays">associative arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a-operator_002c-as-multiplication-operator">asterisk (<code>*</code>), <code>*</code> operator, as multiplication operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a-operator_002c-as-regexp-operator">asterisk (<code>*</code>), <code>*</code> operator, as regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a-operator_002c-null-strings_002c-matching">asterisk (<code>*</code>), <code>*</code> operator, null strings, matching</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a_002a-operator">asterisk (<code>*</code>), <code>**</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a_002a-operator-1">asterisk (<code>*</code>), <code>**</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a_002a_003d-operator">asterisk (<code>*</code>), <code>**=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a_002a_003d-operator-1">asterisk (<code>*</code>), <code>**=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a_003d-operator">asterisk (<code>*</code>), <code>*=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-asterisk-_0028_002a_0029_002c-_002a_003d-operator-1">asterisk (<code>*</code>), <code>*=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-atan2_0028_0029-function"><code>atan2()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-automatic-displays_002c-in-debugger">automatic displays, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awf-_0028amazingly-workable-formatter_0029-program"><code>awf</code> (amazingly workable formatter) program</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-debugging_002c-enabling"><code>awk</code> debugging, enabling</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-language_002c-POSIX-version"><code>awk</code> language, POSIX version</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-profiling_002c-enabling"><code>awk</code> profiling, enabling</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs"><code>awk</code> programs</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs-1"><code>awk</code> programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs-2"><code>awk</code> programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Two-Rules">1.4 两规则的例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-complex"><code>awk</code> programs, complex</a></td><td>&nbsp;</td><td valign="top"><a href="#When">1.8 何时使用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-documenting"><code>awk</code> programs, documenting</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-documenting-1"><code>awk</code> programs, documenting</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-examples-of"><code>awk</code> programs, examples of</a></td><td>&nbsp;</td><td valign="top"><a href="#Sample-Programs">2 实用的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-execution-of"><code>awk</code> programs, execution of</a></td><td>&nbsp;</td><td valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-internationalizing"><code>awk</code> programs, internationalizing</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-internationalizing-1"><code>awk</code> programs, internationalizing</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-lengthy"><code>awk</code> programs, lengthy</a></td><td>&nbsp;</td><td valign="top"><a href="#Long">1.1.3 运行长程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-lengthy_002c-assertions"><code>awk</code> programs, lengthy, assertions</a></td><td>&nbsp;</td><td valign="top"><a href="#Assert-Function">1.2.2 断言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-location-of"><code>awk</code> programs, location of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-location-of-1"><code>awk</code> programs, location of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-location-of-2"><code>awk</code> programs, location of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-one_002dline-examples"><code>awk</code> programs, one-line examples</a></td><td>&nbsp;</td><td valign="top"><a href="#Very-Simple">1.3 一些简单例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-profiling"><code>awk</code> programs, profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-running"><code>awk</code> programs, running</a></td><td>&nbsp;</td><td valign="top"><a href="#Running-gawk">1.1 如何执行 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-running-1"><code>awk</code> programs, running</a></td><td>&nbsp;</td><td valign="top"><a href="#Long">1.1.3 运行长程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-running_002c-from-shell-scripts"><code>awk</code> programs, running, from shell scripts</a></td><td>&nbsp;</td><td valign="top"><a href="#One_002dshot">1.1.1 一次性 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-running_002c-without-input-files"><code>awk</code> programs, running, without input files</a></td><td>&nbsp;</td><td valign="top"><a href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk-programs_002c-shell-variables-in"><code>awk</code> programs, shell variables in</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Shell-Variables">7.2 在程序中使用 Shell 变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-function-of"><code>awk</code>, function of</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-gawk-and"><code>awk</code>, <code>gawk</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-gawk-and-1"><code>awk</code>, <code>gawk</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#This-Manual">使用本书</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-history-of"><code>awk</code>, history of</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-implementation-issues_002c-pipes"><code>awk</code>, implementation issues, pipes</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-implementations"><code>awk</code>, implementations</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-implementations_002c-limits"><code>awk</code>, implementations, limits</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-invoking"><code>awk</code>, invoking</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-new-vs_002e-old"><code>awk</code>, new vs. old</a></td><td>&nbsp;</td><td valign="top"><a href="#Names">玫瑰别名</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-new-vs_002e-old_002c-OFMT-variable"><code>awk</code>, new vs. old, <code>OFMT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-POSIX-and"><code>awk</code>, POSIX and</a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-POSIX-and_002c-See-Also-POSIX-awk"><code>awk</code>, POSIX and, See Also POSIX <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-regexp-constants-and"><code>awk</code>, regexp constants and</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-See-Also-gawk"><code>awk</code>, See Also <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-terms-describing"><code>awk</code>, terms describing</a></td><td>&nbsp;</td><td valign="top"><a href="#This-Manual">使用本书</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-uses-for"><code>awk</code>, uses for</a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-uses-for-1"><code>awk</code>, uses for</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-uses-for-2"><code>awk</code>, uses for</a></td><td>&nbsp;</td><td valign="top"><a href="#When">1.8 何时使用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-versions-of"><code>awk</code>, versions of</a></td><td>&nbsp;</td><td valign="top"><a href="#V7_002fSVR3_002e1">A.1 在 V7 与 SVR3.1 之间的变化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-versions-of_002c-changes-between-SVR3_002e1-and-SVR4"><code>awk</code>, versions of, changes between SVR3.1 and SVR4</a></td><td>&nbsp;</td><td valign="top"><a href="#SVR4">A.2 在 SVR3.1 与 SVR4 之间的变化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-versions-of_002c-changes-between-SVR4-and-POSIX-awk"><code>awk</code>, versions of, changes between SVR4 and POSIX <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#POSIX">A.3 在 SVR4 与 POSIX 之间的变化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-versions-of_002c-changes-between-V7-and-SVR3_002e1"><code>awk</code>, versions of, changes between V7 and SVR3.1</a></td><td>&nbsp;</td><td valign="top"><a href="#V7_002fSVR3_002e1">A.1 在 V7 与 SVR3.1 之间的变化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-versions-of_002c-See-Also-Brian-Kernighan_0027s-awk"><code>awk</code>, versions of, See Also Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#BTL">A.4 Brian Kernighan 的 <code>awk</code> 的扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awk_002c-versions-of_002c-See-Also-Brian-Kernighan_0027s-awk-1"><code>awk</code>, versions of, See Also Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awka-compiler-for-awk"><code>awka</code> compiler for <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AWKLIBPATH-environment-variable"><code>AWKLIBPATH</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#AWKLIBPATH-Variable">2.5.2 环境变量 <code>AWKLIBPATH</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AWKPATH-environment-variable"><code>AWKPATH</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#AWKPATH-Variable">2.5.1 环境变量 <code>AWKPATH</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-AWKPATH-environment-variable-1"><code>AWKPATH</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awkprof_002eout-file"><code>awkprof.out</code> file</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awksed_002eawk-program"><code>awksed.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Simple-Sed">2.3.8 一个简单的流编辑器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-awkvars_002eout-file">&lsquo;<tt>awkvars.out</tt>&rsquo; file</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-b-debugger-command-_0028alias-for-break_0029"><code>b</code> debugger command (alias for <code>break</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029">backslash (<code>\</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-as-field-separator">backslash (<code>\</code>), as field separator</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-continuing-lines-and">backslash (<code>\</code>), continuing lines and</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-continuing-lines-and_002c-comments-and">backslash (<code>\</code>), continuing lines and, comments and</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-continuing-lines-and_002c-in-csh">backslash (<code>\</code>), continuing lines and, in <code>csh</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions-and">backslash (<code>\</code>), <code>gsub()</code>/<code>gensub()</code>/<code>sub()</code> functions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-in-bracket-expressions">backslash (<code>\</code>), in bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-in-escape-sequences">backslash (<code>\</code>), in escape sequences</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-in-escape-sequences-1">backslash (<code>\</code>), in escape sequences</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-in-escape-sequences_002c-POSIX-and">backslash (<code>\</code>), in escape sequences, POSIX and</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-in-regexp-constants">backslash (<code>\</code>), in regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-in-shell-commands">backslash (<code>\</code>), in shell commands</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-regexp-operator">backslash (<code>\</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005c_0022-escape-sequence">backslash (<code>\</code>), <code>\&quot;</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005c_0027-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\'</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005c_002f-escape-sequence">backslash (<code>\</code>), <code>\/</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005c_003c-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\&lt;</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005c_003e-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\&gt;</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005ca-escape-sequence">backslash (<code>\</code>), <code>\a</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cb-escape-sequence">backslash (<code>\</code>), <code>\b</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cB-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\B</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cf-escape-sequence">backslash (<code>\</code>), <code>\f</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cn-escape-sequence">backslash (<code>\</code>), <code>\n</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cnnn-escape-sequence">backslash (<code>\</code>), <code>\</code><var>nnn</var> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cr-escape-sequence">backslash (<code>\</code>), <code>\r</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cs-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\s</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cS-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\S</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005ct-escape-sequence">backslash (<code>\</code>), <code>\t</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cv-escape-sequence">backslash (<code>\</code>), <code>\v</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cw-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\w</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cW-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\W</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cx-escape-sequence">backslash (<code>\</code>), <code>\x</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005cy-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\y</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backslash-_0028_005c_0029_002c-_005c_0060-operator-_0028gawk_0029">backslash (<code>\</code>), <code>\`</code> operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-backtrace-debugger-command"><code>backtrace</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Beebe_002c-Nelson-H_002eF_002e">Beebe, Nelson H.F.</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Beebe_002c-Nelson-H_002eF_002e-1">Beebe, Nelson H.F.</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern"><code>BEGIN</code> pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern-1"><code>BEGIN</code> pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGIN_002fEND">7.1.4 <code>BEGIN</code> 与 <code>END</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern-2"><code>BEGIN</code> pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-BEGIN_002fEND">7.1.4.1 开始与结束动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-and-profiling"><code>BEGIN</code> pattern, and profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-assert_0028_0029-user_002ddefined-function-and"><code>BEGIN</code> pattern, <code>assert()</code> user-defined function and</a></td><td>&nbsp;</td><td valign="top"><a href="#Assert-Function">1.2.2 断言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-Boolean-patterns-and"><code>BEGIN</code> pattern, Boolean patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-exit-statement-and"><code>BEGIN</code> pattern, <code>exit</code> statement and</a></td><td>&nbsp;</td><td valign="top"><a href="#Exit-Statement">7.4.10 <code>exit</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-getline-and"><code>BEGIN</code> pattern, <code>getline</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-headings_002c-adding"><code>BEGIN</code> pattern, headings, adding</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-next_002fnextfile-statements-and"><code>BEGIN</code> pattern, <code>next</code>/<code>nextfile</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-next_002fnextfile-statements-and-1"><code>BEGIN</code> pattern, <code>next</code>/<code>nextfile</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-OFS_002fORS-variables_002c-assigning-values-to"><code>BEGIN</code> pattern, <code>OFS</code>/<code>ORS</code> variables, assigning values to</a></td><td>&nbsp;</td><td valign="top"><a href="#Output-Separators">5.3 输出分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-operators-and"><code>BEGIN</code> pattern, operators and</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-BEGIN_002fEND">7.1.4.1 开始与结束动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-print-statement-and"><code>BEGIN</code> pattern, <code>print</code> statement and</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-pwcat-program"><code>BEGIN</code> pattern, <code>pwcat</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-running-awk-programs-and"><code>BEGIN</code> pattern, running <code>awk</code> programs and</a></td><td>&nbsp;</td><td valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGIN-pattern_002c-TEXTDOMAIN-variable-and"><code>BEGIN</code> pattern, <code>TEXTDOMAIN</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGINFILE-pattern"><code>BEGINFILE</code> pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BEGINFILE-pattern_002c-Boolean-patterns-and"><code>BEGINFILE</code> pattern, Boolean patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-beginfile_0028_0029-user_002ddefined-function"><code>beginfile()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Filetrans-Function">1.3.1 注意数据文件的边界</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bentley_002c-Jon">Bentley, Jon</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Benzinger_002c-Michael">Benzinger, Michael</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Berry_002c-Karl">Berry, Karl</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Berry_002c-Karl-1">Berry, Karl</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Berry_002c-Karl-2">Berry, Karl</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges-and-Locales">A.8 正则表达式范围与本地语言设置：又臭又长陈年旧事</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-binary-input_002foutput">binary input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bindtextdomain_0028_0029-function-_0028C-library_0029"><code>bindtextdomain()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bindtextdomain_0028_0029-function-_0028gawk_0029"><code>bindtextdomain()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bindtextdomain_0028_0029-function-_0028gawk_0029-1"><code>bindtextdomain()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bindtextdomain_0028_0029-function-_0028gawk_0029_002c-portability-and"><code>bindtextdomain()</code> function (<code>gawk</code>), portability and</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BINMODE-variable"><code>BINMODE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BINMODE-variable-1"><code>BINMODE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bit_002dmanipulation-functions">bit-manipulation functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bits2str_0028_0029-user_002ddefined-function"><code>bits2str()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bitwise-AND">bitwise AND</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bitwise-complement">bitwise complement</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bitwise-OR">bitwise OR</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bitwise-XOR">bitwise XOR</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bitwise_002c-complement">bitwise, complement</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bitwise_002c-operations">bitwise, operations</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bitwise_002c-shift">bitwise, shift</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-body_002c-in-actions">body, in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-body_002c-in-loops">body, in loops</a></td><td>&nbsp;</td><td valign="top"><a href="#While-Statement">7.4.2 <code>while</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Boolean-expressions">Boolean expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Boolean-expressions_002c-as-patterns">Boolean expressions, as patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Boolean-operators_002c-See-Boolean-expressions">Boolean operators, See Boolean expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Bourne-shell_002c-quoting-rules-for">Bourne shell, quoting rules for</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-braces-_0028_007b_007d_0029">braces (<code>{}</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-braces-_0028_007b_007d_0029_002c-actions-and">braces (<code>{}</code>), actions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Action-Overview">7.3 动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-braces-_0028_007b_007d_0029_002c-statements_002c-grouping">braces (<code>{}</code>), statements, grouping</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions">bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions-1">bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions_002c-character-classes">bracket expressions, character classes</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions_002c-collating-elements">bracket expressions, collating elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions_002c-collating-symbols">bracket expressions, collating symbols</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions_002c-complemented">bracket expressions, complemented</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions_002c-equivalence-classes">bracket expressions, equivalence classes</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions_002c-non_002dASCII">bracket expressions, non-ASCII</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bracket-expressions_002c-range-expressions">bracket expressions, range expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-break-debugger-command"><code>break</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-break-statement"><code>break</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-breakpoint">breakpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugging-Terms">3.1.2 调试概念</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-breakpoint-at-location_002c-how-to-delete">breakpoint at location, how to delete</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-breakpoint-commands">breakpoint commands</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-breakpoint-condition">breakpoint condition</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-breakpoint_002c-delete-by-number">breakpoint, delete by number</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-breakpoint_002c-how-to-disable-or-enable">breakpoint, how to disable or enable</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-breakpoint_002c-setting">breakpoint, setting</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brennan_002c-Michael">Brennan, Michael</a></td><td>&nbsp;</td><td valign="top"><a href="#Foreword3">第三版前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brennan_002c-Michael-1">Brennan, Michael</a></td><td>&nbsp;</td><td valign="top"><a href="#Foreword4">第四版前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brennan_002c-Michael-2">Brennan, Michael</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brennan_002c-Michael-3">Brennan, Michael</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brennan_002c-Michael-4">Brennan, Michael</a></td><td>&nbsp;</td><td valign="top"><a href="#Simple-Sed">2.3.8 一个简单的流编辑器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brennan_002c-Michael-5">Brennan, Michael</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brennan_002c-Michael-6">Brennan, Michael</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#When">1.8 何时使用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-1">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-2">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-3">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-4">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-5">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-6">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-7">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-8">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Continue-Statement">7.4.7 <code>continue</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-9">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Nextfile-Statement">7.4.9 <code>nextfile</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-10">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-11">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-12">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk-13">Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk_002c-extensions">Brian Kernighan&rsquo;s <code>awk</code>, extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#BTL">A.4 Brian Kernighan 的 <code>awk</code> 的扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brian-Kernighan_0027s-awk_002c-source-code">Brian Kernighan&rsquo;s <code>awk</code>, source code</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brini_002c-Davide">Brini, Davide</a></td><td>&nbsp;</td><td valign="top"><a href="#Signature-Program">2.3.11 来些新鲜的</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brink_002c-Jeroen">Brink, Jeroen</a></td><td>&nbsp;</td><td valign="top"><a href="#DOS-Quoting">1.1.6.1 MS-Windows 批处理文件中的引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Broder_002c-Alan-J_002e">Broder, Alan J.</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Brown_002c-Martin">Brown, Martin</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BSD_002dbased-operating-systems">BSD-based operating systems</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bt-debugger-command-_0028alias-for-backtrace_0029"><code>bt</code> debugger command (alias for <code>backtrace</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Buening_002c-Andreas">Buening, Andreas</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Buening_002c-Andreas-1">Buening, Andreas</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Buening_002c-Andreas-2">Buening, Andreas</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-buffering_002c-input_002foutput">buffering, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-buffering_002c-input_002foutput-1">buffering, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-buffering_002c-interactive-vs_002e-noninteractive">buffering, interactive vs. noninteractive</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-buffers_002c-flushing">buffers, flushing</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-buffers_002c-flushing-1">buffers, flushing</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-buffers_002c-operators-for">buffers, operators for</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bug-reports_002c-email-address_002c-bug_002dgawk_0040gnu_002eorg">bug reports, email address, <code>bug-gawk@gnu.org</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bug_002dgawk_0040gnu_002eorg-bug-reporting-address"><code>bug-gawk@gnu.org</code> bug reporting address</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-built_002din-functions">built-in functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Functions">9 函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-built_002din-functions_002c-evaluation-order">built-in functions, evaluation order</a></td><td>&nbsp;</td><td valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BusyBox-Awk">BusyBox Awk</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-c_002ee_002e_002c-See-common-extensions">c.e., See common extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#ae_009a_0097e_00a7_0092">暗角</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-call-by-reference">call by reference</a></td><td>&nbsp;</td><td valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-call-by-value">call by value</a></td><td>&nbsp;</td><td valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-call-stack_002c-display-in-debugger">call stack, display in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-caret-_0028_005e_0029_002c-in-bracket-expressions">caret (<code>^</code>), in bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-caret-_0028_005e_0029_002c-regexp-operator">caret (<code>^</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-caret-_0028_005e_0029_002c-regexp-operator-1">caret (<code>^</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-caret-_0028_005e_0029_002c-_005e-operator">caret (<code>^</code>), <code>^</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-caret-_0028_005e_0029_002c-_005e_003d-operator">caret (<code>^</code>), <code>^=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-caret-_0028_005e_0029_002c-_005e_003d-operator-1">caret (<code>^</code>), <code>^=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-case-keyword"><code>case</code> keyword</a></td><td>&nbsp;</td><td valign="top"><a href="#Switch-Statement">7.4.5 <code>switch</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-case-sensitivity_002c-and-regexps">case sensitivity, and regexps</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-case-sensitivity_002c-and-string-comparisons">case sensitivity, and string comparisons</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-case-sensitivity_002c-array-indices-and">case sensitivity, array indices and</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-case-sensitivity_002c-converting-case">case sensitivity, converting case</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-case-sensitivity_002c-example-programs">case sensitivity, example programs</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-case-sensitivity_002c-gawk">case sensitivity, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-case-sensitivity_002c-regexps-and">case sensitivity, regexps and</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CGI_002c-awk-scripts-for">CGI, <code>awk</code> scripts for</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-character-classes_002c-See-bracket-expressions">character classes, See bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-character-lists-in-regular-expression">character lists in regular expression</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-character-lists_002c-See-bracket-expressions">character lists, See bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-character-sets-_0028machine-character-encodings_0029">character sets (machine character encodings)</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-character-sets-_0028machine-character-encodings_0029-1">character sets (machine character encodings)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-character-sets_002c-See-Also-bracket-expressions">character sets, See Also bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-characters_002c-counting">characters, counting</a></td><td>&nbsp;</td><td valign="top"><a href="#Wc-Program">2.2.7 统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-characters_002c-transliterating">characters, transliterating</a></td><td>&nbsp;</td><td valign="top"><a href="#Translate-Program">2.3.3 转换字符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-characters_002c-values-of-as-numbers">characters, values of as numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Chassell_002c-Robert-J_002e">Chassell, Robert J.</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chdir_0028_0029-extension-function"><code>chdir()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-File-Functions">5.7.1 与文件相关的函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chem-utility"><code>chem</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chr_0028_0029-extension-function"><code>chr()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Ord">5.7.5 字符与数值：<code>ord()</code> 与 <code>chr()</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-chr_0028_0029-user_002ddefined-function"><code>chr()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-clear-debugger-command"><code>clear</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Cliff-random-numbers">Cliff random numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Cliff-Random-Function">1.2.4 Cliff 随机数生成器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cliff_005frand_0028_0029-user_002ddefined-function"><code>cliff_rand()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Cliff-Random-Function">1.2.4 Cliff 随机数生成器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-close-file-or-coprocess">close file or coprocess</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-close_0028_0029-function"><code>close()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-close_0028_0029-function-1"><code>close()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-close_0028_0029-function_002c-portability"><code>close()</code> function, portability</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-close_0028_0029-function_002c-return-value"><code>close()</code> function, return value</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-close_0028_0029-function_002c-two_002dway-pipes-and"><code>close()</code> function, two-way pipes and</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Close_002c-Diane">Close, Diane</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Close_002c-Diane-1">Close, Diane</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Collado_002c-Manuel">Collado, Manuel</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-collating-elements">collating elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-collating-symbols">collating symbols</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Colombo_002c-Antonio">Colombo, Antonio</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Colombo_002c-Antonio-1">Colombo, Antonio</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-columns_002c-aligning">columns, aligning</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-columns_002c-cutting">columns, cutting</a></td><td>&nbsp;</td><td valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comma-_0028_002c_0029_002c-in-range-patterns">comma (<code>,</code>), in range patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-completion_002c-in-debugger">command completion, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Readline-Support">3.4 支持</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-arguments">command line, arguments</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-arguments-1">command line, arguments</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-arguments-2">command line, arguments</a></td><td>&nbsp;</td><td valign="top"><a href="#ARGC-and-ARGV">7.5.3 使用 <code>ARGC</code> 与 <code>ARGV</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-directories-on">command line, directories on</a></td><td>&nbsp;</td><td valign="top"><a href="#Command_002dline-directories">4.11 命令行中的目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-formats">command line, formats</a></td><td>&nbsp;</td><td valign="top"><a href="#Running-gawk">1.1 如何执行 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-FS-on_002c-setting">command line, <code>FS</code> on, setting</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-invoking-awk-from">command line, invoking <code>awk</code> from</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-option-_002df">command line, option &lsquo;<samp>-f</samp>&rsquo;</a></td><td>&nbsp;</td><td valign="top"><a href="#Long">1.1.3 运行长程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-options">command line, options</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-options_002c-end-of">command line, options, end of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command-line_002c-variables_002c-assigning-on">command line, variables, assigning on</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Options">6.1.3.2 在命令行中进行变量赋值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command_002dline-options_002c-processing">command-line options, processing</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-command_002dline-options_002c-string-extraction">command-line options, string extraction</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands-debugger-command"><code>commands</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commands-to-execute-at-breakpoint">commands to execute at breakpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commenting">commenting</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-commenting_002c-backslash-continuation-and">commenting, backslash continuation and</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-_002a_002a-operator">common extensions, <code>**</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-_002a_002a_003d-operator">common extensions, <code>**=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-_002fdev_002fstderr-special-file">common extensions, <code>/dev/stderr</code> special file</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-_002fdev_002fstdin-special-file">common extensions, <code>/dev/stdin</code> special file</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-_002fdev_002fstdout-special-file">common extensions, <code>/dev/stdout</code> special file</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-BINMODE-variable">common extensions, <code>BINMODE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-delete-to-delete-entire-arrays">common extensions, <code>delete</code> to delete entire arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-func-keyword">common extensions, <code>func</code> keyword</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-length_0028_0029-applied-to-an-array">common extensions, <code>length()</code> applied to an array</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-RS-as-a-regexp">common extensions, <code>RS</code> as a regexp</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-single-character-fields">common extensions, single character fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-common-extensions_002c-_005cx-escape-sequence">common extensions, <code>\x</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comp_002elang_002eawk-newsgroup"><code>comp.lang.awk</code> newsgroup</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comparison-expressions">comparison expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comparison-expressions_002c-as-patterns">comparison expressions, as patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-comparison-expressions_002c-string-vs_002e-regexp">comparison expressions, string vs. regexp</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compatibility-mode-_0028gawk_0029_002c-extensions">compatibility mode (<code>gawk</code>), extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#POSIX_002fGNU">A.5 不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compatibility-mode-_0028gawk_0029_002c-file-names">compatibility mode (<code>gawk</code>), file names</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-Caveats">5.8.3 特殊文件名说明</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compatibility-mode-_0028gawk_0029_002c-hexadecimal-numbers">compatibility mode (<code>gawk</code>), hexadecimal numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compatibility-mode-_0028gawk_0029_002c-octal-numbers">compatibility mode (<code>gawk</code>), octal numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compatibility-mode-_0028gawk_0029_002c-specifying">compatibility mode (<code>gawk</code>), specifying</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compiled-programs">compiled programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compiled-programs-1">compiled programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compiling-gawk-for-Cygwin">compiling <code>gawk</code> for Cygwin</a></td><td>&nbsp;</td><td valign="top"><a href="#Cygwin">B.3.1.5 在 Cygwin 中使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compiling-gawk-for-MS_002dDOS-and-MS_002dWindows">compiling <code>gawk</code> for MS-DOS and MS-Windows</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Compiling">B.3.1.2 为 PC 操作系统编译 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compiling-gawk-for-VMS">compiling <code>gawk</code> for VMS</a></td><td>&nbsp;</td><td valign="top"><a href="#VMS-Compilation">B.3.2.1 在 VMS 上编译 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compiling-gawk-with-EMX-for-OS_002f2">compiling <code>gawk</code> with EMX for OS/2</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Compiling">B.3.1.2 为 PC 操作系统编译 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compl_0028_0029-function-_0028gawk_0029"><code>compl()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-complement_002c-bitwise">complement, bitwise</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compound-statements_002c-control-statements-and">compound statements, control statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-concatenating">concatenating</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-condition-debugger-command"><code>condition</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-conditional-expressions">conditional expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-configuration-option_002c-_002d_002ddisable_002dextensions">configuration option, <code>--disable-extensions</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-configuration-option_002c-_002d_002ddisable_002dlint">configuration option, <code>--disable-lint</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-configuration-option_002c-_002d_002ddisable_002dnls">configuration option, <code>--disable-nls</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-configuration-option_002c-_002d_002dwith_002dwhiny_002duser_002dstrftime">configuration option, <code>--with-whiny-user-strftime</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-configuration-options_002c-gawk">configuration options, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-constant-regexps">constant regexps</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-constants_002c-nondecimal">constants, nondecimal</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-constants_002c-numeric">constants, numeric</a></td><td>&nbsp;</td><td valign="top"><a href="#Scalar-Constants">6.1.1.1 数值与字串常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-constants_002c-types-of">constants, types of</a></td><td>&nbsp;</td><td valign="top"><a href="#Constants">6.1.1 常量表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continue-program_002c-in-debugger">continue program, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-continue-statement"><code>continue</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Continue-Statement">7.4.7 <code>continue</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-control-statements">control statements</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-controlling-array-scanning-order">controlling array scanning order</a></td><td>&nbsp;</td><td valign="top"><a href="#Controlling-Scanning">8.1.6 在 <code>gawk</code> 中使用预定义的数组遍历顺序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convert-string-to-lower-case">convert string to lower case</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convert-string-to-number">convert string to number</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convert-string-to-upper-case">convert string to upper case</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-converting-integer-array-subscripts">converting integer array subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-converting_002c-dates-to-timestamps">converting, dates to timestamps</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-converting_002c-numbers-to-strings">converting, numbers to strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-converting_002c-numbers-to-strings-1">converting, numbers to strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-converting_002c-strings-to-numbers">converting, strings to numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-converting_002c-strings-to-numbers-1">converting, strings to numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CONVFMT-variable"><code>CONVFMT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CONVFMT-variable-1"><code>CONVFMT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CONVFMT-variable_002c-and-array-subscripts"><code>CONVFMT</code> variable, and array subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cookie">cookie</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-coprocesses">coprocesses</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-coprocesses-1">coprocesses</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-coprocesses_002c-closing">coprocesses, closing</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-coprocesses_002c-getline-from">coprocesses, <code>getline</code> from</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cos_0028_0029-function"><code>cos()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cosine">cosine</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-counting">counting</a></td><td>&nbsp;</td><td valign="top"><a href="#Wc-Program">2.2.7 统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-csh-utility"><code>csh</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-csh-utility_002c-POSIXLY_005fCORRECT-environment-variable"><code>csh</code> utility, <code>POSIXLY_CORRECT</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-csh-utility_002c-_007c_0026-operator_002c-comparison-with"><code>csh</code> utility, <code>|&amp;</code> operator, comparison with</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctime_0028_0029-user_002ddefined-function"><code>ctime()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Example">9.2.2 函数定义范例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-currency-symbols_002c-localization">currency symbols, localization</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-current-system-time">current system time</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-custom_002eh-file"><code>custom.h</code> file</a></td><td>&nbsp;</td><td valign="top"><a href="#Configuration-Philosophy">B.2.3 配置过程</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-customized-input-parser">customized input parser</a></td><td>&nbsp;</td><td valign="top"><a href="#Input-Parsers">5.4.5.4 定制输入分析器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-customized-output-wrapper">customized output wrapper</a></td><td>&nbsp;</td><td valign="top"><a href="#Output-Wrappers">5.4.5.5 定制输出包装器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-customized-two_002dway-processor">customized two-way processor</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-processors">5.4.5.6 定制双路处理器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cut-utility"><code>cut</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cut-utility-1"><code>cut</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cut_002eawk-program"><code>cut.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-d-debugger-command-_0028alias-for-delete_0029"><code>d</code> debugger command (alias for <code>delete</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-d_002ec_002e_002c-See-dark-corner">d.c., See dark corner</a></td><td>&nbsp;</td><td valign="top"><a href="#ae_009a_0097e_00a7_0092">暗角</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner">dark corner</a></td><td>&nbsp;</td><td valign="top"><a href="#ae_009a_0097e_00a7_0092">暗角</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner-1">dark corner</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-_00220_0022-is-actually-true">dark corner, <code>&quot;0&quot;</code> is actually true</a></td><td>&nbsp;</td><td valign="top"><a href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-_002f_003d-operator-vs_002e-_002f_003d_2026_002f-regexp-constant">dark corner, <code>/=</code> operator vs. <code>/=&hellip;/</code> regexp constant</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-array-subscripts">dark corner, array subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-break-statement">dark corner, <code>break</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-close_0028_0029-function">dark corner, <code>close()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-command_002dline-arguments">dark corner, command-line arguments</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Options">6.1.3.2 在命令行中进行变量赋值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-continue-statement">dark corner, <code>continue</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Continue-Statement">7.4.7 <code>continue</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-CONVFMT-variable">dark corner, <code>CONVFMT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-escape-sequences">dark corner, escape sequences</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-escape-sequences_002c-for-metacharacters">dark corner, escape sequences, for metacharacters</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-exit-statement">dark corner, <code>exit</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Exit-Statement">7.4.10 <code>exit</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-field-separators">dark corner, field separators</a></td><td>&nbsp;</td><td valign="top"><a href="#Full-Line-Fields">4.5.5 一行即一域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-FILENAME-variable">dark corner, <code>FILENAME</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-FILENAME-variable-1">dark corner, <code>FILENAME</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-FNR_002fNR-variables">dark corner, <code>FNR</code>/<code>NR</code> variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-format_002dcontrol-characters">dark corner, format-control characters</a></td><td>&nbsp;</td><td valign="top"><a href="#Control-Letters">5.5.2 格式控制字母</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-format_002dcontrol-characters-1">dark corner, format-control characters</a></td><td>&nbsp;</td><td valign="top"><a href="#Control-Letters">5.5.2 格式控制字母</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-FS-as-null-string">dark corner, <code>FS</code> as null string</a></td><td>&nbsp;</td><td valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-input-files">dark corner, input files</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-invoking-awk">dark corner, invoking <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-length_0028_0029-function">dark corner, <code>length()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-locale_0027s-decimal-point-character">dark corner, locale&rsquo;s decimal point character</a></td><td>&nbsp;</td><td valign="top"><a href="#Locale-influences-conversions">6.1.4.2 语言设置会影响转换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-multiline-records">dark corner, multiline records</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-NF-variable_002c-decrementing">dark corner, <code>NF</code> variable, decrementing</a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-OFMT-variable">dark corner, <code>OFMT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-regexp-as-second-argument-to-index_0028_0029">dark corner, regexp as second argument to <code>index()</code></a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-regexp-constants">dark corner, regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-regexp-constants_002c-_002f_003d-operator-and">dark corner, regexp constants, <code>/=</code> operator and</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-regexp-constants_002c-as-arguments-to-user_002ddefined-functions">dark corner, regexp constants, as arguments to user-defined functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-split_0028_0029-function">dark corner, <code>split()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-strings_002c-storing">dark corner, strings, storing</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-value-of-ARGV_005b0_005d">dark corner, value of <code>ARGV[0]</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dark-corner_002c-_005e_002c-in-FS">dark corner, <code>^</code>, in <code>FS</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-data_002c-fixed_002dwidth">data, fixed-width</a></td><td>&nbsp;</td><td valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-data_002ddriven-languages">data-driven languages</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-database_002c-group_002c-reading">database, group, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-database_002c-users_002c-reading">database, users, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-date-utility_002c-GNU"><code>date</code> utility, GNU</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-date-utility_002c-POSIX"><code>date</code> utility, POSIX</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dates_002c-converting-to-timestamps">dates, converting to timestamps</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dates_002c-information-related-to_002c-localization">dates, information related to, localization</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Davies_002c-Stephen">Davies, Stephen</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Davies_002c-Stephen-1">Davies, Stephen</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Day_002c-Robert-P_002eJ_002e">Day, Robert P.J.</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dcgettext_0028_0029-function-_0028gawk_0029"><code>dcgettext()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dcgettext_0028_0029-function-_0028gawk_0029-1"><code>dcgettext()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dcgettext_0028_0029-function-_0028gawk_0029_002c-portability-and"><code>dcgettext()</code> function (<code>gawk</code>), portability and</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dcngettext_0028_0029-function-_0028gawk_0029"><code>dcngettext()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dcngettext_0028_0029-function-_0028gawk_0029-1"><code>dcngettext()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dcngettext_0028_0029-function-_0028gawk_0029_002c-portability-and"><code>dcngettext()</code> function (<code>gawk</code>), portability and</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-deadlocks">deadlocks</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-b-_0028break_0029">debugger commands, <code>b</code> (<code>break</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-backtrace">debugger commands, <code>backtrace</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-break">debugger commands, <code>break</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-bt-_0028backtrace_0029">debugger commands, <code>bt</code> (<code>backtrace</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-c-_0028continue_0029">debugger commands, <code>c</code> (<code>continue</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-clear">debugger commands, <code>clear</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-commands">debugger commands, <code>commands</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-condition">debugger commands, <code>condition</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-continue">debugger commands, <code>continue</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-d-_0028delete_0029">debugger commands, <code>d</code> (<code>delete</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-delete">debugger commands, <code>delete</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-disable">debugger commands, <code>disable</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-display">debugger commands, <code>display</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-down">debugger commands, <code>down</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-dump">debugger commands, <code>dump</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-e-_0028enable_0029">debugger commands, <code>e</code> (<code>enable</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-enable">debugger commands, <code>enable</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-end">debugger commands, <code>end</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-eval">debugger commands, <code>eval</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-f-_0028frame_0029">debugger commands, <code>f</code> (<code>frame</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-finish">debugger commands, <code>finish</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-frame">debugger commands, <code>frame</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-h-_0028help_0029">debugger commands, <code>h</code> (<code>help</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-help">debugger commands, <code>help</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-i-_0028info_0029">debugger commands, <code>i</code> (<code>info</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-ignore">debugger commands, <code>ignore</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-info">debugger commands, <code>info</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-l-_0028list_0029">debugger commands, <code>l</code> (<code>list</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-list">debugger commands, <code>list</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-n-_0028next_0029">debugger commands, <code>n</code> (<code>next</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-next">debugger commands, <code>next</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-nexti">debugger commands, <code>nexti</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-ni-_0028nexti_0029">debugger commands, <code>ni</code> (<code>nexti</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-o-_0028option_0029">debugger commands, <code>o</code> (<code>option</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-option">debugger commands, <code>option</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-p-_0028print_0029">debugger commands, <code>p</code> (<code>print</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-print">debugger commands, <code>print</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-printf">debugger commands, <code>printf</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-q-_0028quit_0029">debugger commands, <code>q</code> (<code>quit</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-quit">debugger commands, <code>quit</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-r-_0028run_0029">debugger commands, <code>r</code> (<code>run</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-return">debugger commands, <code>return</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-run">debugger commands, <code>run</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-s-_0028step_0029">debugger commands, <code>s</code> (<code>step</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-set">debugger commands, <code>set</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-si-_0028stepi_0029">debugger commands, <code>si</code> (<code>stepi</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-silent">debugger commands, <code>silent</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-step">debugger commands, <code>step</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-stepi">debugger commands, <code>stepi</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-t-_0028tbreak_0029">debugger commands, <code>t</code> (<code>tbreak</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-tbreak">debugger commands, <code>tbreak</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-trace">debugger commands, <code>trace</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-u-_0028until_0029">debugger commands, <code>u</code> (<code>until</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-undisplay">debugger commands, <code>undisplay</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-until">debugger commands, <code>until</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-unwatch">debugger commands, <code>unwatch</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-up">debugger commands, <code>up</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-w-_0028watch_0029">debugger commands, <code>w</code> (<code>watch</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-watch">debugger commands, <code>watch</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-commands_002c-where-_0028backtrace_0029">debugger commands, <code>where</code> (<code>backtrace</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-default-list-amount">debugger default list amount</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-history-file">debugger history file</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-history-size">debugger history size</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-options">debugger options</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger-prompt">debugger prompt</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger_002c-how-to-start">debugger, how to start</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Invocation">3.2.1 如何开启调试器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugger_002c-read-commands-from-a-file">debugger, read commands from a file</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugging-awk-programs">debugging <code>awk</code> programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger">3 调试 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-debugging-gawk_002c-bug-reports">debugging <code>gawk</code>, bug reports</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-decimal-point-character_002c-locale-specific">decimal point character, locale specific</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-decrement-operators">decrement operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-default-keyword"><code>default</code> keyword</a></td><td>&nbsp;</td><td valign="top"><a href="#Switch-Statement">7.4.5 <code>switch</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Deifik_002c-Scott">Deifik, Scott</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Deifik_002c-Scott-1">Deifik, Scott</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Deifik_002c-Scott-2">Deifik, Scott</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete-array"><code>delete</code> <var>array</var></a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete-breakpoint-at-location">delete breakpoint at location</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete-breakpoint-by-number">delete breakpoint by number</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete-debugger-command"><code>delete</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete-statement"><code>delete</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-delete-watchpoint">delete watchpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-deleting-elements-in-arrays">deleting elements in arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-deleting-entire-arrays">deleting entire arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Demaille_002c-Akim">Demaille, Akim</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-describe-call-stack-frame_002c-in-debugger">describe call stack frame, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-between-gawk-and-awk">differences between <code>gawk</code> and <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-ARGC_002fARGV-variables">differences in <code>awk</code> and <code>gawk</code>, <code>ARGC</code>/<code>ARGV</code> variables</a></td><td>&nbsp;</td><td valign="top"><a href="#ARGC-and-ARGV">7.5.3 使用 <code>ARGC</code> 与 <code>ARGV</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-ARGIND-variable">differences in <code>awk</code> and <code>gawk</code>, <code>ARGIND</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-array-elements_002c-deleting">differences in <code>awk</code> and <code>gawk</code>, array elements, deleting</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-AWKLIBPATH-environment-variable">differences in <code>awk</code> and <code>gawk</code>, <code>AWKLIBPATH</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#AWKLIBPATH-Variable">2.5.2 环境变量 <code>AWKLIBPATH</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-AWKPATH-environment-variable">differences in <code>awk</code> and <code>gawk</code>, <code>AWKPATH</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#AWKPATH-Variable">2.5.1 环境变量 <code>AWKPATH</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-BEGIN_002fEND-patterns">differences in <code>awk</code> and <code>gawk</code>, <code>BEGIN</code>/<code>END</code> patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-BEGINFILE_002fENDFILE-patterns">differences in <code>awk</code> and <code>gawk</code>, <code>BEGINFILE</code>/<code>ENDFILE</code> patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-BINMODE-variable">differences in <code>awk</code> and <code>gawk</code>, <code>BINMODE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-BINMODE-variable-1">differences in <code>awk</code> and <code>gawk</code>, <code>BINMODE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-close_0028_0029-function">differences in <code>awk</code> and <code>gawk</code>, <code>close()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-close_0028_0029-function-1">differences in <code>awk</code> and <code>gawk</code>, <code>close()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-command_002dline-directories">differences in <code>awk</code> and <code>gawk</code>, command-line directories</a></td><td>&nbsp;</td><td valign="top"><a href="#Command_002dline-directories">4.11 命令行中的目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-ERRNO-variable">differences in <code>awk</code> and <code>gawk</code>, <code>ERRNO</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-error-messages">differences in <code>awk</code> and <code>gawk</code>, error messages</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-FIELDWIDTHS-variable">differences in <code>awk</code> and <code>gawk</code>, <code>FIELDWIDTHS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-FPAT-variable">differences in <code>awk</code> and <code>gawk</code>, <code>FPAT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-FUNCTAB-variable">differences in <code>awk</code> and <code>gawk</code>, <code>FUNCTAB</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-function-arguments-_0028gawk_0029">differences in <code>awk</code> and <code>gawk</code>, function arguments (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-getline-command">differences in <code>awk</code> and <code>gawk</code>, <code>getline</code> command</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-IGNORECASE-variable">differences in <code>awk</code> and <code>gawk</code>, <code>IGNORECASE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-implementation-limitations">differences in <code>awk</code> and <code>gawk</code>, implementation limitations</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-implementation-limitations-1">differences in <code>awk</code> and <code>gawk</code>, implementation limitations</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-indirect-function-calls">differences in <code>awk</code> and <code>gawk</code>, indirect function calls</a></td><td>&nbsp;</td><td valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-input_002foutput-operators">differences in <code>awk</code> and <code>gawk</code>, input/output operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-input_002foutput-operators-1">differences in <code>awk</code> and <code>gawk</code>, input/output operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-line-continuations">differences in <code>awk</code> and <code>gawk</code>, line continuations</a></td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-LINT-variable">differences in <code>awk</code> and <code>gawk</code>, <code>LINT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-match_0028_0029-function">differences in <code>awk</code> and <code>gawk</code>, <code>match()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-print_002fprintf-statements">differences in <code>awk</code> and <code>gawk</code>, <code>print</code>/<code>printf</code> statements</a></td><td>&nbsp;</td><td valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-PROCINFO-array">differences in <code>awk</code> and <code>gawk</code>, <code>PROCINFO</code> array</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-read-timeouts">differences in <code>awk</code> and <code>gawk</code>, read timeouts</a></td><td>&nbsp;</td><td valign="top"><a href="#Read-Timeout">4.10 带超时的输入读取</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-record-separators">differences in <code>awk</code> and <code>gawk</code>, record separators</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-regexp-constants">differences in <code>awk</code> and <code>gawk</code>, regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-regular-expressions">differences in <code>awk</code> and <code>gawk</code>, regular expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-RS_002fRT-variables">differences in <code>awk</code> and <code>gawk</code>, <code>RS</code>/<code>RT</code> variables</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-RT-variable">differences in <code>awk</code> and <code>gawk</code>, <code>RT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-single_002dcharacter-fields">differences in <code>awk</code> and <code>gawk</code>, single-character fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-split_0028_0029-function">differences in <code>awk</code> and <code>gawk</code>, <code>split()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-strings">differences in <code>awk</code> and <code>gawk</code>, strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Scalar-Constants">6.1.1.1 数值与字串常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-strings_002c-storing">differences in <code>awk</code> and <code>gawk</code>, strings, storing</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-SYMTAB-variable">differences in <code>awk</code> and <code>gawk</code>, <code>SYMTAB</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-TEXTDOMAIN-variable">differences in <code>awk</code> and <code>gawk</code>, <code>TEXTDOMAIN</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-differences-in-awk-and-gawk_002c-trunc_002dmod-operation">differences in <code>awk</code> and <code>gawk</code>, trunc-mod operation</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directories_002c-command_002dline">directories, command-line</a></td><td>&nbsp;</td><td valign="top"><a href="#Command_002dline-directories">4.11 命令行中的目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directories_002c-searching">directories, searching</a></td><td>&nbsp;</td><td valign="top"><a href="#Programs-Exercises">2.5 练习</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directories_002c-searching-for-loadable-extensions">directories, searching for loadable extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#AWKLIBPATH-Variable">2.5.2 环境变量 <code>AWKLIBPATH</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directories_002c-searching-for-source-files">directories, searching for source files</a></td><td>&nbsp;</td><td valign="top"><a href="#AWKPATH-Variable">2.5.1 环境变量 <code>AWKPATH</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-disable-breakpoint">disable breakpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-disable-debugger-command"><code>disable</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-display-debugger-command"><code>display</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-display-debugger-options">display debugger options</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-division">division</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-do_002dwhile-statement"><code>do</code>-<code>while</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Do-Statement">7.4.3 <code>do</code>-<code>while</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-do_002dwhile-statement_002c-use-of-regexps-in"><code>do</code>-<code>while</code> statement, use of regexps in</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-documentation_002c-of-awk-programs">documentation, of <code>awk</code> programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-documentation_002c-online">documentation, online</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-documents_002c-searching">documents, searching</a></td><td>&nbsp;</td><td valign="top"><a href="#Dupword-Program">2.3.1 查找文档中的重复字</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dollar-sign-_0028_0024_0029_002c-_0024-field-operator">dollar sign (<code>$</code>), <code>$</code> field operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dollar-sign-_0028_0024_0029_002c-_0024-field-operator-1">dollar sign (<code>$</code>), <code>$</code> field operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dollar-sign-_0028_0024_0029_002c-incrementing-fields-and-arrays">dollar sign (<code>$</code>), incrementing fields and arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dollar-sign-_0028_0024_0029_002c-regexp-operator">dollar sign (<code>$</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-double-quote-_0028_0022_0029_002c-in-regexp-constants">double quote (<code>&quot;</code>), in regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-double-quote-_0028_0022_0029_002c-in-shell-commands">double quote (<code>&quot;</code>), in shell commands</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-down-debugger-command"><code>down</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Drepper_002c-Ulrich">Drepper, Ulrich</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Duman_002c-Patrice">Duman, Patrice</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dump-all-variables-of-a-program">dump all variables of a program</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dump-debugger-command"><code>dump</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dupword_002eawk-program"><code>dupword.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Dupword-Program">2.3.1 查找文档中的重复字</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dynamic-profiling">dynamic profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dynamically-loaded-extensions">dynamically loaded extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Dynamic-Extensions">5 编写 <code>gawk</code> 扩展</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-e-debugger-command-_0028alias-for-enable_0029"><code>e</code> debugger command (alias for <code>enable</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EBCDIC">EBCDIC</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-effective-group-ID-of-gawk-user">effective group ID of <code>gawk</code> user</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-effective-user-ID-of-gawk-user">effective user ID of <code>gawk</code> user</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-egrep-utility"><code>egrep</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-egrep-utility-1"><code>egrep</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-egrep_002eawk-program"><code>egrep.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-elements-in-arrays_002c-assigning-values">elements in arrays, assigning values</a></td><td>&nbsp;</td><td valign="top"><a href="#Assigning-Elements">8.1.3 给数组元素赋值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-elements-in-arrays_002c-deleting">elements in arrays, deleting</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-elements-in-arrays_002c-order-of-access-by-in-operator">elements in arrays, order of access by <code>in</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-elements-in-arrays_002c-scanning">elements in arrays, scanning</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-elements-of-arrays">elements of arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-email-address-for-bug-reports_002c-bug_002dgawk_0040gnu_002eorg">email address for bug reports, <code>bug-gawk@gnu.org</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-array-elements">empty array elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-pattern">empty pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#Empty">7.1.6 空模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-strings">empty strings</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-strings_002c-See-null-strings">empty strings, See null strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EMRED"><code>EMRED</code></a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-enable-breakpoint">enable breakpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-enable-debugger-command"><code>enable</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end-debugger-command"><code>end</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern"><code>END</code> pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGIN_002fEND">7.1.4 <code>BEGIN</code> 与 <code>END</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern-1"><code>END</code> pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-BEGIN_002fEND">7.1.4.1 开始与结束动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern_002c-and-profiling"><code>END</code> pattern, and profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern_002c-assert_0028_0029-user_002ddefined-function-and"><code>END</code> pattern, <code>assert()</code> user-defined function and</a></td><td>&nbsp;</td><td valign="top"><a href="#Assert-Function">1.2.2 断言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern_002c-Boolean-patterns-and"><code>END</code> pattern, Boolean patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern_002c-exit-statement-and"><code>END</code> pattern, <code>exit</code> statement and</a></td><td>&nbsp;</td><td valign="top"><a href="#Exit-Statement">7.4.10 <code>exit</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern_002c-next_002fnextfile-statements-and"><code>END</code> pattern, <code>next</code>/<code>nextfile</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern_002c-next_002fnextfile-statements-and-1"><code>END</code> pattern, <code>next</code>/<code>nextfile</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern_002c-operators-and"><code>END</code> pattern, operators and</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-BEGIN_002fEND">7.1.4.1 开始与结束动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-END-pattern_002c-print-statement-and"><code>END</code> pattern, <code>print</code> statement and</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ENDFILE-pattern"><code>ENDFILE</code> pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ENDFILE-pattern_002c-Boolean-patterns-and"><code>ENDFILE</code> pattern, Boolean patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-endfile_0028_0029-user_002ddefined-function"><code>endfile()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Filetrans-Function">1.3.1 注意数据文件的边界</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-endgrent_0028_0029-function-_0028C-library_0029"><code>endgrent()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-endgrent_0028_0029-user_002ddefined-function"><code>endgrent()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-endpwent_0028_0029-function-_0028C-library_0029"><code>endpwent()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-endpwent_0028_0029-user_002ddefined-function"><code>endpwent()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-English_002c-Steve">English, Steve</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">1 <code>gawk</code> 的高级特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ENVIRON-array"><code>ENVIRON</code> array</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment-variables-used-by-gawk">environment variables used by <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Environment-Variables">2.5 <code>gawk</code> 使用的环境变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment-variables_002c-in-ENVIRON-array">environment variables, in <code>ENVIRON</code> array</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-epoch_002c-definition-of">epoch, definition of</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-equals-sign-_0028_003d_0029_002c-_003d-operator">equals sign (<code>=</code>), <code>=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-equals-sign-_0028_003d_0029_002c-_003d_003d-operator">equals sign (<code>=</code>), <code>==</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-equals-sign-_0028_003d_0029_002c-_003d_003d-operator-1">equals sign (<code>=</code>), <code>==</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EREs-_0028Extended-Regular-Expressions_0029">EREs (Extended Regular Expressions)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ERRNO-variable"><code>ERRNO</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ERRNO-variable-1"><code>ERRNO</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ERRNO-variable_002c-with-BEGINFILE-pattern"><code>ERRNO</code> variable, with <code>BEGINFILE</code> pattern</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ERRNO-variable_002c-with-close_0028_0029-function"><code>ERRNO</code> variable, with <code>close()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ERRNO-variable_002c-with-getline-command"><code>ERRNO</code> variable, with <code>getline</code> command</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-error-handling">error handling</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-error-handling_002c-ERRNO-variable-and">error handling, <code>ERRNO</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-error-output">error output</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-escape-processing_002c-gsub_0028_0029_002fgensub_0028_0029_002fsub_0028_0029-functions">escape processing, <code>gsub()</code>/<code>gensub()</code>/<code>sub()</code> functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-escape-sequences_002c-in-strings">escape sequences, in strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eval-debugger-command"><code>eval</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluate-expressions_002c-in-debugger">evaluate expressions, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluation-order">evaluation order</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluation-order_002c-concatenation">evaluation order, concatenation</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluation-order_002c-functions">evaluation order, functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-examining-fields">examining fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021-operator">exclamation point (<code>!</code>), <code>!</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021-operator-1">exclamation point (<code>!</code>), <code>!</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021-operator-2">exclamation point (<code>!</code>), <code>!</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_003d-operator">exclamation point (<code>!</code>), <code>!=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_003d-operator-1">exclamation point (<code>!</code>), <code>!=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator">exclamation point (<code>!</code>), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-1">exclamation point (<code>!</code>), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-2">exclamation point (<code>!</code>), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-3">exclamation point (<code>!</code>), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Constants">6.1.1.3 正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-4">exclamation point (<code>!</code>), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-5">exclamation point (<code>!</code>), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-6">exclamation point (<code>!</code>), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exclamation-point-_0028_0021_0029_002c-_0021_007e-operator-7">exclamation point (<code>!</code>), <code>!~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-debugger-command"><code>exit</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-statement"><code>exit</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Exit-Statement">7.4.10 <code>exit</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-status_002c-of-gawk">exit status, of <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Exit-Status">2.6 <code>gawk</code> 的退出状态</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-status_002c-of-VMS">exit status, of VMS</a></td><td>&nbsp;</td><td valign="top"><a href="#VMS-Running">B.3.2.4 在 VMS 上运行 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-the-debugger">exit the debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exit-the-debugger-1">exit the debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exp_0028_0029-function"><code>exp()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expand-utility"><code>expand</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Very-Simple">1.3 一些简单例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Expat-XML-parser-library">Expat XML parser library</a></td><td>&nbsp;</td><td valign="top"><a href="#gawkextlib">5.8 <code>gawkextlib</code> 项目</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exponent">exponent</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions">expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Expressions">6 表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-as-patterns">expressions, as patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-assignment">expressions, assignment</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-Boolean">expressions, Boolean</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-comparison">expressions, comparison</a></td><td>&nbsp;</td><td valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-conditional">expressions, conditional</a></td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-matching_002c-See-comparison-expressions">expressions, matching, See comparison expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expressions_002c-selecting">expressions, selecting</a></td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Extended-Regular-Expressions-_0028EREs_0029">Extended Regular Expressions (EREs)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extension-API">extension API</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-API-Description">5.4 API 描述</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extension-API-informational-variables">extension API informational variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-API-Informational-Variables">5.4.12.2 信息变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extension-API-version">extension API version</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Versioning">5.4.12.1 API Version Constants and Variables</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extension-API_002c-version-number">extension API, version number</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extension-example">extension example</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Example">5.6 例子：一些文件函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extension-registration">extension registration</a></td><td>&nbsp;</td><td valign="top"><a href="#Registration-Functions">5.4.5 注册函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extension-search-path">extension search path</a></td><td>&nbsp;</td><td valign="top"><a href="#Finding-Extensions">5.5 <code>gawk</code> 如何找到扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions-distributed-with-gawk">extensions distributed with <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Samples">5.7 <code>gawk</code> 发行版本中的例子扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-allocating-memory">extensions, allocating memory</a></td><td>&nbsp;</td><td valign="top"><a href="#Memory-Allocation-Functions">5.4.3 内存分配函数与相应的简化宏</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-Brian-Kernighan_0027s-awk">extensions, Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#BTL">A.4 Brian Kernighan 的 <code>awk</code> 的扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-Brian-Kernighan_0027s-awk-1">extensions, Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Common-Extensions">A.7 通用扩展汇总</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-_002a_002a-operator">extensions, common, <code>**</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-_002a_002a_003d-operator">extensions, common, <code>**=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-_002fdev_002fstderr-special-file">extensions, common, <code>/dev/stderr</code> special file</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-_002fdev_002fstdin-special-file">extensions, common, <code>/dev/stdin</code> special file</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-_002fdev_002fstdout-special-file">extensions, common, <code>/dev/stdout</code> special file</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-BINMODE-variable">extensions, common, <code>BINMODE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-delete-to-delete-entire-arrays">extensions, common, <code>delete</code> to delete entire arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-fflush_0028_0029-function">extensions, common, <code>fflush()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-func-keyword">extensions, common, <code>func</code> keyword</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-length_0028_0029-applied-to-an-array">extensions, common, <code>length()</code> applied to an array</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-RS-as-a-regexp">extensions, common, <code>RS</code> as a regexp</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-single-character-fields">extensions, common, single character fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-common_002c-_005cx-escape-sequence">extensions, common, <code>\x</code> escape sequence</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-in-gawk_002c-not-in-POSIX-awk">extensions, in <code>gawk</code>, not in POSIX <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#POSIX_002fGNU">A.5 不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-loading_002c-_0040load-directive">extensions, loading, <code>@load</code> directive</a></td><td>&nbsp;</td><td valign="top"><a href="#Loading-Shared-Libraries">2.8 在你的程序装入动态扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-mawk">extensions, <code>mawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Common-Extensions">A.7 通用扩展汇总</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extensions_002c-where-to-find">extensions, where to find</a></td><td>&nbsp;</td><td valign="top"><a href="#gawkextlib">5.8 <code>gawkextlib</code> 项目</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extract_002eawk-program"><code>extract.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Extract-Program">2.3.7 从 Texinfo 源文件中提取程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-extraction_002c-of-marked-strings-_0028internationalization_0029">extraction, of marked strings (internationalization)</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-f-debugger-command-_0028alias-for-frame_0029"><code>f</code> debugger command (alias for <code>frame</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-false_002c-logical">false, logical</a></td><td>&nbsp;</td><td valign="top"><a href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FDL-_0028Free-Documentation-License_0029">FDL (Free Documentation License)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-features_002c-adding-to-gawk">features, adding to <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Adding-Code">C.2.2 添加新特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-features_002c-deprecated">features, deprecated</a></td><td>&nbsp;</td><td valign="top"><a href="#Obsolete">2.9 已经取消的选项以及特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-features_002c-undocumented">features, undocumented</a></td><td>&nbsp;</td><td valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fenlason_002c-Jay">Fenlason, Jay</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fenlason_002c-Jay-1">Fenlason, Jay</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fflush_0028_0029-function"><code>fflush()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-numbers">field numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Nonconstant-Fields">4.3 非常数域编号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-operator-_0024">field operator <code>$</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-operators_002c-dollar-sign-as">field operators, dollar sign as</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separator_002c-in-multiline-records">field separator, in multiline records</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separator_002c-on-command-line">field separator, on command line</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separator_002c-POSIX-and">field separator, POSIX and</a></td><td>&nbsp;</td><td valign="top"><a href="#Full-Line-Fields">4.5.5 一行即一域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators">field separators</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators-1">field separators</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators-2">field separators</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators_002c-choice-of">field separators, choice of</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators_002c-FIELDWIDTHS-variable-and">field separators, <code>FIELDWIDTHS</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators_002c-FPAT-variable-and">field separators, <code>FPAT</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators_002c-POSIX-and">field separators, POSIX and</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators_002c-regular-expressions-as">field separators, regular expressions as</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators_002c-regular-expressions-as-1">field separators, regular expressions as</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators_002c-See-Also-OFS">field separators, See Also <code>OFS</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-field-separators_002c-spaces-as">field separators, spaces as</a></td><td>&nbsp;</td><td valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields">fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Reading-Files">4 读取输入文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields-1">fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields-2">fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-adding">fields, adding</a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-changing-contents-of">fields, changing contents of</a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-cutting">fields, cutting</a></td><td>&nbsp;</td><td valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-examining">fields, examining</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-number-of">fields, number of</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-numbers">fields, numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Nonconstant-Fields">4.3 非常数域编号</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-printing">fields, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-separating">fields, separating</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-separating-1">fields, separating</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fields_002c-single_002dcharacter">fields, single-character</a></td><td>&nbsp;</td><td valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FIELDWIDTHS-variable"><code>FIELDWIDTHS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FIELDWIDTHS-variable-1"><code>FIELDWIDTHS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-descriptors">file descriptors</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-inclusion_002c-_0040include-directive">file inclusion, <code>@include</code> directive</a></td><td>&nbsp;</td><td valign="top"><a href="#Include-Files">2.7 在你的程序中包含其他的文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-names_002c-distinguishing">file names, distinguishing</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-names_002c-in-compatibility-mode">file names, in compatibility mode</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-Caveats">5.8.3 特殊文件名说明</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-file-names_002c-standard-streams-in-gawk">file names, standard streams in <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FILENAME-variable"><code>FILENAME</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Reading-Files">4 读取输入文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FILENAME-variable-1"><code>FILENAME</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FILENAME-variable_002c-getline_002c-setting-with"><code>FILENAME</code> variable, <code>getline</code>, setting with</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-filenames_002c-assignments-as">filenames, assignments as</a></td><td>&nbsp;</td><td valign="top"><a href="#Ignoring-Assigns">1.3.5 将赋值当成是文件名</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002egmo">files, <code>.gmo</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002egmo_002c-specifying-directory-of">files, <code>.gmo</code>, specifying directory of</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002egmo_002c-specifying-directory-of-1">files, <code>.gmo</code>, specifying directory of</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002emo_002c-converting-from-_002epo">files, <code>.mo</code>, converting from <code>.po</code></a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002epo">files, <code>.po</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002epo-1">files, <code>.po</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Translator-i18n">2.4 翻译 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002epo_002c-converting-to-_002emo">files, <code>.po</code>, converting to <code>.mo</code></a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002epot">files, <code>.pot</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002fdev_002f_2026-special-files">files, <code>/dev/&hellip;</code> special files</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002finet_002f_2026-_0028gawk_0029">files, <code>/inet/&hellip;</code> (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002finet4_002f_2026-_0028gawk_0029">files, <code>/inet4/&hellip;</code> (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-_002finet6_002f_2026-_0028gawk_0029">files, <code>/inet6/&hellip;</code> (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-awk-programs-in">files, <code>awk</code> programs in</a></td><td>&nbsp;</td><td valign="top"><a href="#Long">1.1.3 运行长程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-awkprof_002eout">files, <code>awkprof.out</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-awkvars_002eout">files, &lsquo;<tt>awkvars.out</tt>&rsquo;</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-closing">files, closing</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-descriptors_002c-See-file-descriptors">files, descriptors, See file descriptors</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-group">files, group</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-initialization-and-cleanup">files, initialization and cleanup</a></td><td>&nbsp;</td><td valign="top"><a href="#Filetrans-Function">1.3.1 注意数据文件的边界</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-input_002c-See-input-files">files, input, See input files</a></td><td>&nbsp;</td><td valign="top"><a href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-log_002c-timestamps-in">files, log, timestamps in</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-managing">files, managing</a></td><td>&nbsp;</td><td valign="top"><a href="#Data-File-Management">1.3 数据文件管理</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-managing_002c-data-file-boundaries">files, managing, data file boundaries</a></td><td>&nbsp;</td><td valign="top"><a href="#Filetrans-Function">1.3.1 注意数据文件的边界</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-message-object">files, message object</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-message-object_002c-converting-from-portable-object-files">files, message object, converting from portable object files</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-message-object_002c-specifying-directory-of">files, message object, specifying directory of</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-message-object_002c-specifying-directory-of-1">files, message object, specifying directory of</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-multiple-passes-over">files, multiple passes over</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-multiple_002c-duplicating-output-into">files, multiple, duplicating output into</a></td><td>&nbsp;</td><td valign="top"><a href="#Tee-Program">2.2.5 将输出复制到多个文件中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-output_002c-See-output-files">files, output, See output files</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-password">files, password</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-portable-object">files, portable object</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-portable-object-1">files, portable object</a></td><td>&nbsp;</td><td valign="top"><a href="#Translator-i18n">2.4 翻译 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-portable-object-template">files, portable object template</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-portable-object_002c-converting-to-message-object-files">files, portable object, converting to message object files</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-portable-object_002c-generating">files, portable object, generating</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-processing_002c-ARGIND-variable-and">files, processing, <code>ARGIND</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-reading">files, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Rewind-Function">1.3.2 重新读取当前文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-reading_002c-multiline-records">files, reading, multiline records</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-searching-for-regular-expressions">files, searching for regular expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-skipping">files, skipping</a></td><td>&nbsp;</td><td valign="top"><a href="#File-Checking">1.3.3 检查可读的数据文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-source_002c-search-path-for">files, source, search path for</a></td><td>&nbsp;</td><td valign="top"><a href="#Programs-Exercises">2.5 练习</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-splitting">files, splitting</a></td><td>&nbsp;</td><td valign="top"><a href="#Split-Program">2.2.4 将大文件分片</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-files_002c-Texinfo_002c-extracting-programs-from">files, Texinfo, extracting programs from</a></td><td>&nbsp;</td><td valign="top"><a href="#Extract-Program">2.3.7 从 Texinfo 源文件中提取程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-find-substring-in-string">find substring in string</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-finding-extensions">finding extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Finding-Extensions">5.5 <code>gawk</code> 如何找到扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-finish-debugger-command"><code>finish</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fish_002c-Fred">Fish, Fred</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fixed_002dwidth-data">fixed-width data</a></td><td>&nbsp;</td><td valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flag-variables">flag variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flag-variables-1">flag variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Tee-Program">2.2.5 将输出复制到多个文件中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-floating_002dpoint_002c-numbers_002c-arbitrary-precision">floating-point, numbers, arbitrary precision</a></td><td>&nbsp;</td><td valign="top"><a href="#Arbitrary-Precision-Arithmetic">4 算术运算与 <code>gawk</code> 中的任意精度算术运算</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-floating_002dpoint_002c-VAX_002fVMS">floating-point, VAX/VMS</a></td><td>&nbsp;</td><td valign="top"><a href="#VMS-Running">B.3.2.4 在 VMS 上运行 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flush-buffered-output">flush buffered output</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fnmatch_0028_0029-extension-function"><code>fnmatch()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Fnmatch">5.7.2 针对 <code>fnmatch()</code>　的接口</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FNR-variable"><code>FNR</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Records">4.1 输入如何拆分为记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FNR-variable-1"><code>FNR</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FNR-variable_002c-changing"><code>FNR</code> variable, changing</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-for-statement"><code>for</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#For-Statement">7.4.4 <code>for</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-for-statement_002c-looping-over-arrays"><code>for</code> statement, looping over arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fork_0028_0029-extension-function"><code>fork()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Fork">5.7.3 针对 <code>fork()</code>，<code>wait()</code>，与 <code>waitpid()</code> 的接口</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-format-specifiers">format specifiers</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Printf">5.5.1 使用 <code>printf</code> 语句美化打印</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-format-specifiers_002c-mixing-regular-with-positional-specifiers">format specifiers, mixing regular with positional specifiers</a></td><td>&nbsp;</td><td valign="top"><a href="#Printf-Ordering">2.4.2 重排 <code>printf</code> 参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-format-specifiers_002c-printf-statement">format specifiers, <code>printf</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Control-Letters">5.5.2 格式控制字母</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-format-specifiers_002c-strftime_0028_0029-function-_0028gawk_0029">format specifiers, <code>strftime()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-format-time-string">format time string</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-formats_002c-numeric-output">formats, numeric output</a></td><td>&nbsp;</td><td valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-formatting-output">formatting output</a></td><td>&nbsp;</td><td valign="top"><a href="#Printf">5.5 使用 <code>printf</code> 语句美化打印</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-formatting-strings">formatting strings</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward-slash-_0028_002f_0029-to-enclose-regular-expressions">forward slash (<code>/</code>) to enclose regular expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp">3 正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward-slash-_0028_002f_0029_002c-_002f-operator">forward slash (<code>/</code>), <code>/</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward-slash-_0028_002f_0029_002c-_002f_003d-operator">forward slash (<code>/</code>), <code>/=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward-slash-_0028_002f_0029_002c-_002f_003d-operator-1">forward slash (<code>/</code>), <code>/=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward-slash-_0028_002f_0029_002c-_002f_003d-operator_002c-vs_002e-_002f_003d_2026_002f-regexp-constant">forward slash (<code>/</code>), <code>/=</code> operator, vs. <code>/=&hellip;/</code> regexp constant</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forward-slash-_0028_002f_0029_002c-patterns-and">forward slash (<code>/</code>), patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FPAT-variable"><code>FPAT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Splitting-By-Content">4.7 以内容定义域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FPAT-variable-1"><code>FPAT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-frame-debugger-command"><code>frame</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Free-Documentation-License-_0028FDL_0029">Free Documentation License (FDL)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Free-Software-Foundation-_0028FSF_0029">Free Software Foundation (FSF)</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Free-Software-Foundation-_0028FSF_0029-1">Free Software Foundation (FSF)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getting">B.1.1 取得 <code>gawk</code> 发布版</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Free-Software-Foundation-_0028FSF_0029-2">Free Software Foundation (FSF)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Free-Software-Foundation-_0028FSF_0029-3">Free Software Foundation (FSF)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FreeBSD">FreeBSD</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS-variable"><code>FS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS-variable-1"><code>FS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS-variable_002c-_002d_002dfield_002dseparator-option-and"><code>FS</code> variable, <code>--field-separator</code> option and</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS-variable_002c-as-null-string"><code>FS</code> variable, as null string</a></td><td>&nbsp;</td><td valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS-variable_002c-as-TAB-character"><code>FS</code> variable, as TAB character</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS-variable_002c-changing-value-of"><code>FS</code> variable, changing value of</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS-variable_002c-running-awk-programs-and"><code>FS</code> variable, running <code>awk</code> programs and</a></td><td>&nbsp;</td><td valign="top"><a href="#Cut-Program">2.2.1 剪切域与列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS-variable_002c-setting-from-command-line"><code>FS</code> variable, setting from command line</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS_002c-containing-_005e"><code>FS</code>, containing <code>^</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FS_002c-in-multiline-records"><code>FS</code>, in multiline records</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FSF-_0028Free-Software-Foundation_0029">FSF (Free Software Foundation)</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FSF-_0028Free-Software-Foundation_0029-1">FSF (Free Software Foundation)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getting">B.1.1 取得 <code>gawk</code> 发布版</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FSF-_0028Free-Software-Foundation_0029-2">FSF (Free Software Foundation)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FSF-_0028Free-Software-Foundation_0029-3">FSF (Free Software Foundation)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fts_0028_0029-extension-function"><code>fts()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-File-Functions">5.7.1 与文件相关的函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FUNCTAB-array"><code>FUNCTAB</code> array</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function-calls">function calls</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Calls">6.4 函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function-calls_002c-indirect">function calls, indirect</a></td><td>&nbsp;</td><td valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function-calls_002c-indirect_002c-_0040_002dnotation-for">function calls, indirect, <code>@</code>-notation for</a></td><td>&nbsp;</td><td valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function-definition-example">function definition example</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Example">9.2.2 函数定义范例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function-pointers">function pointers</a></td><td>&nbsp;</td><td valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-arrays-as-parameters-to">functions, arrays as parameters to</a></td><td>&nbsp;</td><td valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-built_002din">functions, built-in</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Calls">6.4 函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-built_002din-1">functions, built-in</a></td><td>&nbsp;</td><td valign="top"><a href="#Functions">9 函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-built_002din_002c-evaluation-order">functions, built-in, evaluation order</a></td><td>&nbsp;</td><td valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-defining">functions, defining</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library">functions, library</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-assertions">functions, library, assertions</a></td><td>&nbsp;</td><td valign="top"><a href="#Assert-Function">1.2.2 断言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-associative-arrays-and">functions, library, associative arrays and</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-C-library">functions, library, C library</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-character-values-as-numbers">functions, library, character values as numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-Cliff-random-numbers">functions, library, Cliff random numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Cliff-Random-Function">1.2.4 Cliff 随机数生成器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-command_002dline-options">functions, library, command-line options</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-example-program-for-using">functions, library, example program for using</a></td><td>&nbsp;</td><td valign="top"><a href="#Igawk-Program">2.3.9 使用库函数的简单方式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-group-database_002c-reading">functions, library, group database, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-managing-data-files">functions, library, managing data files</a></td><td>&nbsp;</td><td valign="top"><a href="#Data-File-Management">1.3 数据文件管理</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-managing-time">functions, library, managing time</a></td><td>&nbsp;</td><td valign="top"><a href="#Getlocaltime-Function">1.2.7 管理时间</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-merging-arrays-into-strings">functions, library, merging arrays into strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Join-Function">1.2.6 将数组合并成字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-rounding-numbers">functions, library, rounding numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-library_002c-user-database_002c-reading">functions, library, user database, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-names-of">functions, names of</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-recursive">functions, recursive</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-string_002dtranslation">functions, string-translation</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-undefined">functions, undefined</a></td><td>&nbsp;</td><td valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-user_002ddefined">functions, user-defined</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002ddefined">9.2 用户自定义函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-user_002ddefined_002c-calling">functions, user-defined, calling</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Caveats">9.2.3 调用用户自定义函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-user_002ddefined_002c-counts_002c-in-a-profile">functions, user-defined, counts, in a profile</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-user_002ddefined_002c-library-of">functions, user-defined, library of</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-user_002ddefined_002c-next_002fnextfile-statements-and">functions, user-defined, <code>next</code>/<code>nextfile</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-functions_002c-user_002ddefined_002c-next_002fnextfile-statements-and-1">functions, user-defined, <code>next</code>/<code>nextfile</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#Nextfile-Statement">7.4.9 <code>nextfile</code> 语句</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-G_002dd">G-d</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-G_002e_002c-Daniel-Richard">G., Daniel Richard</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-G_002e_002c-Daniel-Richard-1">G., Daniel Richard</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Garfinkle_002c-Scott">Garfinkle, Scott</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk-program_002c-dynamic-profiling"><code>gawk</code> program, dynamic profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk-version"><code>gawk</code> version</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-ARGIND-variable-in"><code>gawk</code>, <code>ARGIND</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-awk-and"><code>gawk</code>, <code>awk</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-awk-and-1"><code>gawk</code>, <code>awk</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#This-Manual">使用本书</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-bitwise-operations-in"><code>gawk</code>, bitwise operations in</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-break-statement-in"><code>gawk</code>, <code>break</code> statement in</a></td><td>&nbsp;</td><td valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-character-classes-and"><code>gawk</code>, character classes and</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-coding-style-in"><code>gawk</code>, coding style in</a></td><td>&nbsp;</td><td valign="top"><a href="#Adding-Code">C.2.2 添加新特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-command_002dline-options_002c-and-regular-expressions"><code>gawk</code>, command-line options, and regular expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-configuring"><code>gawk</code>, configuring</a></td><td>&nbsp;</td><td valign="top"><a href="#Configuration-Philosophy">B.2.3 配置过程</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-configuring_002c-options"><code>gawk</code>, configuring, options</a></td><td>&nbsp;</td><td valign="top"><a href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-continue-statement-in"><code>gawk</code>, <code>continue</code> statement in</a></td><td>&nbsp;</td><td valign="top"><a href="#Continue-Statement">7.4.7 <code>continue</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-distribution"><code>gawk</code>, distribution</a></td><td>&nbsp;</td><td valign="top"><a href="#Distribution-contents">B.1.3 <code>gawk</code> 发布版的内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-ERRNO-variable-in"><code>gawk</code>, <code>ERRNO</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-ERRNO-variable-in-1"><code>gawk</code>, <code>ERRNO</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-ERRNO-variable-in-2"><code>gawk</code>, <code>ERRNO</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-ERRNO-variable-in-3"><code>gawk</code>, <code>ERRNO</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-ERRNO-variable-in-4"><code>gawk</code>, <code>ERRNO</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-escape-sequences"><code>gawk</code>, escape sequences</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-extensions_002c-disabling"><code>gawk</code>, extensions, disabling</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-features_002c-adding"><code>gawk</code>, features, adding</a></td><td>&nbsp;</td><td valign="top"><a href="#Adding-Code">C.2.2 添加新特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-features_002c-advanced"><code>gawk</code>, features, advanced</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">1 <code>gawk</code> 的高级特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-field-separators-and"><code>gawk</code>, field separators and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-FIELDWIDTHS-variable-in"><code>gawk</code>, <code>FIELDWIDTHS</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-FIELDWIDTHS-variable-in-1"><code>gawk</code>, <code>FIELDWIDTHS</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-file-names-in"><code>gawk</code>, file names in</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-Files">5.8 <code>gawk</code> 中的特殊文件名</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-format_002dcontrol-characters"><code>gawk</code>, format-control characters</a></td><td>&nbsp;</td><td valign="top"><a href="#Control-Letters">5.5.2 格式控制字母</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-format_002dcontrol-characters-1"><code>gawk</code>, format-control characters</a></td><td>&nbsp;</td><td valign="top"><a href="#Control-Letters">5.5.2 格式控制字母</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-FPAT-variable-in"><code>gawk</code>, <code>FPAT</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Splitting-By-Content">4.7 以内容定义域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-FPAT-variable-in-1"><code>gawk</code>, <code>FPAT</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-FUNCTAB-array-in"><code>gawk</code>, <code>FUNCTAB</code> array in</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-function-arguments-and"><code>gawk</code>, function arguments and</a></td><td>&nbsp;</td><td valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-hexadecimal-numbers-and"><code>gawk</code>, hexadecimal numbers and</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-IGNORECASE-variable-in"><code>gawk</code>, <code>IGNORECASE</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-IGNORECASE-variable-in-1"><code>gawk</code>, <code>IGNORECASE</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-IGNORECASE-variable-in-2"><code>gawk</code>, <code>IGNORECASE</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-IGNORECASE-variable-in-3"><code>gawk</code>, <code>IGNORECASE</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-IGNORECASE-variable-in-4"><code>gawk</code>, <code>IGNORECASE</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-implementation-issues"><code>gawk</code>, implementation issues</a></td><td>&nbsp;</td><td valign="top"><a href="#Notes">Appendix C 实现提示</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-implementation-issues_002c-debugging"><code>gawk</code>, implementation issues, debugging</a></td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-Mode">C.1 后向兼容与调试</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-implementation-issues_002c-downward-compatibility"><code>gawk</code>, implementation issues, downward compatibility</a></td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-Mode">C.1 后向兼容与调试</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-implementation-issues_002c-limits"><code>gawk</code>, implementation issues, limits</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-implementation-issues_002c-pipes"><code>gawk</code>, implementation issues, pipes</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-installing"><code>gawk</code>, installing</a></td><td>&nbsp;</td><td valign="top"><a href="#Installation">Appendix B 安装 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-internationalization-and_002c-See-internationalization"><code>gawk</code>, internationalization and, See internationalization</a></td><td>&nbsp;</td><td valign="top"><a href="#Internationalization">2 <code>gawk</code> 的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-interpreter_002c-adding-code-to"><code>gawk</code>, interpreter, adding code to</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Internal-File-Ops">5.6.3 整合扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-interval-expressions-and"><code>gawk</code>, interval expressions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-line-continuation-in"><code>gawk</code>, line continuation in</a></td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-LINT-variable-in"><code>gawk</code>, <code>LINT</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-list-of-contributors-to"><code>gawk</code>, list of contributors to</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-MS_002dDOS-version-of"><code>gawk</code>, MS-DOS version of</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-MS_002dWindows-version-of"><code>gawk</code>, MS-Windows version of</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-newlines-in"><code>gawk</code>, newlines in</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-octal-numbers-and"><code>gawk</code>, octal numbers and</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-OS_002f2-version-of"><code>gawk</code>, OS/2 version of</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-predefined-variables-and"><code>gawk</code>, predefined variables and</a></td><td>&nbsp;</td><td valign="top"><a href="#Built_002din-Variables">7.5 预定义变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-PROCINFO-array-in"><code>gawk</code>, <code>PROCINFO</code> array in</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-PROCINFO-array-in-1"><code>gawk</code>, <code>PROCINFO</code> array in</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-PROCINFO-array-in-2"><code>gawk</code>, <code>PROCINFO</code> array in</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-regexp-constants-and"><code>gawk</code>, regexp constants and</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-regular-expressions_002c-case-sensitivity"><code>gawk</code>, regular expressions, case sensitivity</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-regular-expressions_002c-operators"><code>gawk</code>, regular expressions, operators</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-regular-expressions_002c-precedence"><code>gawk</code>, regular expressions, precedence</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-RT-variable-in"><code>gawk</code>, <code>RT</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-RT-variable-in-1"><code>gawk</code>, <code>RT</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-RT-variable-in-2"><code>gawk</code>, <code>RT</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-See-Also-awk"><code>gawk</code>, See Also <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-source-code_002c-obtaining"><code>gawk</code>, source code, obtaining</a></td><td>&nbsp;</td><td valign="top"><a href="#Getting">B.1.1 取得 <code>gawk</code> 发布版</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-splitting-fields-and"><code>gawk</code>, splitting fields and</a></td><td>&nbsp;</td><td valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-string_002dtranslation-functions"><code>gawk</code>, string-translation functions</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-SYMTAB-array-in"><code>gawk</code>, <code>SYMTAB</code> array in</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-TEXTDOMAIN-variable-in"><code>gawk</code>, <code>TEXTDOMAIN</code> variable in</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-timestamps"><code>gawk</code>, timestamps</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-uses-for"><code>gawk</code>, uses for</a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-versions-of_002c-information-about_002c-printing"><code>gawk</code>, versions of, information about, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-VMS-version-of"><code>gawk</code>, VMS version of</a></td><td>&nbsp;</td><td valign="top"><a href="#VMS-Installation">B.3.2 在 Vax/VMS 以及 OpenVMS 系统上编译安装 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawk_002c-word_002dboundary-operator"><code>gawk</code>, word-boundary operator</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawkextlib"><code>gawkextlib</code></a></td><td>&nbsp;</td><td valign="top"><a href="#gawkextlib">5.8 <code>gawkextlib</code> 项目</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gawkextlib-project"><code>gawkextlib</code> project</a></td><td>&nbsp;</td><td valign="top"><a href="#gawkextlib">5.8 <code>gawkextlib</code> 项目</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-General-Public-License-_0028GPL_0029">General Public License (GPL)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-General-Public-License_002c-See-GPL">General Public License, See GPL</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-generate-time-values">generate time values</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gensub_0028_0029-function-_0028gawk_0029"><code>gensub()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gensub_0028_0029-function-_0028gawk_0029-1"><code>gensub()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gensub_0028_0029-function-_0028gawk_0029_002c-escape-processing"><code>gensub()</code> function (<code>gawk</code>), escape processing</a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getaddrinfo_0028_0029-function-_0028C-library_0029"><code>getaddrinfo()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgrent_0028_0029-function-_0028C-library_0029"><code>getgrent()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgrent_0028_0029-function-_0028C-library_0029-1"><code>getgrent()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgrent_0028_0029-user_002ddefined-function"><code>getgrent()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgrent_0028_0029-user_002ddefined-function-1"><code>getgrent()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgrgid_0028_0029-function-_0028C-library_0029"><code>getgrgid()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgrgid_0028_0029-user_002ddefined-function"><code>getgrgid()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgrnam_0028_0029-function-_0028C-library_0029"><code>getgrnam()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgrnam_0028_0029-user_002ddefined-function"><code>getgrnam()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgruser_0028_0029-function-_0028C-library_0029"><code>getgruser()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getgruser_0028_0029-function_002c-user_002ddefined"><code>getgruser()</code> function, user-defined</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command"><code>getline</code> command</a></td><td>&nbsp;</td><td valign="top"><a href="#Reading-Files">4 读取输入文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-coprocesses_002c-using-from"><code>getline</code> command, coprocesses, using from</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-coprocesses_002c-using-from-1"><code>getline</code> command, coprocesses, using from</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-deadlock-and"><code>getline</code> command, deadlock and</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-explicit-input-with"><code>getline</code> command, explicit input with</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-FILENAME-variable-and"><code>getline</code> command, <code>FILENAME</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-return-values"><code>getline</code> command, return values</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-variants"><code>getline</code> command, variants</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Summary">4.9.10 <code>getline</code> 变体总结</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-_005fgr_005finit_0028_0029-user_002ddefined-function"><code>getline</code> command, <code>_gr_init()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-command_002c-_005fpw_005finit_0028_0029-function"><code>getline</code> command, <code>_pw_init()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-from-a-file"><code>getline</code> from a file</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-into-a-variable"><code>getline</code> into a variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fVariable">4.9.2 将 <code>getline</code> 赋值给变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getline-statement_002c-BEGINFILE_002fENDFILE-patterns-and"><code>getline</code> statement, <code>BEGINFILE</code>/<code>ENDFILE</code> patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getlocaltime_0028_0029-user_002ddefined-function"><code>getlocaltime()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Getlocaltime-Function">1.2.7 管理时间</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getopt_0028_0029-function-_0028C-library_0029"><code>getopt()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getopt_0028_0029-user_002ddefined-function"><code>getopt()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getopt_0028_0029-user_002ddefined-function-1"><code>getopt()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getpwent_0028_0029-function-_0028C-library_0029"><code>getpwent()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getpwent_0028_0029-function-_0028C-library_0029-1"><code>getpwent()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getpwent_0028_0029-user_002ddefined-function"><code>getpwent()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getpwent_0028_0029-user_002ddefined-function-1"><code>getpwent()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getpwnam_0028_0029-function-_0028C-library_0029"><code>getpwnam()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getpwnam_0028_0029-user_002ddefined-function"><code>getpwnam()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getpwuid_0028_0029-function-_0028C-library_0029"><code>getpwuid()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getpwuid_0028_0029-user_002ddefined-function"><code>getpwuid()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gettext-library"><code>gettext</code> library</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gettext-library_002c-locale-categories"><code>gettext</code> library, locale categories</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gettext_0028_0029-function-_0028C-library_0029"><code>gettext()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gettimeofday_0028_0029-extension-function"><code>gettimeofday()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Time">5.7.11 扩展的时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-git-utility"><code>git</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#gawkextlib">5.8 <code>gawkextlib</code> 项目</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-git-utility-1"><code>git</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-git-utility-2"><code>git</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Accessing-The-Source">C.2.1 访问 <code>gawk</code> 的 Git 仓库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-git-utility-3"><code>git</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Adding-Code">C.2.2 添加新特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Git_002c-use-of-for-gawk-source-code">Git, use of for <code>gawk</code> source code</a></td><td>&nbsp;</td><td valign="top"><a href="#Derived-Files">C.2.4 为什么自动生成的文件要放在 Git 中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNITS-mailing-list">GNITS mailing list</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-awk_002c-See-gawk">GNU <code>awk</code>, See <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-Free-Documentation-License">GNU Free Documentation License</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-General-Public-License">GNU General Public License</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-Lesser-General-Public-License">GNU Lesser General Public License</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-long-options">GNU long options</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-long-options-1">GNU long options</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-long-options_002c-printing-list-of">GNU long options, printing list of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-Project">GNU Project</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU-Project-1">GNU Project</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU_002fLinux">GNU/Linux</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU_002fLinux-1">GNU/Linux</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNU_002fLinux-2">GNU/Linux</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Gordon_002c-Assaf">Gordon, Assaf</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GPL-_0028General-Public-License_0029">GPL (General Public License)</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GPL-_0028General-Public-License_0029-1">GPL (General Public License)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GPL-_0028General-Public-License_0029_002c-printing">GPL (General Public License), printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-grcat-program"><code>grcat</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Grigera_002c-Juan">Grigera, Juan</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-group-database_002c-reading">group database, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-group-file">group file</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-group-ID-of-gawk-user">group ID of <code>gawk</code> user</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-groups_002c-information-about">groups, information about</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gsub_0028_0029-function"><code>gsub()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gsub_0028_0029-function-1"><code>gsub()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gsub_0028_0029-function_002c-arguments-of"><code>gsub()</code> function, arguments of</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-gsub_0028_0029-function_002c-escape-processing"><code>gsub()</code> function, escape processing</a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-h-debugger-command-_0028alias-for-help_0029"><code>h</code> debugger command (alias for <code>help</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hankerson_002c-Darrel">Hankerson, Darrel</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hankerson_002c-Darrel-1">Hankerson, Darrel</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Haque_002c-John">Haque, John</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hartholz_002c-Elaine">Hartholz, Elaine</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hartholz_002c-Marshall">Hartholz, Marshall</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hasegawa_002c-Isamu">Hasegawa, Isamu</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-help-debugger-command"><code>help</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hexadecimal-numbers">hexadecimal numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hexadecimal-values_002c-enabling-interpretation-of">hexadecimal values, enabling interpretation of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-history-expansion_002c-in-debugger">history expansion, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Readline-Support">3.4 支持</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-histsort_002eawk-program"><code>histsort.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#History-Sorting">2.3.6 从未排序的文本中去重</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Hughes_002c-Phil">Hughes, Phil</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-HUP-signal_002c-for-dynamic-profiling"><code>HUP</code> signal, for dynamic profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hyphen-_0028_002d_0029_002c-_002d-operator">hyphen (<code>-</code>), <code>-</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hyphen-_0028_002d_0029_002c-_002d-operator-1">hyphen (<code>-</code>), <code>-</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hyphen-_0028_002d_0029_002c-_002d_002d-operator">hyphen (<code>-</code>), <code>--</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hyphen-_0028_002d_0029_002c-_002d_002d-operator-1">hyphen (<code>-</code>), <code>--</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hyphen-_0028_002d_0029_002c-_002d_003d-operator">hyphen (<code>-</code>), <code>-=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hyphen-_0028_002d_0029_002c-_002d_003d-operator-1">hyphen (<code>-</code>), <code>-=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hyphen-_0028_002d_0029_002c-filenames-beginning-with">hyphen (<code>-</code>), filenames beginning with</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hyphen-_0028_002d_0029_002c-in-bracket-expressions">hyphen (<code>-</code>), in bracket expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-I">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-i-debugger-command-_0028alias-for-info_0029"><code>i</code> debugger command (alias for <code>info</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-id-utility"><code>id</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Id-Program">2.2.3 打印用户信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-id_002eawk-program"><code>id.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Id-Program">2.2.3 打印用户信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-if-statement"><code>if</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#If-Statement">7.4.1 <code>if</code>-<code>else</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-if-statement_002c-actions_002c-changing"><code>if</code> statement, actions, changing</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-if-statement_002c-use-of-regexps-in"><code>if</code> statement, use of regexps in</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-igawk_002esh-program"><code>igawk.sh</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Igawk-Program">2.3.9 使用库函数的简单方式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ignore-breakpoint">ignore breakpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ignore-debugger-command"><code>ignore</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IGNORECASE-variable"><code>IGNORECASE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IGNORECASE-variable_002c-and-array-indices"><code>IGNORECASE</code> variable, and array indices</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IGNORECASE-variable_002c-and-array-sorting-functions"><code>IGNORECASE</code> variable, and array sorting functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IGNORECASE-variable_002c-in-example-programs"><code>IGNORECASE</code> variable, in example programs</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IGNORECASE-variable_002c-with-_007e-and-_0021_007e-operators"><code>IGNORECASE</code> variable, with <code>~</code> and <code>!~</code> operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Illumos">Illumos</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Illumos_002c-POSIX_002dcompliant-awk">Illumos, POSIX-compliant <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implementation-issues_002c-gawk">implementation issues, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Notes">Appendix C 实现提示</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implementation-issues_002c-gawk_002c-debugging">implementation issues, <code>gawk</code>, debugging</a></td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-Mode">C.1 后向兼容与调试</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implementation-issues_002c-gawk_002c-limits">implementation issues, <code>gawk</code>, limits</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implementation-issues_002c-gawk_002c-limits-1">implementation issues, <code>gawk</code>, limits</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in-operator"><code>in</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in-operator-1"><code>in</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in-operator-2"><code>in</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#For-Statement">7.4.4 <code>for</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in-operator_002c-index-existence-in-multidimensional-arrays"><code>in</code> operator, index existence in multidimensional arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Multidimensional">8.5 多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in-operator_002c-order-of-array-access"><code>in</code> operator, order of array access</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in-operator_002c-testing-if-array-element-exists"><code>in</code> operator, testing if array element exists</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in-operator_002c-use-in-loops"><code>in</code> operator, use in loops</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-including-files_002c-_0040include-directive">including files, <code>@include</code> directive</a></td><td>&nbsp;</td><td valign="top"><a href="#Include-Files">2.7 在你的程序中包含其他的文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-increment-operators">increment operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-index_0028_0029-function"><code>index()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-indexing-arrays">indexing arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-indirect-function-calls">indirect function calls</a></td><td>&nbsp;</td><td valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-indirect-function-calls_002c-_0040_002dnotation">indirect function calls, <code>@</code>-notation</a></td><td>&nbsp;</td><td valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-infinite-precision">infinite precision</a></td><td>&nbsp;</td><td valign="top"><a href="#Arbitrary-Precision-Arithmetic">4 算术运算与 <code>gawk</code> 中的任意精度算术运算</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-info-debugger-command"><code>info</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-initialization_002c-automatic">initialization, automatic</a></td><td>&nbsp;</td><td valign="top"><a href="#More-Complex">1.5 复杂一点的例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-inplace-extension"><code>inplace</code> extension</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Inplace">5.7.4 启用文件就地编辑</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-files">input files</a></td><td>&nbsp;</td><td valign="top"><a href="#Reading-Files">4 读取输入文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-files_002c-closing">input files, closing</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-files_002c-counting-elements-in">input files, counting elements in</a></td><td>&nbsp;</td><td valign="top"><a href="#Wc-Program">2.2.7 统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-files_002c-examples">input files, examples</a></td><td>&nbsp;</td><td valign="top"><a href="#Sample-Data-Files">1.2 例子中使用的数据文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-files_002c-reading">input files, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Reading-Files">4 读取输入文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-files_002c-running-awk-without">input files, running <code>awk</code> without</a></td><td>&nbsp;</td><td valign="top"><a href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-files_002c-running-awk-without-1">input files, running <code>awk</code> without</a></td><td>&nbsp;</td><td valign="top"><a href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-files_002c-variable-assignments-and">input files, variable assignments and</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-pipeline">input pipeline</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-record_002c-length-of">input record, length of</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-redirection">input redirection</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-data_002c-nondecimal">input, data, nondecimal</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-explicit">input, explicit</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline">4.9 用 <code>getline</code> 输入数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-files_002c-See-input-files">input, files, See input files</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-multiline-records">input, multiline records</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-splitting-into-records">input, splitting into records</a></td><td>&nbsp;</td><td valign="top"><a href="#Records">4.1 输入如何拆分为记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-standard">input, standard</a></td><td>&nbsp;</td><td valign="top"><a href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-standard-1">input, standard</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002foutput-functions">input/output functions</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002foutput_002c-binary">input/output, binary</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002foutput_002c-from-BEGIN-and-END">input/output, from <code>BEGIN</code> and <code>END</code></a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002foutput_002c-two_002dway">input/output, two-way</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-insomnia_002c-cure-for">insomnia, cure for</a></td><td>&nbsp;</td><td valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-installation_002c-VMS">installation, VMS</a></td><td>&nbsp;</td><td valign="top"><a href="#VMS-Installation">B.3.2 在 Vax/VMS 以及 OpenVMS 系统上编译安装 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-installing-gawk">installing <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Installation">Appendix B 安装 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-instruction-tracing_002c-in-debugger">instruction tracing, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-INT-signal-_0028MS_002dWindows_0029"><code>INT</code> signal (MS-Windows)</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-int_0028_0029-function"><code>int()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-integer-array-indices">integer array indices</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-integers_002c-arbitrary-precision">integers, arbitrary precision</a></td><td>&nbsp;</td><td valign="top"><a href="#Arbitrary-Precision-Integers">4.5 <code>gawk</code> 中的任意精度整数计算</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-integers_002c-unsigned">integers, unsigned</a></td><td>&nbsp;</td><td valign="top"><a href="#Computer-Arithmetic">4.1 计算机算术计算说明</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interacting-with-other-programs">interacting with other programs</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization">internationalization</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization-1">internationalization</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-and-L10N">2.1 国际化与本地化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization_002c-localization">internationalization, localization</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization_002c-localization-1">internationalization, localization</a></td><td>&nbsp;</td><td valign="top"><a href="#Internationalization">2 <code>gawk</code> 的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization_002c-localization_002c-character-classes">internationalization, localization, character classes</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization_002c-localization_002c-gawk-and">internationalization, localization, <code>gawk</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#Internationalization">2 <code>gawk</code> 的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization_002c-localization_002c-locale-categories">internationalization, localization, locale categories</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization_002c-localization_002c-marked-strings">internationalization, localization, marked strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalization_002c-localization_002c-portability-and">internationalization, localization, portability and</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internationalizing-a-program">internationalizing a program</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interpreted-programs">interpreted programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interpreted-programs-1">interpreted programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-interval-expressions_002c-regexp-operator">interval expressions, regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-inventory_002dshipped-file"><code>inventory-shipped</code> file</a></td><td>&nbsp;</td><td valign="top"><a href="#Sample-Data-Files">1.2 例子中使用的数据文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-invoke-shell-command">invoke shell command</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-isarray_0028_0029-function-_0028gawk_0029"><code>isarray()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Type-Functions">9.1.7 获取类型信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ISO">ISO</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ISO-8859_002d1">ISO 8859-1</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ISO-Latin_002d1">ISO Latin-1</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-J">J</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Jacobs_002c-Andrew">Jacobs, Andrew</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Jaegermann_002c-Michal">Jaegermann, Michal</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Jaegermann_002c-Michal-1">Jaegermann, Michal</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Java-implementation-of-awk">Java implementation of <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Java-programming-language">Java programming language</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-jawk"><code>jawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Jedi-knights">Jedi knights</a></td><td>&nbsp;</td><td valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Johansen_002c-Chris">Johansen, Chris</a></td><td>&nbsp;</td><td valign="top"><a href="#Signature-Program">2.3.11 来些新鲜的</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-join_0028_0029-user_002ddefined-function"><code>join()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Join-Function">1.2.6 将数组合并成字串</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-K">K</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kahrs_002c-Jurgen">Kahrs, J&uuml;rgen</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kahrs_002c-Jurgen-1">Kahrs, J&uuml;rgen</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kasal_002c-Stepan">Kasal, Stepan</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kenobi_002c-Obi_002dWan">Kenobi, Obi-Wan</a></td><td>&nbsp;</td><td valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-1">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#ae_009a_0097e_00a7_0092">暗角</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-2">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-3">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-4">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-5">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-6">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#BTL">A.4 Brian Kernighan 的 <code>awk</code> 的扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-7">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-8">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-9">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kernighan_002c-Brian-10">Kernighan, Brian</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-kill-command_002c-dynamic-profiling"><code>kill</code> command, dynamic profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Knights_002c-jedi">Knights, jedi</a></td><td>&nbsp;</td><td valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kwok_002c-Conrad">Kwok, Conrad</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-l-debugger-command-_0028alias-for-list_0029"><code>l</code> debugger command (alias for <code>list</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-labels_002eawk-program"><code>labels.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Labels-Program">2.3.4 打印邮件标题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Langston_002c-Peter">Langston, Peter</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">1 <code>gawk</code> 的高级特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LANGUAGE-environment-variable"><code>LANGUAGE</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-languages_002c-data_002ddriven">languages, data-driven</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fALL-locale-category"><code>LC_ALL</code> locale category</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fCOLLATE-locale-category"><code>LC_COLLATE</code> locale category</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fCTYPE-locale-category"><code>LC_CTYPE</code> locale category</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fMESSAGES-locale-category"><code>LC_MESSAGES</code> locale category</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fMESSAGES-locale-category_002c-bindtextdomain_0028_0029-function-_0028gawk_0029"><code>LC_MESSAGES</code> locale category, <code>bindtextdomain()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fMONETARY-locale-category"><code>LC_MONETARY</code> locale category</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fNUMERIC-locale-category"><code>LC_NUMERIC</code> locale category</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LC_005fTIME-locale-category"><code>LC_TIME</code> locale category</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left-angle-bracket-_0028_003c_0029_002c-_003c-operator">left angle bracket (<code>&lt;</code>), <code>&lt;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left-angle-bracket-_0028_003c_0029_002c-_003c-operator-1">left angle bracket (<code>&lt;</code>), <code>&lt;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left-angle-bracket-_0028_003c_0029_002c-_003c-operator-_0028I_002fO_0029">left angle bracket (<code>&lt;</code>), <code>&lt;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left-angle-bracket-_0028_003c_0029_002c-_003c_003d-operator">left angle bracket (<code>&lt;</code>), <code>&lt;=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left-angle-bracket-_0028_003c_0029_002c-_003c_003d-operator-1">left angle bracket (<code>&lt;</code>), <code>&lt;=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left-shift">left shift</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left-shift_002c-bitwise">left shift, bitwise</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-leftmost-longest-match">leftmost longest match</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length-of-input-record">length of input record</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length-of-string">length of string</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length_0028_0029-function"><code>length()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lesser-General-Public-License-_0028LGPL_0029">Lesser General Public License (LGPL)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LGPL-_0028Lesser-General-Public-License_0029">LGPL (Lesser General Public License)</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libmawk">libmawk</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions">libraries of <code>awk</code> functions</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-assertions">libraries of <code>awk</code> functions, assertions</a></td><td>&nbsp;</td><td valign="top"><a href="#Assert-Function">1.2.2 断言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-associative-arrays-and">libraries of <code>awk</code> functions, associative arrays and</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-character-values-as-numbers">libraries of <code>awk</code> functions, character values as numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-command_002dline-options">libraries of <code>awk</code> functions, command-line options</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-example-program-for-using">libraries of <code>awk</code> functions, example program for using</a></td><td>&nbsp;</td><td valign="top"><a href="#Igawk-Program">2.3.9 使用库函数的简单方式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-group-database_002c-reading">libraries of <code>awk</code> functions, group database, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-managing_002c-data-files">libraries of <code>awk</code> functions, managing, data files</a></td><td>&nbsp;</td><td valign="top"><a href="#Data-File-Management">1.3 数据文件管理</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-managing_002c-time">libraries of <code>awk</code> functions, managing, time</a></td><td>&nbsp;</td><td valign="top"><a href="#Getlocaltime-Function">1.2.7 管理时间</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-merging-arrays-into-strings">libraries of <code>awk</code> functions, merging arrays into strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Join-Function">1.2.6 将数组合并成字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-rounding-numbers">libraries of <code>awk</code> functions, rounding numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-libraries-of-awk-functions_002c-user-database_002c-reading">libraries of <code>awk</code> functions, user database, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-line-breaks">line breaks</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-line-continuations">line continuations</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-line-continuations_002c-gawk">line continuations, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-line-continuations_002c-in-print-statement">line continuations, in <code>print</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-line-continuations_002c-with-C-shell">line continuations, with C shell</a></td><td>&nbsp;</td><td valign="top"><a href="#More-Complex">1.5 复杂一点的例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lines_002c-blank_002c-printing">lines, blank, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Print">5.1 <code>print</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lines_002c-counting">lines, counting</a></td><td>&nbsp;</td><td valign="top"><a href="#Wc-Program">2.2.7 统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lines_002c-duplicate_002c-removing">lines, duplicate, removing</a></td><td>&nbsp;</td><td valign="top"><a href="#History-Sorting">2.3.6 从未排序的文本中去重</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lines_002c-matching-ranges-of">lines, matching ranges of</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lines_002c-skipping-between-markers">lines, skipping between markers</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint-checking">lint checking</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint-checking_002c-array-elements">lint checking, array elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint-checking_002c-array-subscripts">lint checking, array subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint-checking_002c-empty-programs">lint checking, empty programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint-checking_002c-issuing-warnings">lint checking, issuing warnings</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint-checking_002c-POSIXLY_005fCORRECT-environment-variable">lint checking, <code>POSIXLY_CORRECT</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lint-checking_002c-undefined-functions">lint checking, undefined functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LINT-variable"><code>LINT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linux">Linux</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linux-1">Linux</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linux-2">Linux</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-list-all-global-variables_002c-in-debugger">list all global variables, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-list-debugger-command"><code>list</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-list-function-definitions_002c-in-debugger">list function definitions, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loading-extensions_002c-_0040load-directive">loading extensions, <code>@load</code> directive</a></td><td>&nbsp;</td><td valign="top"><a href="#Loading-Shared-Libraries">2.8 在你的程序装入动态扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loading_002c-extensions">loading, extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-local-variables_002c-in-a-function">local variables, in a function</a></td><td>&nbsp;</td><td valign="top"><a href="#Variable-Scope">9.2.3.2 控制变量作用域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-locale-categories">locale categories</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-locale-decimal-point-character">locale decimal point character</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-locale_002c-definition-of">locale, definition of</a></td><td>&nbsp;</td><td valign="top"><a href="#Locales">6.6 哪里造成差异</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-localization">localization</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-and-L10N">2.1 国际化与本地化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-localization_002c-See-internationalization_002c-localization">localization, See internationalization, localization</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-and-L10N">2.1 国际化与本地化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-log-files_002c-timestamps-in">log files, timestamps in</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-log_0028_0029-function"><code>log()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-logarithm">logarithm</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-logical-false_002ftrue">logical false/true</a></td><td>&nbsp;</td><td valign="top"><a href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-logical-operators_002c-See-Boolean-expressions">logical operators, See Boolean expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-login-information">login information</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-long-options">long options</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops">loops</a></td><td>&nbsp;</td><td valign="top"><a href="#While-Statement">7.4.2 <code>while</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-break-statement-and">loops, <code>break</code> statement and</a></td><td>&nbsp;</td><td valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-continue-statements-and">loops, <code>continue</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#For-Statement">7.4.4 <code>for</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-count-for-header_002c-in-a-profile">loops, count for header, in a profile</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-do_002dwhile">loops, <code>do</code>-<code>while</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Do-Statement">7.4.3 <code>do</code>-<code>while</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-exiting">loops, exiting</a></td><td>&nbsp;</td><td valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-for_002c-array-scanning">loops, <code>for</code>, array scanning</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-for_002c-iterative">loops, <code>for</code>, iterative</a></td><td>&nbsp;</td><td valign="top"><a href="#For-Statement">7.4.4 <code>for</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-See-Also-while-statement">loops, See Also <code>while</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#While-Statement">7.4.2 <code>while</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loops_002c-while">loops, <code>while</code></a></td><td>&nbsp;</td><td valign="top"><a href="#While-Statement">7.4.2 <code>while</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ls-utility"><code>ls</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#More-Complex">1.5 复杂一点的例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lshift_0028_0029-function-_0028gawk_0029"><code>lshift()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lvalues_002frvalues">lvalues/rvalues</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-mail_002dlist-file"><code>mail-list</code> file</a></td><td>&nbsp;</td><td valign="top"><a href="#Sample-Data-Files">1.2 例子中使用的数据文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mailing-labels_002c-printing">mailing labels, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Labels-Program">2.3.4 打印邮件标题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mailing-list_002c-GNITS">mailing list, GNITS</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Malmberg_002c-John">Malmberg, John</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Malmberg_002c-John-1">Malmberg, John</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Malmberg_002c-John-E_002e">Malmberg, John E.</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mark-parity">mark parity</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-marked-string-extraction-_0028internationalization_0029">marked string extraction (internationalization)</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-marked-strings_002c-extracting">marked strings, extracting</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Marx_002c-Groucho">Marx, Groucho</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-match-regexp-in-string">match regexp in string</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-match_0028_0029-function"><code>match()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-match_0028_0029-function_002c-RSTART_002fRLENGTH-variables"><code>match()</code> function, <code>RSTART</code>/<code>RLENGTH</code> variables</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-matching_002c-expressions_002c-See-comparison-expressions">matching, expressions, See comparison expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-matching_002c-leftmost-longest">matching, leftmost longest</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-matching_002c-null-strings">matching, null strings</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mawk-utility"><code>mawk</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mawk-utility-1"><code>mawk</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mawk-utility-2"><code>mawk</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mawk-utility-3"><code>mawk</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Nextfile-Statement">7.4.9 <code>nextfile</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mawk-utility-4"><code>mawk</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-maximum-precision-supported-by-MPFR-library">maximum precision supported by MPFR library</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-McIlroy_002c-Doug">McIlroy, Doug</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-McPhee_002c-Patrick">McPhee, Patrick</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-message-object-files">message object files</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-message-object-files_002c-converting-from-portable-object-files">message object files, converting from portable object files</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-message-object-files_002c-specifying-directory-of">message object files, specifying directory of</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-message-object-files_002c-specifying-directory-of-1">message object files, specifying directory of</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-messages-from-extensions">messages from extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Printing-Messages">5.4.6 打印信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-metacharacters-in-regular-expressions">metacharacters in regular expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-metacharacters_002c-escape-sequences-for">metacharacters, escape sequences for</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-minimum-precision-required-by-MPFR-library">minimum precision required by MPFR library</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mktime_0028_0029-function-_0028gawk_0029"><code>mktime()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-modifiers_002c-in-format-specifiers">modifiers, in format specifiers</a></td><td>&nbsp;</td><td valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-monetary-information_002c-localization">monetary information, localization</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Moore_002c-Duncan">Moore, Duncan</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-msgfmt-utility"><code>msgfmt</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiple-precision">multiple precision</a></td><td>&nbsp;</td><td valign="top"><a href="#Arbitrary-Precision-Arithmetic">4 算术运算与 <code>gawk</code> 中的任意精度算术运算</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-multiple_002dline-records">multiple-line records</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-N">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-n-debugger-command-_0028alias-for-next_0029"><code>n</code> debugger command (alias for <code>next</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-names_002c-arrays_002fvariables">names, arrays/variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-names_002c-functions">names, functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-names_002c-functions-1">names, functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-namespace-issues">namespace issues</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-namespace-issues_002c-functions">namespace issues, functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NetBSD">NetBSD</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-networks_002c-programming">networks, programming</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-networks_002c-support-for">networks, support for</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-Network">5.8.2 用于网络的特殊文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines">newlines</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines-1">newlines</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines-2">newlines</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines_002c-as-field-separators">newlines, as field separators</a></td><td>&nbsp;</td><td valign="top"><a href="#Default-Field-Splitting">4.5.1 标准的域分隔符空白符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines_002c-as-record-separators">newlines, as record separators</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines_002c-in-dynamic-regexps">newlines, in dynamic regexps</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines_002c-in-regexp-constants">newlines, in regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines_002c-printing">newlines, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines_002c-separating-statements-in-actions">newlines, separating statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Action-Overview">7.3 动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-newlines_002c-separating-statements-in-actions-1">newlines, separating statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next-debugger-command"><code>next</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next-file-statement"><code>next file</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Feature-History">A.6 <code>gawk</code> 特性历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next-statement"><code>next</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next-statement-1"><code>next</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next-statement_002c-BEGIN_002fEND-patterns-and"><code>next</code> statement, <code>BEGIN</code>/<code>END</code> patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next-statement_002c-BEGINFILE_002fENDFILE-patterns-and"><code>next</code> statement, <code>BEGINFILE</code>/<code>ENDFILE</code> patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next-statement_002c-user_002ddefined-functions-and"><code>next</code> statement, user-defined functions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nextfile-statement"><code>nextfile</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Nextfile-Statement">7.4.9 <code>nextfile</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nextfile-statement_002c-BEGIN_002fEND-patterns-and"><code>nextfile</code> statement, <code>BEGIN</code>/<code>END</code> patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nextfile-statement_002c-BEGINFILE_002fENDFILE-patterns-and"><code>nextfile</code> statement, <code>BEGINFILE</code>/<code>ENDFILE</code> patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nextfile-statement_002c-user_002ddefined-functions-and"><code>nextfile</code> statement, user-defined functions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Nextfile-Statement">7.4.9 <code>nextfile</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nexti-debugger-command"><code>nexti</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NF-variable"><code>NF</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NF-variable-1"><code>NF</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NF-variable_002c-decrementing"><code>NF</code> variable, decrementing</a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ni-debugger-command-_0028alias-for-nexti_0029"><code>ni</code> debugger command (alias for <code>nexti</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-noassign_002eawk-program"><code>noassign.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Ignoring-Assigns">1.3.5 将赋值当成是文件名</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dexistent-array-elements">non-existent array elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-not-Boolean_002dlogic-operator">not Boolean-logic operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NR-variable"><code>NR</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Records">4.1 输入如何拆分为记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NR-variable-1"><code>NR</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NR-variable_002c-changing"><code>NR</code> variable, changing</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings">null strings</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings-1">null strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings-2">null strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings-3">null strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings-in-gawk-arguments_002c-quoting-and">null strings in <code>gawk</code> arguments, quoting and</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings_002c-and-deleting-array-elements">null strings, and deleting array elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings_002c-as-array-subscripts">null strings, as array subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings_002c-converting-numbers-to-strings">null strings, converting numbers to strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-strings_002c-matching">null strings, matching</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-number-as-string-of-bits">number as string of bits</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-number-of-array-elements">number of array elements</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-number-sign-_0028_0023_0029_002c-_0023_0021-_0028executable-scripts_0029">number sign (<code>#</code>), <code>#!</code> (executable scripts)</a></td><td>&nbsp;</td><td valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-number-sign-_0028_0023_0029_002c-commenting">number sign (<code>#</code>), commenting</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-as-array-subscripts">numbers, as array subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-as-values-of-characters">numbers, as values of characters</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-Cliff-random">numbers, Cliff random</a></td><td>&nbsp;</td><td valign="top"><a href="#Cliff-Random-Function">1.2.4 Cliff 随机数生成器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-converting">numbers, converting</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-converting-1">numbers, converting</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-converting_002c-to-strings">numbers, converting, to strings</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-converting_002c-to-strings-1">numbers, converting, to strings</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-hexadecimal">numbers, hexadecimal</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-octal">numbers, octal</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numbers_002c-rounding">numbers, rounding</a></td><td>&nbsp;</td><td valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numeric-constants">numeric constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Scalar-Constants">6.1.1.1 数值与字串常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numeric-functions">numeric functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numeric_002c-output-format">numeric, output format</a></td><td>&nbsp;</td><td valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-numeric_002c-strings">numeric, strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Variable-Typing">6.3.2.1 字串类型与数值类型</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-O">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-o-debugger-command-_0028alias-for-option_0029"><code>o</code> debugger command (alias for <code>option</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-obsolete-features">obsolete features</a></td><td>&nbsp;</td><td valign="top"><a href="#Obsolete">2.9 已经取消的选项以及特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-octal-numbers">octal numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-octal-values_002c-enabling-interpretation-of">octal values, enabling interpretation of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OFMT-variable"><code>OFMT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OFMT-variable-1"><code>OFMT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OFMT-variable-2"><code>OFMT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OFMT-variable_002c-POSIX-awk-and"><code>OFMT</code> variable, POSIX <code>awk</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OFS-variable"><code>OFS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OFS-variable-1"><code>OFS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Output-Separators">5.3 输出分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OFS-variable-2"><code>OFS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OpenBSD">OpenBSD</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OpenSolaris">OpenSolaris</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operating-systems_002c-BSD_002dbased">operating systems, BSD-based</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operating-systems_002c-PC_002c-gawk-on">operating systems, PC, <code>gawk</code> on</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operating-systems_002c-PC_002c-gawk-on_002c-installing">operating systems, PC, <code>gawk</code> on, installing</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Installation">B.3.1 安装到 PC 操作系统</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operating-systems_002c-porting-gawk-to">operating systems, porting <code>gawk</code> to</a></td><td>&nbsp;</td><td valign="top"><a href="#New-Ports">C.2.3 将 <code>gawk</code> 移植到新系统中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operating-systems_002c-See-Also-GNU_002fLinux_002c-PC-operating-systems_002c-Unix">operating systems, See Also GNU/Linux, PC operating systems, Unix</a></td><td>&nbsp;</td><td valign="top"><a href="#Installation">Appendix B 安装 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operations_002c-bitwise">operations, bitwise</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-arithmetic">operators, arithmetic</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-assignment">operators, assignment</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-assignment-1">operators, assignment</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-assignment_002c-evaluation-order">operators, assignment, evaluation order</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-Boolean_002c-See-Boolean-expressions">operators, Boolean, See Boolean expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-decrement_002fincrement">operators, decrement/increment</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-GNU_002dspecific">operators, GNU-specific</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-input_002foutput">operators, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-input_002foutput-1">operators, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-input_002foutput-2">operators, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-input_002foutput-3">operators, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-input_002foutput-4">operators, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-input_002foutput-5">operators, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-input_002foutput-6">operators, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-input_002foutput-7">operators, input/output</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-logical_002c-See-Boolean-expressions">operators, logical, See Boolean expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-precedence">operators, precedence</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-precedence-1">operators, precedence</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-relational_002c-See-operators_002c-comparison">operators, relational, See operators, comparison</a></td><td>&nbsp;</td><td valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-short_002dcircuit">operators, short-circuit</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-string">operators, string</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-string_002dmatching">operators, string-matching</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-string_002dmatching_002c-for-buffers">operators, string-matching, for buffers</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-operators_002c-word_002dboundary-_0028gawk_0029">operators, word-boundary (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-option-debugger-command"><code>option</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-command_002dline">options, command-line</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-command_002dline_002c-end-of">options, command-line, end of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-command_002dline_002c-invoking-awk">options, command-line, invoking <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-command_002dline_002c-processing">options, command-line, processing</a></td><td>&nbsp;</td><td valign="top"><a href="#Getopt-Function">1.4 处理命令行选项</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-deprecated">options, deprecated</a></td><td>&nbsp;</td><td valign="top"><a href="#Obsolete">2.9 已经取消的选项以及特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-long">options, long</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line">2.1 调用 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-long-1">options, long</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-options_002c-printing-list-of">options, printing list of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-OR-bitwise-operation">OR bitwise operation</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-or-Boolean_002dlogic-operator">or Boolean-logic operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-or_0028_0029-function-_0028gawk_0029"><code>or()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ord_0028_0029-extension-function"><code>ord()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Ord">5.7.5 字符与数值：<code>ord()</code> 与 <code>chr()</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ord_0028_0029-user_002ddefined-function"><code>ord()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-order-of-evaluation_002c-concatenation">order of evaluation, concatenation</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ORS-variable"><code>ORS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Output-Separators">5.3 输出分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ORS-variable-1"><code>ORS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output-field-separator_002c-See-OFS-variable">output field separator, See <code>OFS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output-record-separator_002c-See-ORS-variable">output record separator, See <code>ORS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Output-Separators">5.3 输出分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output-redirection">output redirection</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output-wrapper">output wrapper</a></td><td>&nbsp;</td><td valign="top"><a href="#Output-Wrappers">5.4.5.5 定制输出包装器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-buffering">output, buffering</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-buffering-1">output, buffering</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-duplicating-into-files">output, duplicating into files</a></td><td>&nbsp;</td><td valign="top"><a href="#Tee-Program">2.2.5 将输出复制到多个文件中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-files_002c-closing">output, files, closing</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-format-specifier_002c-OFMT">output, format specifier, <code>OFMT</code></a></td><td>&nbsp;</td><td valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-formatted">output, formatted</a></td><td>&nbsp;</td><td valign="top"><a href="#Printf">5.5 使用 <code>printf</code> 语句美化打印</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-pipes">output, pipes</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-printing_002c-See-printing">output, printing, See printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Printing">5 打印输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-records">output, records</a></td><td>&nbsp;</td><td valign="top"><a href="#Output-Separators">5.3 输出分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-output_002c-standard">output, standard</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-p-debugger-command-_0028alias-for-print_0029"><code>p</code> debugger command (alias for <code>print</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Papadopoulos_002c-Panos">Papadopoulos, Panos</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parent-process-ID-of-gawk-process">parent process ID of <code>gawk</code> process</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parentheses-_0028_0029_002c-in-a-profile">parentheses <code>()</code>, in a profile</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parentheses-_0028_0029_002c-regexp-operator">parentheses <code>()</code>, regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-password-file">password file</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patsplit_0028_0029-function-_0028gawk_0029"><code>patsplit()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns">patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Patterns-and-Actions">7 模式、动作与变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns_002c-comparison-expressions-as">patterns, comparison expressions as</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns_002c-counts_002c-in-a-profile">patterns, counts, in a profile</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns_002c-default">patterns, default</a></td><td>&nbsp;</td><td valign="top"><a href="#Very-Simple">1.3 一些简单例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns_002c-empty">patterns, empty</a></td><td>&nbsp;</td><td valign="top"><a href="#Empty">7.1.6 空模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns_002c-expressions-as">patterns, expressions as</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Patterns">7.1.1 以正则表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns_002c-ranges-in">patterns, ranges in</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns_002c-regexp-constants-as">patterns, regexp constants as</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-patterns_002c-types-of">patterns, types of</a></td><td>&nbsp;</td><td valign="top"><a href="#Pattern-Overview">7.1 模式元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pawk-_0028profiling-version-of-Brian-Kernighan_0027s-awk_0029"><code>pawk</code> (profiling version of Brian Kernighan&rsquo;s <code>awk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pawk_002c-awk_002dlike-facilities-for-Python"><code>pawk</code>, <code>awk</code>-like facilities for Python</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PC-operating-systems_002c-gawk-on">PC operating systems, <code>gawk</code> on</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PC-operating-systems_002c-gawk-on_002c-installing">PC operating systems, <code>gawk</code> on, installing</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Installation">B.3.1 安装到 PC 操作系统</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-percent-sign-_0028_0025_0029_002c-_0025-operator">percent sign (<code>%</code>), <code>%</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-percent-sign-_0028_0025_0029_002c-_0025_003d-operator">percent sign (<code>%</code>), <code>%=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-percent-sign-_0028_0025_0029_002c-_0025_003d-operator-1">percent sign (<code>%</code>), <code>%=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-period-_0028_002e_0029_002c-regexp-operator">period (<code>.</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Perl">Perl</a></td><td>&nbsp;</td><td valign="top"><a href="#Future-Extensions">C.3 后续可能的扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Peters_002c-Arno">Peters, Arno</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Peterson_002c-Hal">Peterson, Hal</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pipe_002c-closing">pipe, closing</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pipe_002c-input">pipe, input</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pipe_002c-output">pipe, output</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Pitts_002c-Dave">Pitts, Dave</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Pitts_002c-Dave-1">Pitts, Dave</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Plauger_002c-P_002eJ_002e">Plauger, P.J.</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plug_002din">plug-in</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Intro">5.1 介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plus-sign-_0028_002b_0029_002c-_002b-operator">plus sign (<code>+</code>), <code>+</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plus-sign-_0028_002b_0029_002c-_002b-operator-1">plus sign (<code>+</code>), <code>+</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plus-sign-_0028_002b_0029_002c-_002b_002b-operator">plus sign (<code>+</code>), <code>++</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plus-sign-_0028_002b_0029_002c-_002b_002b-operator-1">plus sign (<code>+</code>), <code>++</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plus-sign-_0028_002b_0029_002c-_002b_002b-operator-2">plus sign (<code>+</code>), <code>++</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plus-sign-_0028_002b_0029_002c-_002b_003d-operator">plus sign (<code>+</code>), <code>+=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plus-sign-_0028_002b_0029_002c-_002b_003d-operator-1">plus sign (<code>+</code>), <code>+=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plus-sign-_0028_002b_0029_002c-regexp-operator">plus sign (<code>+</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pointers-to-functions">pointers to functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Indirect-Calls">9.3 间接函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability">portability</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-_0023_0021-_0028executable-scripts_0029">portability, <code>#!</code> (executable scripts)</a></td><td>&nbsp;</td><td valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-_002a_002a-operator-and">portability, <code>**</code> operator and</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-_002a_002a_003d-operator-and">portability, <code>**=</code> operator and</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-ARGV-variable">portability, <code>ARGV</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-backslash-continuation-and">portability, backslash continuation and</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-backslash-in-escape-sequences">portability, backslash in escape sequences</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-close_0028_0029-function-and">portability, <code>close()</code> function and</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-data-files-as-single-record">portability, data files as single record</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-deleting-array-elements">portability, deleting array elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-example-programs">portability, example programs</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-functions_002c-defining">portability, functions, defining</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-gawk">portability, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#New-Ports">C.2.3 将 <code>gawk</code> 移植到新系统中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-gettext-library-and">portability, <code>gettext</code> library and</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-internationalization-and">portability, internationalization and</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-length_0028_0029-function">portability, <code>length()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-new-awk-vs_002e-old-awk">portability, new <code>awk</code> vs. old <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-next-statement-in-user_002ddefined-functions">portability, <code>next</code> statement in user-defined functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-NF-variable_002c-decrementing">portability, <code>NF</code> variable, decrementing</a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-operators">portability, operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-operators_002c-not-in-POSIX-awk">portability, operators, not in POSIX <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-POSIXLY_005fCORRECT-environment-variable">portability, <code>POSIXLY_CORRECT</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portability_002c-substr_0028_0029-function">portability, <code>substr()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portable-object-files">portable object files</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portable-object-files-1">portable object files</a></td><td>&nbsp;</td><td valign="top"><a href="#Translator-i18n">2.4 翻译 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portable-object-files_002c-converting-to-message-object-files">portable object files, converting to message object files</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Example">2.5 简单的国际化例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portable-object-files_002c-generating">portable object files, generating</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-portable-object-template-files">portable object template files</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-porting-gawk">porting <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#New-Ports">C.2.3 将 <code>gawk</code> 移植到新系统中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-positional-specifiers_002c-printf-statement">positional specifiers, <code>printf</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-positional-specifiers_002c-printf-statement-1">positional specifiers, <code>printf</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Printf-Ordering">2.4.2 重排 <code>printf</code> 参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-positional-specifiers_002c-printf-statement_002c-mixing-with-regular-formats">positional specifiers, <code>printf</code> statement, mixing with regular formats</a></td><td>&nbsp;</td><td valign="top"><a href="#Printf-Ordering">2.4.2 重排 <code>printf</code> 参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk">POSIX <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#This-Manual">使用本书</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk-1">POSIX <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-_002a_002a-operator-and">POSIX <code>awk</code>, <code>**</code> operator and</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-_002a_002a_003d-operator-and">POSIX <code>awk</code>, <code>**=</code> operator and</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-_003c-operator-and">POSIX <code>awk</code>, <code>&lt;</code> operator and</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-arithmetic-operators-and">POSIX <code>awk</code>, arithmetic operators and</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-backslashes-in-string-constants">POSIX <code>awk</code>, backslashes in string constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-BEGIN_002fEND-patterns">POSIX <code>awk</code>, <code>BEGIN</code>/<code>END</code> patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-bracket-expressions-and">POSIX <code>awk</code>, bracket expressions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-bracket-expressions-and_002c-character-classes">POSIX <code>awk</code>, bracket expressions and, character classes</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-bracket-expressions-and_002c-character-classes-1">POSIX <code>awk</code>, bracket expressions and, character classes</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-break-statement-and">POSIX <code>awk</code>, <code>break</code> statement and</a></td><td>&nbsp;</td><td valign="top"><a href="#Break-Statement">7.4.6 <code>break</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-changes-in-awk-versions">POSIX <code>awk</code>, changes in <code>awk</code> versions</a></td><td>&nbsp;</td><td valign="top"><a href="#POSIX">A.3 在 SVR4 与 POSIX 之间的变化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-continue-statement-and">POSIX <code>awk</code>, <code>continue</code> statement and</a></td><td>&nbsp;</td><td valign="top"><a href="#Continue-Statement">7.4.7 <code>continue</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-CONVFMT-variable-and">POSIX <code>awk</code>, <code>CONVFMT</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-date-utility-and">POSIX <code>awk</code>, <code>date</code> utility and</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-field-separators-and">POSIX <code>awk</code>, field separators and</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-field-separators-and-1">POSIX <code>awk</code>, field separators and</a></td><td>&nbsp;</td><td valign="top"><a href="#Full-Line-Fields">4.5.5 一行即一域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-FS-variable-and">POSIX <code>awk</code>, <code>FS</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-function-keyword-in">POSIX <code>awk</code>, <code>function</code> keyword in</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-functions-and_002c-gsub_0028_0029_002fsub_0028_0029">POSIX <code>awk</code>, functions and, <code>gsub()</code>/<code>sub()</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-functions-and_002c-length_0028_0029">POSIX <code>awk</code>, functions and, <code>length()</code></a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-GNU-long-options-and">POSIX <code>awk</code>, GNU long options and</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-interval-expressions-in">POSIX <code>awk</code>, interval expressions in</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-next_002fnextfile-statements-and">POSIX <code>awk</code>, <code>next</code>/<code>nextfile</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#Next-Statement">7.4.8 <code>next</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-numeric-strings-and">POSIX <code>awk</code>, numeric strings and</a></td><td>&nbsp;</td><td valign="top"><a href="#Variable-Typing">6.3.2.1 字串类型与数值类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-OFMT-variable-and">POSIX <code>awk</code>, <code>OFMT</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-OFMT-variable-and-1">POSIX <code>awk</code>, <code>OFMT</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-period-_0028_002e_0029_002c-using">POSIX <code>awk</code>, period (<code>.</code>), using</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-printf-format-strings-and">POSIX <code>awk</code>, <code>printf</code> format strings and</a></td><td>&nbsp;</td><td valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-regular-expressions-and">POSIX <code>awk</code>, regular expressions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-timestamps-and">POSIX <code>awk</code>, timestamps and</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-awk_002c-_007c-I_002fO-operator-and">POSIX <code>awk</code>, <code>|</code> I/O operator and</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-mode">POSIX mode</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX-mode-1">POSIX mode</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX_002c-awk-and">POSIX, <code>awk</code> and</a></td><td>&nbsp;</td><td valign="top"><a href="#Preface">前言</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX_002c-gawk-extensions-not-included-in">POSIX, <code>gawk</code> extensions not included in</a></td><td>&nbsp;</td><td valign="top"><a href="#POSIX_002fGNU">A.5 不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIX_002c-programs_002c-implementing-in-awk">POSIX, programs, implementing in <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Clones">2.2 为快乐与评测重新发明轮子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-POSIXLY_005fCORRECT-environment-variable"><code>POSIXLY_CORRECT</code> environment variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PREC-variable"><code>PREC</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-precedence">precedence</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-precedence-1">precedence</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-precedence_002c-regexp-operators">precedence, regexp operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-predefined-variables">predefined variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Built_002din-Variables">7.5 预定义变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-predefined-variables_002c-_002dv-option_002c-setting-with">predefined variables, <code>-v</code> option, setting with</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-predefined-variables_002c-conveying-information">predefined variables, conveying information</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-predefined-variables_002c-user_002dmodifiable">predefined variables, user-modifiable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-debugger-command"><code>print</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-statement"><code>print</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Printing">5 打印输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-statement_002c-BEGIN_002fEND-patterns-and"><code>print</code> statement, <code>BEGIN</code>/<code>END</code> patterns and</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-statement_002c-commas_002c-omitting"><code>print</code> statement, commas, omitting</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-statement_002c-I_002fO-operators-in"><code>print</code> statement, I/O operators in</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-statement_002c-line-continuations-and"><code>print</code> statement, line continuations and</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-statement_002c-OFMT-variable-and"><code>print</code> statement, <code>OFMT</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-statement_002c-See-Also-redirection_002c-of-output"><code>print</code> statement, See Also redirection, of output</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-statement_002c-sprintf_0028_0029-function-and"><code>print</code> statement, <code>sprintf()</code> function and</a></td><td>&nbsp;</td><td valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print-variables_002c-in-debugger">print variables, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-debugger-command"><code>printf</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement"><code>printf</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Printing">5 打印输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement-1"><code>printf</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Printf">5.5 使用 <code>printf</code> 语句美化打印</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-columns_002c-aligning"><code>printf</code> statement, columns, aligning</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-format_002dcontrol-characters"><code>printf</code> statement, format-control characters</a></td><td>&nbsp;</td><td valign="top"><a href="#Control-Letters">5.5.2 格式控制字母</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-I_002fO-operators-in"><code>printf</code> statement, I/O operators in</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-modifiers"><code>printf</code> statement, modifiers</a></td><td>&nbsp;</td><td valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-positional-specifiers"><code>printf</code> statement, positional specifiers</a></td><td>&nbsp;</td><td valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-positional-specifiers-1"><code>printf</code> statement, positional specifiers</a></td><td>&nbsp;</td><td valign="top"><a href="#Printf-Ordering">2.4.2 重排 <code>printf</code> 参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-positional-specifiers_002c-mixing-with-regular-formats"><code>printf</code> statement, positional specifiers, mixing with regular formats</a></td><td>&nbsp;</td><td valign="top"><a href="#Printf-Ordering">2.4.2 重排 <code>printf</code> 参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-See-Also-redirection_002c-of-output"><code>printf</code> statement, See Also redirection, of output</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-sprintf_0028_0029-function-and"><code>printf</code> statement, <code>sprintf()</code> function and</a></td><td>&nbsp;</td><td valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printf-statement_002c-syntax-of"><code>printf</code> statement, syntax of</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Printf">5.5.1 使用 <code>printf</code> 语句美化打印</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing">printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Printing">5 打印输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing-messages-from-extensions">printing messages from extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Printing-Messages">5.4.6 打印信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing_002c-list-of-options">printing, list of options</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing_002c-mailing-labels">printing, mailing labels</a></td><td>&nbsp;</td><td valign="top"><a href="#Labels-Program">2.3.4 打印邮件标题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing_002c-unduplicated-lines-of-text">printing, unduplicated lines of text</a></td><td>&nbsp;</td><td valign="top"><a href="#Uniq-Program">2.2.6 打印去重文本行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-printing_002c-user-information">printing, user information</a></td><td>&nbsp;</td><td valign="top"><a href="#Id-Program">2.2.3 打印用户信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-private-variables">private variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-process-group-ID-of-gawk-process">process group ID of <code>gawk</code> process</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-process-ID-of-gawk-process">process ID of <code>gawk</code> process</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-processes_002c-two_002dway-communications-with">processes, two-way communications with</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-processing-data">processing data</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROCINFO-array"><code>PROCINFO</code> array</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROCINFO-array-1"><code>PROCINFO</code> array</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROCINFO-array-2"><code>PROCINFO</code> array</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROCINFO-array_002c-and-communications-via-ptys"><code>PROCINFO</code> array, and communications via ptys</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROCINFO-array_002c-and-group-membership"><code>PROCINFO</code> array, and group membership</a></td><td>&nbsp;</td><td valign="top"><a href="#Group-Functions">1.6 读取组数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROCINFO-array_002c-and-user-and-group-ID-numbers"><code>PROCINFO</code> array, and user and group ID numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Id-Program">2.2.3 打印用户信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROCINFO-array_002c-testing-the-field-splitting"><code>PROCINFO</code> array, testing the field splitting</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PROCINFO_002c-values-of-sorted_005fin"><code>PROCINFO</code>, values of <code>sorted_in</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Controlling-Scanning">8.1.6 在 <code>gawk</code> 中使用预定义的数组遍历顺序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-profiling-awk-programs">profiling <code>awk</code> programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-profiling-awk-programs_002c-dynamically">profiling <code>awk</code> programs, dynamically</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-program-identifiers">program identifiers</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-program_002c-definition-of">program, definition of</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-conventions_002c-_002d_002dnon_002ddecimal_002ddata-option">programming conventions, <code>--non-decimal-data</code> option</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-conventions_002c-ARGC_002fARGV-variables">programming conventions, <code>ARGC</code>/<code>ARGV</code> variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-conventions_002c-exit-statement">programming conventions, <code>exit</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Exit-Statement">7.4.10 <code>exit</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-conventions_002c-function-parameters">programming conventions, function parameters</a></td><td>&nbsp;</td><td valign="top"><a href="#Return-Statement">9.2.4 <code>return</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-conventions_002c-functions_002c-calling">programming conventions, functions, calling</a></td><td>&nbsp;</td><td valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-conventions_002c-functions_002c-writing">programming conventions, functions, writing</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-conventions_002c-gawk-extensions">programming conventions, <code>gawk</code> extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#Internal-File-Ops">5.6.2 <code>chdir()</code> 与 <code>stat()</code> 的C 代码</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-conventions_002c-private-variable-names">programming conventions, private variable names</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-language_002c-recipe-for">programming language, recipe for</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-languages_002c-Ada">programming languages, Ada</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-languages_002c-data_002ddriven-vs_002e-procedural">programming languages, data-driven vs. procedural</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming-languages_002c-Java">programming languages, Java</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming_002c-basic-steps">programming, basic steps</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming_002c-concepts">programming, concepts</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Concepts">Appendix D 基本编程概念</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-programming_002c-concepts-1">programming, concepts</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Concepts">Appendix D 基本编程概念</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pwcat-program"><code>pwcat</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-Q">Q</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-q-debugger-command-_0028alias-for-quit_0029"><code>q</code> debugger command (alias for <code>quit</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-QSE-awk">QSE <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Quanstrom_002c-Erik">Quanstrom, Erik</a></td><td>&nbsp;</td><td valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-question-mark-_0028_003f_0029_002c-_003f_003a-operator">question mark (<code>?</code>), <code>?:</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-question-mark-_0028_003f_0029_002c-regexp-operator">question mark (<code>?</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-question-mark-_0028_003f_0029_002c-regexp-operator-1">question mark (<code>?</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-QuikTrim-Awk">QuikTrim Awk</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quit-debugger-command"><code>quit</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-QUIT-signal-_0028MS_002dWindows_0029"><code>QUIT</code> signal (MS-Windows)</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting-in-gawk-command-lines">quoting in <code>gawk</code> command lines</a></td><td>&nbsp;</td><td valign="top"><a href="#Long">1.1.3 运行长程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting-in-gawk-command-lines_002c-tricks-for">quoting in <code>gawk</code> command lines, tricks for</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quoting_002c-for-small-awk-programs">quoting, for small awk programs</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-r-debugger-command-_0028alias-for-run_0029"><code>r</code> debugger command (alias for <code>run</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rakitzis_002c-Byron">Rakitzis, Byron</a></td><td>&nbsp;</td><td valign="top"><a href="#History-Sorting">2.3.6 从未排序的文本中去重</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ramey_002c-Chet">Ramey, Chet</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ramey_002c-Chet-1">Ramey, Chet</a></td><td>&nbsp;</td><td valign="top"><a href="#General-Data-Types">5.4.2 通用目的的数据类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rand_0028_0029-function"><code>rand()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-random-numbers_002c-Cliff">random numbers, Cliff</a></td><td>&nbsp;</td><td valign="top"><a href="#Cliff-Random-Function">1.2.4 Cliff 随机数生成器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-random-numbers_002c-rand_0028_0029_002fsrand_0028_0029-functions">random numbers, <code>rand()</code>/<code>srand()</code> functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-random-numbers_002c-seed-of">random numbers, seed of</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-range-expressions-_0028regexps_0029">range expressions (regexps)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bracket-Expressions">3.4 使用方括号表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-range-patterns">range patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-range-patterns_002c-line-continuation-and">range patterns, line continuation and</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges">7.1.3 用模式指定记录范围</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rankin_002c-Pat">Rankin, Pat</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rankin_002c-Pat-1">Rankin, Pat</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rankin_002c-Pat-2">Rankin, Pat</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reada_0028_0029-extension-function"><code>reada()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Read-write-array">5.7.9 输出与恢复数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-readable-data-files_002c-checking">readable data files, checking</a></td><td>&nbsp;</td><td valign="top"><a href="#File-Checking">1.3.3 检查可读的数据文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-readable_002eawk-program"><code>readable.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#File-Checking">1.3.3 检查可读的数据文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-readdir-extension"><code>readdir</code> extension</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Readdir">5.7.6 读取目录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-readfile_0028_0029-extension-function"><code>readfile()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Readfile">5.7.10 读取整个文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-readfile_0028_0029-user_002ddefined-function"><code>readfile()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Readfile-Function">1.2.8 一次读取整个文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reading-input-files">reading input files</a></td><td>&nbsp;</td><td valign="top"><a href="#Reading-Files">4 读取输入文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recipe-for-a-programming-language">recipe for a programming language</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-record-separators">record separators</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-record-separators-1">record separators</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-record-separators_002c-changing">record separators, changing</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-record-separators_002c-regular-expressions-as">record separators, regular expressions as</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-record-separators_002c-with-multiline-records">record separators, with multiline records</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-records">records</a></td><td>&nbsp;</td><td valign="top"><a href="#Reading-Files">4 读取输入文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-records-1">records</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-High-Level">D.1 程序做的是什么</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-records_002c-multiline">records, multiline</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-records_002c-printing">records, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Print">5.1 <code>print</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-records_002c-splitting-input-into">records, splitting input into</a></td><td>&nbsp;</td><td valign="top"><a href="#Records">4.1 输入如何拆分为记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-records_002c-terminating">records, terminating</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-records_002c-treating-files-as">records, treating files as</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursive-functions">recursive functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-redirect-gawk-output_002c-in-debugger">redirect <code>gawk</code> output, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-redirection-of-input">redirection of input</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-redirection-of-output">redirection of output</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-redirection-on-VMS">redirection on VMS</a></td><td>&nbsp;</td><td valign="top"><a href="#VMS-Running">B.3.2.4 在 VMS 上运行 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reference-counting_002c-sorting-arrays">reference counting, sorting arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp">regexp</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp">3 正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp-constants">regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp-constants-1">regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Constants">6.1.1.3 正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp-constants-2">regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp-constants_002c-_002f_003d_2026_002f_002c-_002f_003d-operator-and">regexp constants, <code>/=&hellip;/</code>, <code>/=</code> operator and</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp-constants_002c-as-patterns">regexp constants, as patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp-constants_002c-in-gawk">regexp constants, in <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp-constants_002c-slashes-vs_002e-quotes">regexp constants, slashes vs. quotes</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regexp-constants_002c-vs_002e-string-constants">regexp constants, vs. string constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-register-extension">register extension</a></td><td>&nbsp;</td><td valign="top"><a href="#Registration-Functions">5.4.5 注册函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions">regular expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp">3 正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions-as-field-separators">regular expressions as field separators</a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-anchors-in">regular expressions, anchors in</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-as-field-separators">regular expressions, as field separators</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-as-patterns">regular expressions, as patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-as-patterns-1">regular expressions, as patterns</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Patterns">7.1.1 以正则表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-as-record-separators">regular expressions, as record separators</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-case-sensitivity">regular expressions, case sensitivity</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-case-sensitivity-1">regular expressions, case sensitivity</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-computed">regular expressions, computed</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-constants_002c-See-regexp-constants">regular expressions, constants, See regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-dynamic">regular expressions, dynamic</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-dynamic_002c-with-embedded-newlines">regular expressions, dynamic, with embedded newlines</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-gawk_002c-command_002dline-options">regular expressions, <code>gawk</code>, command-line options</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-interval-expressions-and">regular expressions, interval expressions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-leftmost-longest-match">regular expressions, leftmost longest match</a></td><td>&nbsp;</td><td valign="top"><a href="#Leftmost-Longest">3.5 匹配多少？</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-operators">regular expressions, operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-operators-1">regular expressions, operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-operators_002c-for-buffers">regular expressions, operators, for buffers</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-operators_002c-for-words">regular expressions, operators, for words</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-operators_002c-gawk">regular expressions, operators, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-operators_002c-precedence-of">regular expressions, operators, precedence of</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-regular-expressions_002c-searching-for">regular expressions, searching for</a></td><td>&nbsp;</td><td valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-relational-operators_002c-See-comparison-operators">relational operators, See comparison operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-replace-in-string">replace in string</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-return-debugger-command"><code>return</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-return-statement_002c-user_002ddefined-functions"><code>return</code> statement, user-defined functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Return-Statement">9.2.4 <code>return</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-return-value_002c-close_0028_0029-function">return value, <code>close()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rev_0028_0029-user_002ddefined-function"><code>rev()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Example">9.2.2 函数定义范例</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-revoutput-extension"><code>revoutput</code> extension</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Revout">5.7.7 倒转输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-revtwoway-extension"><code>revtwoway</code> extension</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Rev2way">5.7.8 双路 I/O 例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rewind_0028_0029-user_002ddefined-function"><code>rewind()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Rewind-Function">1.3.2 重新读取当前文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-angle-bracket-_0028_003e_0029_002c-_003e-operator">right angle bracket (<code>&gt;</code>), <code>&gt;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-angle-bracket-_0028_003e_0029_002c-_003e-operator-1">right angle bracket (<code>&gt;</code>), <code>&gt;</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-angle-bracket-_0028_003e_0029_002c-_003e-operator-_0028I_002fO_0029">right angle bracket (<code>&gt;</code>), <code>&gt;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-angle-bracket-_0028_003e_0029_002c-_003e_003d-operator">right angle bracket (<code>&gt;</code>), <code>&gt;=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-angle-bracket-_0028_003e_0029_002c-_003e_003d-operator-1">right angle bracket (<code>&gt;</code>), <code>&gt;=</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-angle-bracket-_0028_003e_0029_002c-_003e_003e-operator-_0028I_002fO_0029">right angle bracket (<code>&gt;</code>), <code>&gt;&gt;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-angle-bracket-_0028_003e_0029_002c-_003e_003e-operator-_0028I_002fO_0029-1">right angle bracket (<code>&gt;</code>), <code>&gt;&gt;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-shift">right shift</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-shift_002c-bitwise">right shift, bitwise</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ritchie_002c-Dennis">Ritchie, Dennis</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RLENGTH-variable"><code>RLENGTH</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RLENGTH-variable_002c-match_0028_0029-function-and"><code>RLENGTH</code> variable, <code>match()</code> function and</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Arnold">Robbins, Arnold</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Arnold-1">Robbins, Arnold</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Arnold-2">Robbins, Arnold</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Arnold-3">Robbins, Arnold</a></td><td>&nbsp;</td><td valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Arnold-4">Robbins, Arnold</a></td><td>&nbsp;</td><td valign="top"><a href="#General-Data-Types">5.4.2 通用目的的数据类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Arnold-5">Robbins, Arnold</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Arnold-6">Robbins, Arnold</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Arnold-7">Robbins, Arnold</a></td><td>&nbsp;</td><td valign="top"><a href="#Future-Extensions">C.3 后续可能的扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Bill">Robbins, Bill</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Harry">Robbins, Harry</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Jean">Robbins, Jean</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Miriam">Robbins, Miriam</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Miriam-1">Robbins, Miriam</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robbins_002c-Miriam-2">Robbins, Miriam</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rommel_002c-Kai-Uwe">Rommel, Kai Uwe</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-round-to-nearest-integer">round to nearest integer</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-round_0028_0029-user_002ddefined-function"><code>round()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rounding-numbers">rounding numbers</a></td><td>&nbsp;</td><td valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ROUNDMODE-variable"><code>ROUNDMODE</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RS-variable"><code>RS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RS-variable-1"><code>RS</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RS-variable_002c-multiline-records-and"><code>RS</code> variable, multiline records and</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rshift_0028_0029-function-_0028gawk_0029"><code>rshift()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RSTART-variable"><code>RSTART</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RSTART-variable_002c-match_0028_0029-function-and"><code>RSTART</code> variable, <code>match()</code> function and</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RT-variable"><code>RT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RT-variable-1"><code>RT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiple-Line">4.8 多行记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RT-variable-2"><code>RT</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rubin_002c-Paul">Rubin, Paul</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Rubin_002c-Paul-1">Rubin, Paul</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-definition-of">rule, definition of</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-run-debugger-command"><code>run</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rvalues_002flvalues">rvalues/lvalues</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-s-debugger-command-_0028alias-for-step_0029"><code>s</code> debugger command (alias for <code>step</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sample-debugging-session">sample debugging session</a></td><td>&nbsp;</td><td valign="top"><a href="#Sample-Debugging-Session">3.2 <code>gawk</code> 调试例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sandbox-mode">sandbox mode</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-save-debugger-options">save debugger options</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-scalar-or-array">scalar or array</a></td><td>&nbsp;</td><td valign="top"><a href="#Type-Functions">9.1.7 获取类型信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-scalar-values">scalar values</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-scanning-arrays">scanning arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Scanning-an-Array">8.1.5 遍历数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-scanning-multidimensional-arrays">scanning multidimensional arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiscanning">8.5.1 遍历多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schorr_002c-Andrew">Schorr, Andrew</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schorr_002c-Andrew-1">Schorr, Andrew</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schorr_002c-Andrew-2">Schorr, Andrew</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schreiber_002c-Bert">Schreiber, Bert</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Schreiber_002c-Rita">Schreiber, Rita</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-and-replace-in-strings">search and replace in strings</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-in-string">search in string</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-paths">search paths</a></td><td>&nbsp;</td><td valign="top"><a href="#Programs-Exercises">2.5 练习</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-paths-1">search paths</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-paths-2">search paths</a></td><td>&nbsp;</td><td valign="top"><a href="#VMS-Running">B.3.2.4 在 VMS 上运行 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-paths_002c-for-loadable-extensions">search paths, for loadable extensions</a></td><td>&nbsp;</td><td valign="top"><a href="#AWKLIBPATH-Variable">2.5.2 环境变量 <code>AWKLIBPATH</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-paths_002c-for-source-files">search paths, for source files</a></td><td>&nbsp;</td><td valign="top"><a href="#AWKPATH-Variable">2.5.1 环境变量 <code>AWKPATH</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-paths_002c-for-source-files-1">search paths, for source files</a></td><td>&nbsp;</td><td valign="top"><a href="#Programs-Exercises">2.5 练习</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-paths_002c-for-source-files-2">search paths, for source files</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search-paths_002c-for-source-files-3">search paths, for source files</a></td><td>&nbsp;</td><td valign="top"><a href="#VMS-Running">B.3.2.4 在 VMS 上运行 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-searching_002c-files-for-regular-expressions">searching, files for regular expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-searching_002c-for-words">searching, for words</a></td><td>&nbsp;</td><td valign="top"><a href="#Dupword-Program">2.3.1 查找文档中的重复字</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sed-utility"><code>sed</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Full-Line-Fields">4.5.5 一行即一域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sed-utility-1"><code>sed</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Simple-Sed">2.3.8 一个简单的流编辑器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sed-utility-2"><code>sed</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-seeding-random-number-generator">seeding random number generator</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-semicolon-_0028_003b_0029_002c-AWKPATH-variable-and">semicolon (<code>;</code>), <code>AWKPATH</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-semicolon-_0028_003b_0029_002c-separating-statements-in-actions">semicolon (<code>;</code>), separating statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-semicolon-_0028_003b_0029_002c-separating-statements-in-actions-1">semicolon (<code>;</code>), separating statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Action-Overview">7.3 动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-semicolon-_0028_003b_0029_002c-separating-statements-in-actions-2">semicolon (<code>;</code>), separating statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-field">separators, field</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-field-1">separators, field</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-field_002c-FIELDWIDTHS-variable-and">separators, field, <code>FIELDWIDTHS</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-field_002c-FPAT-variable-and">separators, field, <code>FPAT</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-field_002c-POSIX-and">separators, field, POSIX and</a></td><td>&nbsp;</td><td valign="top"><a href="#Fields">4.2 检查域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-for-records">separators, for records</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-for-records-1">separators, for records</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-for-records-2">separators, for records</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-for-records_002c-regular-expressions-as">separators, for records, regular expressions as</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-for-statements-in-actions">separators, for statements in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Action-Overview">7.3 动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-separators_002c-subscript">separators, subscript</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-set-breakpoint">set breakpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-set-debugger-command"><code>set</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-set-directory-of-message-catalogs">set directory of message catalogs</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-set-watchpoint">set watchpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shadowing-of-variable-values">shadowing of variable values</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shell-quoting_002c-rules-for">shell quoting, rules for</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shells_002c-piping-commands-into">shells, piping commands into</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shells_002c-quoting">shells, quoting</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Shell-Variables">7.2 在程序中使用 Shell 变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shells_002c-quoting_002c-rules-for">shells, quoting, rules for</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shells_002c-scripts">shells, scripts</a></td><td>&nbsp;</td><td valign="top"><a href="#One_002dshot">1.1.1 一次性 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shells_002c-sea">shells, sea</a></td><td>&nbsp;</td><td valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shells_002c-variables">shells, variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Shell-Variables">7.2 在程序中使用 Shell 变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shift_002c-bitwise">shift, bitwise</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-short_002dcircuit-operators">short-circuit operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show-all-source-files_002c-in-debugger">show all source files, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show-breakpoints">show breakpoints</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show-function-arguments_002c-in-debugger">show function arguments, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show-local-variables_002c-in-debugger">show local variables, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show-name-of-current-source-file_002c-in-debugger">show name of current source file, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-show-watchpoints">show watchpoints</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-si-debugger-command-_0028alias-for-stepi_0029"><code>si</code> debugger command (alias for <code>stepi</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects">side effects</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects-1">side effects</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects-2">side effects</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-array-indexing">side effects, array indexing</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-asort_0028_0029-function">side effects, <code>asort()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-assignment-expressions">side effects, assignment expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-Boolean-operators">side effects, Boolean operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-conditional-expressions">side effects, conditional expressions</a></td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Exp">6.3.4 条件表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-decrement_002fincrement-operators">side effects, decrement/increment operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-FILENAME-variable">side effects, <code>FILENAME</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-function-calls">side effects, function calls</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Calls">6.4 函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-side-effects_002c-statements">side effects, statements</a></td><td>&nbsp;</td><td valign="top"><a href="#Action-Overview">7.3 动作</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-_002f_003d-a_00b8_008eae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fa_00b9_008be_0097_00b4c_009a_0084a_00ba_008ca_00b9_0089ae_0080_00a7">sidebar, &lsquo;<samp>/=</samp>&rsquo; 与正则表达式之间的二义性</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-FS-a_00b8_008e-IGNORECASE">sidebar, <code>FS</code> 与 <code>IGNORECASE</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Splitting-Summary">4.5.6 域分割总结</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-POSIX-ae_00a0_0087aa_0087_0086aa_0089_008d-awk-c_0094_00a8-OFMT-e_00bf_009be_00a1_008caa_00ad_0097c_00ac_00a6a_00b8_00b2e_00bd_00acae_008d_00a2">sidebar, POSIX 标准前 <code>awk</code> 用 <code>OFMT</code> 进行字符串转换</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-RS-_003d-_0022_005c0_0022-ae_0098_00afa_00b8_008daa_008f_00afc_00a7_00bbae_00a4_008dc_009a_0084">sidebar, <code>RS = &quot;\0&quot;</code> 是不可移植的</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-a_00ba_00a4a_00ba_0092aa_00bc_008fa_00b8_008ee_009d_009ea_00ba_00a4a_00ba_0092aa_00bc_008fc_00bc_0093aa_00ad_0098">sidebar, 交互式与非交互式缓存</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-a_00bd_00bfc_0094_00a8-close_0028_0029-c_009a_0084e_00bf_0094aa_009b_009eaa_0080_00bc">sidebar, 使用 <code>close()</code> 的返回值</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-aa_008c_00b9e_0085_008dc_00a9_00baa_00b8_00b2">sidebar, 匹配空串</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-aa_009c_00a8aa_008a_00a8ae_0080_0081ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fa_00b8_00adc_009a_0084ae_0096_00b9ae_008b_00acaa_008f_00b7e_00a1_00a8e_00be_00beaa_00bc_008fa_00b8_00ada_00bd_00bfc_0094_00a8-_005cn">sidebar, 在动态正则表达式中的方括号表达式中使用 <code>\n</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-aa_00b8_00b8e_00a7_0084aa_00ad_0097c_00ac_00a6aa_0089_008dc_009a_0084aa_008f_008dae_0096_009cae_009d_00a0">sidebar, 常规字符前的反斜杠</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-aa_00b8_00b8e_0087_008fc_009a_0084e_00bf_009baa_0088_00b6a_00b8_008da_00bc_009aaa_00bd_00b1aa_0093_008daa_00ae_0083c_009a_0084aa_0080_00bc">sidebar, 常量的进制不会影响它的值</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-ae_0093_008da_00bd_009cc_00ac_00a6ae_00b1_0082aa_0080_00bce_00a1_00baaa_00ba_008f">sidebar, 操作符求值顺序</a></td><td>&nbsp;</td><td valign="top"><a href="#Increment-Ops">6.2.4 递增与递减操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-ae_0094_00b9aa_008f_0098-FS-a_00b8_008da_00bc_009aaa_00bd_00b1aa_0093_008daa_009f_009f">sidebar, 改变 <code>FS</code> 不会影响域</a></td><td>&nbsp;</td><td valign="top"><a href="#Full-Line-Fields">4.5.5 一行即一域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-ae_0094_00b9aa_008f_0098-NR-a_00b8_008e-FNR">sidebar, 改变 <code>NR</code> 与 <code>FNR</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-c_0090_0086e_00a7_00a3-_0023_0021">sidebar, 理解 &lsquo;<samp>#!</samp>&rsquo;</a></td><td>&nbsp;</td><td valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-c_0090_0086e_00a7_00a3-_00240">sidebar, 理解 <code>$0</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Changing-Fields">4.4 更改域内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-c_00ae_00a1e_0081_0093e_00be_0093aa_0087_00baaa_0088_00b0-sh">sidebar, 管道输出到 <code>sh</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-c_00bc_0096c_00a8_008be_00af_00ade_00a8_0080e_008f_009caa_008d_0095">sidebar, 编程语言菜单</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-e_00bd_00aca_00b9_0089aa_0085_0083aa_00ad_0097c_00ac_00a6">sidebar, 转义元字符</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-e_0080_009ae_00bf_0087-system_0028_0029-ae_009d_00a5ae_008e_00a7aa_0088_00b6e_00be_0093aa_0087_00bac_00bc_0093aa_00ad_0098">sidebar, 通过 <code>system()</code> 来控制输出缓存</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sidebar_002c-e_0082_00a3a_00b9_0088a_00b8_00baa_00bb_0080a_00b9_0088-gawk-e_009c_0080e_00a6_0081-BEGINFILE-a_00b8_008e-ENDFILE_003f">sidebar, 那么为什么 <code>gawk</code> 需要 <code>BEGINFILE</code> 与 <code>ENDFILE</code>?</a></td><td>&nbsp;</td><td valign="top"><a href="#Filetrans-Function">1.3.1 注意数据文件的边界</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SIGHUP-signal_002c-for-dynamic-profiling"><code>SIGHUP</code> signal, for dynamic profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SIGINT-signal-_0028MS_002dWindows_0029"><code>SIGINT</code> signal (MS-Windows)</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-signals_002c-HUP_002fSIGHUP_002c-for-profiling">signals, <code>HUP</code>/<code>SIGHUP</code>, for profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-signals_002c-INT_002fSIGINT-_0028MS_002dWindows_0029">signals, <code>INT</code>/<code>SIGINT</code> (MS-Windows)</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-signals_002c-QUIT_002fSIGQUIT-_0028MS_002dWindows_0029">signals, <code>QUIT</code>/<code>SIGQUIT</code> (MS-Windows)</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-signals_002c-USR1_002fSIGUSR1_002c-for-profiling">signals, <code>USR1</code>/<code>SIGUSR1</code>, for profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-signature-program">signature program</a></td><td>&nbsp;</td><td valign="top"><a href="#Signature-Program">2.3.11 来些新鲜的</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SIGQUIT-signal-_0028MS_002dWindows_0029"><code>SIGQUIT</code> signal (MS-Windows)</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SIGUSR1-signal_002c-for-dynamic-profiling"><code>SIGUSR1</code> signal, for dynamic profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-silent-debugger-command"><code>silent</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sin_0028_0029-function"><code>sin()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sine">sine</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-single-quote-_0028_0027_0029">single quote (<code>'</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#One_002dshot">1.1.1 一次性 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-single-quote-_0028_0027_0029-in-gawk-command-lines">single quote (<code>'</code>) in <code>gawk</code> command lines</a></td><td>&nbsp;</td><td valign="top"><a href="#Long">1.1.3 运行长程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-single-quote-_0028_0027_0029_002c-in-shell-commands">single quote (<code>'</code>), in shell commands</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-single-quote-_0028_0027_0029_002c-vs_002e-apostrophe">single quote (<code>'</code>), vs. apostrophe</a></td><td>&nbsp;</td><td valign="top"><a href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-single-quote-_0028_0027_0029_002c-with-double-quotes">single quote (<code>'</code>), with double quotes</a></td><td>&nbsp;</td><td valign="top"><a href="#Quoting">1.1.6 Shell 引号问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-single_002dcharacter-fields">single-character fields</a></td><td>&nbsp;</td><td valign="top"><a href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-single_002dstep-execution_002c-in-the-debugger">single-step execution, in the debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Skywalker_002c-Luke">Skywalker, Luke</a></td><td>&nbsp;</td><td valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sleep-utility"><code>sleep</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sleep_0028_0029-extension-function"><code>sleep()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Time">5.7.11 扩展的时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Solaris_002c-POSIX_002dcompliant-awk">Solaris, POSIX-compliant <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sort-array">sort array</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sort-array-indices">sort array indices</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sort-function_002c-arrays_002c-sorting">sort function, arrays, sorting</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sort-utility"><code>sort</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Word-Sorting">2.3.5 生成字使用统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sort-utility_002c-coprocesses-and"><code>sort</code> utility, coprocesses and</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sorting-characters-in-different-languages">sorting characters in different languages</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-awka">source code, <code>awka</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-Brian-Kernighan_0027s-awk">source code, Brian Kernighan&rsquo;s <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-BusyBox-Awk">source code, BusyBox Awk</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-gawk">source code, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Gawk-Distribution">B.1 <code>gawk</code> 发布版</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-Illumos-awk">source code, Illumos <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-jawk">source code, <code>jawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-libmawk">source code, libmawk</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-mawk">source code, <code>mawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-mixing">source code, mixing</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-pawk">source code, <code>pawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-pawk-_0028Python-version_0029">source code, <code>pawk</code> (Python version)</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-QSE-awk">source code, QSE <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-QuikTrim-Awk">source code, QuikTrim Awk</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-code_002c-Solaris-awk">source code, Solaris <code>awk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source-files_002c-search-path-for">source files, search path for</a></td><td>&nbsp;</td><td valign="top"><a href="#Programs-Exercises">2.5 练习</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sparse-arrays">sparse arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Spencer_002c-Henry">Spencer, Henry</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-split-string-into-array">split string into array</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-split-utility"><code>split</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Split-Program">2.2.4 将大文件分片</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-split_0028_0029-function"><code>split()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-split_0028_0029-function_002c-array-elements_002c-deleting"><code>split()</code> function, array elements, deleting</a></td><td>&nbsp;</td><td valign="top"><a href="#Delete">8.4 <code>delete</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-split_002eawk-program"><code>split.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Split-Program">2.2.4 将大文件分片</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sprintf_0028_0029-function"><code>sprintf()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sprintf_0028_0029-function-1"><code>sprintf()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sprintf_0028_0029-function_002c-OFMT-variable-and"><code>sprintf()</code> function, <code>OFMT</code> variable and</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sprintf_0028_0029-function_002c-print_002fprintf-statements-and"><code>sprintf()</code> function, <code>print</code>/<code>printf</code> statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#Round-Function">1.2.3 数值舍入舍出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sqrt_0028_0029-function"><code>sqrt()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-square-brackets-_0028_005b_005d_0029_002c-regexp-operator">square brackets (<code>[]</code>), regexp operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-square-root">square root</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-srand_0028_0029-function"><code>srand()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Functions">9.1.2 数值函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stack-frame">stack frame</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugging-Terms">3.1.2 调试概念</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stallman_002c-Richard">Stallman, Richard</a></td><td>&nbsp;</td><td valign="top"><a href="#Manual-History">GNU 项目及本网页</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stallman_002c-Richard-1">Stallman, Richard</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stallman_002c-Richard-2">Stallman, Richard</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Stallman_002c-Richard-3">Stallman, Richard</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standard-error">standard error</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standard-input">standard input</a></td><td>&nbsp;</td><td valign="top"><a href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standard-input-1">standard input</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standard-output">standard output</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-starting-the-debugger">starting the debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Invocation">3.2.1 如何开启调试器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stat_0028_0029-extension-function"><code>stat()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-File-Functions">5.7.1 与文件相关的函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-statements_002c-compound_002c-control-statements-and">statements, compound, control statements and</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-statements_002c-control_002c-in-actions">statements, control, in actions</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements">7.4 动作中的控制语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-statements_002c-multiple">statements, multiple</a></td><td>&nbsp;</td><td valign="top"><a href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-step-debugger-command"><code>step</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stepi-debugger-command"><code>stepi</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stop-automatic-display_002c-in-debugger">stop automatic display, in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stream-editors">stream editors</a></td><td>&nbsp;</td><td valign="top"><a href="#Full-Line-Fields">4.5.5 一行即一域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stream-editors-1">stream editors</a></td><td>&nbsp;</td><td valign="top"><a href="#Simple-Sed">2.3.8 一个简单的流编辑器</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strftime_0028_0029-function-_0028gawk_0029"><code>strftime()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string-constants">string constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Scalar-Constants">6.1.1.1 数值与字串常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string-constants_002c-vs_002e-regexp-constants">string constants, vs. regexp constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string-extraction-_0028internationalization_0029">string extraction (internationalization)</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string-length">string length</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string-operators">string operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string_002c-regular-expression-match">string, regular expression match</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string_002dmanipulation-functions">string-manipulation functions</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string_002dmatching-operators">string-matching operators</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string_002dtranslation-functions">string-translation functions</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings-splitting_002c-example">strings splitting, example</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-converting">strings, converting</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-converting-1">strings, converting</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-converting-letter-case">strings, converting letter case</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-converting_002c-numbers-to">strings, converting, numbers to</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-converting_002c-numbers-to-1">strings, converting, numbers to</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-empty_002c-See-null-strings">strings, empty, See null strings</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-extracting">strings, extracting</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-for-localization">strings, for localization</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-length-limitations">strings, length limitations</a></td><td>&nbsp;</td><td valign="top"><a href="#Scalar-Constants">6.1.1.1 数值与字串常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-merging-arrays-into">strings, merging arrays into</a></td><td>&nbsp;</td><td valign="top"><a href="#Join-Function">1.2.6 将数组合并成字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-null">strings, null</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings_002c-numeric">strings, numeric</a></td><td>&nbsp;</td><td valign="top"><a href="#Variable-Typing">6.3.2.1 字串类型与数值类型</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strtonum_0028_0029-function-_0028gawk_0029"><code>strtonum()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strtonum_0028_0029-function-_0028gawk_0029_002c-_002d_002dnon_002ddecimal_002ddata-option-and"><code>strtonum()</code> function (<code>gawk</code>), <code>--non-decimal-data</code> option and</a></td><td>&nbsp;</td><td valign="top"><a href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sub_0028_0029-function"><code>sub()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sub_0028_0029-function-1"><code>sub()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sub_0028_0029-function_002c-arguments-of"><code>sub()</code> function, arguments of</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sub_0028_0029-function_002c-escape-processing"><code>sub()</code> function, escape processing</a></td><td>&nbsp;</td><td valign="top"><a href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subscript-separators">subscript separators</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subscripts-in-arrays_002c-multidimensional">subscripts in arrays, multidimensional</a></td><td>&nbsp;</td><td valign="top"><a href="#Multidimensional">8.5 多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subscripts-in-arrays_002c-multidimensional_002c-scanning">subscripts in arrays, multidimensional, scanning</a></td><td>&nbsp;</td><td valign="top"><a href="#Multiscanning">8.5.1 遍历多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subscripts-in-arrays_002c-numbers-as">subscripts in arrays, numbers as</a></td><td>&nbsp;</td><td valign="top"><a href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subscripts-in-arrays_002c-uninitialized-variables-as">subscripts in arrays, uninitialized variables as</a></td><td>&nbsp;</td><td valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SUBSEP-variable"><code>SUBSEP</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SUBSEP-variable_002c-and-multidimensional-arrays"><code>SUBSEP</code> variable, and multidimensional arrays</a></td><td>&nbsp;</td><td valign="top"><a href="#Multidimensional">8.5 多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-substitute-in-string">substitute in string</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-substr_0028_0029-function"><code>substr()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-substring">substring</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Sumner_002c-Andrew">Sumner, Andrew</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-supplementary-groups-of-gawk-process">supplementary groups of <code>gawk</code> process</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-switch-statement"><code>switch</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#Switch-Statement">7.4.5 <code>switch</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SYMTAB-array"><code>SYMTAB</code> array</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-syntactic-ambiguity_003a-_002f_003d-operator-vs_002e-_002f_003d_2026_002f-regexp-constant">syntactic ambiguity: <code>/=</code> operator vs. <code>/=&hellip;/</code> regexp constant</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-system_0028_0029-function"><code>system()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-systime_0028_0029-function-_0028gawk_0029"><code>systime()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-t-debugger-command-_0028alias-for-tbreak_0029"><code>t</code> debugger command (alias for <code>tbreak</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tbreak-debugger-command"><code>tbreak</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Tcl">Tcl</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TCP_002fIP">TCP/IP</a></td><td>&nbsp;</td><td valign="top"><a href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TCP_002fIP_002c-support-for">TCP/IP, support for</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-Network">5.8.2 用于网络的特殊文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tee-utility"><code>tee</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Tee-Program">2.2.5 将输出复制到多个文件中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tee_002eawk-program"><code>tee.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Tee-Program">2.2.5 将输出复制到多个文件中</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-temporary-breakpoint">temporary breakpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Breakpoint-Control">3.3.1 控制断点</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-terminating-records">terminating records</a></td><td>&nbsp;</td><td valign="top"><a href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-testbits_002eawk-program"><code>testbits.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-testext-extension"><code>testext</code> extension</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-API-Tests">5.7.12 <code>API</code> 测试</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo">Texinfo</a></td><td>&nbsp;</td><td valign="top"><a href="#Conventions">排版约定</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo-1">Texinfo</a></td><td>&nbsp;</td><td valign="top"><a href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo-2">Texinfo</a></td><td>&nbsp;</td><td valign="top"><a href="#Dupword-Program">2.3.1 查找文档中的重复字</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo-3">Texinfo</a></td><td>&nbsp;</td><td valign="top"><a href="#Extract-Program">2.3.7 从 Texinfo 源文件中提取程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo-4">Texinfo</a></td><td>&nbsp;</td><td valign="top"><a href="#Distribution-contents">B.1.3 <code>gawk</code> 发布版的内容</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo-5">Texinfo</a></td><td>&nbsp;</td><td valign="top"><a href="#Adding-Code">C.2.2 添加新特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo_002c-chapter-beginnings-in-files">Texinfo, chapter beginnings in files</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Texinfo_002c-extracting-programs-from-source-files">Texinfo, extracting programs from source files</a></td><td>&nbsp;</td><td valign="top"><a href="#Extract-Program">2.3.7 从 Texinfo 源文件中提取程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-text_002c-printing">text, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Print">5.1 <code>print</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-text_002c-printing_002c-unduplicated-lines-of">text, printing, unduplicated lines of</a></td><td>&nbsp;</td><td valign="top"><a href="#Uniq-Program">2.2.6 打印去重文本行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TEXTDOMAIN-variable"><code>TEXTDOMAIN</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TEXTDOMAIN-variable-1"><code>TEXTDOMAIN</code> variable</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TEXTDOMAIN-variable_002c-BEGIN-pattern-and"><code>TEXTDOMAIN</code> variable, <code>BEGIN</code> pattern and</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TEXTDOMAIN-variable_002c-portability-and"><code>TEXTDOMAIN</code> variable, portability and</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-textdomain_0028_0029-function-_0028C-library_0029"><code>textdomain()</code> function (C library)</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029_002c-_007e-operator">tilde (<code>~</code>), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029_002c-_007e-operator-1">tilde (<code>~</code>), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029_002c-_007e-operator-2">tilde (<code>~</code>), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Case_002dsensitivity">3.8 匹配时的大小写</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029_002c-_007e-operator-3">tilde (<code>~</code>), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Constants">6.1.1.3 正则表达式常量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029_002c-_007e-operator-4">tilde (<code>~</code>), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029_002c-_007e-operator-5">tilde (<code>~</code>), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029_002c-_007e-operator-6">tilde (<code>~</code>), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tilde-_0028_007e_0029_002c-_007e-operator-7">tilde (<code>~</code>), <code>~</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Expression-Patterns">7.1.2 以表达式为模式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-time-functions">time functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-time_002c-alarm-clock-example-program">time, alarm clock example program</a></td><td>&nbsp;</td><td valign="top"><a href="#Alarm-Program">2.3.2 报警时钟程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-time_002c-localization-and">time, localization and</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-time_002c-managing">time, managing</a></td><td>&nbsp;</td><td valign="top"><a href="#Getlocaltime-Function">1.2.7 管理时间</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-time_002c-retrieving">time, retrieving</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-timeout_002c-reading-input">timeout, reading input</a></td><td>&nbsp;</td><td valign="top"><a href="#Read-Timeout">4.10 带超时的输入读取</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-timestamps">timestamps</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-timestamps-1">timestamps</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-timestamps_002c-converting-dates-to">timestamps, converting dates to</a></td><td>&nbsp;</td><td valign="top"><a href="#Time-Functions">9.1.5 时间函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-timestamps_002c-formatted">timestamps, formatted</a></td><td>&nbsp;</td><td valign="top"><a href="#Getlocaltime-Function">1.2.7 管理时间</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tolower_0028_0029-function"><code>tolower()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-toupper_0028_0029-function"><code>toupper()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tr-utility"><code>tr</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Translate-Program">2.3.3 转换字符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trace-debugger-command"><code>trace</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-traceback_002c-display-in-debugger">traceback, display in debugger</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate-string">translate string</a></td><td>&nbsp;</td><td valign="top"><a href="#I18N-Functions">9.1.8 字串翻译函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate_002eawk-program"><code>translate.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Translate-Program">2.3.3 转换字符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-treating-files_002c-as-single-records">treating files, as single records</a></td><td>&nbsp;</td><td valign="top"><a href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-_002d_002dnon_002ddecimal_002ddata-option">troubleshooting, <code>--non-decimal-data</code> option</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-_003d_003d-operator">troubleshooting, <code>==</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Comparison-Operators">6.3.2.2 比较操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-awk-uses-FS-not-IFS">troubleshooting, <code>awk</code> uses <code>FS</code> not <code>IFS</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Field-Separators">4.5 指定记录如何进行分隔</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-backslash-before-nonspecial-character">troubleshooting, backslash before nonspecial character</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-division">troubleshooting, division</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-fatal-errors_002c-field-widths_002c-specifying">troubleshooting, fatal errors, field widths, specifying</a></td><td>&nbsp;</td><td valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-fatal-errors_002c-printf-format-strings">troubleshooting, fatal errors, <code>printf</code> format strings</a></td><td>&nbsp;</td><td valign="top"><a href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-fflush_0028_0029-function">troubleshooting, <code>fflush()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-function-call-syntax">troubleshooting, function call syntax</a></td><td>&nbsp;</td><td valign="top"><a href="#Function-Calls">6.4 函数调用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-gawk">troubleshooting, <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Compatibility-Mode">C.1 后向兼容与调试</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-gawk_002c-bug-reports">troubleshooting, <code>gawk</code>, bug reports</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-gawk_002c-fatal-errors_002c-function-arguments">troubleshooting, <code>gawk</code>, fatal errors, function arguments</a></td><td>&nbsp;</td><td valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-getline-function">troubleshooting, <code>getline</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#File-Checking">1.3.3 检查可读的数据文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-gsub_0028_0029_002fsub_0028_0029-functions">troubleshooting, <code>gsub()</code>/<code>sub()</code> functions</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-match_0028_0029-function">troubleshooting, <code>match()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-print-statement_002c-omitting-commas">troubleshooting, <code>print</code> statement, omitting commas</a></td><td>&nbsp;</td><td valign="top"><a href="#Print-Examples">5.2 <code>print</code> 语句例子</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-printing">troubleshooting, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-quotes-with-file-names">troubleshooting, quotes with file names</a></td><td>&nbsp;</td><td valign="top"><a href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-readable-data-files">troubleshooting, readable data files</a></td><td>&nbsp;</td><td valign="top"><a href="#File-Checking">1.3.3 检查可读的数据文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-regexp-constants-vs_002e-string-constants">troubleshooting, regexp constants vs. string constants</a></td><td>&nbsp;</td><td valign="top"><a href="#Computed-Regexps">3.6 使用动态正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-string-concatenation">troubleshooting, string concatenation</a></td><td>&nbsp;</td><td valign="top"><a href="#Concatenation">6.2.2 字串连接</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-substr_0028_0029-function">troubleshooting, <code>substr()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Functions">9.1.3 字串操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-system_0028_0029-function">troubleshooting, <code>system()</code> function</a></td><td>&nbsp;</td><td valign="top"><a href="#I_002fO-Functions">9.1.4 输入输出函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-troubleshooting_002c-typographical-errors_002c-global-variables">troubleshooting, typographical errors, global variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-true_002c-logical">true, logical</a></td><td>&nbsp;</td><td valign="top"><a href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trueman_002c-David">Trueman, David</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trueman_002c-David-1">Trueman, David</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Trueman_002c-David-2">Trueman, David</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trunc_002dmod-operation">trunc-mod operation</a></td><td>&nbsp;</td><td valign="top"><a href="#Arithmetic-Ops">6.2.1 算术操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-truth-values">truth values</a></td><td>&nbsp;</td><td valign="top"><a href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-type-conversion">type conversion</a></td><td>&nbsp;</td><td valign="top"><a href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-U">U</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-u-debugger-command-_0028alias-for-until_0029"><code>u</code> debugger command (alias for <code>until</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unassigned-array-elements">unassigned array elements</a></td><td>&nbsp;</td><td valign="top"><a href="#Reference-to-Elements">8.1.2 指向数组元素</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-undefined-functions">undefined functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-underscore-_0028_005f_0029_002c-C-macro">underscore (<code>_</code>), C macro</a></td><td>&nbsp;</td><td valign="top"><a href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-underscore-_0028_005f_0029_002c-in-names-of-private-variables">underscore (<code>_</code>), in names of private variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-underscore-_0028_005f_0029_002c-translatable-string">underscore (<code>_</code>), translatable string</a></td><td>&nbsp;</td><td valign="top"><a href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-undisplay-debugger-command"><code>undisplay</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-undocumented-features">undocumented features</a></td><td>&nbsp;</td><td valign="top"><a href="#Undocumented">2.10 未记载的选项与特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Unicode">Unicode</a></td><td>&nbsp;</td><td valign="top"><a href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Unicode-1">Unicode</a></td><td>&nbsp;</td><td valign="top"><a href="#Ranges-and-Locales">A.8 正则表达式范围与本地语言设置：又臭又长陈年旧事</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Unicode-2">Unicode</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-uninitialized-variables_002c-as-array-subscripts">uninitialized variables, as array subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-uniq-utility"><code>uniq</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Uniq-Program">2.2.6 打印去重文本行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-uniq_002eawk-program"><code>uniq.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Uniq-Program">2.2.6 打印去重文本行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Unix">Unix</a></td><td>&nbsp;</td><td valign="top"><a href="#Glossary">名词解释</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Unix-awk_002c-backslashes-in-escape-sequences">Unix <code>awk</code>, backslashes in escape sequences</a></td><td>&nbsp;</td><td valign="top"><a href="#Escape-Sequences">3.2 转义序列</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Unix-awk_002c-close_0028_0029-function-and">Unix <code>awk</code>, <code>close()</code> function and</a></td><td>&nbsp;</td><td valign="top"><a href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Unix-awk_002c-password-files_002c-field-separators-and">Unix <code>awk</code>, password files, field separators and</a></td><td>&nbsp;</td><td valign="top"><a href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Unix_002c-awk-scripts-and">Unix, <code>awk</code> scripts and</a></td><td>&nbsp;</td><td valign="top"><a href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-UNIXROOT-variable_002c-on-OS_002f2-systems"><code>UNIXROOT</code> variable, on OS/2 systems</a></td><td>&nbsp;</td><td valign="top"><a href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unsigned-integers">unsigned integers</a></td><td>&nbsp;</td><td valign="top"><a href="#Computer-Arithmetic">4.1 计算机算术计算说明</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-until-debugger-command"><code>until</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugger-Execution-Control">3.3.2 控制执行</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unwatch-debugger-command"><code>unwatch</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-up-debugger-command"><code>up</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-user-database_002c-reading">user database, reading</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-user_002ddefined-functions">user-defined functions</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002ddefined">9.2 用户自定义函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-user_002ddefined_002c-functions_002c-counts_002c-in-a-profile">user-defined, functions, counts, in a profile</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-user_002ddefined_002c-variables">user-defined, variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Variables">6.1.3 变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-user_002dmodifiable-variables">user-modifiable variables</a></td><td>&nbsp;</td><td valign="top"><a href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-users_002c-information-about_002c-printing">users, information about, printing</a></td><td>&nbsp;</td><td valign="top"><a href="#Id-Program">2.2.3 打印用户信息</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-users_002c-information-about_002c-retrieving">users, information about, retrieving</a></td><td>&nbsp;</td><td valign="top"><a href="#Passwd-Functions">1.5 读取用户数据库</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-USR1-signal_002c-for-dynamic-profiling"><code>USR1</code> signal, for dynamic profiling</a></td><td>&nbsp;</td><td valign="top"><a href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-values_002c-numeric">values, numeric</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-values_002c-string">values, string</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable-assignments-and-input-files">variable assignments and input files</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Arguments">2.3 其他命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable-typing">variable typing</a></td><td>&nbsp;</td><td valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables">variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Other-Features">1.7 <code>awk</code> 的其他特性</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables-1">variables</a></td><td>&nbsp;</td><td valign="top"><a href="#Basic-Data-Typing">D.2 计算机中数据的值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-assigning-on-command-line">variables, assigning on command line</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Options">6.1.3.2 在命令行中进行变量赋值</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-built_002din">variables, built-in</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Variables">6.1.3.1 在程序中使用变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-flag">variables, flag</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-getline-command-into_002c-using">variables, <code>getline</code> command into, using</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fVariable">4.9.2 将 <code>getline</code> 赋值给变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-getline-command-into_002c-using-1">variables, <code>getline</code> command into, using</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fVariable_002fFile">4.9.4 从文件中 <code>getline</code> 到变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-getline-command-into_002c-using-2">variables, <code>getline</code> command into, using</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fVariable_002fPipe">4.9.6 从管道中 <code>getline</code> 到变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-getline-command-into_002c-using-3">variables, <code>getline</code> command into, using</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fVariable_002fCoprocess">4.9.8 使用并程 <code>getline</code> 到变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-global_002c-for-library-functions">variables, global, for library functions</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-global_002c-printing-list-of">variables, global, printing list of</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-initializing">variables, initializing</a></td><td>&nbsp;</td><td valign="top"><a href="#Using-Variables">6.1.3.1 在程序中使用变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-local-to-a-function">variables, local to a function</a></td><td>&nbsp;</td><td valign="top"><a href="#Variable-Scope">9.2.3.2 控制变量作用域</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-predefined">variables, predefined</a></td><td>&nbsp;</td><td valign="top"><a href="#Built_002din-Variables">7.5 预定义变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-predefined-_002dv-option_002c-setting-with">variables, predefined <code>-v</code> option, setting with</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-predefined-conveying-information">variables, predefined conveying information</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-private">variables, private</a></td><td>&nbsp;</td><td valign="top"><a href="#Library-Names">1.1 命名函数库的全局变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-setting">variables, setting</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-shadowing">variables, shadowing</a></td><td>&nbsp;</td><td valign="top"><a href="#Definition-Syntax">9.2.1 函数定义语法</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-types-of">variables, types of</a></td><td>&nbsp;</td><td valign="top"><a href="#Assignment-Ops">6.2.3 赋值表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-types-of_002c-comparison-expressions-and">variables, types of, comparison expressions and</a></td><td>&nbsp;</td><td valign="top"><a href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-uninitialized_002c-as-array-subscripts">variables, uninitialized, as array subscripts</a></td><td>&nbsp;</td><td valign="top"><a href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variables_002c-user_002ddefined">variables, user-defined</a></td><td>&nbsp;</td><td valign="top"><a href="#Variables">6.1.3 变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-version-of-gawk">version of <code>gawk</code></a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-version-of-gawk-extension-API">version of <code>gawk</code> extension API</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-version-of-GNU-MP-library">version of GNU MP library</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-version-of-GNU-MPFR-library">version of GNU MPFR library</a></td><td>&nbsp;</td><td valign="top"><a href="#Auto_002dset">7.5.2 传递信息的内置变量</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertical-bar-_0028_007c_0029">vertical bar (<code>|</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Operators">3.3 正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertical-bar-_0028_007c_0029_002c-_007c-operator-_0028I_002fO_0029">vertical bar (<code>|</code>), <code>|</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertical-bar-_0028_007c_0029_002c-_007c-operator-_0028I_002fO_0029-1">vertical bar (<code>|</code>), <code>|</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertical-bar-_0028_007c_0029_002c-_007c_0026-operator-_0028I_002fO_0029">vertical bar (<code>|</code>), <code>|&amp;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertical-bar-_0028_007c_0029_002c-_007c_0026-operator-_0028I_002fO_0029-1">vertical bar (<code>|</code>), <code>|&amp;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertical-bar-_0028_007c_0029_002c-_007c_0026-operator-_0028I_002fO_0029-2">vertical bar (<code>|</code>), <code>|&amp;</code> operator (I/O)</a></td><td>&nbsp;</td><td valign="top"><a href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertical-bar-_0028_007c_0029_002c-_007c_007c-operator">vertical bar (<code>|</code>), <code>||</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Boolean-Ops">6.3.3 布林表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertical-bar-_0028_007c_0029_002c-_007c_007c-operator-1">vertical bar (<code>|</code>), <code>||</code> operator</a></td><td>&nbsp;</td><td valign="top"><a href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Vinschen_002c-Corinna">Vinschen, Corinna</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-W">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-w-debugger-command-_0028alias-for-watch_0029"><code>w</code> debugger command (alias for <code>watch</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-w-utility"><code>w</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Constant-Size">4.6 读取固定宽度数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wait_0028_0029-extension-function"><code>wait()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Fork">5.7.3 针对 <code>fork()</code>，<code>wait()</code>，与 <code>waitpid()</code> 的接口</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-waitpid_0028_0029-extension-function"><code>waitpid()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Fork">5.7.3 针对 <code>fork()</code>，<code>wait()</code>，与 <code>waitpid()</code> 的接口</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-walk_005farray_0028_0029-user_002ddefined-function"><code>walk_array()</code> user-defined function</a></td><td>&nbsp;</td><td valign="top"><a href="#Walking-Arrays">1.7 遍历多维数组</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Wall_002c-Larry">Wall, Larry</a></td><td>&nbsp;</td><td valign="top"><a href="#Array-Intro">8.1.1 数组介绍</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Wall_002c-Larry-1">Wall, Larry</a></td><td>&nbsp;</td><td valign="top"><a href="#Future-Extensions">C.3 后续可能的扩展</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Wallin_002c-Anders">Wallin, Anders</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-warnings_002c-issuing">warnings, issuing</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-watch-debugger-command"><code>watch</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-watchpoint">watchpoint</a></td><td>&nbsp;</td><td valign="top"><a href="#Debugging-Terms">3.1.2 调试概念</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wc-utility"><code>wc</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#Wc-Program">2.2.7 统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wc_002eawk-program"><code>wc.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Wc-Program">2.2.7 统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Weinberger_002c-Peter">Weinberger, Peter</a></td><td>&nbsp;</td><td valign="top"><a href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Weinberger_002c-Peter-1">Weinberger, Peter</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-where-debugger-command"><code>where</code> debugger command</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-where-debugger-command-_0028alias-for-backtrace_0029"><code>where</code> debugger command (alias for <code>backtrace</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Execution-Stack">3.3.4 程序栈</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-while-statement"><code>while</code> statement</a></td><td>&nbsp;</td><td valign="top"><a href="#While-Statement">7.4.2 <code>while</code> 语句</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-while-statement_002c-use-of-regexps-in"><code>while</code> statement, use of regexps in</a></td><td>&nbsp;</td><td valign="top"><a href="#Regexp-Usage">3.1 如何使用正则表达式</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-whitespace_002c-as-field-separators">whitespace, as field separators</a></td><td>&nbsp;</td><td valign="top"><a href="#Default-Field-Splitting">4.5.1 标准的域分隔符空白符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-whitespace_002c-functions_002c-calling">whitespace, functions, calling</a></td><td>&nbsp;</td><td valign="top"><a href="#Calling-Built_002din">9.1.1 调用内置函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-whitespace_002c-newlines-as">whitespace, newlines as</a></td><td>&nbsp;</td><td valign="top"><a href="#Options">2.2 命令行参数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Williams_002c-Kent">Williams, Kent</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Woehlke_002c-Matthew">Woehlke, Matthew</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Woods_002c-John">Woods, John</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-word-boundaries_002c-matching">word boundaries, matching</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-word_002c-regexp-definition-of">word, regexp definition of</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-word_002dboundary-operator-_0028gawk_0029">word-boundary operator (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wordfreq_002eawk-program"><code>wordfreq.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Word-Sorting">2.3.5 生成字使用统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-counting">words, counting</a></td><td>&nbsp;</td><td valign="top"><a href="#Wc-Program">2.2.7 统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-duplicate_002c-searching-for">words, duplicate, searching for</a></td><td>&nbsp;</td><td valign="top"><a href="#Dupword-Program">2.3.1 查找文档中的重复字</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-words_002c-usage-counts_002c-generating">words, usage counts, generating</a></td><td>&nbsp;</td><td valign="top"><a href="#Word-Sorting">2.3.5 生成字使用统计</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-writea_0028_0029-extension-function"><code>writea()</code> extension function</a></td><td>&nbsp;</td><td valign="top"><a href="#Extension-Sample-Read-write-array">5.7.9 输出与恢复数组</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-X">X</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-xgettext-utility"><code>xgettext</code> utility</a></td><td>&nbsp;</td><td valign="top"><a href="#String-Extraction">2.4.1 提取已标志字串</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-XOR-bitwise-operation">XOR bitwise operation</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-xor_0028_0029-function-_0028gawk_0029"><code>xor()</code> function (<code>gawk</code>)</a></td><td>&nbsp;</td><td valign="top"><a href="#Bitwise-Functions">9.1.6 位操作函数</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-Y">Y</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Yawitz_002c-Efraim">Yawitz, Efraim</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-1_cp_letter-Z">Z</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zaretskii_002c-Eli">Zaretskii, Eli</a></td><td>&nbsp;</td><td valign="top"><a href="#Acknowledgments">致谢</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zaretskii_002c-Eli-1">Zaretskii, Eli</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zaretskii_002c-Eli-2">Zaretskii, Eli</a></td><td>&nbsp;</td><td valign="top"><a href="#Bugs">B.4 报告问题与 BUG</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-zerofile_002eawk-program"><code>zerofile.awk</code> program</a></td><td>&nbsp;</td><td valign="top"><a href="#Empty-Files">1.3.4 检查长度为零的文件</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Zoulas_002c-Christos">Zoulas, Christos</a></td><td>&nbsp;</td><td valign="top"><a href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index-1_cp_symbol-1"><b>!</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-2"><b>&quot;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-3"><b>#</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-4"><b>$</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-5"><b>%</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-6"><b>&amp;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-7"><b>'</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-8"><b>(</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-9"><b>*</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-10"><b>+</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-11"><b>,</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-12"><b>-</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-13"><b>.</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-14"><b>/</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-15"><b>;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-16"><b>&lt;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-17"><b>=</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-18"><b>&gt;</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-19"><b>?</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-20"><b>@</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-21"><b>[</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-22"><b>\</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-23"><b>^</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-24"><b>_</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-25"><b>{</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-26"><b>|</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_symbol-27"><b>~</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Index-1_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-X"><b>X</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-Y"><b>Y</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-1_cp_letter-Z"><b>Z</b></a>
 &nbsp; 
</td></tr></table>

<hr size="6">
<a name="SEC_Foot"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1>Footnotes</h1>

<h3><a name="FOOT1" href="#DOCF1">(1)</a></h3>
<p>The 2008 POSIX standard is accessible online at
<a href="http://www.opengroup.org/onlinepubs/9699919799/">http://www.opengroup.org/onlinepubs/9699919799/</a>.
</p><h3><a name="FOOT2" href="#DOCF2">(2)</a></h3>
<p>这些工具在 Posix 兼容的系统上都有，在传统的基于 Unix 的系统上也存在。如果你使用的是一些其他的系统，你也需要熟悉一些 IO 重定向及管道的概念。
</p><h3><a name="FOOT3" href="#DOCF3">(3)</a></h3>
<p>一些已经不用的系统，在这些系统上 <code>gawk</code> 有过移植，但是已经不再支持，并且为支持这些系统而存在的代码也已经移除
</p><h3><a name="FOOT4" href="#DOCF4">(4)</a></h3>
<p>SNOBOL语言，一种面向字符串符号（StriNg Oriented symBOlic Language）语言。——译者
</p><h3><a name="FOOT5" href="#DOCF5">(5)</a></h3>
<p>只有在 Solaris 的系统中依然使用旧 <code>awk</code> 作为默认的 <code>awk</code> 工具。更为现代的 <code>awk</code> 则位于这些系统中的 &lsquo;<tt>/usr/xpg6/bin</tt>&rsquo; 目录下。
</p><h3><a name="FOOT6" href="#DOCF6">(6)</a></h3>
<p>所有这些差异都归集在“awk 与 gawk 之间的差异”下。
</p><h3><a name="FOOT7" href="#DOCF7">(7)</a></h3>
<p>一种文档处理软件，用一种格式即可以完成网页输出以及打印输出。这种工具主要用于编写软件手册。——译者
</p><h3><a name="FOOT8" href="#DOCF8">(8)</a></h3>
<p>GNU 表示“GNU&rsquo;s Not Unix”。
</p><h3><a name="FOOT9" href="#DOCF9">(9)</a></h3>
<p>术语&ldquo;GNU/Linux&rdquo;在<a href="#Glossary">名词解释</a>进行说明。
</p><h3><a name="FOOT10" href="#DOCF10">(10)</a></h3>
<p>如在 Linux 系统中用户目录下的 .profile 等文件中。——译者注
</p><h3><a name="FOOT11" href="#DOCF11">(11)</a></h3>
<p>&lsquo;<samp>#!</samp>&rsquo; 这样的机制可以在GNU/Linux，基于 BSD 的系统以及 Unix 系统上使用。
</p><h3><a name="FOOT12" href="#DOCF12">(12)</a></h3>
<p>硬链接(hard link， 也称链接)就是一个文件的一个或多个文件名。多数文件系统可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。一个文件有几个文件名，就说该文件的链接数为几。这个与软链接不同，软连接是指向文件名的文件。删除所有硬连接才能删除文件。删除被软连接的指向的文件（如果只有一个硬连接）就可以删除文件本身。——译者注
</p><h3><a name="FOOT13" href="#DOCF13">(13)</a></h3>
<p>这里的 &lsquo;<samp>?</samp>&rsquo; 与 &lsquo;<samp>:</samp>&rsquo; 是一个三元操作符表达式，<a href="#Conditional-Exp">条件表达式</a> 中进行了描述。
在 &lsquo;<samp>?</samp>&rsquo; 与 &lsquo;<samp>:</samp>&rsquo; 之后进行断行是一个小扩展，如果指定了&lsquo;<samp>--posix</samp>&rsquo; 参数(see section <a href="#Options">命令行参数</a>)，则这个特性就会被禁用。
</p><h3><a name="FOOT14" href="#DOCF14">(14)</a></h3>
<p>其他的流行的工具包括 Ruby 与 Perl。
</p><h3><a name="FOOT15" href="#DOCF15">(15)</a></h3>
<p>要获取更多的细节，请参考 <a href="http://www.ietf.org/rfc/rfc3875">RFC 3875</a> 的 Section 4.4。
也可以查看 <a href="http://lists.gnu.org/archive/html/bug-gawk/2014-11/msg00022.html">发送到 <code>gawk</code> 的 bug mailing 列表中的解释</a>。
</p><h3><a name="FOOT16" href="#DOCF16">(16)</a></h3>
<p>不建议这么做。
</p><h3><a name="FOOT17" href="#DOCF17">(17)</a></h3>
<p>在 MS-Windows 与 MS-DOS 中则使用分号“;”。
</p><h3><a name="FOOT18" href="#DOCF18">(18)</a></h3>
<p>你的 <code>gawk</code> 版本可能使用不同的目录；这依赖于 <code>gawk</code> 是如何被构建与安装的。
实际的路径是 <code>$(datadir)</code> 在 <code>gawk</code> 配置时所产生的值。尽管如此，一般来说你也不需要担心。
</p><h3><a name="FOOT19" href="#DOCF19">(19)</a></h3>
<p>正则引擎主要可以分为两大类：一种是 DFA（确定的有穷自动机，Deterministic finite automaton），一种是 NFA（非确定的有穷自动机，Non-deterministic finite automaton)。这两种引擎都有了很久的历史，当中也由这两种引擎产生了很多变体！于是 POSIX 的出台规避了不必要变体的继续产生。这样一来，主流的正则引擎又分为 3 类：一、DFA，二、传统型NFA，三、POSIX NFA。DFA 引擎在线性式状态下执行，因为它们不要求回溯（并因此它们永远不测试相同的字符两次）。DFA 引擎还可以确保匹配最长的可能的字符串。但是，因为 DFA 引擎只包含有限的状态，所以它不能匹配具有反向引用的模式；并且因为它不构造显式扩展，所以它不可以捕获子表达式。——译者注
</p><h3><a name="FOOT20" href="#DOCF20">(20)</a></h3>
<p>在其他说法中，你可能会看到方括号表达式指的是要么是一个<em>字符集</em>，或者<em>字符类型</em>，或者是一个<em>字符列表</em>。
</p><h3><a name="FOOT21" href="#DOCF21">(21)</a></h3>
<p>如果你在正则表达式操作符或者函数中使用字串常量，你需要使用两个反斜杠。
</p><h3><a name="FOOT22" href="#DOCF22">(22)</a></h3>
<p>有经验的 C 与 C++ 程序员会注意到，通过使用这样 
&lsquo;<samp>IGNORECASE = 1 &amp;&amp; /foObAr/ { &hellip; }</samp>&rsquo; 和 
&lsquo;<samp>IGNORECASE = 0 || /foobar/ { &hellip; }</samp>&rsquo; 的方式，这种情况是可能的。
但是这多少有点含糊，因此我们不建议这么干。
</p><h3><a name="FOOT23" href="#DOCF23">(23)</a></h3>
<p>如果你不了解这些，不用担心，这仅仅意味着 gawk 可以做正确的事情。
</p><h3><a name="FOOT24" href="#DOCF24">(24)</a></h3>
<p>至少我们所知道的那些。
</p><h3><a name="FOOT25" href="#DOCF25">(25)</a></h3>
<p>在 POSIX awk，换行符不被认为是用来进行域分隔的空白符。
</p><h3><a name="FOOT26" href="#DOCF26">(26)</a></h3>
<p><em>二元操作符</em>，如果 &lsquo;<samp>*</samp>&rsquo; 用于乘法，会使用两个操作数。之所以要做这样的区分，
是因为 <code>awk</code> 也有一元操作符（只有一个操作数）以及三元操作符（三个操作数）。
</p><h3><a name="FOOT27" href="#DOCF27">(27)</a></h3>
<p>感谢 Andrew Schorr 所做的提示。
</p><h3><a name="FOOT28" href="#DOCF28">(28)</a></h3>
<p><code>sed</code> 工具称为“流编辑器”。它的行为也由 POSIX 标准来定义。
</p><h3><a name="FOOT29" href="#DOCF29">(29)</a></h3>
<p>CSV 格式缺乏正式的标准定义多年，
<a href="http://www.ietf.org/rfc/rfc4180.txt">RFC 4180</a> 标准化了多数的通用实践。
</p><h3><a name="FOOT30" href="#DOCF30">(30)</a></h3>
<p>当 <code>FS</code> 为空串（<code>&quot;&quot;</code>）或者正则表达式，
这个特殊的特性没有应用在 <code>RS</code> 中。
但是却可以应用在当域分隔符为默认空格时：&lsquo;<samp>FS = &quot;&nbsp;&quot;</samp>&rsquo; 情况中。
</p><h3><a name="FOOT31" href="#DOCF31">(31)</a></h3>
<p>这个不太是这么回事。<code>RT</code> 在 <code>RS</code> 是一个正则表达式时可能会改变。
</p><h3><a name="FOOT32" href="#DOCF32">(32)</a></h3>
<p>这里假设标准输入就是键盘。
</p><h3><a name="FOOT33" href="#DOCF33">(33)</a></h3>
<p>在 &lsquo;<tt>/dev/tty</tt>&rsquo; 中的“tty”代表的是“Teletype”（电传打字机），是一种串行终端
</p><h3><a name="FOOT34" href="#DOCF34">(34)</a></h3>
<p>技术术语应该是病态进程（morbid），已经完成的子进程称为“僵尸进程（zombie）”，通过“回收（reaping）”后，进程就会被清理。
</p><h3><a name="FOOT35" href="#DOCF35">(35)</a></h3>
<p>这是一个全 16 位的由 <code>wait()</code> 系统调用返回的值。查看系统手册来获取如何解码这个值的相关信息。
</p><h3><a name="FOOT36" href="#DOCF36">(36)</a></h3>
<p>所有的数值，包括整数，在内部都表示成双精度的浮点数。
在多数的现代系统中，使用的都是 IEEE754 的标准格式。查看 <a href="#Arbitrary-Precision-Arithmetic">算术运算与 <code>gawk</code> 中的任意精度算术运算</a>，来取得更多的信息。
</p><h3><a name="FOOT37" href="#DOCF37">(37)</a></h3>
<p>在病理学情况下需要多达 752 位数（！），但是我们认为你不需要为此担心（你平时用不到这么长的有效位）。
</p><h3><a name="FOOT38" href="#DOCF38">(38)</a></h3>
<p>这在 BWK <code>awk</code> 中会发生，<code>gawk</code> 以及 <code>mawk</code> 都“执行正确”，但是别依赖于这个结果。
</p><h3><a name="FOOT39" href="#DOCF39">(39)</a></h3>
<p>从技术上说，字串比较应该的行为应该一致，就好像字串的的比较使用的是 C <code>strcoll()</code> 函数一样。
</p><h3><a name="FOOT40" href="#DOCF40">(40)</a></h3>
<p>这个程序有一个 BUG，它会打印以 &lsquo;<samp>END</samp>&rsquo; 开头的行。看看你怎么来修复它？
</p><h3><a name="FOOT41" href="#DOCF41">(41)</a></h3>
<p>在 POSIX <code>awk</code> 中，换行符不被当成空白。
</p><h3><a name="FOOT42" href="#DOCF42">(42)</a></h3>
<p>有一些 Unix <code>awk</code> 的早期实现将 <code>FILENAME</code> 的值设置成 <code>&quot;-&quot;</code>，
就算还没有文件被处理。这个行为是不正确的，在你的程序中不能依赖于它。
</p><h3><a name="FOOT43" href="#DOCF43">(43)</a></h3>
<p>更不用提在实现上的困难。
</p><h3><a name="FOOT44" href="#DOCF44">(44)</a></h3>
<p>顺序在不同的 <code>awk</code> 实现中是不同的，典型的情况下是吏用哈希表来存储数组元素与它的值。
</p><h3><a name="FOOT45" href="#DOCF45">(45)</a></h3>
<p>当两个元素比较相同时，C 的 <code>qsort()</code> 函数不保证它们比较之后保持比较之前的相对顺序（不稳定排序）。
通过字串比较，可以保证在数值比较为相同时，可提供唯一的顺序，因此 <code>gawk</code> 可以在不同的环境中行为一致。
</p><h3><a name="FOOT46" href="#DOCF46">(46)</a></h3>
<p>感谢 Michael Brennan 提出这点。
</p><h3><a name="FOOT47" href="#DOCF47">(47)</a></h3>
<p>大家都知道，在很多 Unix 系统上的 C 版本的 <code>rand()</code>，产生的随机数序列非常不好。
但是 <code>awk</code> 版本的实现一点都没有使用 C 版本的 <code>rand()</code>。
事实上，<code>gawk</code> 使用 BSD 的 <code>random()</code> 函数，这个函数产生的随机数要比 <code>rand()</code> 好很多。
</p><h3><a name="FOOT48" href="#DOCF48">(48)</a></h3>
<p><code>mawk</code> 每次都使用不同的种子。
</p><h3><a name="FOOT49" href="#DOCF49">(49)</a></h3>
<p>计算机产生的随机数不是真正的随机数。在技术上，它们都是<em>伪随机</em>的。
这就是说，尽管数值序列看起来是随机的，但是事实上会一次次地产生相同的随机序列。
</p><h3><a name="FOOT50" href="#DOCF50">(50)</a></h3>
<p>除非你使用了 &lsquo;<samp>--non-decimal-data</samp>&rsquo; 选项，但我们不建议这么使用。查看 <a href="#Nondecimal-Data">允许非十进制数数据输入</a>，取得更多的信息。
</p><h3><a name="FOOT51" href="#DOCF51">(51)</a></h3>
<p>注意这意味着那条记录首先会使用 <code>OFS</code> 来重新生成，因为有域已经被改变了，并且在替换之后，域会更新，就算操作是一个“no-op”，例如 &lsquo;<samp>sub(/^/, &quot;&quot;)</samp>&rsquo;。
</p><h3><a name="FOOT52" href="#DOCF52">(52)</a></h3>
<p>这里不同 C 和 C++，在 C 和 C++ 中第一个字符是数字 0。
</p><h3><a name="FOOT53" href="#DOCF53">(53)</a></h3>
<p>那个人真是幼稚，尽管这个小节中有一个提示说下个主要的版本会跟 POSIX 保持一致。
</p><h3><a name="FOOT54" href="#DOCF54">(54)</a></h3>
<p>如果标准输出连接到一个终端设备，则程序是交互式的。在现代系统中，这表示设备是你的键盘或者屏幕。
</p><h3><a name="FOOT55" href="#DOCF55">(55)</a></h3>
<p>在私人通信中，Dr. Kernighan 曾经向我表明，已有的这个处理方式可能是一个错误。
</p><h3><a name="FOOT56" href="#DOCF56">(56)</a></h3>
<p><a href="#Glossary">名词解释</a>，特别是 “Epoch” 与 “UTC” 项。
</p><h3><a name="FOOT57" href="#DOCF57">(57)</a></h3>
<p>GNU 的 <code>date</code> 工具也可以做这里所描述的很多的事情。如果在 Shell 中处理的是简单的与时间有关的操作，则可优先使用它。
</p><h3><a name="FOOT58" href="#DOCF58">(58)</a></h3>
<p>在偶尔的情况下，一年中有几分钟会有润秒，因此秒数可以到 60。
</p><h3><a name="FOOT59" href="#DOCF59">(59)</a></h3>
<p>不幸的是，不是所有的系统的 <code>strftime()</code> 都必须支持这里所列的所有转换。
</p><h3><a name="FOOT60" href="#DOCF60">(60)</a></h3>
<p>如果你不理解这个，也不用担心，这个设施主要用于方便实现 “国际化” 程序。其他的国际化特性在 <a href="#Internationalization"><code>gawk</code> 的国际化</a>，这里描述。
</p><h3><a name="FOOT61" href="#DOCF61">(61)</a></h3>
<p>这是因为 ISO C 将 C 版本的 <code>strftime()</code> 保留其行为为未定义的，<code>gawk</code> 就使用其所在系统的 <code>strftime()</code> 的版本。典型的情况下，转换指定符要么不会出现在返回的字串里，要么就以这面的方式出现。
</p><h3><a name="FOOT62" href="#DOCF62">(62)</a></h3>
<p>这个例子显示在左边会用 0 进行填补。对于 <code>gawk</code>，这总是正确的，但是在其他语言中，有可能会用 1 进行填补。
</p><h3><a name="FOOT63" href="#DOCF63">(63)</a></h3>
<p>这个程序实际上不会运行，因为 <code>foo()</code> 是未定义的。
</p><h3><a name="FOOT64" href="#DOCF64">(64)</a></h3>
<p>2012 年的晚些时候。
</p><h3><a name="FOOT65" href="#DOCF65">(65)</a></h3>
<p>这个在未来的版本可能会改变：要检查与你的 <code>gawk</code> 一起的文档来查看是否已经改变。
</p><h3><a name="FOOT66" href="#DOCF66">(66)</a></h3>
<p>很惨的是，35 年之后，这本书中所教的经验还没有被大量的实践中的程序员所学到。
</p><h3><a name="FOOT67" href="#DOCF67">(67)</a></h3>
<p>效果是不完全相同。变化记录的输出所有的都是小写。而 <code>IGNORECASE</code> 保持了输入记录的最初值。
</p><h3><a name="FOOT68" href="#DOCF68">(68)</a></h3>
<p>尽管所有的库例程都使用这样的惯例进行了重写，但是还没有完成。为了显示我们自己的 <code>awk</code> 程序风格的演化，也为了这些讨论提供一些基础素材。
</p><h3><a name="FOOT69" href="#DOCF69">(69)</a></h3>
<p><code>gawk</code> 的 &lsquo;<samp>--dump-variables</samp>&rsquo; 命令行选项用来验证这个非常有用。
</p><h3><a name="FOOT70" href="#DOCF70">(70)</a></h3>
<p>这个正在改变：很多的系统使用 Unicode。这是一种很大的字符集，ASCII 是它的一个子集。在完全支持 Unicode 的系统中，一个字符可以占到 32 位。使得这里所使用的简单测试有可能也非常消耗性能。
</p><h3><a name="FOOT71" href="#DOCF71">(71)</a></h3>
<p>ASCII 被扩展到很多的国家，并使用到 128 到 255 之间的值表示特定国家的字符。如果你的系统使用这些扩展，你可简化 <code>_ord_init()</code> 来迭代从0 到 255 的数值。
</p><h3><a name="FOOT72" href="#DOCF72">(72)</a></h3>
<p>如果 <code>awk</code> 有一个赋值操作符来进行连接就很好了。缺少一个显式的连接操作符使得字串操作比实际需要的要难一些。
</p><h3><a name="FOOT73" href="#DOCF73">(73)</a></h3>
<p><code>BEGINFILE</code> 特定模式（查看 see section <a href="#BEGINFILE_002fENDFILE"><code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a>）提供了另一种机制来处理那些不可以打开的文件。但是，这里的代码提供了一种可移植的方案。
</p><h3><a name="FOOT74" href="#DOCF74">(74)</a></h3>
<p>这个版本在 <code>gawk</code> 要求用 <code>&quot;&quot;</code> 将字串分隔为字符的能力之前写成的。我们已经不管它了，因为用 <code>substr()</code> 可移植性更好。
</p><h3><a name="FOOT75" href="#DOCF75">(75)</a></h3>
<p>用户的密码信息很多情况下都存储在网络数据库中。
</p><h3><a name="FOOT76" href="#DOCF76">(76)</a></h3>
<p>刚才展示的代码有一个很细微的问题。假设第一次时是没有名字的，则这个代码会将名字前面带逗号加入。同时也没有检测是否有第 4 个域，<code>$4</code>。
</p><h3><a name="FOOT77" href="#DOCF77">(77)</a></h3>
<p>这里同时也引入了一个隐蔽的 Bug，如果发生了匹配，我们输出被转换了的行，而不是原来的行。
</p><h3><a name="FOOT78" href="#DOCF78">(78)</a></h3>
<p>这是传统的用法。POSIX 的用法是不同的，但是对于要程序要说明的东西是无关的。
</p><h3><a name="FOOT79" href="#DOCF79">(79)</a></h3>
<p>由于 <code>gawk</code> 可以处理多字节的本地语言设置，所以这个代码统计的是字符，而不是字节。
</p><h3><a name="FOOT80" href="#DOCF80">(80)</a></h3>
<p>在一些旧的系统上，包括 Solaris，<code>tr</code> 的系统版本可能需要列表要写在范围表达式，并包含在方括号中（&lsquo;<samp>[a-z]</samp>&rsquo;），引起来，为的是避免 Shell 会尝试对文件名扩展。但这不是个特性。
</p><h3><a name="FOOT81" href="#DOCF81">(81)</a></h3>
<p>“真实世界”定义为“就是实际上用来处理某些事情的程序”。
</p><h3><a name="FOOT82" href="#DOCF82">(82)</a></h3>
<p>完整的 <code>sh</code> 语言的解释超出了这本书的范围。我们提供了一些最小的说明，但是如果你想更深入地理解，请阅读一个好的 Shell 编程书。
</p><h3><a name="FOOT83" href="#DOCF83">(83)</a></h3>
<p>在一些非常老的 <code>awk</code> 版本中，如果文件存在但为空，&lsquo;<samp>getline junk &lt; t</samp>&rsquo; 这样的测试能够永远循环。
</p><h3><a name="FOOT84" href="#DOCF84">(84)</a></h3>
<p><code>gawk</code> 自己来处理 <code>@include</code>，为的是支持将 <code>awk</code> 程序用作 WEB CGI 脚本。
</p><h3><a name="FOOT85" href="#DOCF85">(85)</a></h3>
<p>这个是由输入 <code>define: state machine</code> 到 Google 返回的定义。
</p><h3><a name="FOOT86" href="#DOCF86">(86)</a></h3>
<p>这就是为什么预定义的排序顺序都以 &lsquo;<samp>@</samp>&rsquo; 字符开头，它不可以是标识符的一部份。
</p><h3><a name="FOOT87" href="#DOCF87">(87)</a></h3>
<p>因为基于本地语言设置的比较只会出现在 POSIX 的兼容模式中，因此这确实是真的，并且由于 <code>asort()</code> 与 <code>asorti()</code> 是 <code>gawk</code> 的扩展，在上面的设置中，它们是不可用的。
</p><h3><a name="FOOT88" href="#DOCF88">(88)</a></h3>
<p>Michael Brenna 建议使用 <code>rand()</code> 来产生唯一的文件名。这是个有效的观点，但是，临时文件比起双路管道来讲还是困难些。
</p><h3><a name="FOOT89" href="#DOCF89">(89)</a></h3>
<p>这与 Bash 与 C Shell 中的操作符非常不同。
</p><h3><a name="FOOT90" href="#DOCF90">(90)</a></h3>
<p>对于某些操作系统，<code>gawk</code> 的移植不支持 GNU <code>gettext</code>。因此，如果你在这个系统上使用，这个特性就不可用。非常抱歉！
</p><h3><a name="FOOT91" href="#DOCF91">(91)</a></h3>
<p>美国使用每个三个进制数之间放一个逗号，以及用圆点来作为十进制小数点，而很多的欧洲国家则相反：1,234.56 与 1.234，56。
</p><h3><a name="FOOT92" href="#DOCF92">(92)</a></h3>
<p>感谢 Bruno Haible 提供这个例子。
</p><h3><a name="FOOT93" href="#DOCF93">(93)</a></h3>
<p>与 GNU <code>gettext</code> 一起发布的 <code>xgettext</code> 工具可以处理 &lsquo;<tt>.awk</tt>&rsquo; 文件。
</p><h3><a name="FOOT94" href="#DOCF94">(94)</a></h3>
<p>这个例子是从 GNU <code>gettext</code> 手册上借来的。
</p><h3><a name="FOOT95" href="#DOCF95">(95)</a></h3>
<p>这是一个很好的用来存放“令人困惑的 <code>awk</code>”内容的目录。
</p><h3><a name="FOOT96" href="#DOCF96">(96)</a></h3>
<p>也许，我们称之为 “Hippy”可能会更好。
</p><h3><a name="FOOT97" href="#DOCF97">(97)</a></h3>
<p>我们不知道他们为什么希望有这个能力，从是确实是有这种期望。
</p><h3><a name="FOOT98" href="#DOCF98">(98)</a></h3>
<p>感谢 Michael Brennan 提供了这个描述（我们改写了原描述）和这些例子。
</p><h3><a name="FOOT99" href="#DOCF99">(99)</a></h3>
<p>有一个非常好的 <a href="http://www.validlab.com/goldberg/paper.pdf">关于浮点数算术运算的论文</a>，由 David Goldberg 所写，“What Every Computer Scientist Should Know About Floating-Point Arithmetic”，
<cite>ACM Computing Surveys</cite> <strong>23</strong>, 1 (1991-03): 5-48. 如果你对于细节非常感兴趣，这个值得一读，但是确实需要一定的计算机科学背景。
</p><h3><a name="FOOT100" href="#DOCF100">(100)</a></h3>
<p>如果在你的系统上的 C 库不支持使用 IEEE 754 的偶数舍入舍出规则来为 <code>printf</code> 舍入舍出半数的情况，有可能输出完全不同。
</p><h3><a name="FOOT101" href="#DOCF101">(101)</a></h3>
<p>Weisstein, Eric W.
<cite>Sylvester&rsquo;s Sequence</cite>，来自于 MathWorld——一个Wolfram WEB 资源 (<a href="http://mathworld.wolfram.com/SylvestersSequence.html">http://mathworld.wolfram.com/SylvestersSequence.html</a>)。
</p><h3><a name="FOOT102" href="#DOCF102">(102)</a></h3>
<p>自作自受。
</p><h3><a name="FOOT103" href="#DOCF103">(103)</a></h3>
<p>查看 <a href="http://catb.org/jargon/html/C/cookie.html">the &ldquo;cookie&rdquo; entry in the Jargon file</a> 来查看 <em>cookie</em> 的定义，以及 <a href="http://catb.org/jargon/html/M/magic-cookie.html">the &ldquo;magic cookie&rdquo; entry in the Jargon file</a> 来查看其中的例子。
See also the entry for &ldquo;Cookie&rdquo; in the <a href="#Glossary">名词解释</a>.
也可看 <a href="#Glossary">名词解释</a> 中的“Cookie”词条。
</p><h3><a name="FOOT104" href="#DOCF104">(104)</a></h3>
<p>这在 MS-Windows 系统中更常见，不过也可能发生在 Unix 类似的系统中。
</p><h3><a name="FOOT105" href="#DOCF105">(105)</a></h3>
<p>由于 API 只使用 ISO C 90 的特性，因此不能使用 ISO C 99 的可能参数宏特性来隐藏参数。多少有点遗憾。
</p><h3><a name="FOOT106" href="#DOCF106">(106)</a></h3>
<p>相信我们，差异是可测量并且真实的。
</p><h3><a name="FOOT107" href="#DOCF107">(107)</a></h3>
<p>数值值问题就少得多，因为只需要存储一个 C 的 <code>double</code> 类型。
</p><h3><a name="FOOT108" href="#DOCF108">(108)</a></h3>
<p>好吧，也是唯一的数据结构。
</p><h3><a name="FOOT109" href="#DOCF109">(109)</a></h3>
<p>它也是一个“cookie”，但是 <code>gawk</code> 开发得不想过多地使用这个术语。
</p><h3><a name="FOOT110" href="#DOCF110">(110)</a></h3>
<p>为了表现，这个版本有一些小改动。到 <code>gawk</code> 发布版 &lsquo;<tt>extension/filefuncs.c</tt>&rsquo; 中查看完整的版本。
</p><h3><a name="FOOT111" href="#DOCF111">(111)</a></h3>
<p>在实践中，你可能想使用 GNU Autotools（Automake，Autoconf，Libtool，以及 <code>gettext</code>）来配置及构建你的库。如何来做超出了本网页的范围。查看 <a href="#gawkextlib"><code>gawkextlib</code> 项目</a>，来获取这些工具的地址。
</p><h3><a name="FOOT112" href="#DOCF112">(112)</a></h3>
<p>那么生活就美妙了。
</p><h3><a name="FOOT113" href="#DOCF113">(113)</a></h3>
<p>也因此产生了“合理范围解释报怨”（或者 RRI）。很多的 GNU 工具已经实现了这样的变化，或者不久将实现。非常感谢 Karl Berry 发明了“合理范围解释”这个词。
</p><h3><a name="FOOT114" href="#DOCF114">(114)</a></h3>
<p>查看 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05">标准</a>和<a href="http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap09.html#tag_21_09_03_05">它的解释</a>
</p><h3><a name="FOOT115" href="#DOCF115">(115)</a></h3>
<p>2014 年的 11 月，这个站点都还在，但是作者没有找到 GNU Make 包。
</p><h3><a name="FOOT116" href="#DOCF116">(116)</a></h3>
<p>可以从 <a href="ftp://ftp.delorie.com/pub/djgpp/current/v2gnu/">ftp://ftp.delorie.com/pub/djgpp/current/v2gnu/</a> 获得。
</p><h3><a name="FOOT117" href="#DOCF117">(117)</a></h3>
<p>IA64 平台也称为 “Itanium”。
</p><h3><a name="FOOT118" href="#DOCF118">(118)</a></h3>
<p>我们试过，但是非常痛苦。
</p><h3><a name="FOOT119" href="#DOCF119">(119)</a></h3>
<p>有一个 GNU 程序，（以我们的观点看）很难从 Git 库中生成。比如，在作者的旧的（但是还工作）的 PowerPC Macintosh ，安装的是 Mac OS X 10.5，很有必要从 Git 库本身生成和很多软件，使其能够与最新的代码一起工作。这一点也不让人感觉愉快，特别是在一些老旧的系统中，这简直就是浪费时间。
</p>
<p>使用最新的 tarball 也不需要担心。维护都已经不用 &lsquo;<tt>.gz</tt>&rsquo; 与 &lsquo;<tt>.bz2</tt>&rsquo; 文件了，而只发布 &lsquo;<tt>.tar.xz</tt>&rsquo; 文件。有必要先安装 <code>xz</code>。
</p><h3><a name="FOOT120" href="#DOCF120">(120)</a></h3>
<p>一个由其他开发者生成的分支（已经删除），并没有包含所生成的文件。
</p><h3><a name="FOOT121" href="#DOCF121">(121)</a></h3>
<p><code>gawk</code> 中的关键的核心数组结构。
</p><h3><a name="FOOT122" href="#DOCF122">(122)</a></h3>
<p><em>符号</em>是定义在 <code>gawk</code> 中的变量与函数。在 <code>gawk</code> 外部的运行时动态装载代码中对这些符号的访问在 MS-Windows 平台上是有问题的。
</p><h3><a name="FOOT123" href="#DOCF123">(123)</a></h3>
<p>编译型程序一般使用低阶语言来写，如 C ，C++ 或者 Ada，然后被翻译或者说是<em>编译</em>为计算机可直接执行的形式。
</p><hr>
<a name="SEC_Contents"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1>Table of Contents</h1>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-c_00ac_00aca_00b8_0089c_0089_0088aa_0089_008de_00a8_0080" href="#Foreword3">第三版前言</a></li>
  <li><a name="toc-c_00ac_00acaa_009b_009bc_0089_0088aa_0089_008de_00a8_0080" href="#Foreword4">第四版前言</a></li>
  <li><a name="toc-aa_0089_008de_00a8_0080" href="#Preface">前言</a></li>
  <li><a name="toc-e_00af_0091aa_00ba_008f" href="#Translator-Preface">译序</a>
  <ul class="no-bullet">
    <li><a name="toc-awk-a_00b8_008e-gawk-c_009a_0084aa_008e_0086aa_008f_00b2" href="#History"><code>awk</code> 与 <code>gawk</code> 的历史</a></li>
    <li><a name="toc-c_008e_00abc_0091_00b0aa_0088_00abaa_0090_008d" href="#Names">玫瑰别名</a></li>
    <li><a name="toc-a_00bd_00bfc_0094_00a8ae_009c_00aca_00b9_00a6" href="#This-Manual">使用本书</a></li>
    <li><a name="toc-ae_008e_0092c_0089_0088c_00ba_00a6aa_00ae_009a" href="#Conventions">排版约定</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_009a_0097e_00a7_0092" href="#ae_009a_0097e_00a7_0092">暗角</a></li>
    </ul></li>
    <li><a name="toc-GNU-e_00a1_00b9c_009b_00aeaa_008f_008aae_009c_00acc_00bd_0091e_00a1_00b5" href="#Manual-History">GNU 项目及本网页</a></li>
    <li><a name="toc-aa_00a6_0082a_00bd_0095e_00b4_00a1c_008c_00ae" href="#How-To-Contribute">如何贡献</a></li>
    <li><a name="toc-e_0087_00b4e_00b0_00a2" href="#Acknowledgments">致谢</a></li>
  </ul></li>
  <li><a name="toc-c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">第一部分:<br> <code>awk</code> 语言</a></li>
  <li><a name="toc-aa_00bc_0080aa_00a7_008b-awk" href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a>
  <ul class="no-bullet">
    <li><a name="toc-aa_00a6_0082a_00bd_0095ae_0089_00a7e_00a1_008c-awk-c_00a8_008baa_00ba_008f" href="#Running-gawk">1.1 如何执行 <code>awk</code> 程序</a>
    <ul class="no-bullet">
      <li><a name="toc-a_00b8_0080ae_00ac_00a1ae_0080_00a7-awk-c_00a8_008baa_00ba_008f" href="#One_002dshot">1.1.1 一次性 <code>awk</code> 程序</a></li>
      <li><a name="toc-a_00b8_008daa_00b8_00a6e_00be_0093aa_0085_00a5ae_0096_0087a_00bb_00b6e_00bf_0090e_00a1_008c-awk" href="#Read-Terminal">1.1.2 不带输入文件运行 <code>awk</code></a></li>
      <li><a name="toc-e_00bf_0090e_00a1_008ce_0095_00bfc_00a8_008baa_00ba_008f" href="#Long">1.1.3 运行长程序</a></li>
      <li><a name="toc-aa_008f_00afae_0089_00a7e_00a1_008cc_009a_0084-awk-c_00a8_008baa_00ba_008f" href="#Executable-Scripts">1.1.4 可执行的 <code>awk</code> 程序</a></li>
      <li><a name="toc-awk-c_00a8_008baa_00ba_008fa_00b8_00adc_009a_0084ae_00b3_00a8e_0087_008a" href="#Comments">1.1.5 <code>awk</code> 程序中的注释</a></li>
      <li><a name="toc-Shell-aa_00bc_0095aa_008f_00b7e_0097_00aee_00a2_0098" href="#Quoting">1.1.6 Shell 引号问题</a>
      <ul class="no-bullet">
        <li><a name="toc-MS_002dWindows-ae_0089_00b9aa_00a4_0084c_0090_0086ae_0096_0087a_00bb_00b6a_00b8_00adc_009a_0084aa_00bc_0095aa_008f_00b7e_0097_00aee_00a2_0098" href="#DOS-Quoting">1.1.6.1 MS-Windows 批处理文件中的引号问题</a></li>
      </ul>
</li>
    </ul></li>
    <li><a name="toc-a_00be_008baa_00ad_0090a_00b8_00ada_00bd_00bfc_0094_00a8c_009a_0084ae_0095_00b0ae_008d_00aeae_0096_0087a_00bb_00b6" href="#Sample-Data-Files">1.2 例子中使用的数据文件</a></li>
    <li><a name="toc-a_00b8_0080a_00ba_009bc_00ae_0080aa_008d_0095a_00be_008baa_00ad_0090" href="#Very-Simple">1.3 一些简单例子</a></li>
    <li><a name="toc-a_00b8_00a4e_00a7_0084aa_0088_0099c_009a_0084a_00be_008baa_00ad_0090" href="#Two-Rules">1.4 两规则的例子</a></li>
    <li><a name="toc-aa_00a4_008dae_009d_0082a_00b8_0080c_0082_00b9c_009a_0084a_00be_008baa_00ad_0090" href="#More-Complex">1.5 复杂一点的例子</a></li>
    <li><a name="toc-awk-e_00af_00adaa_008f_00a5a_00b8_008ee_00a1_008c" href="#Statements_002fLines">1.6 <code>awk</code> 语句与行</a></li>
    <li><a name="toc-awk-c_009a_0084aa_0085_00b6a_00bb_0096c_0089_00b9ae_0080_00a7" href="#Other-Features">1.7 <code>awk</code> 的其他特性</a></li>
    <li><a name="toc-a_00bd_0095ae_0097_00b6a_00bd_00bfc_0094_00a8-awk" href="#When">1.8 何时使用 <code>awk</code></a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-12" href="#Intro-Summary">1.9 总结</a></li>
  </ul></li>
  <li><a name="toc-e_00bf_0090e_00a1_008c-awk-a_00b8_008e-gawk" href="#Invoking-Gawk">2 运行 <code>awk</code> 与 <code>gawk</code></a>
  <ul class="no-bullet">
    <li><a name="toc-e_00b0_0083c_0094_00a8-awk" href="#Command-Line">2.1 调用 <code>awk</code></a></li>
    <li><a name="toc-aa_0091_00bda_00bb_00a4e_00a1_008caa_008f_0082ae_0095_00b0" href="#Options">2.2 命令行参数</a></li>
    <li><a name="toc-aa_0085_00b6a_00bb_0096aa_0091_00bda_00bb_00a4e_00a1_008caa_008f_0082ae_0095_00b0" href="#Other-Arguments">2.3 其他命令行参数</a></li>
    <li><a name="toc-aa_0091_00bdaa_0090_008dae_00a0_0087aa_0087_0086e_00be_0093aa_0085_00a5" href="#Naming-Standard-Input">2.4 命名标准输入</a></li>
    <li><a name="toc-gawk-a_00bd_00bfc_0094_00a8c_009a_0084c_008e_00afaa_00a2_0083aa_008f_0098e_0087_008f" href="#Environment-Variables">2.5 <code>gawk</code> 使用的环境变量</a>
    <ul class="no-bullet">
      <li><a name="toc-c_008e_00afaa_00a2_0083aa_008f_0098e_0087_008f-AWKPATH" href="#AWKPATH-Variable">2.5.1 环境变量 <code>AWKPATH</code></a></li>
      <li><a name="toc-c_008e_00afaa_00a2_0083aa_008f_0098e_0087_008f-AWKLIBPATH" href="#AWKLIBPATH-Variable">2.5.2 环境变量 <code>AWKLIBPATH</code></a></li>
      <li><a name="toc-aa_0085_00b6a_00bb_0096c_009a_0084c_008e_00afaa_00a2_0083aa_008f_0098e_0087_008f" href="#Other-Environment-Variables">2.5.3 其他的环境变量</a></li>
    </ul></li>
    <li><a name="toc-gawk-c_009a_0084e_0080_0080aa_0087_00bac_008a_00b6ae_0080_0081" href="#Exit-Status">2.6 <code>gawk</code> 的退出状态</a></li>
    <li><a name="toc-aa_009c_00a8a_00bd_00a0c_009a_0084c_00a8_008baa_00ba_008fa_00b8_00adaa_008c_0085aa_0090_00abaa_0085_00b6a_00bb_0096c_009a_0084ae_0096_0087a_00bb_00b6" href="#Include-Files">2.7 在你的程序中包含其他的文件</a></li>
    <li><a name="toc-aa_009c_00a8a_00bd_00a0c_009a_0084c_00a8_008baa_00ba_008fe_00a3_0085aa_0085_00a5aa_008a_00a8ae_0080_0081ae_0089_00a9aa_00b1_0095" href="#Loading-Shared-Libraries">2.8 在你的程序装入动态扩展</a></li>
    <li><a name="toc-aa_00b7_00b2c_00bb_008faa_008f_0096ae_00b6_0088c_009a_0084e_0080_0089e_00a1_00b9a_00bb_00a5aa_008f_008ac_0089_00b9ae_0080_00a7" href="#Obsolete">2.9 已经取消的选项以及特性</a></li>
    <li><a name="toc-ae_009c_00aae_00ae_00b0e_00bd_00bdc_009a_0084e_0080_0089e_00a1_00b9a_00b8_008ec_0089_00b9ae_0080_00a7" href="#Undocumented">2.10 未记载的选项与特性</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-7" href="#Invoking-Summary">2.11 总结</a></li>
  </ul></li>
  <li><a name="toc-ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Regexp">3 正则表达式</a>
  <ul class="no-bullet">
    <li><a name="toc-aa_00a6_0082a_00bd_0095a_00bd_00bfc_0094_00a8ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Regexp-Usage">3.1 如何使用正则表达式</a></li>
    <li><a name="toc-e_00bd_00aca_00b9_0089aa_00ba_008faa_0088_0097" href="#Escape-Sequences">3.2 转义序列</a></li>
    <li><a name="toc-ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fae_0093_008da_00bd_009cc_00ac_00a6" href="#Regexp-Operators">3.3 正则表达式操作符</a></li>
    <li><a name="toc-a_00bd_00bfc_0094_00a8ae_0096_00b9ae_008b_00acaa_008f_00b7e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Bracket-Expressions">3.4 使用方括号表达式</a></li>
    <li><a name="toc-aa_008c_00b9e_0085_008daa_00a4_009aaa_00b0_0091i_00bc_009f" href="#Leftmost-Longest">3.5 匹配多少？</a></li>
    <li><a name="toc-a_00bd_00bfc_0094_00a8aa_008a_00a8ae_0080_0081ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Computed-Regexps">3.6 使用动态正则表达式</a></li>
    <li><a name="toc-c_0089_00b9aa_00ae_009aa_00ba_008e-gawk-c_009a_0084ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fae_0093_008da_00bd_009cc_00ac_00a6" href="#GNU-Regexp-Operators">3.7 特定于 <code>gawk</code> 的正则表达式操作符</a></li>
    <li><a name="toc-aa_008c_00b9e_0085_008dae_0097_00b6c_009a_0084aa_00a4_00a7aa_00b0_008faa_0086_0099" href="#Case_002dsensitivity">3.8 匹配时的大小写</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-10" href="#Regexp-Summary">3.9 总结</a></li>
  </ul></li>
  <li><a name="toc-e_00af_00bbaa_008f_0096e_00be_0093aa_0085_00a5ae_0096_0087a_00bb_00b6" href="#Reading-Files">4 读取输入文件</a>
  <ul class="no-bullet">
    <li><a name="toc-e_00be_0093aa_0085_00a5aa_00a6_0082a_00bd_0095ae_008b_0086aa_0088_0086a_00b8_00bae_00ae_00b0aa_00bd_0095" href="#Records">4.1 输入如何拆分为记录</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_00a0_0087aa_0087_0086-awk-c_009a_0084e_00ae_00b0aa_00bd_0095ae_008b_0086aa_0088_0086" href="#awk-split-records">4.1.1 标准 <code>awk</code> 的记录拆分</a></li>
      <li><a name="toc-a_00bd_00bfc_0094_00a8-gawk-aa_0088_0086aa_0089_00b2e_00ae_00b0aa_00bd_0095" href="#gawk-split-records">4.1.2 使用 <code>gawk</code> 分割记录</a></li>
    </ul></li>
    <li><a name="toc-ae_00a3_0080ae_009f_00a5aa_009f_009f" href="#Fields">4.2 检查域</a></li>
    <li><a name="toc-e_009d_009eaa_00b8_00b8ae_0095_00b0aa_009f_009fc_00bc_0096aa_008f_00b7" href="#Nonconstant-Fields">4.3 非常数域编号</a></li>
    <li><a name="toc-ae_009b_00b4ae_0094_00b9aa_009f_009faa_0086_0085aa_00ae_00b9" href="#Changing-Fields">4.4 更改域内容</a></li>
    <li><a name="toc-ae_008c_0087aa_00ae_009ae_00ae_00b0aa_00bd_0095aa_00a6_0082a_00bd_0095e_00bf_009be_00a1_008caa_0088_0086e_009a_0094" href="#Field-Separators">4.5 指定记录如何进行分隔</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_00a0_0087aa_0087_0086c_009a_0084aa_009f_009faa_0088_0086e_009a_0094c_00ac_00a6c_00a9_00bac_0099_00bdc_00ac_00a6" href="#Default-Field-Splitting">4.5.1 标准的域分隔符空白符</a></li>
      <li><a name="toc-a_00bd_00bfc_0094_00a8ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008faa_0088_0086e_009a_0094aa_009f_009f" href="#Regexp-Field-Splitting">4.5.2 使用正则表达式分隔域</a></li>
      <li><a name="toc-aa_0090_0084aa_00ad_0097c_00ac_00a6c_009a_0086a_00b8_00baaa_0088_0086e_009a_0094c_00ac_00a6" href="#Single-Character-Fields">4.5.3 各字符皆为分隔符</a></li>
      <li><a name="toc-a_00bb_008eaa_0091_00bda_00bb_00a4e_00a1_008ca_00b8_00ade_00ae_00bec_00bd_00ae-FS" href="#Command-Line-Field-Separator">4.5.4 从命令行中设置 <code>FS</code></a></li>
      <li><a name="toc-a_00b8_0080e_00a1_008caa_008d_00b3a_00b8_0080aa_009f_009f" href="#Full-Line-Fields">4.5.5 一行即一域</a></li>
      <li><a name="toc-aa_009f_009faa_0088_0086aa_0089_00b2ae_0080_00bbc_00bb_0093" href="#Field-Splitting-Summary">4.5.6 域分割总结</a></li>
    </ul></li>
    <li><a name="toc-e_00af_00bbaa_008f_0096aa_009b_00baaa_00ae_009aaa_00ae_00bdaa_00ba_00a6ae_0095_00b0ae_008d_00ae" href="#Constant-Size">4.6 读取固定宽度数据</a></li>
    <li><a name="toc-a_00bb_00a5aa_0086_0085aa_00ae_00b9aa_00ae_009aa_00b9_0089aa_009f_009f" href="#Splitting-By-Content">4.7 以内容定义域</a></li>
    <li><a name="toc-aa_00a4_009ae_00a1_008ce_00ae_00b0aa_00bd_0095" href="#Multiple-Line">4.8 多行记录</a></li>
    <li><a name="toc-c_0094_00a8-getline-e_00be_0093aa_0085_00a5ae_0095_00b0ae_008d_00ae" href="#Getline">4.9 用 <code>getline</code> 输入数据</a>
    <ul class="no-bullet">
      <li><a name="toc-a_00b8_008daa_00b8_00a6aa_008f_0082ae_0095_00b0e_00b0_0083c_0094_00a8-getline" href="#Plain-Getline">4.9.1 不带参数调用 <code>getline</code></a></li>
      <li><a name="toc-aa_00b0_0086-getline-e_00b5_008baa_0080_00bcc_00bb_0099aa_008f_0098e_0087_008f" href="#Getline_002fVariable">4.9.2 将 <code>getline</code> 赋值给变量</a></li>
      <li><a name="toc-a_00bd_00bfc_0094_00a8-getline-e_00af_00bbaa_008f_0096ae_0096_0087a_00bb_00b6" href="#Getline_002fFile">4.9.3 使用 <code>getline</code> 读取文件</a></li>
      <li><a name="toc-a_00bb_008eae_0096_0087a_00bb_00b6a_00b8_00ad-getline-aa_0088_00b0aa_008f_0098e_0087_008f" href="#Getline_002fVariable_002fFile">4.9.4 从文件中 <code>getline</code> 到变量</a></li>
      <li><a name="toc-a_00bb_008ec_00ae_00a1e_0081_0093a_00b8_00ada_00bd_00bfc_0094_00a8-getline" href="#Getline_002fPipe">4.9.5 从管道中使用 <code>getline</code></a></li>
      <li><a name="toc-a_00bb_008ec_00ae_00a1e_0081_0093a_00b8_00ad-getline-aa_0088_00b0aa_008f_0098e_0087_008f" href="#Getline_002fVariable_002fPipe">4.9.6 从管道中 <code>getline</code> 到变量</a></li>
      <li><a name="toc-a_00bb_008eaa_00b9_00b6c_00a8_008ba_00b8_00ada_00bd_00bfc_0094_00a8-getline" href="#Getline_002fCoprocess">4.9.7 从并程中使用 <code>getline</code></a></li>
      <li><a name="toc-a_00bd_00bfc_0094_00a8aa_00b9_00b6c_00a8_008b-getline-aa_0088_00b0aa_008f_0098e_0087_008f" href="#Getline_002fVariable_002fCoprocess">4.9.8 使用并程 <code>getline</code> 到变量</a></li>
      <li><a name="toc-aa_009b_009ee_00a1_00be-getline" href="#Getline-Notes">4.9.9 回顾 <code>getline</code></a></li>
      <li><a name="toc-getline-aa_008f_0098a_00bd_0093ae_0080_00bbc_00bb_0093" href="#Getline-Summary">4.9.10 <code>getline</code> 变体总结</a></li>
    </ul></li>
    <li><a name="toc-aa_00b8_00a6e_00b6_0085ae_0097_00b6c_009a_0084e_00be_0093aa_0085_00a5e_00af_00bbaa_008f_0096" href="#Read-Timeout">4.10 带超时的输入读取</a></li>
    <li><a name="toc-aa_0091_00bda_00bb_00a4e_00a1_008ca_00b8_00adc_009a_0084c_009b_00aeaa_00bd_0095" href="#Command_002dline-directories">4.11 命令行中的目录</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-4" href="#Input-Summary">4.12 总结</a></li>
    <li><a name="toc-c_00bb_0083a_00b9_00a0-2" href="#Input-Exercises">4.13 练习</a></li>
  </ul></li>
  <li><a name="toc-ae_0089_0093aa_008d_00b0e_00be_0093aa_0087_00ba" href="#Printing">5 打印输出</a>
  <ul class="no-bullet">
    <li><a name="toc-print-e_00af_00adaa_008f_00a5" href="#Print">5.1 <code>print</code> 语句</a></li>
    <li><a name="toc-print-e_00af_00adaa_008f_00a5a_00be_008baa_00ad_0090" href="#Print-Examples">5.2 <code>print</code> 语句例子</a></li>
    <li><a name="toc-e_00be_0093aa_0087_00baaa_0088_0086e_009a_0094c_00ac_00a6" href="#Output-Separators">5.3 输出分隔符</a></li>
    <li><a name="toc-ae_008e_00a7aa_0088_00b6-print-c_009a_0084ae_0095_00b0aa_00ad_0097e_00be_0093aa_0087_00ba" href="#OFMT">5.4 控制 <code>print</code> 的数字输出</a></li>
    <li><a name="toc-a_00bd_00bfc_0094_00a8-printf-e_00af_00adaa_008f_00a5c_00be_008eaa_008c_0096ae_0089_0093aa_008d_00b0" href="#Printf">5.5 使用 <code>printf</code> 语句美化打印</a>
    <ul class="no-bullet">
      <li><a name="toc-a_00bd_00bfc_0094_00a8-printf-e_00af_00adaa_008f_00a5c_00be_008eaa_008c_0096ae_0089_0093aa_008d_00b0-1" href="#Basic-Printf">5.5.1 使用 <code>printf</code> 语句美化打印</a></li>
      <li><a name="toc-ae_00a0_00bcaa_00bc_008fae_008e_00a7aa_0088_00b6aa_00ad_0097ae_00af_008d" href="#Control-Letters">5.5.2 格式控制字母</a></li>
      <li><a name="toc-printf-c_009a_0084a_00bf_00aee_00a5_00b0c_00ac_00a6" href="#Format-Modifiers">5.5.3 <code>printf</code> 的修饰符</a></li>
      <li><a name="toc-printf-e_008c_0083a_00be_008b" href="#Printf-Examples">5.5.4 <code>printf</code> 范例</a></li>
    </ul></li>
    <li><a name="toc-e_0087_008daa_00ae_009aaa_0090_0091-print-a_00b8_008e-printf-c_009a_0084e_00be_0093aa_0087_00ba" href="#Redirection">5.6 重定向 <code>print</code> 与 <code>printf</code> 的输出</a></li>
    <li><a name="toc-ae_00a0_0087aa_0087_0086c_009a_0084e_00a2_0084ae_0089_0093aa_00bc_0080c_009a_0084c_0089_00b9ae_00ae_008aae_0096_0087a_00bb_00b6ae_0095_00b0ae_008d_00aeae_00b5_0081" href="#Special-FD">5.7 标准的预打开的特殊文件数据流</a></li>
    <li><a name="toc-gawk-a_00b8_00adc_009a_0084c_0089_00b9ae_00ae_008aae_0096_0087a_00bb_00b6aa_0090_008d" href="#Special-Files">5.8 <code>gawk</code> 中的特殊文件名</a>
    <ul class="no-bullet">
      <li><a name="toc-aa_009c_00a8-gawk-e_00ae_00bfe_0097_00aeaa_0085_00b6a_00bb_0096aa_00b7_00b2aa_00bc_0080ae_0096_0087a_00bb_00b6" href="#Other-Inherited-Files">5.8.1 在 <code>gawk</code> 访问其他已开文件</a></li>
      <li><a name="toc-c_0094_00a8a_00ba_008ec_00bd_0091c_00bb_009cc_009a_0084c_0089_00b9ae_00ae_008aae_0096_0087a_00bb_00b6" href="#Special-Network">5.8.2 用于网络的特殊文件</a></li>
      <li><a name="toc-c_0089_00b9ae_00ae_008aae_0096_0087a_00bb_00b6aa_0090_008de_00af_00b4ae_0098_008e" href="#Special-Caveats">5.8.3 特殊文件名说明</a></li>
    </ul></li>
    <li><a name="toc-aa_0085_00b3e_0097_00ade_00be_0093aa_0085_00a5e_00be_0093aa_0087_00bae_0087_008daa_00ae_009aaa_0090_0091" href="#Close-Files-And-Pipes">5.9 关闭输入输出重定向</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-15" href="#Output-Summary">5.10 总结</a></li>
    <li><a name="toc-c_00bb_0083a_00b9_00a0-3" href="#Output-Exercises">5.11 练习</a></li>
  </ul></li>
  <li><a name="toc-e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Expressions">6 表达式</a>
  <ul class="no-bullet">
    <li><a name="toc-aa_00b8_00b8e_0087_008fa_0080_0081aa_008f_0098e_0087_008fa_00b8_008ee_00bd_00acae_008d_00a2" href="#Values">6.1 常量、变量与转换</a>
    <ul class="no-bullet">
      <li><a name="toc-aa_00b8_00b8e_0087_008fe_00a1_00a8e_00be_00beaa_00bc_008f" href="#Constants">6.1.1 常量表达式</a>
      <ul class="no-bullet">
        <li><a name="toc-ae_0095_00b0aa_0080_00bca_00b8_008eaa_00ad_0097a_00b8_00b2aa_00b8_00b8e_0087_008f" href="#Scalar-Constants">6.1.1.1 数值与字串常量</a></li>
        <li><a name="toc-aa_0085_00abe_00bf_009baa_0088_00b6a_00b8_008eaa_008d_0081aa_0085_00ade_00bf_009baa_0088_00b6ae_0095_00b0aa_0080_00bc" href="#Nondecimal_002dnumbers">6.1.1.2 八进制与十六进制数值</a></li>
        <li><a name="toc-ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008faa_00b8_00b8e_0087_008f" href="#Regexp-Constants">6.1.1.3 正则表达式常量</a></li>
      </ul></li>
      <li><a name="toc-a_00bd_00bfc_0094_00a8ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008faa_00b8_00b8e_0087_008f" href="#Using-Constant-Regexps">6.1.2 使用正则表达式常量</a></li>
      <li><a name="toc-aa_008f_0098e_0087_008f" href="#Variables">6.1.3 变量</a>
      <ul class="no-bullet">
        <li><a name="toc-aa_009c_00a8c_00a8_008baa_00ba_008fa_00b8_00ada_00bd_00bfc_0094_00a8aa_008f_0098e_0087_008f" href="#Using-Variables">6.1.3.1 在程序中使用变量</a></li>
        <li><a name="toc-aa_009c_00a8aa_0091_00bda_00bb_00a4e_00a1_008ca_00b8_00ade_00bf_009be_00a1_008caa_008f_0098e_0087_008fe_00b5_008baa_0080_00bc" href="#Assignment-Options">6.1.3.2 在命令行中进行变量赋值</a></li>
      </ul></li>
      <li><a name="toc-aa_009c_00a8aa_00ad_0097a_00b8_00b2a_00b8_008eae_0095_00b0aa_0080_00bca_00b9_008be_0097_00b4e_00bf_009be_00a1_008ce_00bd_00acae_008d_00a2" href="#Conversion">6.1.4 在字串与数值之间进行转换</a>
      <ul class="no-bullet">
        <li><a name="toc-awk-aa_00a6_0082a_00bd_0095e_00bd_00acae_008d_00a2aa_00ad_0097a_00b8_00b2a_00b8_008eae_0095_00b0aa_0080_00bc" href="#Strings-And-Numbers">6.1.4.1 <code>awk</code> 如何转换字串与数值</a></li>
        <li><a name="toc-e_00af_00ade_00a8_0080e_00ae_00bec_00bd_00aea_00bc_009aaa_00bd_00b1aa_0093_008de_00bd_00acae_008d_00a2" href="#Locale-influences-conversions">6.1.4.2 语言设置会影响转换</a></li>
      </ul>
</li>
    </ul></li>
    <li><a name="toc-ae_0093_008da_00bd_009cc_00ac_00a6i_00bc_009aaa_00af_00b9aa_0080_00bce_00bf_009be_00a1_008caa_00a4_0084c_0090_0086" href="#All-Operators">6.2 操作符：对值进行处理</a>
    <ul class="no-bullet">
      <li><a name="toc-c_00ae_0097ae_009c_00afae_0093_008da_00bd_009cc_00ac_00a6" href="#Arithmetic-Ops">6.2.1 算术操作符</a></li>
      <li><a name="toc-aa_00ad_0097a_00b8_00b2e_00bf_009eae_008e_00a5" href="#Concatenation">6.2.2 字串连接</a></li>
      <li><a name="toc-e_00b5_008baa_0080_00bce_00a1_00a8e_00be_00beaa_00bc_008f" href="#Assignment-Ops">6.2.3 赋值表达式</a></li>
      <li><a name="toc-e_0080_0092aa_00a2_009ea_00b8_008ee_0080_0092aa_0087_008fae_0093_008da_00bd_009cc_00ac_00a6" href="#Increment-Ops">6.2.4 递增与递减操作符</a></li>
    </ul></li>
    <li><a name="toc-c_009c_009faa_0080_00bca_00b8_008eae_009d_00a1a_00bb_00b6" href="#Truth-Values-and-Conditions">6.3 真值与条件</a>
    <ul class="no-bullet">
      <li><a name="toc-awk-c_009a_0084c_009c_009fa_00b8_008eaa_0081_0087" href="#Truth-Values">6.3.1 <code>awk</code> 的真与假</a></li>
      <li><a name="toc-aa_008f_0098e_0087_008fc_00b1_00bbaa_009e_008ba_00b8_008eae_00af_0094e_00be_0083e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Typing-and-Comparison">6.3.2 变量类型与比较表达式</a>
      <ul class="no-bullet">
        <li><a name="toc-aa_00ad_0097a_00b8_00b2c_00b1_00bbaa_009e_008ba_00b8_008eae_0095_00b0aa_0080_00bcc_00b1_00bbaa_009e_008b" href="#Variable-Typing">6.3.2.1 字串类型与数值类型</a></li>
        <li><a name="toc-ae_00af_0094e_00be_0083ae_0093_008da_00bd_009cc_00ac_00a6" href="#Comparison-Operators">6.3.2.2 比较操作符</a></li>
        <li><a name="toc-POSIX-a_00b8_00adc_009a_0084aa_00ad_0097a_00b8_00b2ae_00af_0094e_00be_0083e_00a7_0084aa_0088_0099" href="#POSIX-String-Comparison">6.3.2.3 POSIX 中的字串比较规则</a></li>
      </ul></li>
      <li><a name="toc-aa_00b8_0083ae_009e_0097e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Boolean-Ops">6.3.3 布林表达式</a></li>
      <li><a name="toc-ae_009d_00a1a_00bb_00b6e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Conditional-Exp">6.3.4 条件表达式</a></li>
    </ul></li>
    <li><a name="toc-aa_0087_00bdae_0095_00b0e_00b0_0083c_0094_00a8" href="#Function-Calls">6.4 函数调用</a></li>
    <li><a name="toc-ae_0093_008da_00bd_009cc_00ac_00a6a_00bc_0098aa_0085_0088c_00ba_00a7i_00bc_0088ae_0093_008da_00bd_009cc_00ac_00a6c_009a_0084aa_00b5_008caa_00a5_0097i_00bc_0089" href="#Precedence">6.5 操作符优先级（操作符的嵌套）</a></li>
    <li><a name="toc-aa_0093_00aae_0087_008ce_0080_00a0ae_0088_0090aa_00b7_00aeaa_00bc_0082" href="#Locales">6.6 哪里造成差异</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-2" href="#Expressions-Summary">6.7 总结</a></li>
  </ul></li>
  <li><a name="toc-ae_00a8_00a1aa_00bc_008fa_0080_0081aa_008a_00a8a_00bd_009ca_00b8_008eaa_008f_0098e_0087_008f" href="#Patterns-and-Actions">7 模式、动作与变量</a>
  <ul class="no-bullet">
    <li><a name="toc-ae_00a8_00a1aa_00bc_008faa_0085_0083c_00b4_00a0" href="#Pattern-Overview">7.1 模式元素</a>
    <ul class="no-bullet">
      <li><a name="toc-a_00bb_00a5ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fa_00b8_00baae_00a8_00a1aa_00bc_008f" href="#Regexp-Patterns">7.1.1 以正则表达式为模式</a></li>
      <li><a name="toc-a_00bb_00a5e_00a1_00a8e_00be_00beaa_00bc_008fa_00b8_00baae_00a8_00a1aa_00bc_008f" href="#Expression-Patterns">7.1.2 以表达式为模式</a></li>
      <li><a name="toc-c_0094_00a8ae_00a8_00a1aa_00bc_008fae_008c_0087aa_00ae_009ae_00ae_00b0aa_00bd_0095e_008c_0083aa_009b_00b4" href="#Ranges">7.1.3 用模式指定记录范围</a></li>
      <li><a name="toc-BEGIN-a_00b8_008e-END-c_0089_00b9ae_00ae_008aae_00a8_00a1aa_00bc_008f" href="#BEGIN_002fEND">7.1.4 <code>BEGIN</code> 与 <code>END</code> 特殊模式</a>
      <ul class="no-bullet">
        <li><a name="toc-aa_00bc_0080aa_00a7_008ba_00b8_008ec_00bb_0093ae_009d_009faa_008a_00a8a_00bd_009c" href="#Using-BEGIN_002fEND">7.1.4.1 开始与结束动作</a></li>
        <li><a name="toc-BEGIN-a_00b8_008e-END-e_00a7_0084aa_0088_0099a_00b8_00adc_009a_0084e_00be_0093aa_0085_00a5e_00be_0093aa_0087_00ba" href="#I_002fO-And-BEGIN_002fEND">7.1.4.2 <code>BEGIN</code> 与 <code>END</code> 规则中的输入输出</a></li>
      </ul></li>
      <li><a name="toc-BEGINFILE-a_00b8_008e-ENDFILE-c_0089_00b9ae_00ae_008aae_00a8_00a1aa_00bc_008f" href="#BEGINFILE_002fENDFILE">7.1.5 <code>BEGINFILE</code> 与 <code>ENDFILE</code> 特殊模式</a></li>
      <li><a name="toc-c_00a9_00baae_00a8_00a1aa_00bc_008f" href="#Empty">7.1.6 空模式</a></li>
    </ul></li>
    <li><a name="toc-aa_009c_00a8c_00a8_008baa_00ba_008fa_00b8_00ada_00bd_00bfc_0094_00a8-Shell-aa_008f_0098e_0087_008f" href="#Using-Shell-Variables">7.2 在程序中使用 Shell 变量</a></li>
    <li><a name="toc-aa_008a_00a8a_00bd_009c" href="#Action-Overview">7.3 动作</a></li>
    <li><a name="toc-aa_008a_00a8a_00bd_009ca_00b8_00adc_009a_0084ae_008e_00a7aa_0088_00b6e_00af_00adaa_008f_00a5" href="#Statements">7.4 动作中的控制语句</a>
    <ul class="no-bullet">
      <li><a name="toc-if_002delse-e_00af_00adaa_008f_00a5" href="#If-Statement">7.4.1 <code>if</code>-<code>else</code> 语句</a></li>
      <li><a name="toc-while-e_00af_00adaa_008f_00a5" href="#While-Statement">7.4.2 <code>while</code> 语句</a></li>
      <li><a name="toc-do_002dwhile-e_00af_00adaa_008f_00a5" href="#Do-Statement">7.4.3 <code>do</code>-<code>while</code> 语句</a></li>
      <li><a name="toc-for-e_00af_00adaa_008f_00a5" href="#For-Statement">7.4.4 <code>for</code> 语句</a></li>
      <li><a name="toc-switch-e_00af_00adaa_008f_00a5" href="#Switch-Statement">7.4.5 <code>switch</code> 语句</a></li>
      <li><a name="toc-break-e_00af_00adaa_008f_00a5" href="#Break-Statement">7.4.6 <code>break</code> 语句</a></li>
      <li><a name="toc-continue-e_00af_00adaa_008f_00a5" href="#Continue-Statement">7.4.7 <code>continue</code> 语句</a></li>
      <li><a name="toc-next-e_00af_00adaa_008f_00a5" href="#Next-Statement">7.4.8 <code>next</code> 语句</a></li>
      <li><a name="toc-nextfile-e_00af_00adaa_008f_00a5" href="#Nextfile-Statement">7.4.9 <code>nextfile</code> 语句</a></li>
      <li><a name="toc-exit-e_00af_00adaa_008f_00a5" href="#Exit-Statement">7.4.10 <code>exit</code> 语句</a></li>
    </ul></li>
    <li><a name="toc-e_00a2_0084aa_00ae_009aa_00b9_0089aa_008f_0098e_0087_008f" href="#Built_002din-Variables">7.5 预定义变量</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_008e_00a7aa_0088_00b6-awk-c_009a_0084aa_0086_0085c_00bd_00aeaa_008f_0098e_0087_008f" href="#User_002dmodified">7.5.1 控制 <code>awk</code> 的内置变量</a></li>
      <li><a name="toc-a_00bc_00a0e_0080_0092a_00bf_00a1ae_0081_00afc_009a_0084aa_0086_0085c_00bd_00aeaa_008f_0098e_0087_008f" href="#Auto_002dset">7.5.2 传递信息的内置变量</a></li>
      <li><a name="toc-a_00bd_00bfc_0094_00a8-ARGC-a_00b8_008e-ARGV" href="#ARGC-and-ARGV">7.5.3 使用 <code>ARGC</code> 与 <code>ARGV</code></a></li>
    </ul></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-17" href="#Pattern-Action-Summary">7.6 总结</a></li>
  </ul></li>
  <li><a name="toc-awk-ae_0095_00b0c_00bb_0084" href="#Arrays">8 <code>awk</code> 数组</a>
  <ul class="no-bullet">
    <li><a name="toc-ae_0095_00b0c_00bb_0084aa_009f_00bac_00a1_0080" href="#Array-Basics">8.1 数组基础</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_0095_00b0c_00bb_0084a_00bb_008bc_00bb_008d" href="#Array-Intro">8.1.1 数组介绍</a></li>
      <li><a name="toc-ae_008c_0087aa_0090_0091ae_0095_00b0c_00bb_0084aa_0085_0083c_00b4_00a0" href="#Reference-to-Elements">8.1.2 指向数组元素</a></li>
      <li><a name="toc-c_00bb_0099ae_0095_00b0c_00bb_0084aa_0085_0083c_00b4_00a0e_00b5_008baa_0080_00bc" href="#Assigning-Elements">8.1.3 给数组元素赋值</a></li>
      <li><a name="toc-aa_009f_00baae_009c_00acae_0095_00b0c_00bb_0084aa_00ae_009ea_00be_008b" href="#Array-Example">8.1.4 基本数组实例</a></li>
      <li><a name="toc-e_0081_008daa_008e_0086ae_0095_00b0c_00bb_0084aa_0085_0083c_00b4_00a0" href="#Scanning-an-Array">8.1.5 遍历数组元素</a></li>
      <li><a name="toc-aa_009c_00a8-gawk-a_00b8_00ada_00bd_00bfc_0094_00a8e_00a2_0084aa_00ae_009aa_00b9_0089c_009a_0084ae_0095_00b0c_00bb_0084e_0081_008daa_008e_0086e_00a1_00baaa_00ba_008f" href="#Controlling-Scanning">8.1.6 在 <code>gawk</code> 中使用预定义的数组遍历顺序</a></li>
    </ul></li>
    <li><a name="toc-c_0094_00a8ae_0095_00b0aa_0080_00bca_00bd_009ca_00b8_00baae_0095_00b0c_00bb_0084a_00b8_008bae_00a0_0087" href="#Numeric-Array-Subscripts">8.2 用数值作为数组下标</a></li>
    <li><a name="toc-c_0094_00a8ae_009c_00aaaa_0088_009daa_00a7_008baa_008c_0096c_009a_0084ae_0095_00b0aa_0080_00bca_00bd_009ca_00b8_00baae_0095_00b0c_00bb_0084a_00b8_008bae_00a0_0087" href="#Uninitialized-Subscripts">8.3 用未初始化的数值作为数组下标</a></li>
    <li><a name="toc-delete-e_00af_00adaa_008f_00a5" href="#Delete">8.4 <code>delete</code> 语句</a></li>
    <li><a name="toc-aa_00a4_009ac_00bb_00b4ae_0095_00b0c_00bb_0084" href="#Multidimensional">8.5 多维数组</a>
    <ul class="no-bullet">
      <li><a name="toc-e_0081_008daa_008e_0086aa_00a4_009ac_00bb_00b4ae_0095_00b0c_00bb_0084-1" href="#Multiscanning">8.5.1 遍历多维数组</a></li>
    </ul></li>
    <li><a name="toc-aa_00a4_009ac_00bb_00b4ae_0095_00b0c_00bb_0084-1" href="#Arrays-of-Arrays">8.6 多维数组</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-18" href="#Arrays-Summary">8.7 总结</a></li>
  </ul></li>
  <li><a name="toc-aa_0087_00bdae_0095_00b0" href="#Functions">9 函数</a>
  <ul class="no-bullet">
    <li><a name="toc-aa_0086_0085c_00bd_00aeaa_0087_00bdae_0095_00b0" href="#Built_002din">9.1 内置函数</a>
    <ul class="no-bullet">
      <li><a name="toc-e_00b0_0083c_0094_00a8aa_0086_0085c_00bd_00aeaa_0087_00bdae_0095_00b0" href="#Calling-Built_002din">9.1.1 调用内置函数</a></li>
      <li><a name="toc-ae_0095_00b0aa_0080_00bcaa_0087_00bdae_0095_00b0" href="#Numeric-Functions">9.1.2 数值函数</a></li>
      <li><a name="toc-aa_00ad_0097a_00b8_00b2ae_0093_008da_00bd_009caa_0087_00bdae_0095_00b0" href="#String-Functions">9.1.3 字串操作函数</a>
      <ul class="no-bullet">
        <li><a name="toc-sub_0028_0029a_0080_0081gsub_0028_0029-a_00b8_008e-gensub_0028_0029-aa_0087_00bdae_0095_00b0a_00b8_00adc_009a_0084-_005c-a_00b8_008e-_0026" href="#Gory-Details">9.1.3.1 <code>sub()</code>、<code>gsub()</code> 与 <code>gensub()</code> 函数中的 &lsquo;<samp>\</samp>&rsquo; 与 &lsquo;<samp>&amp;</samp>&rsquo;</a></li>
      </ul></li>
      <li><a name="toc-e_00be_0093aa_0085_00a5e_00be_0093aa_0087_00baaa_0087_00bdae_0095_00b0" href="#I_002fO-Functions">9.1.4 输入输出函数</a></li>
      <li><a name="toc-ae_0097_00b6e_0097_00b4aa_0087_00bdae_0095_00b0" href="#Time-Functions">9.1.5 时间函数</a></li>
      <li><a name="toc-a_00bd_008dae_0093_008da_00bd_009caa_0087_00bdae_0095_00b0" href="#Bitwise-Functions">9.1.6 位操作函数</a></li>
      <li><a name="toc-e_008e_00b7aa_008f_0096c_00b1_00bbaa_009e_008ba_00bf_00a1ae_0081_00af" href="#Type-Functions">9.1.7 获取类型信息</a></li>
      <li><a name="toc-aa_00ad_0097a_00b8_00b2c_00bf_00bbe_00af_0091aa_0087_00bdae_0095_00b0" href="#I18N-Functions">9.1.8 字串翻译函数</a></li>
    </ul></li>
    <li><a name="toc-c_0094_00a8ae_0088_00b7e_0087_00aaaa_00ae_009aa_00b9_0089aa_0087_00bdae_0095_00b0" href="#User_002ddefined">9.2 用户自定义函数</a>
    <ul class="no-bullet">
      <li><a name="toc-aa_0087_00bdae_0095_00b0aa_00ae_009aa_00b9_0089e_00af_00adae_00b3_0095" href="#Definition-Syntax">9.2.1 函数定义语法</a></li>
      <li><a name="toc-aa_0087_00bdae_0095_00b0aa_00ae_009aa_00b9_0089e_008c_0083a_00be_008b" href="#Function-Example">9.2.2 函数定义范例</a></li>
      <li><a name="toc-e_00b0_0083c_0094_00a8c_0094_00a8ae_0088_00b7e_0087_00aaaa_00ae_009aa_00b9_0089aa_0087_00bdae_0095_00b0" href="#Function-Caveats">9.2.3 调用用户自定义函数</a>
      <ul class="no-bullet">
        <li><a name="toc-aa_00a6_0082a_00bd_0095e_00b0_0083c_0094_00a8aa_0087_00bdae_0095_00b0" href="#Calling-A-Function">9.2.3.1 如何调用函数</a></li>
        <li><a name="toc-ae_008e_00a7aa_0088_00b6aa_008f_0098e_0087_008fa_00bd_009cc_0094_00a8aa_009f_009f" href="#Variable-Scope">9.2.3.2 控制变量作用域</a></li>
        <li><a name="toc-aa_0087_00bdae_0095_00b0aa_008f_0098e_0087_008fa_00b8_00adc_009a_0084a_00bc_00a0aa_008f_0082a_00b8_008ea_00bc_00a0aa_00bc_0095c_0094_00a8" href="#Pass-By-Value_002fReference">9.2.3.3 函数变量中的传参与传引用</a></li>
      </ul></li>
      <li><a name="toc-return-e_00af_00adaa_008f_00a5" href="#Return-Statement">9.2.4 <code>return</code> 语句</a></li>
      <li><a name="toc-aa_0087_00bdae_0095_00b0a_00b8_008eaa_0085_00b6aa_009c_00a8aa_008f_0098e_0087_008fc_00b1_00bbaa_009e_008ba_00b8_008ac_009a_0084aa_00bd_00b1aa_0093_008d" href="#Dynamic-Typing">9.2.5 函数与其在变量类型上的影响</a></li>
    </ul></li>
    <li><a name="toc-e_0097_00b4ae_008e_00a5aa_0087_00bdae_0095_00b0e_00b0_0083c_0094_00a8" href="#Indirect-Calls">9.3 间接函数调用</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-6" href="#Functions-Summary">9.4 总结</a></li>
  </ul></li>
  <li><a name="toc-c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">第二部分:<br>用 <code>awk</code> 来解决问题</a></li>
  <li><a name="toc-awk-aa_0087_00bdae_0095_00b0aa_00ba_0093" href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a>
  <ul class="no-bullet">
    <li><a name="toc-aa_0091_00bdaa_0090_008daa_0087_00bdae_0095_00b0aa_00ba_0093c_009a_0084aa_0085_00a8aa_00b1_0080aa_008f_0098e_0087_008f" href="#Library-Names">1.1 命名函数库的全局变量</a></li>
    <li><a name="toc-e_0080_009ac_0094_00a8c_00bc_0096c_00a8_008b" href="#General-Functions">1.2 通用编程</a>
    <ul class="no-bullet">
      <li><a name="toc-aa_00b0_0086ae_0095_00b0aa_0080_00bce_00bd_00acae_008d_00a2ae_0088_0090aa_00ad_0097a_00b8_00b2" href="#Strtonum-Function">1.2.1 将数值转换成字串</a></li>
      <li><a name="toc-ae_0096_00ade_00a8_0080" href="#Assert-Function">1.2.2 断言</a></li>
      <li><a name="toc-ae_0095_00b0aa_0080_00bce_0088_008daa_0085_00a5e_0088_008daa_0087_00ba" href="#Round-Function">1.2.3 数值舍入舍出</a></li>
      <li><a name="toc-Cliff-e_009a_008fae_009c_00baae_0095_00b0c_0094_009fae_0088_0090aa_0099_00a8" href="#Cliff-Random-Function">1.2.4 Cliff 随机数生成器</a></li>
      <li><a name="toc-aa_009c_00a8aa_00ad_0097c_00ac_00a6a_00b8_008eae_0095_00b0aa_0080_00bca_00b9_008be_0097_00b4aa_008f_0098ae_008d_00a2" href="#Ordinal-Functions">1.2.5 在字符与数值之间变换</a></li>
      <li><a name="toc-aa_00b0_0086ae_0095_00b0c_00bb_0084aa_0090_0088aa_00b9_00b6ae_0088_0090aa_00ad_0097a_00b8_00b2" href="#Join-Function">1.2.6 将数组合并成字串</a></li>
      <li><a name="toc-c_00ae_00a1c_0090_0086ae_0097_00b6e_0097_00b4" href="#Getlocaltime-Function">1.2.7 管理时间</a></li>
      <li><a name="toc-a_00b8_0080ae_00ac_00a1e_00af_00bbaa_008f_0096ae_0095_00b4a_00b8_00aaae_0096_0087a_00bb_00b6" href="#Readfile-Function">1.2.8 一次读取整个文件</a></li>
      <li><a name="toc-aa_00b0_0086aa_00ad_0097a_00b8_00b2c_0094_00a8aa_00bc_0095aa_008f_00b7aa_00bc_0095e_00b5_00b7aa_00b9_00b6a_00bc_00a0e_0080_0092c_00bb_0099-Shell" href="#Shell-Quoting">1.2.9 将字串用引号引起并传递给 Shell</a></li>
    </ul></li>
    <li><a name="toc-ae_0095_00b0ae_008d_00aeae_0096_0087a_00bb_00b6c_00ae_00a1c_0090_0086" href="#Data-File-Management">1.3 数据文件管理</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_00b3_00a8ae_0084_008fae_0095_00b0ae_008d_00aeae_0096_0087a_00bb_00b6c_009a_0084e_00be_00b9c_0095_008c" href="#Filetrans-Function">1.3.1 注意数据文件的边界</a></li>
      <li><a name="toc-e_0087_008dae_0096_00b0e_00af_00bbaa_008f_0096aa_00bd_0093aa_0089_008dae_0096_0087a_00bb_00b6" href="#Rewind-Function">1.3.2 重新读取当前文件</a></li>
      <li><a name="toc-ae_00a3_0080ae_009f_00a5aa_008f_00afe_00af_00bbc_009a_0084ae_0095_00b0ae_008d_00aeae_0096_0087a_00bb_00b6" href="#File-Checking">1.3.3 检查可读的数据文件</a></li>
      <li><a name="toc-ae_00a3_0080ae_009f_00a5e_0095_00bfaa_00ba_00a6a_00b8_00bae_009b_00b6c_009a_0084ae_0096_0087a_00bb_00b6" href="#Empty-Files">1.3.4 检查长度为零的文件</a></li>
      <li><a name="toc-aa_00b0_0086e_00b5_008baa_0080_00bcaa_00bd_0093ae_0088_0090ae_0098_00afae_0096_0087a_00bb_00b6aa_0090_008d" href="#Ignoring-Assigns">1.3.5 将赋值当成是文件名</a></li>
    </ul></li>
    <li><a name="toc-aa_00a4_0084c_0090_0086aa_0091_00bda_00bb_00a4e_00a1_008ce_0080_0089e_00a1_00b9" href="#Getopt-Function">1.4 处理命令行选项</a></li>
    <li><a name="toc-e_00af_00bbaa_008f_0096c_0094_00a8ae_0088_00b7ae_0095_00b0ae_008d_00aeaa_00ba_0093" href="#Passwd-Functions">1.5 读取用户数据库</a></li>
    <li><a name="toc-e_00af_00bbaa_008f_0096c_00bb_0084ae_0095_00b0ae_008d_00aeaa_00ba_0093" href="#Group-Functions">1.6 读取组数据库</a></li>
    <li><a name="toc-e_0081_008daa_008e_0086aa_00a4_009ac_00bb_00b4ae_0095_00b0c_00bb_0084" href="#Walking-Arrays">1.7 遍历多维数组</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-5" href="#Library-Functions-Summary">1.8 总结</a></li>
    <li><a name="toc-c_00bb_0083a_00b9_00a0-4" href="#Library-Exercises">1.9 练习</a></li>
  </ul></li>
  <li><a name="toc-aa_00ae_009ec_0094_00a8c_009a_0084-awk-c_00a8_008baa_00ba_008f" href="#Sample-Programs">2 实用的 <code>awk</code> 程序</a>
  <ul class="no-bullet">
    <li><a name="toc-e_00bf_0090e_00a1_008ca_00be_008baa_00ad_0090c_00a8_008baa_00ba_008f" href="#Running-Examples">2.1 运行例子程序</a></li>
    <li><a name="toc-a_00b8_00baaa_00bf_00aba_00b9_0090a_00b8_008ee_00af_0084ae_00b5_008be_0087_008dae_0096_00b0aa_008f_0091ae_0098_008ee_00bd_00aeaa_00ad_0090" href="#Clones">2.2 为快乐与评测重新发明轮子</a>
    <ul class="no-bullet">
      <li><a name="toc-aa_0089_00aaaa_0088_0087aa_009f_009fa_00b8_008eaa_0088_0097" href="#Cut-Program">2.2.1 剪切域与列</a></li>
      <li><a name="toc-c_0094_00a8ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008faa_009c_00a8ae_0096_0087a_00bb_00b6a_00b8_00adae_0090_009cc_00b4_00a2" href="#Egrep-Program">2.2.2 用正则表达式在文件中搜索</a></li>
      <li><a name="toc-ae_0089_0093aa_008d_00b0c_0094_00a8ae_0088_00b7a_00bf_00a1ae_0081_00af" href="#Id-Program">2.2.3 打印用户信息</a></li>
      <li><a name="toc-aa_00b0_0086aa_00a4_00a7ae_0096_0087a_00bb_00b6aa_0088_0086c_0089_0087" href="#Split-Program">2.2.4 将大文件分片</a></li>
      <li><a name="toc-aa_00b0_0086e_00be_0093aa_0087_00baaa_00a4_008daa_0088_00b6aa_0088_00b0aa_00a4_009aa_00b8_00aaae_0096_0087a_00bb_00b6a_00b8_00ad" href="#Tee-Program">2.2.5 将输出复制到多个文件中</a></li>
      <li><a name="toc-ae_0089_0093aa_008d_00b0aa_008e_00bbe_0087_008dae_0096_0087ae_009c_00ace_00a1_008c" href="#Uniq-Program">2.2.6 打印去重文本行</a></li>
      <li><a name="toc-c_00bb_009fe_00ae_00a1" href="#Wc-Program">2.2.7 统计</a></li>
    </ul></li>
    <li><a name="toc-awk-c_00a8_008baa_00ba_008fc_009a_0084aa_00a4_00a7e_009b_0086aa_0090_0088" href="#Miscellaneous-Programs">2.3 <code>awk</code> 程序的大集合</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_009f_00a5ae_0089_00beae_0096_0087ae_00a1_00a3a_00b8_00adc_009a_0084e_0087_008daa_00a4_008daa_00ad_0097" href="#Dupword-Program">2.3.1 查找文档中的重复字</a></li>
      <li><a name="toc-ae_008a_00a5e_00ad_00a6ae_0097_00b6e_0092_009fc_00a8_008baa_00ba_008f" href="#Alarm-Program">2.3.2 报警时钟程序</a></li>
      <li><a name="toc-e_00bd_00acae_008d_00a2aa_00ad_0097c_00ac_00a6" href="#Translate-Program">2.3.3 转换字符</a></li>
      <li><a name="toc-ae_0089_0093aa_008d_00b0e_0082_00aea_00bb_00b6ae_00a0_0087e_00a2_0098" href="#Labels-Program">2.3.4 打印邮件标题</a></li>
      <li><a name="toc-c_0094_009fae_0088_0090aa_00ad_0097a_00bd_00bfc_0094_00a8c_00bb_009fe_00ae_00a1" href="#Word-Sorting">2.3.5 生成字使用统计</a></li>
      <li><a name="toc-a_00bb_008eae_009c_00aaae_008e_0092aa_00ba_008fc_009a_0084ae_0096_0087ae_009c_00aca_00b8_00adaa_008e_00bbe_0087_008d" href="#History-Sorting">2.3.6 从未排序的文本中去重</a></li>
      <li><a name="toc-a_00bb_008e-Texinfo-ae_00ba_0090ae_0096_0087a_00bb_00b6a_00b8_00adae_008f_0090aa_008f_0096c_00a8_008baa_00ba_008f" href="#Extract-Program">2.3.7 从 Texinfo 源文件中提取程序</a></li>
      <li><a name="toc-a_00b8_0080a_00b8_00aac_00ae_0080aa_008d_0095c_009a_0084ae_00b5_0081c_00bc_0096e_00be_0091aa_0099_00a8" href="#Simple-Sed">2.3.8 一个简单的流编辑器</a></li>
      <li><a name="toc-a_00bd_00bfc_0094_00a8aa_00ba_0093aa_0087_00bdae_0095_00b0c_009a_0084c_00ae_0080aa_008d_0095ae_0096_00b9aa_00bc_008f" href="#Igawk-Program">2.3.9 使用库函数的简单方式</a></li>
      <li><a name="toc-a_00bb_008eaa_00ad_0097aa_0085_00b8a_00b8_00adae_009f_00a5ae_0089_00beaa_008d_0095e_00af_008d" href="#Anagram-Program">2.3.10 从字典中查找单词</a></li>
      <li><a name="toc-ae_009d_00a5a_00ba_009bae_0096_00b0e_00b2_009cc_009a_0084" href="#Signature-Program">2.3.11 来些新鲜的</a></li>
    </ul></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-16" href="#Programs-Summary">2.4 总结</a></li>
    <li><a name="toc-c_00bb_0083a_00b9_00a0-1" href="#Programs-Exercises">2.5 练习</a></li>
  </ul></li>
  <li><a name="toc-c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">第三部分:<br> 用 <code>gawk</code> 超越标准 <code>awk</code></a></li>
  <li><a name="toc-gawk-c_009a_0084e_00ab_0098c_00ba_00a7c_0089_00b9ae_0080_00a7" href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">1 <code>gawk</code> 的高级特性</a>
  <ul class="no-bullet">
    <li><a name="toc-aa_0085_0081e_00ae_00b8e_009d_009eaa_008d_0081e_00bf_009baa_0088_00b6ae_0095_00b0ae_0095_00b0ae_008d_00aee_00be_0093aa_0085_00a5" href="#Nondecimal-Data">1.1 允许非十进制数数据输入</a></li>
    <li><a name="toc-ae_008e_00a7aa_0088_00b6ae_0095_00b0c_00bb_0084ae_008e_0092aa_00ba_008fa_00b8_008ee_0081_008daa_008e_0086" href="#Array-Sorting">1.2 控制数组排序与遍历</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_008e_00a7aa_0088_00b6ae_0095_00b0ae_008d_00aee_0081_008daa_008e_0086" href="#Controlling-Array-Traversal">1.2.1 控制数据遍历</a></li>
      <li><a name="toc-c_0094_00a8-gawk-aa_00af_00b9ae_0095_00b0c_00bb_0084e_00bf_009be_00a1_008caa_0080_00bca_00b8_008ee_0094_00aec_009a_0084ae_008e_0092aa_00ba_008f" href="#Array-Sorting-Functions">1.2.2 用 <code>gawk</code> 对数组进行值与键的排序</a></li>
    </ul></li>
    <li><a name="toc-a_00b8_008eaa_0085_00b6a_00bb_0096e_00bf_009bc_00a8_008be_00bf_009be_00a1_008caa_008f_008caa_0090_0091e_0080_009aa_00bf_00a1" href="#Two_002dway-I_002fO">1.3 与其他进程进行双向通信</a></li>
    <li><a name="toc-aa_0088_00a9c_0094_00a8-gawk-e_00bf_009be_00a1_008cc_00bd_0091c_00bb_009ce_0080_009aa_00bf_00a1" href="#TCP_002fIP-Networking">1.4 利用 <code>gawk</code> 进行网络通信</a></li>
    <li><a name="toc-ae_00b5_008be_00af_0084a_00bd_00a0c_009a_0084-awk-c_00a8_008baa_00ba_008f" href="#Profiling">1.5 测评你的 <code>awk</code> 程序</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-9" href="#Advanced-Features-Summary">1.6 总结</a></li>
  </ul></li>
  <li><a name="toc-gawk-c_009a_0084aa_009b_00bde_0099_0085aa_008c_0096" href="#Internationalization">2 <code>gawk</code> 的国际化</a>
  <ul class="no-bullet">
    <li><a name="toc-aa_009b_00bde_0099_0085aa_008c_0096a_00b8_008eae_009c_00acaa_009c_00b0aa_008c_0096" href="#I18N-and-L10N">2.1 国际化与本地化</a></li>
    <li><a name="toc-GNU-c_009a_0084-gettext" href="#Explaining-gettext">2.2 GNU 的 <code>gettext</code></a></li>
    <li><a name="toc-awk-c_00a8_008baa_00ba_008fc_009a_0084aa_009b_00bde_0099_0085aa_008c_0096" href="#Programmer-i18n">2.3 <code>awk</code> 程序的国际化</a></li>
    <li><a name="toc-c_00bf_00bbe_00af_0091-awk-c_00a8_008baa_00ba_008f" href="#Translator-i18n">2.4 翻译 <code>awk</code> 程序</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_008f_0090aa_008f_0096aa_00b7_00b2ae_00a0_0087aa_00bf_0097aa_00ad_0097a_00b8_00b2" href="#String-Extraction">2.4.1 提取已标志字串</a></li>
      <li><a name="toc-e_0087_008dae_008e_0092-printf-aa_008f_0082ae_0095_00b0" href="#Printf-Ordering">2.4.2 重排 <code>printf</code> 参数</a></li>
      <li><a name="toc-awk-c_009a_0084c_00a7_00bbae_00a4_008dae_0080_00a7e_0097_00aee_00a2_0098" href="#I18N-Portability">2.4.3 <code>awk</code> 的移植性问题</a></li>
    </ul></li>
    <li><a name="toc-c_00ae_0080aa_008d_0095c_009a_0084aa_009b_00bde_0099_0085aa_008c_0096a_00be_008baa_00ad_0090" href="#I18N-Example">2.5 简单的国际化例子</a></li>
    <li><a name="toc-gawk-aa_008f_00afa_00bb_00a5e_00af_00b4a_00bd_00a0c_009a_0084e_00af_00ade_00a8_0080" href="#Gawk-I18N">2.6 <code>gawk</code> 可以说你的语言</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-1" href="#I18N-Summary">2.7 总结</a></li>
  </ul></li>
  <li><a name="toc-e_00b0_0083e_00af_0095-awk-c_00a8_008baa_00ba_008f" href="#Debugger">3 调试 <code>awk</code> 程序</a>
  <ul class="no-bullet">
    <li><a name="toc-gawk-e_00b0_0083e_00af_0095aa_0099_00a8a_00bb_008bc_00bb_008d" href="#Debugging">3.1 <code>gawk</code> 调试器介绍</a>
    <ul class="no-bullet">
      <li><a name="toc-e_0080_009ac_0094_00a8c_009a_0084e_00b0_0083e_00af_0095ae_008a_0080ae_009c_00af" href="#Debugging-Concepts">3.1.1 通用的调试技术</a></li>
      <li><a name="toc-e_00b0_0083e_00af_0095ae_00a6_0082aa_00bf_00b5" href="#Debugging-Terms">3.1.2 调试概念</a></li>
      <li><a name="toc-awk-e_00b0_0083e_00af_0095" href="#Awk-Debugging">3.1.3 <code>awk</code> 调试</a></li>
    </ul></li>
    <li><a name="toc-gawk-e_00b0_0083e_00af_0095a_00be_008baa_00ad_0090" href="#Sample-Debugging-Session">3.2 <code>gawk</code> 调试例子</a>
    <ul class="no-bullet">
      <li><a name="toc-aa_00a6_0082a_00bd_0095aa_00bc_0080aa_0090_00afe_00b0_0083e_00af_0095aa_0099_00a8" href="#Debugger-Invocation">3.2.1 如何开启调试器</a></li>
      <li><a name="toc-ae_009f_00a5ae_0089_00be-Bug" href="#Finding-The-Bug">3.2.2 查找 Bug</a></li>
    </ul></li>
    <li><a name="toc-a_00b8_00bbe_00a6_0081c_009a_0084e_00b0_0083e_00af_0095aa_0099_00a8aa_0091_00bda_00bb_00a4" href="#List-of-Debugger-Commands">3.3 主要的调试器命令</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_008e_00a7aa_0088_00b6ae_0096_00adc_0082_00b9" href="#Breakpoint-Control">3.3.1 控制断点</a></li>
      <li><a name="toc-ae_008e_00a7aa_0088_00b6ae_0089_00a7e_00a1_008c" href="#Debugger-Execution-Control">3.3.2 控制执行</a></li>
      <li><a name="toc-ae_009f_00a5c_009c_008ba_00b8_008eae_009b_00b4ae_0094_00b9ae_0095_00b0ae_008d_00ae" href="#Viewing-And-Changing-Data">3.3.3 查看与更改数据</a></li>
      <li><a name="toc-c_00a8_008baa_00ba_008fae_00a0_0088" href="#Execution-Stack">3.3.4 程序栈</a></li>
      <li><a name="toc-e_008e_00b7aa_008f_0096c_00a8_008baa_00ba_008fa_00b8_008ee_00b0_0083e_00af_0095aa_0099_00a8c_008a_00b6ae_0080_0081a_00bf_00a1ae_0081_00af" href="#Debugger-Info">3.3.5 获取程序与调试器状态信息</a></li>
      <li><a name="toc-aa_0085_00b6a_00bb_0096aa_0091_00bda_00bb_00a4" href="#Miscellaneous-Debugger-Commands">3.3.6 其他命令</a></li>
    </ul></li>
    <li><a name="toc-ae_0094_00afae_008c_0081" href="#Readline-Support">3.4 支持</a></li>
    <li><a name="toc-e_0099_0090aa_0088_00b6" href="#Limitations">3.5 限制</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-11" href="#Debugging-Summary">3.6 总结</a></li>
  </ul></li>
  <li><a name="toc-c_00ae_0097ae_009c_00afe_00bf_0090c_00ae_0097a_00b8_008e-gawk-a_00b8_00adc_009a_0084a_00bb_00bbae_0084_008fc_00b2_00beaa_00ba_00a6c_00ae_0097ae_009c_00afe_00bf_0090c_00ae_0097" href="#Arbitrary-Precision-Arithmetic">4 算术运算与 <code>gawk</code> 中的任意精度算术运算</a>
  <ul class="no-bullet">
    <li><a name="toc-e_00ae_00a1c_00ae_0097ae_009c_00bac_00ae_0097ae_009c_00afe_00ae_00a1c_00ae_0097e_00af_00b4ae_0098_008e" href="#Computer-Arithmetic">4.1 计算机算术计算说明</a></li>
    <li><a name="toc-e_00a6_0081a_00ba_0086e_00a7_00a3c_009a_0084aa_0085_00b6a_00bb_0096c_009f_00a5e_00af_0086" href="#Math-Definitions">4.2 要了解的其他知识</a></li>
    <li><a name="toc-gawk-c_009a_0084a_00bb_00bbae_0084_008fc_00b2_00beaa_00ba_00a6e_00ae_00a1c_00ae_0097" href="#MPFR-features">4.3 <code>gawk</code> 的任意精度计算</a></li>
    <li><a name="toc-ae_00b5_00aec_0082_00b9c_00ae_0097ae_00b3_0095i_00bc_009aa_00b9_00b0e_0080_0085e_0087_00aaae_0085_008ei_00bc_0081" href="#FP-Math-Caution">4.4 浮点算法：买者自慎！</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_00b5_00aec_0082_00b9e_00ae_00a1c_00ae_0097ae_0098_00afa_00b8_008dc_00b2_00bec_00a1_00aec_009a_0084" href="#Inexactness-of-computations">4.4.1 浮点计算是不精确的</a>
      <ul class="no-bullet">
        <li><a name="toc-aa_00be_0088aa_00a4_009ac_009a_0084ae_0095_00b0a_00b8_008de_0083_00bdaa_00ae_008caa_0085_00a8e_00a1_00a8c_00a4_00ba" href="#Inexact-representation">4.4.1.1 很多的数不能完全表示</a></li>
        <li><a name="toc-aa_0080_00bcae_00af_0094e_00be_0083ae_0097_00b6e_00a6_0081aa_00b0_008faa_00bf_0083" href="#Comparing-FP-Values">4.4.1.2 值比较时要小心</a></li>
        <li><a name="toc-e_0094_0099e_00af_00afc_00b4_00afc_00a7_00af" href="#Errors-accumulate">4.4.1.3 错误累积</a></li>
      </ul></li>
      <li><a name="toc-e_008e_00b7aa_008f_0096a_00bd_00a0e_009c_0080e_00a6_0081c_009a_0084c_00b2_00beaa_00ba_00a6" href="#Getting-Accuracy">4.4.2 获取你需要的精度</a></li>
      <li><a name="toc-aa_00a2_009eaa_008a_00a0aa_0087_00a0a_00bd_008dc_00b2_00beaa_00ba_00a6c_0084_00b6aa_0090_008eaa_0086_008de_0088_008daa_0085_00a5e_00bd_00acaa_0087_00ba" href="#Try-To-Round">4.4.3 增加几位精度然后再舍入转出</a></li>
      <li><a name="toc-e_00ae_00bec_00bd_00aec_00b2_00beaa_00ba_00a6" href="#Setting-precision">4.4.4 设置精度</a></li>
      <li><a name="toc-e_00ae_00bec_00bd_00aee_0088_008daa_0085_00a5e_00bd_00acaa_0087_00baae_00a8_00a1aa_00bc_008f" href="#Setting-the-rounding-mode">4.4.5 设置舍入转出模式</a></li>
    </ul></li>
    <li><a name="toc-gawk-a_00b8_00adc_009a_0084a_00bb_00bbae_0084_008fc_00b2_00beaa_00ba_00a6ae_0095_00b4ae_0095_00b0e_00ae_00a1c_00ae_0097" href="#Arbitrary-Precision-Integers">4.5 <code>gawk</code> 中的任意精度整数计算</a></li>
    <li><a name="toc-ae_00a0_0087aa_0087_0086a_00b8_008eae_0097_00a2aa_00ad_0098aa_00ae_009ee_00b7_00b5" href="#POSIX-Floating-Point-Problems">4.6 标准与既存实践</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-13" href="#Floating-point-summary">4.7 总结</a></li>
  </ul></li>
  <li><a name="toc-c_00bc_0096aa_0086_0099-gawk-ae_0089_00a9aa_00b1_0095" href="#Dynamic-Extensions">5 编写 <code>gawk</code> 扩展</a>
  <ul class="no-bullet">
    <li><a name="toc-a_00bb_008bc_00bb_008d-1" href="#Extension-Intro">5.1 介绍</a></li>
    <li><a name="toc-ae_0089_00a9aa_00b1_0095e_00ae_00b8aa_008f_00af" href="#Plugin-License">5.2 扩展许可</a></li>
    <li><a name="toc-aa_009c_00a8e_00ab_0098aa_00b1_0082c_00ba_00a7a_00b8_00adae_0098_00afaa_00ae_0083ae_0098_00afaa_00a6_0082a_00bd_0095aa_00b7_00a5a_00bd_009cc_009a_0084" href="#Extension-Mechanism-Outline">5.3 在高层级中是它是如何工作的</a></li>
    <li><a name="toc-API-ae_008f_008fe_00bf_00b0" href="#Extension-API-Description">5.4 API 描述</a>
    <ul class="no-bullet">
      <li><a name="toc-a_00bb_008bc_00bb_008d" href="#Extension-API-Functions-Introduction">5.4.1 介绍</a></li>
      <li><a name="toc-e_0080_009ac_0094_00a8c_009b_00aec_009a_0084c_009a_0084ae_0095_00b0ae_008d_00aec_00b1_00bbaa_009e_008b" href="#General-Data-Types">5.4.2 通用目的的数据类型</a></li>
      <li><a name="toc-aa_0086_0085aa_00ad_0098aa_0088_0086e_0085_008daa_0087_00bdae_0095_00b0a_00b8_008ec_009b_00b8aa_00ba_0094c_009a_0084c_00ae_0080aa_008c_0096aa_00ae_008f" href="#Memory-Allocation-Functions">5.4.3 内存分配函数与相应的简化宏</a></li>
      <li><a name="toc-ae_009e_0084e_0080_00a0aa_0087_00bdae_0095_00b0" href="#Constructor-Functions">5.4.4 构造函数</a></li>
      <li><a name="toc-ae_00b3_00a8aa_0086_008caa_0087_00bdae_0095_00b0" href="#Registration-Functions">5.4.5 注册函数</a>
      <ul class="no-bullet">
        <li><a name="toc-ae_00b3_00a8aa_0086_008cae_0089_00a9aa_00b1_0095aa_0087_00bdae_0095_00b0" href="#Extension-Functions">5.4.5.1 注册扩展函数</a></li>
        <li><a name="toc-ae_00b3_00a8aa_0086_008ce_0080_0080aa_0087_00baaa_0087_00bdae_0095_00b0" href="#Exit-Callback-Functions">5.4.5.2 注册退出函数</a></li>
        <li><a name="toc-ae_00b3_00a8aa_0086_008cae_0089_00a9aa_00b1_0095c_0089_0088ae_009c_00acaa_00ad_0097a_00b8_00b2" href="#Extension-Version-String">5.4.5.3 注册扩展版本字串</a></li>
        <li><a name="toc-aa_00ae_009aaa_0088_00b6e_00be_0093aa_0085_00a5aa_0088_0086ae_009e_0090aa_0099_00a8" href="#Input-Parsers">5.4.5.4 定制输入分析器</a></li>
        <li><a name="toc-aa_00ae_009aaa_0088_00b6e_00be_0093aa_0087_00baaa_008c_0085e_00a3_0085aa_0099_00a8" href="#Output-Wrappers">5.4.5.5 定制输出包装器</a></li>
        <li><a name="toc-aa_00ae_009aaa_0088_00b6aa_008f_008ce_00b7_00afaa_00a4_0084c_0090_0086aa_0099_00a8" href="#Two_002dway-processors">5.4.5.6 定制双路处理器</a></li>
      </ul></li>
      <li><a name="toc-ae_0089_0093aa_008d_00b0a_00bf_00a1ae_0081_00af" href="#Printing-Messages">5.4.6 打印信息</a></li>
      <li><a name="toc-ae_009b_00b4ae_0096_00b0-ERRNO" href="#Updating-ERRNO">5.4.7 更新 <code>ERRNO</code></a></li>
      <li><a name="toc-e_00af_00b7ae_00b1_0082aa_0080_00bc" href="#Requesting-Values">5.4.8 请求值</a></li>
      <li><a name="toc-e_00ae_00bfe_0097_00aea_00b8_008eae_009b_00b4ae_0096_00b0aa_008f_0082ae_0095_00b0" href="#Accessing-Parameters">5.4.9 访问与更新参数</a></li>
      <li><a name="toc-c_00ac_00a6aa_008f_00b7e_00a1_00a8e_00ae_00bfe_0097_00ae" href="#Symbol-Table-Access">5.4.10 符号表访问</a>
      <ul class="no-bullet">
        <li><a name="toc-e_0080_009ae_00bf_0087aa_0090_008daa_00ad_0097e_00ae_00bfe_0097_00aea_00b8_008eae_009b_00b4ae_0096_00b0aa_008f_0098e_0087_008f" href="#Symbol-table-by-name">5.4.10.1 通过名字访问与更新变量</a></li>
        <li><a name="toc-e_0080_009ae_00bf_0087-Cookie-e_00ae_00bfe_0097_00aea_00b8_008eae_009b_00b4ae_0096_00b0aa_008f_0098e_0087_008f" href="#Symbol-table-by-cookie">5.4.10.2 通过 Cookie 访问与更新变量</a></li>
        <li><a name="toc-aa_0088_009baa_00bb_00baaa_00b9_00b6a_00bd_00bfc_0094_00a8c_00bc_0093aa_00ad_0098aa_0080_00bc" href="#Cached-values">5.4.10.3 创建并使用缓存值</a></li>
      </ul></li>
      <li><a name="toc-ae_0095_00b0c_00bb_0084ae_0093_008da_00bd_009c" href="#Array-Manipulation">5.4.11 数组操作</a>
      <ul class="no-bullet">
        <li><a name="toc-ae_0095_00b0c_00bb_0084ae_0095_00b0ae_008d_00aec_00b1_00bbaa_009e_008b" href="#Array-Data-Types">5.4.11.1 数组数据类型</a></li>
        <li><a name="toc-ae_0095_00b0c_00bb_0084aa_0087_00bdae_0095_00b0" href="#Array-Functions">5.4.11.2 数组函数</a></li>
        <li><a name="toc-e_0081_008daa_008e_0086ae_0095_00b0c_00bb_0084c_009a_0084ae_0089_0080ae_009c_0089aa_0085_0083c_00b4_00a0" href="#Flattening-Arrays">5.4.11.3 遍历数组的所有元素</a></li>
        <li><a name="toc-aa_00a6_0082a_00bd_0095c_0094_009fae_0088_0090a_00b8_008eaa_008f_0091aa_00b8_0083ae_0095_00b0c_00bb_0084" href="#Creating-Arrays">5.4.11.4 如何生成与发布数组</a></li>
      </ul></li>
      <li><a name="toc-API-aa_008f_0098e_0087_008f" href="#Extension-API-Variables">5.4.12 API 变量</a>
      <ul class="no-bullet">
        <li><a name="toc-API-Version-Constants-and-Variables" href="#Extension-Versioning">5.4.12.1 API Version Constants and Variables</a></li>
        <li><a name="toc-a_00bf_00a1ae_0081_00afaa_008f_0098e_0087_008f" href="#Extension-API-Informational-Variables">5.4.12.2 信息变量</a></li>
      </ul></li>
      <li><a name="toc-ae_00a0_00b7ae_009d_00bfa_00bb_00a3c_00a0_0081" href="#Extension-API-Boilerplate">5.4.13 样板代码</a></li>
    </ul></li>
    <li><a name="toc-gawk-aa_00a6_0082a_00bd_0095ae_0089_00beaa_0088_00b0ae_0089_00a9aa_00b1_0095" href="#Finding-Extensions">5.5 <code>gawk</code> 如何找到扩展</a></li>
    <li><a name="toc-a_00be_008baa_00ad_0090i_00bc_009aa_00b8_0080a_00ba_009bae_0096_0087a_00bb_00b6aa_0087_00bdae_0095_00b0" href="#Extension-Example">5.6 例子：一些文件函数</a>
    <ul class="no-bullet">
      <li><a name="toc-a_00bd_00bfc_0094_00a8-chdir_0028_0029-a_00b8_008e-stat_0028_0029" href="#Internal-File-Description">5.6.1 使用 <code>chdir()</code> 与 <code>stat()</code></a></li>
      <li><a name="toc-chdir_0028_0029-a_00b8_008e-stat_0028_0029-c_009a_0084C-a_00bb_00a3c_00a0_0081" href="#Internal-File-Ops">5.6.2 <code>chdir()</code> 与 <code>stat()</code> 的C 代码</a></li>
      <li><a name="toc-ae_0095_00b4aa_0090_0088ae_0089_00a9aa_00b1_0095" href="#Using-Internal-File-Ops">5.6.3 整合扩展</a></li>
    </ul></li>
    <li><a name="toc-gawk-aa_008f_0091e_00a1_008cc_0089_0088ae_009c_00aca_00b8_00adc_009a_0084a_00be_008baa_00ad_0090ae_0089_00a9aa_00b1_0095" href="#Extension-Samples">5.7 <code>gawk</code> 发行版本中的例子扩展</a>
    <ul class="no-bullet">
      <li><a name="toc-a_00b8_008eae_0096_0087a_00bb_00b6c_009b_00b8aa_0085_00b3c_009a_0084aa_0087_00bdae_0095_00b0" href="#Extension-Sample-File-Functions">5.7.1 与文件相关的函数</a></li>
      <li><a name="toc-e_0092_0088aa_00af_00b9-fnmatch_0028_0029a_0080_0080c_009a_0084ae_008e_00a5aa_008f_00a3" href="#Extension-Sample-Fnmatch">5.7.2 针对 <code>fnmatch()</code>　的接口</a></li>
      <li><a name="toc-e_0092_0088aa_00af_00b9-fork_0028_0029i_00bc_008cwait_0028_0029i_00bc_008ca_00b8_008e-waitpid_0028_0029-c_009a_0084ae_008e_00a5aa_008f_00a3" href="#Extension-Sample-Fork">5.7.3 针对 <code>fork()</code>，<code>wait()</code>，与 <code>waitpid()</code> 的接口</a></li>
      <li><a name="toc-aa_0090_00afc_0094_00a8ae_0096_0087a_00bb_00b6aa_00b0_00b1aa_009c_00b0c_00bc_0096e_00be_0091" href="#Extension-Sample-Inplace">5.7.4 启用文件就地编辑</a></li>
      <li><a name="toc-aa_00ad_0097c_00ac_00a6a_00b8_008eae_0095_00b0aa_0080_00bci_00bc_009aord_0028_0029-a_00b8_008e-chr_0028_0029" href="#Extension-Sample-Ord">5.7.5 字符与数值：<code>ord()</code> 与 <code>chr()</code></a></li>
      <li><a name="toc-e_00af_00bbaa_008f_0096c_009b_00aeaa_00bd_0095" href="#Extension-Sample-Readdir">5.7.6 读取目录</a></li>
      <li><a name="toc-aa_0080_0092e_00bd_00ace_00be_0093aa_0087_00ba" href="#Extension-Sample-Revout">5.7.7 倒转输出</a></li>
      <li><a name="toc-aa_008f_008ce_00b7_00af-I_002fO-a_00be_008baa_00ad_0090" href="#Extension-Sample-Rev2way">5.7.8 双路 I/O 例子</a></li>
      <li><a name="toc-e_00be_0093aa_0087_00baa_00b8_008eae_0081_00a2aa_00a4_008dae_0095_00b0c_00bb_0084" href="#Extension-Sample-Read-write-array">5.7.9 输出与恢复数组</a></li>
      <li><a name="toc-e_00af_00bbaa_008f_0096ae_0095_00b4a_00b8_00aaae_0096_0087a_00bb_00b6" href="#Extension-Sample-Readfile">5.7.10 读取整个文件</a></li>
      <li><a name="toc-ae_0089_00a9aa_00b1_0095c_009a_0084ae_0097_00b6e_0097_00b4aa_0087_00bdae_0095_00b0" href="#Extension-Sample-Time">5.7.11 扩展的时间函数</a></li>
      <li><a name="toc-API-ae_00b5_008be_00af_0095" href="#Extension-Sample-API-Tests">5.7.12 <code>API</code> 测试</a></li>
    </ul></li>
    <li><a name="toc-gawkextlib-e_00a1_00b9c_009b_00ae" href="#gawkextlib">5.8 <code>gawkextlib</code> 项目</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-3" href="#Extension-summary">5.9 总结</a></li>
    <li><a name="toc-c_00bb_0083a_00b9_00a0" href="#Extension-Exercises">5.10 练习</a></li>
  </ul></li>
  <li><a name="toc-c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095">第四部分:<br> 附录</a></li>
  <li><a name="toc-awk-e_00af_00ade_00a8_0080c_009a_0084ae_00bc_0094aa_008c_0096" href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095">Appendix A <code>awk</code> 语言的演化</a>
  <ul class="no-bullet">
    <li><a name="toc-aa_009c_00a8-V7-a_00b8_008e-SVR3_002e1-a_00b9_008be_0097_00b4c_009a_0084aa_008f_0098aa_008c_0096" href="#V7_002fSVR3_002e1">A.1 在 V7 与 SVR3.1 之间的变化</a></li>
    <li><a name="toc-aa_009c_00a8-SVR3_002e1-a_00b8_008e-SVR4-a_00b9_008be_0097_00b4c_009a_0084aa_008f_0098aa_008c_0096" href="#SVR4">A.2 在 SVR3.1 与 SVR4 之间的变化</a></li>
    <li><a name="toc-aa_009c_00a8-SVR4-a_00b8_008e-POSIX-a_00b9_008be_0097_00b4c_009a_0084aa_008f_0098aa_008c_0096" href="#POSIX">A.3 在 SVR4 与 POSIX 之间的变化</a></li>
    <li><a name="toc-Brian-Kernighan-c_009a_0084-awk-c_009a_0084ae_0089_00a9aa_00b1_0095" href="#BTL">A.4 Brian Kernighan 的 <code>awk</code> 的扩展</a></li>
    <li><a name="toc-a_00b8_008daa_009c_00a8-POSIX-awk-a_00b8_00adc_009a_0084-gawk-ae_0089_00a9aa_00b1_0095" href="#POSIX_002fGNU">A.5 不在 POSIX <code>awk</code> 中的 <code>gawk</code> 扩展</a></li>
    <li><a name="toc-gawk-c_0089_00b9ae_0080_00a7aa_008e_0086aa_008f_00b2" href="#Feature-History">A.6 <code>gawk</code> 特性历史</a></li>
    <li><a name="toc-e_0080_009ac_0094_00a8ae_0089_00a9aa_00b1_0095ae_00b1_0087ae_0080_00bb" href="#Common-Extensions">A.7 通用扩展汇总</a></li>
    <li><a name="toc-ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008fe_008c_0083aa_009b_00b4a_00b8_008eae_009c_00acaa_009c_00b0e_00af_00ade_00a8_0080e_00ae_00bec_00bd_00aei_00bc_009aaa_008f_0088e_0087_00adaa_008f_0088e_0095_00bfe_0099_0088aa_00b9_00b4ae_0097_00a7a_00ba_008b" href="#Ranges-and-Locales">A.8 正则表达式范围与本地语言设置：又臭又长陈年旧事</a></li>
    <li><a name="toc-gawk-c_009a_0084a_00b8_00bbe_00a6_0081e_00b4_00a1c_008c_00aee_0080_0085" href="#Contributors">A.9 <code>gawk</code> 的主要贡献者</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-8" href="#History-summary">A.10 总结</a></li>
  </ul></li>
  <li><a name="toc-aa_00ae_0089e_00a3_0085-gawk" href="#Installation">Appendix B 安装 <code>gawk</code></a>
  <ul class="no-bullet">
    <li><a name="toc-gawk-aa_008f_0091aa_00b8_0083c_0089_0088" href="#Gawk-Distribution">B.1 <code>gawk</code> 发布版</a>
    <ul class="no-bullet">
      <li><a name="toc-aa_008f_0096aa_00be_0097-gawk-aa_008f_0091aa_00b8_0083c_0089_0088" href="#Getting">B.1.1 取得 <code>gawk</code> 发布版</a></li>
      <li><a name="toc-ae_008f_0090aa_008f_0096aa_008f_0091aa_00b8_0083c_0089_0088" href="#Extracting">B.1.2 提取发布版</a></li>
      <li><a name="toc-gawk-aa_008f_0091aa_00b8_0083c_0089_0088c_009a_0084aa_0086_0085aa_00ae_00b9" href="#Distribution-contents">B.1.3 <code>gawk</code> 发布版的内容</a></li>
    </ul></li>
    <li><a name="toc-aa_009c_00a8-Unix_002dlike-c_009a_0084c_00b3_00bbc_00bb_009fa_00b8_008ac_00bc_0096e_00af_0091a_00b8_008eaa_00ae_0089e_00a3_0085-gawk" href="#Unix-Installation">B.2 在 Unix-like 的系统上编译与安装 <code>gawk</code></a>
    <ul class="no-bullet">
      <li><a name="toc-a_00b8_00ba-Unix_002dlike-c_009a_0084c_00b3_00bbc_00bb_009fc_00bc_0096e_00af_0091-gawk" href="#Quick-Installation">B.2.1 为 Unix-like 的系统编译 <code>gawk</code></a></li>
      <li><a name="toc-aa_0085_00b6a_00bb_0096e_0085_008dc_00bd_00aee_0080_0089e_00a1_00b9" href="#Additional-Configuration-Options">B.2.2 其他配置选项</a></li>
      <li><a name="toc-e_0085_008dc_00bd_00aee_00bf_0087c_00a8_008b" href="#Configuration-Philosophy">B.2.3 配置过程</a></li>
    </ul></li>
    <li><a name="toc-aa_00ae_0089e_00a3_0085aa_0088_00b0aa_0085_00b6a_00bb_0096ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009fa_00b8_008a" href="#Non_002dUnix-Installation">B.3 安装到其他操作系统上</a>
    <ul class="no-bullet">
      <li><a name="toc-aa_00ae_0089e_00a3_0085aa_0088_00b0-PC-ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009f" href="#PC-Installation">B.3.1 安装到 PC 操作系统</a>
      <ul class="no-bullet">
        <li><a name="toc-a_00b8_00ba-PC-c_00b3_00bbc_00bb_009faa_00ae_0089e_00a3_0085a_00b8_0080a_00b8_00aac_00bc_0096e_00af_0091c_0089_0088" href="#PC-Binary-Installation">B.3.1.1 为 PC 系统安装一个编译版</a></li>
        <li><a name="toc-a_00b8_00ba-PC-ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009fc_00bc_0096e_00af_0091-gawk" href="#PC-Compiling">B.3.1.2 为 PC 操作系统编译 <code>gawk</code></a></li>
        <li><a name="toc-aa_009c_00a8-PC-ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009fa_00b8_008aae_00b5_008be_00af_0095-gawk" href="#PC-Testing">B.3.1.3 在 PC 操作系统上测试 <code>gawk</code></a></li>
        <li><a name="toc-aa_009c_00a8-PC-ae_0093_008da_00bd_009cc_00b3_00bbc_00bb_009fa_00b8_008aa_00bd_00bfc_0094_00a8-gawk" href="#PC-Using">B.3.1.4 在 PC 操作系统上使用 <code>gawk</code></a></li>
        <li><a name="toc-aa_009c_00a8-Cygwin-a_00b8_00ada_00bd_00bfc_0094_00a8-gawk" href="#Cygwin">B.3.1.5 在 Cygwin 中使用 <code>gawk</code></a></li>
        <li><a name="toc-aa_009c_00a8-MSYS-c_008e_00afaa_00a2_0083a_00b8_00ada_00bd_00bfc_0094_00a8-gawk" href="#MSYS">B.3.1.6 在 MSYS 环境中使用 <code>gawk</code></a></li>
      </ul></li>
      <li><a name="toc-aa_009c_00a8-Vax_002fVMS-a_00bb_00a5aa_008f_008a-OpenVMS-c_00b3_00bbc_00bb_009fa_00b8_008ac_00bc_0096e_00af_0091aa_00ae_0089e_00a3_0085-gawk" href="#VMS-Installation">B.3.2 在 Vax/VMS 以及 OpenVMS 系统上编译安装 <code>gawk</code></a>
      <ul class="no-bullet">
        <li><a name="toc-aa_009c_00a8-VMS-a_00b8_008ac_00bc_0096e_00af_0091-gawk" href="#VMS-Compilation">B.3.2.1 在 VMS 上编译 <code>gawk</code></a></li>
        <li><a name="toc-aa_009c_00a8-VMS-c_00bc_0096e_00af_0091-gawk-aa_008a_00a8ae_0080_0081ae_0089_00a9aa_00b1_0095" href="#VMS-Dynamic-Extensions">B.3.2.2 在 VMS 编译 <code>gawk</code> 动态扩展</a></li>
        <li><a name="toc-aa_009c_00a8VMS-a_00b8_008aaa_00ae_0089e_00a3_0085gawk" href="#VMS-Installation-Details">B.3.2.3 在VMS 上安装<code>gawk</code></a></li>
        <li><a name="toc-aa_009c_00a8-VMS-a_00b8_008ae_00bf_0090e_00a1_008c-gawk" href="#VMS-Running">B.3.2.4 在 VMS 上运行 <code>gawk</code></a></li>
        <li><a name="toc-VMS-c_009a_0084-GNV-e_00a1_00b9c_009b_00ae" href="#VMS-GNV">B.3.2.5 VMS 的 GNV 项目</a></li>
        <li><a name="toc-ae_009c_0089a_00b8_0080a_00ba_009b-VMS-c_00b3_00bbc_00bb_009fae_009c_0089ae_0097_00a7c_0089_0088ae_009c_00acc_009a_0084-gawk" href="#VMS-Old-Gawk">B.3.2.6 有一些 VMS 系统有旧版本的 <code>gawk</code></a></li>
      </ul>
</li>
    </ul></li>
    <li><a name="toc-ae_008a_00a5aa_0091_008ae_0097_00aee_00a2_0098a_00b8_008e-BUG" href="#Bugs">B.4 报告问题与 BUG</a></li>
    <li><a name="toc-aa_0085_00b6a_00bb_0096aa_008f_00afe_0087_00aac_0094_00b1e_008e_00b7aa_008f_0096c_009a_0084-awk" href="#Other-Versions">B.5 其他可自由获取的 <code>awk</code></a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093" href="#Installation-summary">B.6 总结</a></li>
  </ul></li>
  <li><a name="toc-aa_00ae_009ec_008e_00b0ae_008f_0090c_00a4_00ba" href="#Notes">Appendix C 实现提示</a>
  <ul class="no-bullet">
    <li><a name="toc-aa_0090_008eaa_0090_0091aa_0085_00bcaa_00ae_00b9a_00b8_008ee_00b0_0083e_00af_0095" href="#Compatibility-Mode">C.1 后向兼容与调试</a></li>
    <li><a name="toc-gawk-ae_00b7_00bbaa_008a_00a0aa_008a_009fe_0083_00bd" href="#Additions">C.2 <code>gawk</code> 添加功能</a>
    <ul class="no-bullet">
      <li><a name="toc-e_00ae_00bfe_0097_00ae-gawk-c_009a_0084-Git-a_00bb_0093aa_00ba_0093" href="#Accessing-The-Source">C.2.1 访问 <code>gawk</code> 的 Git 仓库</a></li>
      <li><a name="toc-ae_00b7_00bbaa_008a_00a0ae_0096_00b0c_0089_00b9ae_0080_00a7" href="#Adding-Code">C.2.2 添加新特性</a></li>
      <li><a name="toc-aa_00b0_0086-gawk-c_00a7_00bbae_00a4_008daa_0088_00b0ae_0096_00b0c_00b3_00bbc_00bb_009fa_00b8_00ad" href="#New-Ports">C.2.3 将 <code>gawk</code> 移植到新系统中</a></li>
      <li><a name="toc-a_00b8_00baa_00bb_0080a_00b9_0088e_0087_00aaaa_008a_00a8c_0094_009fae_0088_0090c_009a_0084ae_0096_0087a_00bb_00b6e_00a6_0081ae_0094_00beaa_009c_00a8-Git-a_00b8_00ad" href="#Derived-Files">C.2.4 为什么自动生成的文件要放在 Git 中</a></li>
    </ul></li>
    <li><a name="toc-aa_0090_008ec_00bb_00adaa_008f_00afe_0083_00bdc_009a_0084ae_0089_00a9aa_00b1_0095" href="#Future-Extensions">C.3 后续可能的扩展</a></li>
    <li><a name="toc-aa_00ae_009ec_008e_00b0c_009a_0084a_00b8_0080a_00ba_009be_0099_0090aa_0088_00b6" href="#Implementation-Limitations">C.4 实现的一些限制</a></li>
    <li><a name="toc-ae_0089_00a9aa_00b1_0095-API-e_00ae_00bee_00ae_00a1" href="#Extension-Design">C.5 扩展 API 设计</a>
    <ul class="no-bullet">
      <li><a name="toc-ae_0097_00a7ae_009c_00baaa_0088_00b6c_009a_0084e_0097_00aee_00a2_0098" href="#Old-Extension-Problems">C.5.1 旧机制的问题</a></li>
      <li><a name="toc-ae_0096_00b0ae_009c_00baaa_0088_00b6c_009a_0084c_009b_00aeae_00a0_0087" href="#Extension-New-Mechanism-Goals">C.5.2 新机制的目标</a></li>
      <li><a name="toc-aa_0085_00b6a_00bb_0096c_009a_0084e_00ae_00bee_00ae_00a1aa_0086_00b3c_00ad_0096" href="#Extension-Other-Design-Decisions">C.5.3 其他的设计决策</a></li>
      <li><a name="toc-ae_009c_00aaae_009d_00a5c_009a_0084aa_00a2_009ee_0095_00bfc_00a9_00bae_0097_00b4" href="#Extension-Future-Growth">C.5.4 未来的增长空间</a></li>
    </ul></li>
    <li><a name="toc-aa_00af_00b9ae_0097_00a7ae_0089_00a9aa_00b1_0095c_009a_0084aa_0085_00bcaa_00ae_00b9ae_0080_00a7" href="#Old-Extension-Mechanism">C.6 对旧扩展的兼容性</a></li>
    <li><a name="toc-ae_0080_00bbc_00bb_0093-14" href="#Notes-summary">C.7 总结</a></li>
  </ul></li>
  <li><a name="toc-aa_009f_00baae_009c_00acc_00bc_0096c_00a8_008bae_00a6_0082aa_00bf_00b5" href="#Basic-Concepts">Appendix D 基本编程概念</a>
  <ul class="no-bullet">
    <li><a name="toc-c_00a8_008baa_00ba_008faa_0081_009ac_009a_0084ae_0098_00afa_00bb_0080a_00b9_0088" href="#Basic-High-Level">D.1 程序做的是什么</a></li>
    <li><a name="toc-e_00ae_00a1c_00ae_0097ae_009c_00baa_00b8_00adae_0095_00b0ae_008d_00aec_009a_0084aa_0080_00bc" href="#Basic-Data-Typing">D.2 计算机中数据的值</a></li>
  </ul></li>
  <li><a name="toc-aa_0090_008de_00af_008de_00a7_00a3e_0087_008a" href="#Glossary">名词解释</a></li>
  <li><a name="toc-GNU-General-Public-License" href="#Copying">GNU General Public License</a></li>
  <li><a name="toc-GNU-Free-Documentation-License-1" href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>
  <ul class="no-bullet">
    <li><a name="toc-ADDENDUM_003a-How-to-use-this-License-for-your-documents" href="#ADDENDUM_003a-How-to-use-this-License-for-your-documents">ADDENDUM: How to use this License for your documents</a></li>
  </ul></li>
  <li><a name="toc-Index-1" href="#Index">Index</a></li>
</ul>
</div>
<hr>
<a name="SEC_Overview"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1>Short Table of Contents</h1>

<div class="shortcontents">
<ul class="no-bullet">
<li><a name="stoc-c_00ac_00aca_00b8_0089c_0089_0088aa_0089_008de_00a8_0080" href="#Foreword3">第三版前言</a></li>
<li><a name="stoc-c_00ac_00acaa_009b_009bc_0089_0088aa_0089_008de_00a8_0080" href="#Foreword4">第四版前言</a></li>
<li><a name="stoc-aa_0089_008de_00a8_0080" href="#Preface">前言</a></li>
<li><a name="stoc-e_00af_0091aa_00ba_008f" href="#Translator-Preface">译序</a></li>
<li><a name="stoc-c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080" href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">第一部分:<br> <code>awk</code> 语言</a></li>
<li><a name="stoc-aa_00bc_0080aa_00a7_008b-awk" href="#c_00ac_00aca_00b8_0080e_0083_00a8aa_0088_0086_003a--awk-e_00af_00ade_00a8_0080">1 开始 <code>awk</code></a></li>
<li><a name="stoc-e_00bf_0090e_00a1_008c-awk-a_00b8_008e-gawk" href="#Invoking-Gawk">2 运行 <code>awk</code> 与 <code>gawk</code></a></li>
<li><a name="stoc-ae_00ad_00a3aa_0088_0099e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Regexp">3 正则表达式</a></li>
<li><a name="stoc-e_00af_00bbaa_008f_0096e_00be_0093aa_0085_00a5ae_0096_0087a_00bb_00b6" href="#Reading-Files">4 读取输入文件</a></li>
<li><a name="stoc-ae_0089_0093aa_008d_00b0e_00be_0093aa_0087_00ba" href="#Printing">5 打印输出</a></li>
<li><a name="stoc-e_00a1_00a8e_00be_00beaa_00bc_008f" href="#Expressions">6 表达式</a></li>
<li><a name="stoc-ae_00a8_00a1aa_00bc_008fa_0080_0081aa_008a_00a8a_00bd_009ca_00b8_008eaa_008f_0098e_0087_008f" href="#Patterns-and-Actions">7 模式、动作与变量</a></li>
<li><a name="stoc-awk-ae_0095_00b0c_00bb_0084" href="#Arrays">8 <code>awk</code> 数组</a></li>
<li><a name="stoc-aa_0087_00bdae_0095_00b0" href="#Functions">9 函数</a></li>
<li><a name="stoc-c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098" href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">第二部分:<br>用 <code>awk</code> 来解决问题</a></li>
<li><a name="stoc-awk-aa_0087_00bdae_0095_00b0aa_00ba_0093" href="#c_00ac_00aca_00ba_008ce_0083_00a8aa_0088_0086_003a-c_0094_00a8-awk-ae_009d_00a5e_00a7_00a3aa_0086_00b3e_0097_00aee_00a2_0098">1 <code>awk</code> 函数库</a></li>
<li><a name="stoc-aa_00ae_009ec_0094_00a8c_009a_0084-awk-c_00a8_008baa_00ba_008f" href="#Sample-Programs">2 实用的 <code>awk</code> 程序</a></li>
<li><a name="stoc-c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk" href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">第三部分:<br> 用 <code>gawk</code> 超越标准 <code>awk</code></a></li>
<li><a name="stoc-gawk-c_009a_0084e_00ab_0098c_00ba_00a7c_0089_00b9ae_0080_00a7" href="#c_00ac_00aca_00b8_0089e_0083_00a8aa_0088_0086_003a--c_0094_00a8-gawk-e_00b6_0085e_00b6_008aae_00a0_0087aa_0087_0086-awk">1 <code>gawk</code> 的高级特性</a></li>
<li><a name="stoc-gawk-c_009a_0084aa_009b_00bde_0099_0085aa_008c_0096" href="#Internationalization">2 <code>gawk</code> 的国际化</a></li>
<li><a name="stoc-e_00b0_0083e_00af_0095-awk-c_00a8_008baa_00ba_008f" href="#Debugger">3 调试 <code>awk</code> 程序</a></li>
<li><a name="stoc-c_00ae_0097ae_009c_00afe_00bf_0090c_00ae_0097a_00b8_008e-gawk-a_00b8_00adc_009a_0084a_00bb_00bbae_0084_008fc_00b2_00beaa_00ba_00a6c_00ae_0097ae_009c_00afe_00bf_0090c_00ae_0097" href="#Arbitrary-Precision-Arithmetic">4 算术运算与 <code>gawk</code> 中的任意精度算术运算</a></li>
<li><a name="stoc-c_00bc_0096aa_0086_0099-gawk-ae_0089_00a9aa_00b1_0095" href="#Dynamic-Extensions">5 编写 <code>gawk</code> 扩展</a></li>
<li><a name="stoc-c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095" href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095">第四部分:<br> 附录</a></li>
<li><a name="stoc-awk-e_00af_00ade_00a8_0080c_009a_0084ae_00bc_0094aa_008c_0096" href="#c_00ac_00acaa_009b_009be_0083_00a8aa_0088_0086_003a--e_0099_0084aa_00bd_0095">Appendix A <code>awk</code> 语言的演化</a></li>
<li><a name="stoc-aa_00ae_0089e_00a3_0085-gawk" href="#Installation">Appendix B 安装 <code>gawk</code></a></li>
<li><a name="stoc-aa_00ae_009ec_008e_00b0ae_008f_0090c_00a4_00ba" href="#Notes">Appendix C 实现提示</a></li>
<li><a name="stoc-aa_009f_00baae_009c_00acc_00bc_0096c_00a8_008bae_00a6_0082aa_00bf_00b5" href="#Basic-Concepts">Appendix D 基本编程概念</a></li>
<li><a name="stoc-aa_0090_008de_00af_008de_00a7_00a3e_0087_008a" href="#Glossary">名词解释</a></li>
<li><a name="stoc-GNU-General-Public-License" href="#Copying">GNU General Public License</a></li>
<li><a name="stoc-GNU-Free-Documentation-License-1" href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></li>
<li><a name="stoc-Index-1" href="#Index">Index</a></li>
</ul>
</div>
<hr>
<a name="SEC_About"></a>
<table class="header" cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1>About This Document</h1>

<p>
  This document was generated on <i>December 27, 2018</i> using <a href="http://www.nongnu.org/texi2html/"><i>texi2html 5.0</i></a>.
</p>
<p>
  The buttons in the navigation panels have the following meaning:
</p>
<table border="1">
  <tr>
    <th> Button </th>
    <th> Name </th>
    <th> Go to </th>
    <th> From 1.2.3 go to</th>
  </tr>
  <tr>
    <td align="center"> [ &lt;&lt; ] </td>
    <td align="center">FastBack</td>
    <td>Beginning of this chapter or previous chapter</td>
    <td>1</td>
  </tr>
  <tr>
    <td align="center"> [ &lt; ] </td>
    <td align="center">Back</td>
    <td>Previous section in reading order</td>
    <td>1.2.2</td>
  </tr>
  <tr>
    <td align="center"> [ Up ] </td>
    <td align="center">Up</td>
    <td>Up section</td>
    <td>1.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt; ] </td>
    <td align="center">Forward</td>
    <td>Next section in reading order</td>
    <td>1.2.4</td>
  </tr>
  <tr>
    <td align="center"> [ &gt;&gt; ] </td>
    <td align="center">FastForward</td>
    <td>Next chapter</td>
    <td>2</td>
  </tr>
  <tr>
    <td align="center"> [Top] </td>
    <td align="center">Top</td>
    <td>Cover (top) of document</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [Contents] </td>
    <td align="center">Contents</td>
    <td>Table of contents</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [Index] </td>
    <td align="center">Index</td>
    <td>Index</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [ ? ] </td>
    <td align="center">About</td>
    <td>About (help)</td>
    <td> &nbsp; </td>
  </tr>
</table>

<p>
  where the <strong> Example </strong> assumes that the current position is at <strong> Subsubsection One-Two-Three </strong> of a document of the following structure:
</p>

<ul>
  <li> 1. Section One
    <ul>
      <li>1.1 Subsection One-One
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.2 Subsection One-Two
        <ul>
          <li>1.2.1 Subsubsection One-Two-One</li>
          <li>1.2.2 Subsubsection One-Two-Two</li>
          <li>1.2.3 Subsubsection One-Two-Three &nbsp; &nbsp;
            <strong>&lt;== Current Position </strong></li>
          <li>1.2.4 Subsubsection One-Two-Four</li>
        </ul>
      </li>
      <li>1.3 Subsection One-Three
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.4 Subsection One-Four</li>
    </ul>
  </li>
</ul>

<hr>
<p>
 <font size="-1">
  This document was generated on <i>December 27, 2018</i> using <a href="http://www.nongnu.org/texi2html/"><i>texi2html 5.0</i></a>.
 </font>
 <br>

</p>
</body>
</html>
